<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="local.xsl"?>
<!DOCTYPE TEI.2 [
<!ENTITY date.last.touched '10 March 2022' >
<!ATTLIST bibl id ID #REQUIRED>
<!ATTLIST div  id ID #REQUIRED>
<!ATTLIST scrap id ID #IMPLIED>

<!-- to turn debugging and statistics off -->
<!ENTITY DEBUG  "(:debug ...">
<!ENTITY GUBED  "... gubed:)">
<!ENTITY STAT   "(:stat ...">
<!ENTITY TATS   "... tats:)">

<!-- to turn debugging and statistics on -->
<!ENTITY DEBUG  "(:debug:)">
<!ENTITY GUBED  "(:gubed:)">
<!ENTITY STAT   "(:stat:) ">
<!ENTITY TATS   "(:tats:)">

<!-- to turn debugging and statistics on -->
<!ENTITY DEBUG  "">
<!ENTITY GUBED  "">
<!ENTITY STAT   "">
<!ENTITY TATS   "">

<!ENTITY darr   "&#x2193;" ><!--/downarrow A: =downward arrow-->
<!ENTITY isin   "&#x2208;" ><!--/in R: =set membership-->
<!ENTITY larr   "&#x2190;" ><!--/leftarrow /gets A: =leftward arrow-->
<!ENTITY mdash  "&#x2014;" ><!--=em dash-->
<!ENTITY prime  "&#x2032;" ><!--/prime =prime or minute-->
<!ENTITY rarr   "&#x2192;" ><!--/rightarrow /to A: =rightward arrow-->
<!ENTITY rArr   "&#x21D2;" ><!--/Rightarrow A: =implies-->
<!ENTITY times  "&#215;" ><!--/times B: =multiply sign-->
<!ENTITY uarr   "&#x2191;" ><!--/uparrow A: =upward arrow-->
<!ENTITY uuml    "&#252;" ><!-- small u, dieresis or umlaut mark -->

<!ENTITY c '<ident>c</ident>' >
<!ENTITY C '<ident>C</ident>' >
<!ENTITY e '<ident>e</ident>' >
<!ENTITY ei '<ident>ei</ident>' >
<!ENTITY E '<ident>E</ident>' >
<!ENTITY E.. '<ident>$E</ident>' >
<!ENTITY f '<ident>f</ident>' >
<!ENTITY F '<ident>F</ident>' >
<!ENTITY G '<ident>G</ident>' >
<!ENTITY I '<ident>I</ident>' >
<!ENTITY i '<ident>i</ident>' >
<!ENTITY L.E '<ident>L(E)</ident>' >
<!ENTITY L..E '<ident>L($E)</ident>' >
<!ENTITY L.G '<ident>L(G)</ident>' >
<!ENTITY L.q '<ident>L(q)</ident>' >
<!ENTITY M '<ident>M</ident>' >
<!ENTITY n '<ident>n</ident>' >
<!ENTITY N '<ident>N</ident>' >
<!ENTITY N.. '<ident>N&prime;</ident>' >
<!ENTITY N.x.y '&N;·&x;·&y;' >
<!ENTITY M_E '&M;<hi rend="sub">&E;</hi>' >
<!ENTITY ME '&M_E;' >
<!ENTITY O0 '<ident>O</ident><hi rend="sub">0</hi>' >
<!ENTITY p '<ident>p</ident>' >
<!ENTITY q '<ident>q</ident>' >
<!ENTITY q0 '<ident>q</ident><hi rend="sub">0</hi>' >
<!ENTITY qf '<ident>q</ident><hi rend="sub">&f;</hi>' >
<!ENTITY s '<ident>s</ident>' >
<!ENTITY T '<ident>T</ident>' >
<!ENTITY V '<ident>V</ident>' >
<!ENTITY w '<ident>w</ident>' >
<!ENTITY w- '<ident>w&prime;</ident>' >
<!ENTITY x '<ident>x</ident>' >
<!ENTITY y '<ident>y</ident>' >


<!--* Reminder:
      (progn
        (make-variable-buffer-local 'nxml-child-indent)
        (setq nxml-child-indent 0)
      )

      For now, do this manually.  I don't know how to
      make Aquamacs do it using eval-last-sexp or eval-expression.
    *-->
]>
<TEI.2>
<teiHeader>
<fileDesc>
<titleStmt>
<title>Aparecium:  an ixml parser for XSLT and XQuery</title>
<author>C. M. Sperberg-McQueen</author>
</titleStmt>
<publicationStmt>
<!--* This will be true rsn *-->
<authority>Black Mesa Technologies LLC</authority>
<authority>Github</authority>
<date>2021</date>
</publicationStmt>
<sourceDesc>
<p>Created in electronic form.</p>
</sourceDesc>
</fileDesc>
<revisionDesc>
<list>
<item>2022-04-12 : CMSMcQ : try again to escape newlines in error message</item>
<item>2022-03-10 : CMSMcQ : re-organize section on top-level
interfaces; mention error cases explicitly</item>
<item>2022-03-02? / 03-10 : CMSMcQ : writing parse-forest grammar
code, making it work</item>
<item>2022-02-16 : CMSMcQ : trying to clean up a bit</item>
<item>2022-02-16 : CMSMcQ : insert timing requests in earley-closure.
Conjecture:  4/5 of the time will be in the call to leiPCSrel(),
very little in deduping etc.</item>
<item>2022-02-09 : CMSMcQ : resuming work (some changes unlogged
between October and now).</item>
<item>2021-10-18 : CMSMcQ : take git snapshot of current state; then
insert the changes I needed to make to make it work in Oxygen with
Saxon.</item>
<item>2021-10-14 : CMSMcQ : works for demos.</item>
<item>2021-10-05/-10-12 : CMSMcQ : update to use current syntax.
Current status:  producing plausible raw parse trees.</item>
<item>2021-10-05 : CMSMcQ : change module import for Gluschkov to use
correct ns name</item>
<item>2021-10-03 : CMSMcQ : dump existing code into this document</item>
<item>2021-08-16 : CMSMcQ : made first version of this file</item>
</list>
</revisionDesc>
</teiHeader>

<text>

<front>
<titlePage>
<docTitle>
<titlePart>Aparecium</titlePart>
<titlePart>An ixml parser for XSLT and XQuery</titlePart>
</docTitle>
<docAuthor>C. M. Sperberg-McQueen</docAuthor>
<docDate>Begun 16 August 2021
<lb/>Last rev. &date.last.touched;</docDate>
</titlePage>
<versionList>
<version id="v0.2">Version presented at Balisage in 2020
and at Declarative Amsterdam in 2021</version>
<version id="pfg">Modifications to support
production of parse-forest grammars</version>
<version id="tok0" fallback="v0.2">Modifications to support
faster tokenization in user-annotated grammars</version>
</versionList>
<divGen type="toc"/>
</front>
<body>
<epigraph>
<q type="block">
<p>... Hermione was pulling her wand out of her bag.</p>
<p><q>It might be invisible ink!</q> she whispered.</p>
<p>She tapped the diary three times and said,
<q>Aparecium!</q></p>
</q>
<bibl>
J. K. Rowling, <title>Harry Potter 
and the Chamber of Secrets</title>
</bibl>
</epigraph>

<p>This document is the source code for Aparecium, an invisible-XML
processor written in XSLT and XQuery, as a library for use in those
languages.  Aparecium is a <soCalled>literate program</soCalled>, in
the sense defined by Donald Knuth: this document contains descriptions
of the program in English prose and in XQuery and XSLT source code.
Processed in one way, the document produces XQuery and XSLT programs;
processed another way, it produces a (rather dry) technical exposition
of their structure and coding.  Readers in search of user-level
introductions to invisible XML or the use of Aparecium to build
applications will not find here what they seek.</p>

<p>The specific literate programming system used here is SWeb; a
description of its notation is given in <ptr target="msm-1996"/>.
The locus classicus for literate programming in general is
<ptr target="Knuth-1984"/>.<note place="foot">
<p>In most crucial ways, SWeb resembles Knuth's WEB system, as do
most other literate programming systems: code is presented in a
sequence determined by rhetorical and expository considerations and
not by the constraints imposed by the programming language, one code
scrap can refer to another (which generally takes the form of a
hyperlink in the readable documentation, and of a transclusion in
the machine-processable form), and some code scraps are identified
as continuations of others, without an explicit hyperlink from the
predecessor to the continuation.</p>

<p>There are, of course, some differences.  WEB and CWEB are each
specialized to a particular programming language (C, Pascal) and
pretty-print code scraps using a characteristic typographic style;
SWeb follows the example of nuweb, noweb, and other
language-independent systems in presenting code verbatim, much as it
would appear in a programmer's editor before the widespread
introduction of syntax-coloring.  WEB documents consist of a flat
sequence of numbered <soCalled>modules</soCalled> each with at most
one scrap of code; SWeb documents have (or can have) a more
conventional hierarchical structure of sections and subsections; in
consequence, the numbering of code scraps is independent of document
structure.  WEB has a relatively simple but powerful macro system;
SWeb has none.</p>
</note>
<!-- <ref target="notation">in an appendix</ref>. -->
</p>

<p>In its current form, the document is incomplete and not well
organized.  It was created by making a skeletal overview of the
document as it should be and then breaking the source code of a
running version of Aparecium up into chunks and inserting them into
that skeleton.  Not everything landed where it ought in principle to
have landed; the organization of the document suffered somewhat from
that.  As time permits, I hope to revise the document to make it
easier to read and better organized.</p>
<p>At this revision (&date.last.touched;), Aparecium works and passes
the large majority of the tests available.  (A list of test-case
failures as of today is given <ref target="known-bugs">in an
appendix</ref>.)  The current plans for further work are 
given <ref target="to-do">in a different appendix</ref>.</p>

<div id="intro">
<head>Introduction</head>
<p>Aparecium is an XQuery implementation of Invisible XML (or:
ixml).  In the usual case, it accepts a context-free grammar
and input, and it returns an XML representation of the parse
tree.  Any grammar in the grammar notation defined by the
specification for Invisible XML (<ptr
target="pemberton-2021"/>) is accepted, and the XML
representation returned will be not the raw parse tree but the
tree as modified by annotations in the grammar.
</p>
<!-- further description of ixml desirable -->
<p>This paper assumes that the reader is familiar with the ideas of
Invisible XML and those of Earley parsing.  Several accessible
introductions to Invisible XML can be found at
<xref>http://invisiblexml.org</xref>, as can the formal
specification itself (<ptr target="pemberton-2021"/>).  A discussion
of the particular challenges of implementing an Earley parser in a
declarative functional language, and a re-formulation of the Earley
algorithm in declarative terms to simplify that task, may be found
in <ptr target="msm-2017"/>.</p>
</div>

<div id="overall">
<head>Overall structure</head>
<p>Aparecium divides its task into several steps:
<list>
<item>
<p>Depending on the top-level function called, we may
start work with a string containing the input to be
parsed, or with a URI which should be dereferenced in
order to obtain the string to be parsed.  The grammar may
be provided as a string, as a URI, as an XML document
containing the standard XML representation of the ixml
grammar, or as a <soCalled>compiled</soCalled> or prepared
grammar.</p>	    
<p>The first step is thus to collect what is needed and
put it into the form required for further processing: a
prepared grammar &G; and a string &I; (for
<gloss>input</gloss>) to be parsed.</p>
</item>
<item>
<p>The second step is to calculate the Earley set, a set
of Earley items sufficient to indicate whether &I; is a
sentence in &L.G; (the language defined by &G;).</p>
<p>This suffices for an Earley recognizer, which
recognizes &L.G;, but not for a parser, which identifies
the parse trees of sentences in &L.G;.
</p>
</item>
<item>
<p>The next step is to use the Earley set to construct a
parse tree for the sentence.</p>
<p>When the sentence has only one parse tree, this is
relatively straightforward, but there are some cases of
interest in which we can expect sentences to be ambiguous,
and in which the user may wish to inspect more than one
possible parse tree.  For example, in a programming
language, keywords might have the same lexical form as
variable or function names, and this can easily give rise
to ambiguity.  Or the grammar writer may be trying to
detect possible ambiguities in a language specification
and need to examine in detail the possible parses for
ambiguous sentences.</p>
<p>In some cases, the number of possible parse trees
may be unbounded.<note place="foot">
<p>A simple example is the grammar <code>S:  'a';
S.</code>,
for which the single sentence (<q><code>a</code></q>)
has an infinite number of parses (one <ident>S</ident>
node, two <ident>S</ident> nodes, three, ...).</p>
<p>Another is the grammar <code>S: S*; {nil}.</code>,
which provides an infinite number of parses for the
empty string, which vary both in depth and in width.</p>
</note></p>
<p>For this reason, Aparecium typically divides this step further.
For historical reasons, there are two work flows.
<list>
<item>
<p>In the original flow, Aparecium extracts raw parse trees direct
from the Earley set.  It attempts to identify and return
<emph>all</emph> the parse trees for the sentence, except that it
uses simple forms of loop detection to avoid attempting to produce
an infinite number of trees.</p>
</item>
<item>
<p>A second function then simplifies the raw parse trees as
specified in the annotation of the ixml grammar, in order to produce
the XML output (sometimes referred to here as an abtract syntax tree
or AST).</p>
</item>
</list>
A second flow works differently.
<list>
<item>
<p>From the Earley set, the second flow extracts a parse-forest
grammar extract a parse-forest grammar representing all parse trees
for the sentence.  (Well, almost all: here, too, loop detection is
used to keep the task finite.)</p>
<p>Parse-forest grammars have the convenient property that they can
concisely describe more than one parse tree over the given input,
even infinite trees.  It is relatively straightforward to tell by
examining the parse-forest grammar whether it describes a single
parse tree or multiple parse trees, and whether the number of parse
trees is finite or infinite.</p>
</item>
<item>
<p>A separate function extracts a single parse tree from the
parse-forest grammar.</p>
</item>
</list>
</p>
</item>
<item>
<p>Again depending on the top-level function called, we may return
to the user a single tree, a collection of trees, or a parse-forest
grammar.</p>
<p>The design also foresees the user being able to specify a maximum
number of parse trees to return in case of ambiguity, or the
processor being able to deliver a <soCalled>tree cursor</soCalled>
pair consisting of a parse tree and a function which, when called,
returns the next parse tree and a function to call for the one after
that.  At this time, these additional variations are not
available.</p>
</item>
</list>
</p>
<p>Functions performing these high-level tasks are described
below in section <ptr target="highlevel" type="secnum"/>.</p>
<p>Lower-level functions called upon by the higher-level
routines are described in section <ptr target="lowlevel"
type="secnum"/>.</p>
</div>

<div id="highlevel">
<head>High-level functions</head>
<p>The following sections describe the high-level
functionality described above.</p>

<div id="hi-code-org">
<head>Organization of the code</head>
<p>The code is organized into different modules
(and files) in an attempt to keep things organized.
<list>
<item><ident>Aparecium.xqm</ident> declares the top-level user-facing
functions for parsing (and also some cruft most users can and should
ignore).</item>
<item><ident>Earley-recognizer.xqm</ident> declares the high-level
functions of an Earley recognizer.  These functions prepare the
grammar, build the initial Earley item, and construct the Earley set.
The functions here are relatively abstract and are intended to be
independent of many of the lower-level implementation details, which
are factored out into an internals module.  As a recognizer, all the
main function here does is to decide whether the input given is or is
not a sentence in the language defined by the grammar.</item>
<item><ident>Earley-rec-internals.xqm</ident> declares low-level
functions called by the Earley recognizer.  These routines reflect
specific implementation choices from which the recognizer itself
should ideally be insulated.</item>
<item><ident>Earley-parser.xqm</ident> declares the high-level
functions of the Earley parser.  The main function calls the
recognizer and constructs a parse tree from the Earley set generated
by the recognizer.</item>
<item><ident>Earley-parser-internals.xqm</ident> contains low-level
routines for the Earley parser.</item>
<item><ident>Gluschkov.xqm</ident> decorates the right-hand sides of
rules in a grammar with attributes allowing the rule to be interpreted
as a finite state automaton instead of as a regular expression.</item>
</list>
These files are described in the following paragraphs.
</p>
<div id="files-ap">
<head>Aparecium module:  <ident>Aparecium.xqm</ident></head>
<p>The file <ident>Aparecium.xqm</ident>
contains the module the typical user will
want to import and use.
<scrap file="Aparecium.xqm">
module namespace aparecium =
"http://blackmesatech.com/2019/iXML/Aparecium";

(: Aparecium:  a library to make invisible XML visible.

    ... Hermione was pulling her wand out of her bag.
    "It might be invisible ink!" she whispered.
    She tapped the diary three times and said, "Aparecium!"
      
                           - J. K. Rowling, Harry Potter 
                           and the Chamber of Secrets

:)

<ptr target="aparecium-imports"/>

<ptr target="aparecium-main"/>
<ptr target="aparecium-secondary"/>
<ptr target="aparecium-tertiary"/>
<ptr target="aparecium-variables"/>
</scrap></p>

<p>The file needs to import the Earley parser and the constructor
for Gluschkov automata.
<scrap id="aparecium-imports"
       name="Module imports for Aparecium top-level">
import module namespace earley
   = "http://blackmesatech.com/2019/iXML/Earley-parser"
  at "Earley-parser.xqm";
import module namespace gluschkov
   = "http://blackmesatech.com/2019/iXML/Gluschkov"
  at "Gluschkov.xqm";
  
(: Quick hack for testing ... :)
import module namespace ws
   = "http://blackmesatech.com/2019/iXML/wstrimtree"
   at "wstrimtree.xqm";
</scrap>
</p>
<p>The user-facing functions of this module are described in
sections <ptr target="hi-calling" type="secnum"/> and <ptr
target="alt-calls" type="secnum"/>.</p>
</div>

<div id="files-parser">
<head>Parser:  <ident>Earley-parser.xqm</ident></head>
<p><ident>Earley-parser.xqm</ident> has the functions called
by the Aparecium module to parse the input and construct the
parse tree.</p>
<p>As far as I have been able to make it so, the functions defined
here are ignorant of details of how the data are represented; they
call functions defined in other modules to take care of the details.
<scrap file="Earley-parser.xqm">
module namespace ep =
"http://blackmesatech.com/2019/iXML/Earley-parser";

(: The top-level definition of an Earley parser. :)

import module namespace epi =
"http://blackmesatech.com/2019/iXML/Earley-parser-internals"
at "Earley-parser-internals.xqm";
  
</scrap></p>
</div>

<div id="files-epi">
<head>Parser internals:  <ident>Earley-parser-internals.xqm</ident></head>
<p>Some lower-level functions are separated out into
<ident>Earley-parser-internals.xqm</ident>.  These functions are not
intended to be used by users of the Earley parsers; if I knew how to
hide their names, I would.  The functions defined here are intended to
be called by the parser proper; the internal details (in particular
the representation of data structures) are subject to change.
<scrap file="Earley-parser-internals.xqm">
module namespace epi =
"http://blackmesatech.com/2019/iXML/Earley-parser-internals";

(: Internals of Earley parser. :)
(: Not intended for user exposure. :) 

import module namespace er =
"http://blackmesatech.com/2019/iXML/Earley-recognizer"
at "Earley-recognizer.xqm";

import module namespace eri =
"http://blackmesatech.com/2019/iXML/Earley-rec-internals"
at "Earley-rec-internals.xqm";
  
declare namespace follow = 
"http://blackmesatech.com/2016/nss/ixml-gluschkov-automata-followset"; 

declare namespace ixml = 
"http://invisiblexml.org/NS";

declare namespace ap = 
"http://blackmesatech.com/2019/iXML/Aparecium";

(: We rely on the EXPath file module, and we use maps. :)
declare namespace file =
"http://expath.org/ns/file";

declare namespace map =
"http://www.w3.org/2005/xpath-functions/map";



<ptr target="epi-earley-parse"/>
<ptr target="epi-all-trees"/>
<ptr target="epi-any-tree"/>
<ptr target="epi-tree-cursor"/>
<ptr target="epi-parse-forest-map"/>
<ptr target="epi-parse-forest-grammar"/>
<ptr target="epi-tree-from-pfg"/>
<ptr target="epi-all-node-sequences"/><!--
<ptr target="epi-lnDepXCLeC"/> -->
<ptr target="epi-astXparsetree"/>
</scrap></p>
</div>

<div id="files-rec">
<head>Recognizer: <ident>Earley-recognizer.xqm</ident></head>

<p>Most of the actual work done is performed by the code in
<ident>Earley-recognizer.xqm</ident>: 

<scrap file="Earley-recognizer.xqm" id="Earley-rec">
module namespace ix =
"http://blackmesatech.com/2019/iXML/Earley-recognizer";

(: Earley parser, v0 :)

import module namespace ixi =
"http://blackmesatech.com/2019/iXML/Earley-rec-internals"
at "Earley-rec-internals.xqm";

<ptr target="er-scan"/>
<ptr target="er-pred"/>
<ptr target="er-comp"/>
<ptr target="er-recognize"/>
</scrap></p>
</div>
<div id="files-eri">
<head>Recognizer internals: <ident>Earley-rec-internals.xqm</ident></head>
<p>The low-level functions of the recognizer are in
<ident>Earley-rec-internals.xqm</ident>.  The
<soCalled>public</soCalled> interface (the functions intended for use
by consumers) is in Earley-recognizer.xqm; this module contains
details that are subject to change and intended to be
<soCalled>private</soCalled>.</p>

<p>The Earley-rec-internals module has a (cyclic) import
for the recognizer itself (why?), and also some low-level
things.
<scrap id="eri-imports"
       name="Imports for recognizer internals">
(: ****************************************************** 
   * Imports and setup
   ****************************************************** :)

import module namespace ix =
"http://blackmesatech.com/2019/iXML/Earley-recognizer"
at "Earley-recognizer.xqm";
  
import module namespace d2x =
'http://blackmesatech.com/2019/iXML/d2x'
at "d2x.xqm";
  
declare namespace follow = 
"http://blackmesatech.com/2016/nss/ixml-gluschkov-automata-followset";

(: $ixi:combinedups:  convenience variable for calls to 
   map:merge. :)
declare variable $ixi:combinedups as map(*)
   := map:entry('duplicates','combine');
</scrap>
</p>
<p>
The overall structure of the internals file:
<scrap file="Earley-rec-internals.xqm">
module namespace ixi =
"http://blackmesatech.com/2019/iXML/Earley-rec-internals";

(: Earley recognizer internals :)

declare namespace map =
"http://www.w3.org/2005/xpath-functions/map";

<ptr target="eri-imports"/>   
<ptr target="eri-items"/>   
<ptr target="eri-grammars"/>   
<ptr target="eri-rules"/>   
<ptr target="eri-symbols"/>   
<ptr target="eri-input"/>   
<ptr target="eri-utils-and-misc"/>   
</scrap>
</p>
</div>
</div>
<div id="hi-calling">
<head>Calling the parser</head>

<p>Aparecium is designed to make loading non-XML resources as easy
as loading XML documents.  When loading XML, the user of the XPath 3
function library merely needs to call the <code>doc()</code>
function, with a URI naming the resource, and the processor takes
care of the rest.</p>
<p>Aparecium provides several main functions to do analogous work for
non-XML data described by a gramar:<list>
<item><p>The <ident>parse-resource()</ident> function takes URIs for
the input string and the input grammar to be used to parse the
string.</p></item>
<item><p>The <ident>parse-string()</ident> function is intended for
use when the input string and the input grammar are already
available, as character strings.</p></item>
<item><p>The <ident>parse-string-with-compiled-grammar()</ident>
function caters for the case in which multiple strings are to be
parsed with the same grammar; functions to compile the grammar for
reuse are listed in section <ptr type="secnum"
target="alt-calls-secondary"/>.</p></item>
<item><p>The <ident>doc()</ident> function (not yet implemented) is
an attempt to let the function library handle the task of
identifying a suitable grammar for a given input.</p></item>
</list>

<scrap id="aparecium-main"
       name="Main interfaces for Aparecium">

(: ******************************************************
   * Main interfaces (and the simplest) 
   ******************************************************
   :)  
<ptr target="ap-pr"/>
<ptr target="ap-ps"/>
<ptr target="ap-pswcg"/>
<ptr target="ap-doc"/>
</scrap>
</p>

<p>All of the user-facing functions <hi>[will eventually]</hi> come in
two forms, with and without an <ident>$options</ident> argument.<note place="foot">
<p>User-supplied options have been postponed for a while, in part
because they complicate testing; other things have a higher
priority.</p>
</note>  The
<ident>$options</ident> argument is a map with various user-settable
options.  For the moment, the options we care about are:
<list>
<item><kw>return</kw>:  specifies what information the user would
like back.  Values are:
<list>
<item><kw>any-tree</kw>: return a parse tree; if there is more than one, return any one.</item>
<item><kw>all-trees</kw>: return all the parse trees, except those excluded by
loop detection.</item>
<item><kw>n-trees</kw>: return up to &n; parse trees, if there are that many; &n; is
specified on the <kw>tree-count</kw> option. <hi>Not yet implemented.</hi></item>
<!-- 
<item><kw>tree-cursor</kw>: return a pair consisting of a parse trees
and a function; when called, the function returns the next parse tree
and a new function.  By calling each function in turn, the user can
retrieve and examine as many parse trees as they wish.  When the set
of parse trees has been exhausted, a no-more-trees signal is
returned. <hi>Not yet implemented.</hi></item> 
-->
<item><kw>parse-forest-grammar</kw>: return a parse-forest grammar (in ixml form) for
the set of parse trees found.</item>
<!--
<item><kw>parse-forest-map</kw>: return a map with a parse forest.  <hi>Not yet
implemented.</hi></item>
-->
<item><kw>Earley-set</kw>: return the set of Earley items generated by the
Earley recognition algorithm; often called a <term>chart</term>.  <hi>Not yet
implemented.</hi></item>
</list>
Other values foreseen but not yet implemented include
<kw>tree-cursor</kw> and <kw>parse-forest-map</kw>.  (These may be
mentioned elsewhere.)
</item>
<item><kw>tree-count</kw>:  specifies how many trees to return; makes sense
only with <kw>n-trees</kw> value for <kw>return</kw>.
</item>
<item><kw>tree-form</kw>: allows the user to request raw parse trees
instead of the abstract syntax trees required by the ixml spec.  Makes
sense only if XML parse trees are being returned.  Values:
<list>
<item><kw>ast</kw>: the default.  An abstract syntax tree in which the
marks in the ixml input grammar specify that some nonterminals and
terminals are to be hidden and some nonterminals serialized as
attributes.</item>
<item><kw>raw</kw>: A parse tree in which every nonterminal and
terminal is serialized as an element; for details see section <ptr
target="hi-ptc-raw" type="secnum"/>.</item>
</list>
</item>
</list>
Other options may be described later.</p>
<p>The default options are specified as a global variable:<scrap id="aparecium-variables"
       name="Variables (of interest only for maintainer)">
(: ******************************************************
   * Variables (of interest only for maintainer) 
   ******************************************************
   :)
declare variable $aparecium:options 
   as map(xs:string, item()*)
   := map {
        'return': 'any-tree',
        'tree-count': 2,
        'tree-form': 'ast',
        <ptr target="aparecium-other-default-options"/>
      };
</scrap>
</p>
<p>
<hi>N.B. Not all of these options are implemented yet.</hi></p>
<p><hi>To do: figure out how to pass in options from the command line.</hi></p>
<p>
<hi>To do:</hi> allow options
on these to control what is returned, and how:
<list>
<item>parse tree(s) or parse-forest grammar?</item>
<item>AST (as in the spec) or raw parse tree (for debugging)?</item>
<item>with or without <att>_from</att> and <att>_to</att> attributes
giving character offsets of the construct?</item>
</list>
</p>

<div id="hi-call-pr">
<head>The <ident>parse-resource()</ident> function</head>
<p>Given URIs for the input and an ixml grammar describing it, the
<ident>parse-resource()</ident> function returns (if all goes well)
the XML representation of the resource. If not all goes well, XML
representations of other situations are returned:
<list>
<item><p>An <gi>aparecium:no-parse</gi> element indicates that the
grammar does not actually describe the input &mdash; the input is
not a sentence in the language described by the grammar.  The
element may contain some diagnostic information intended to help the
human user understand where the parsing attempt failed.</p></item>
<item><p>An <gi>aparecium:error</gi> element indicates that
something went wrong.  It should have both an error code (tbd) and
some prose explanation of the error.</p>
<p><hi>At present, the error detection and error reporting of
Aparecium offer many opportunities for improvement.</hi></p></item>
</list>
<!-- scrap prev="aparecium-main" -->
<scrap id="ap-pr"
       name="Define parse-resource()">
(: ......................................................
   parse-resource($Input, $Grammar)
   ......................................................
:)

declare function aparecium:parse-resource(
  $uriI as xs:string,
  $uriG as xs:string
) as element() {
  let $sI := if (unparsed-text-available($uriI))
             then unparsed-text($uriI)
             else (),
      $sG := if (unparsed-text-available($uriG))
             then unparsed-text($uriG)
             else ()
  return if (exists($sI) and exists($sG))
         then aparecium:parse-string($sI, $sG)
         else <ptr target="appr-errors"/>
};
</scrap>
We wrap the attempts to dereference the URIs in conditionals so as
to detect the case where they are not in fact available.  If both
the input and the grammar are available, we call the
<ident>parse-string()</ident> function and return its result.  (Note
that we assume that if <ident>unparsed-text-available()</ident>
succeeds, then <ident>unparsed-text()</ident> will also succeed.
<hi>The Functions and Operators spec should be checked to make sure
this is the guarantee.</hi>) If either, or both, are missing, we
return an error element.
<scrap id="appr-errors"
       name="If input or grammar are not found, say so">
         if (exists($sI))
         then element aparecium:error {
              attribute id { "ap:tbd01" },
              "Grammar (" || $uriG || ") not found."
         }
         else if (exists($sG))
         then element aparecium:error {
              attribute id { "ap:tbd02" },
              "Input string (" || $uriI || ") not found."
         }
         else element aparecium:error {
              attribute id { "ap:tbd03" },
              "Input string (" || $uriI || ") not found.",
              "Grammar (" || $uriG || ") not found.",
              "You're breaking my heart here."
         }
</scrap>
</p>
</div>

<div id="hi-call-ps">
<head>The <ident>aparecium:parse-string()</ident> function</head>

<p>Given strings with the input and an ixml grammar describing it,
the <ident>parse-string()</ident> function returns the XML
representation of the resource, or an <gi>aparecium:no-parse</gi>
element, or an <gi>aparecium:error</gi> element.

<scrap id="ap-ps"       
       name="Define parse-string()">
(: ......................................................
   parse-string($Input, $Grammar)
   ......................................................
:)

declare function aparecium:parse-string(
  $sI as xs:string,
  $sG as xs:string
) as element() {
  let $cG := &STAT;prof:time( &TATS;
             aparecium:compile-grammar-from-string($sG)
             &STAT;, 
             'parse-string: compiling grammar from string:') 
             &TATS;
             
  return 
    if ($cG/self::aparecium:error)
    then element aparecium:error {
      attribute id { "ap:tbd04" },
      "parse-string():  Error compiling grammar.",
      $cG      
    }
    else &STAT;prof:time( &TATS;
         aparecium:parse-string-with-compiled-grammar($sI, $cG)
         &STAT;, 'parse-string:  parsing input string:') &TATS;
};
</scrap>
</p>
</div>

<div id="hi-call-pscg">
<head>The <ident>aparecium:parse-string-with-compiled-grammar()</ident> function</head>
<p>Given a string with the input and the pre-processed form of an ixml
grammar describing it, the function
<ident>parse-string-with-compiled-grammar()</ident> returns the XML
representation of the string's parse tree.</p>
<p>This is the workhorse of the library, called by many other
functions.  Because it can be called directly with an untrusted
grammar, by default it checks the grammar before using it.<note place="foot">
<p>Since in many cases, the grammar in question will just
have been checked, this may lead to unnecessary slowdowns
in some cases.  If it becomes an issue, we can pass an option
in signaling that the grammar has just been checked.  But in
fact it's quite possible that the XQuery engine will detect
the double call and re-use the answer from the first call.</p>
</note>
<scrap id="ap-pswcg"
       name="Define parse-string-with-compiled-grammar()">
(: ......................................................
   parse-string-with-compiled-grammar($Input, $Grammar)
   ......................................................
:)
declare function aparecium:parse-string-with-compiled-grammar(
  $sI as xs:string,
  $cG as element(ixml)
) as element() {
  let $cg-ok := &STAT;prof:time( &TATS;
                aparecium:grammar-ok($cG)
                &STAT;, 'pswcg() calling grammar-ok():') &TATS;

  let $result := if ($cg-ok/self::ixml) 
                 then &STAT;prof:time( &TATS;
                     earley:any-tree($sI, $cG) 
                     &STAT;
                     , '0 Outer call to earley:any-tree(): ')
                      &TATS;
                 else element aparecium:error {
                   attribute id { "ap:tbd05" },
                   "Compiled grammar flawed:",
                   $cg-ok
                 }
		 
  return if (count($result) eq 1)
         then $result
         else &lt;forest 
              xmlns:ixml="http://invisiblexml.org/NS"
	      >{$result}&lt;/forest>
};
</scrap>
</p>
</div>

<div id="hi-call-doc">
<head>The <ident>aparecium:doc()</ident> function</head>


<p>In the simple case, Aparecium is designed to be callable
in much the same way as the <code>doc()</code> function.
If the file at <ident>http://example.com/local.css</ident>
were in XML, the expression
<code>doc("http://example.com/local.css")</code>
would have a document node as its value.  But a file
named <ident>local.css</ident> is probably not in XML.
With Aparecium, the idea is to open it with a call like
<code>aparecium:parse-resource( "http://example.com/local.css",
"http://example.com/grammars/css.ixml")</code>, which will
fetch the CSS file and a grammar for CSS, use the grammar
to parse the CSS, and return the document node of an XML
document representing the resulting parse tree.</p>

<p>The <ident>aparecium:doc()</ident> function is intended to be as close
as possible to the <ident>fn:doc()</ident> function.

<hi>This function is not yet implemented, because I haven't gotten
around to it yet.  To work well, it requires a bit more
infrastructure.</hi>

<scrap id="ap-doc"
       name="The doc() function">
(: ......................................................
   doc($InputURI)
   ......................................................
   Given the URI of the input, fetch the ixml grammar 
   describing it and return the XML representation of 
   the resource.
:)

(: TO BE IMPLEMENTED: use html fetch to get both HTTP
header and payload.  If MIME type is ixml, fetch grammar
and call parse-string.  Otherwise, if XML and 200 return
payload, otherwise return header and payload.

declare function aparecium:doc(
  $uriI as xs:string
) as element() {
  let $sI := unparsed-text($uriI),
      $sG := unparsed-text($uriG)
  return aparecium:parse-string($sI, $sG)
};
:)
</scrap>
Before it can parse the resource, the <ident>doc()</ident> function
will need to find a grammar for it.  There are two ways this
can happen (maybe more).
<list>
<item><p>The web server hosting the resource can label it with an HTTP
header in which a reference to the grammar is given.  In <ptr
target="Pemberton-2013"/>, the example given is a CSS stylesheet which
can be served either as <code>text/css</code> (which is usual)
<emph>or</emph> with the HTTP mediatype header
<code>application/xml-invisible;
syntax=http://example.com/syntax/css</code>.  The media type
<code>application/xml-invisible</code> (not currently standardized)
signals that the resource is an invisible XML document; the
<code>syntax</code> parameter gives the URI of an appropriate ixml
grammar.</p>
<p>This approach allows ixml to fit nicely into the architecture of
the Web.  It has the drawback that for the foreseeable future few
servers will provide such HTTP headers; of lesser importance in the
long run (but one important reason the <ident>aparecium:doc()</ident> function
has not yet been implemented) is that this approach requires
the implementor of an invisible-XML parser to understand
content negotiation and implement it correctly.</p>
</item>
<item><p>Even if the web server does not provide a pointer to an
invisible-XML grammar, an ixml parser can keep a cache or directory of
grammars for a set of known media types, and use the media type
returned by the server to find an appropriate grammar.</p>
<p>A parser's installation package might, for example, install
grammars for common media types (<code>text/css</code>,
<code>text/csv</code>, <!-- <code>text/javascript</code> or
<code>application/javascript</code>, -->
<code>text/markdown</code>,
<code>application/sql</code>,
<!-- <code>text/mizar</code>, 
<code>text/n3</code>, 
<code>text/php</code>, 
<code>text/rfc822-headers</code>, 
<code>text/rtf</code>, -->
etc.) and use them when <ident>doc()</ident> is called on a resource
with a known media type.  Since grammars for known media types will be
useful for all ixml users, there might be reason to make the
collection of grammars available on the web.</p>
<p>A parser might allow the user to add grammars to the
cache, to fill gaps in the collection.</p>
<p>Unfortunately, a number of notations that might be of interest to
ixml users have no MIME type registered with IANA, so this approach
does not help for TeX or LaTeX files (even ones that do not change the
default parsing rules), or for grammars in well known notations like
ABNF or Wirth's EBNF or ISO-standard EBNF.  Other notations of
possible interest for ixml users (such as SVG path expressions,
XPath expressions, XSLT match patterns, and others) do not have
registered media types because they are generally embedded in other
contexts rather than being served as stand-alone resources.</p>
</item>
<item><p>In an environment where a small number of grammars are very
often used, an ixml parser might emulate web browsers which sniff
content by examining the first portion of a resource and seeing
whether it <soCalled>looks</soCalled> like a known media type.  In the
same way, an ixml parser could attempt to identify the grammar of an
undocumented (or <code>text/plain</code>) resource by attempting to
parse the first 100 characters using several grammars.  This seems
unlikely to be generally useful, however: there are too many possible
grammars.</p>
</item>
</list>
</p>
</div>
</div>

<div id="hi-prep-input">
<head>Preparing the input</head>
<p>The input does not require any particular preparation (beyond
loading it from a URI in some cases). So this section turns out
to be empty.</p>
</div>

<div id="hi-prep-grammar">
<head>Preparing the grammar</head>
<p>The grammar, on the other hand, does need preparation: once
it's in XML form, it's <soCalled>compiled</soCalled>, which
here means that attributes are added to each <gi>rule</gi> element
describing the right-hand side of the rule as a finite state
automaton, and providing some other information.</p>
<p>In the ideal case, there would be three slightly different data
flows, depending on how the grammar was supplied:
<list>
<item>for a string: parsing into XML, hygiene and other conformance
checks, cleanup, compilation;</item>
<item>for XML: structural checks on the XML, hygiene and other
conformance checks, cleanup, compilation;</item>
<item>for a compiled grammar supplied by the user: structural checks
on the XML, hygiene and other conformance checks, cleanup.</item>
</list>
For the first two, cleanup precedes compilation since cleanup of the
grammar can reduce its size, so the compiler has less work to do.</p>
<p>But the current code uses the same work-flow for all grammars: an
ixml grammar is parsed into XML; an XML grammar is compiled; a
compiled grammar is examined for structural integrity and hygiene
and then cleaned up if options permit it.</p>

<!--
<div id="hi-initial-grammar-check">
<head>Initial grammar checking</head>
<p>Pre-compilation sanity checks.</p>
<p>Omitted for now.</p>
</div>
-->

<p><hi>Notes towards refactoring:</hi> There are several operations
we need to perform on the grammar; how should they be sequenced?
A tentative sequence:
<list>

<item>calculating effective mark for every nonterminal
reference(?)</item>

<item>regular expressions for terminals:<list>
<item>generation of regular expressions for terminals</item>
<item>simplification of resulting expressions (to deal with
terminals which generate the empty language)</item>
</list>
Simplification should precede calculation of Gluschkov automaton.
</item>

<item>inlining to reduce number of Earley items to create:
<list>
<item>identification of nonterminals which should be inlined</item>
<item>rewriting the grammar with inlined hidden nonterminals</item>
<item>simplifying resulting expressions</item>
</list>
Rewriting and simplification should precede calculation of Gluschkov
automaton.
The inlining of hidden nonterminals will interact with the detection
of hidden pseudo-terminals.
</item>

<item>rewriting to create pseudo-terminals:
<list>
<item>marking all nonterminals as CDATA, element-only, or mixed</item>
<item>identification of nonterminals which are candidate
pseudo-terminals:<list>
<item>regular (only regular descendants)</item>
<item>marked ^ with no ^ descendants, or marked - but with a parent
which is not a candidate pseudo-terminal</item>
</list></item>
<item>calculating regular expressions for pseudo-tokens</item>
<item>marking pseudo-tokens</item>
</list>
The detection of hidden pseudo-terminals will interact with
the inlining of hidden nonterminals.
</item>

<item>annotation of each rule with Gluschkov automaton for its
right-hand sides</item>
<item>calculating whether the grammar is LL(1)</item>
<item>determining whether a pseudo-token can be recognized greedily
or must be recognized cautiously.</item>
</list>
<hi>For now, the sequence is simpler: we calculate regexes for
terminals in the same pass as the Gluschkov automaton.  We do not
identify pseudo-terminals, we do not inline hidden nonterminals,</hi>
</p>

<div id="hi-compile-grammar">
<head>Compiling the grammar</head>

<p>Compilation is handled by a separate module,
<ident>Gluschkov.xqm</ident>, which has routines for annotating a
grammar with attributes that allow the right-hand sides to be
interpreted as Gluschkov automata: that is, finite state automata
whose states are the basic symbols of the regular expression.
<scrap file="Gluschkov.xqm">
module namespace gl =
"http://blackmesatech.com/2019/iXML/Gluschkov";

(: Constructs a Gluschkov automaton for ixml :)

(: GPL ...:) 

<ptr target="gl-prolog"/>
<ptr target="gl-ME"/>
<ptr target="gl-merge"/>
<!-- <ptr target="gl-read-one-ixml-char"/> -->
<ptr target="gl-trace"/>
</scrap></p>

<p>This module is one place affected by the syntax changes
between 2013 and 2021.  Most scraps have been written twice,
once in the initial version following the 2013 syntax,
and again for today's syntax. 
(Steven's original paper said something about bootstrapping
and supporting multiple syntaxes, but I got confused and am
not going to try to do that.  Too clever for me.)
Most of the old code should by now have been moved into
an <ref target="ob-ll-sym">appendix</ref>.
</p>

<div id="higl-prolog">
<head>Module prolog</head>
<p>The module prolog defines a namespace for follow sets, and a
variable with the namespace name.  We also import the
<ident>d2x</ident> library so we can use its hex-to-decimal
conversion, and the Earley recognizer internal module, for
constructing regexes from terminal symbols.<note place="foot">
<p>The resulting circular import seems to suggest a failure
of analysis:  perhaps the regex construction belongs here.
But I expect grammar compilation to be refactored soonish,
and the import of <ident>eri</ident> may no longer be needed.</p>
</note>
<scrap id="gl-prolog"
       name="Prolog for Gluschkov module">
import module namespace d2x =
'http://blackmesatech.com/2019/iXML/d2x'
at "d2x.xqm";

import module namespace eri =
"http://blackmesatech.com/2019/iXML/Earley-rec-internals"
at "Earley-rec-internals.xqm";

declare namespace follow =
"http://blackmesatech.com/2016/nss/ixml-gluschkov-automata-followset";

declare variable $gl:follow-ns :=
"http://blackmesatech.com/2016/nss/ixml-gluschkov-automata-followset";
</scrap>
</p>
</div>

<div id="higl-ME">
<head>Calculating the Gluschkov automaton &ME;</head>

<p>For a regular expression &E;, the Gluschkov automaton
(conventionally referred to as &M_E;) is a finite state automaton
derived from (and in some sense constructed on top of) &E;.  The
states of &ME; are the basic symbols of &E;, with the fairly
straightforward interpretation that we are in a given state &q; if and
only if we have just read an input character (or, in the general case,
character sequence) that matches the atomic symbol &q;.  We calculate
the Gluschkov automaton by following the algorithm laid out in <ptr
target="ABK1993"/>, adapted for the XML form of ixml grammars.</p>

<p>Each node <ident>$E</ident> in the expression gets:
<list>
<item><att>id</att> to identify the expression; in the case of
positions (i.e.  occurrences of symbols in the alphabet, as opposed to
parenthesized expressions etc.), this also serves as an identifier for
the FSA state.</item>
<item><att>first</att> = set of positions which match the first symbol
of some word in &L..E;</item>
<item><att>last</att> = set of positions which match the last symbol
in some word in &L..E;</item>
<item><att>nullable</att> = true iff &L..E; contains the empty
word<note place="foot">

<p>Note that if some nonterminal &N; is required in &E;,
<ident>nullable</ident> is false even when &N; generates the empty
string.</p>

<p>It may be helpful in some contexts to distinguish between
<gloss>generates the empty string of symbols in &V;</gloss>
(<ident>nullable<hi rend="sub">V</hi></ident>) from <gloss>generates
the empty string of symbols in &T;</gloss> (<ident>nullable<hi
rend="sub">T</hi></ident>).  Here, <ident>nullable</ident> is just
short for <ident>nullable<hi rend="sub">V</hi></ident>.
</p>

</note></item>
</list>
</p>

<p>We also have attributes to represent the
<ident>follow</ident>(<ident>exp</ident>, <ident>sym</ident>) function
for <ident>exp</ident>=<ident>$E</ident>.  For each position
<ident>$p</ident> in <ident>$E</ident> we have an attribute in the
<ident>follow</ident> namespace whose local name is the ID of
<ident>$p</ident>; the value of the attribute is the set of positions
which can follow <ident>$p</ident> in a path through
<ident>$E</ident>.
</p>

<p>By representing <ident>follow($E,$p)</ident> as an attribute on
<ident>$E</ident> we avoid having to traverse the tree multiple
times.</p>

<p>The construction of the Gluschkov automaton consists largely of
calculating, from the structure of &E;, which symbols can follow which
other symbols, and defining an appropriate transition function.  Along
the way, various auxiliary functions are computed for each
subexpression of &E;.</p>

<p>For the right-hand side of a rule in an ixml grammar, the basic
symbols of the expression are terminal and nonterminal symbols, and
the subexpressions include both the basic symbols and the other
elements in the XML representation of the right-hand side.  For each
subexpression, we add attributes to record various values:
<list>
<item>an ID (for use in referring to the state)</item>
<item><att>nullable</att> (is the empty string in the language
defined by this sub-expression?)</item>
<item><att>first</att> (what are the initial states in the
sub-automaton for this sub-expression?)</item>
<item><att>last</att> (what are the final states in the
sub-automaton for this sub-expression?)</item>
<item>for each state &q; within (the sub-automaton for) this
sub-expression, what are the follow states of &q;?  Here, we need one
attribute for every state within the sub-expression; we make them by
creating, for each such state, an attribute with a local name matching
the ID of the state, in a namespace designed to hold such follow-state
attributes.  So if the states in a given expression are named
<ident>q0</ident>, <ident>q1</ident>, and <ident>q2</ident>, we would
have attributes named <ident>follow:q0</ident>,
<ident>follow:q1</ident>, and <ident>follow:q2</ident>.</item>
<item>For later use in recognition, it will also be helpful to
calculate an XPath 3 regular expression that matches the
terminal.</item>
</list>
These attributes are for the most part of only transient interest:
they are essential for calculating information for the next higher
level of sub-expression, but the information we care about when
running the Earley parser is just the information on the top-level
element of the right-hand side.</p>

<p>Since the values of these attributes are in general calculated
inductively, the first step in handling any element &e; is to recur
to handle the element's children, and then to construct the values
for &e; itself.
<scrap id="gl-ME"
       name="Define function gl:ME()">
declare function gl:ME (
  $E as element()
) as element() {
  let $children := for $c in $E/node() 
                   return if ($c/self::element())
                          then gl:ME($c)
                          else $c,
      $ch := $children[self::element()]
  return <ptr target="gl-ME-identity"/>
  else <ptr target="gl-ME-terminals"/>
  else <ptr target="gl-ME-nonterminal"/>
  else <ptr target="gl-ME-option"/>
  else <ptr target="gl-ME-repeats"/>   
  else <ptr target="gl-ME-sep"/>     
  else <ptr target="gl-ME-alt"/>
  else <ptr target="gl-ME-def"/>
  else <ptr target="gl-ME-rule"/>
  else <ptr target="gl-ME-comment"/>
  else <ptr target="gl-ME-ixml"/>
  else <ptr target="gl-ME-whahhh"/>
};
</scrap></p>
<p>The following sections describe the handling of individual kinds of
expressions.</p>
</div>

<div id="higl-ME-terminals">
<head>Gluschkov automata for terminal symbols</head>

<p>The <gi>range</gi> and <gi>class</gi> elements are always children
of <gi>inclusion</gi> or <gi>exclusion</gi>.  They are thus internal
to the basic symbol and need no decoration, but when the function
handles the parent it will call itself recursively on them; they
should be returned without change.  The <gi>literal</gi> element falls
into this category when it is a child of <gi>inclusion</gi> or
<gi>exclusion</gi>, but it does no harm to handle it separately.</p>

<p>Since all we do is return the elements without change, the code is
trivial.
<scrap id="gl-ME-identity"
       name="Handle leaf nodes">
if ($E/self::range) then $E
else if ($E/self::class) then $E
</scrap>
</p>

<p>For terminal symbols, all attribute values are straightforward.
They are non-nullable, they are their own first and last states, and
they have no follow states.  
<scrap id="gl-ME-terminals"
       name="Handle terminal nodes">
if ($E/self::inclusion or $E/self::exclusion
    or $E/self::literal)
then
      let $id := '_t_' 
                 || (1 + count(($E/preceding::* | $E/ancestor::*)
                    [self::inclusion 
                    or self::exclusion
		    or self::literal])), 
          $re := eri:reXTerminal($E)
      return element {name($E)} {
         $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @regex,
                     @follow:*)),
         attribute xml:id { $id },
         attribute nullable { false() },
         attribute first { $id },
         attribute last { $id },
         attribute {QName($gl:follow-ns, "follow:" || $id)} { },
	 attribute regex { $re },
         $children
      }
</scrap>
The calculation of a regular expression to match the terminal is
delegated to <ident>reXTerminal()</ident> from the Earley
internals module.
</p>

</div>
<div id="higl-ME-nonterminals">
<head>Gluschkov automata for nonterminal symbols</head>

<p>Nonterminals are similarly straightforward:  from the
point of view of the Gluschkov automaton, they are
indistinguishable from terminals.
<scrap id="gl-ME-nonterminal"
       name="Handle nonterminal symbols">
if ($E/self::nonterminal)
then
     let $id := $E/@name || '_'
                || (1 + count($E/preceding::nonterminal
                              [@name = $E/@name]))
     return element nonterminal {
       $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @follow:*)),
       attribute xml:id { $id },
       attribute nullable { false() },
       attribute first { $id },
       attribute last { $id },
       attribute {QName($gl:follow-ns, "follow:" || $id)} { },
       $children
     }</scrap>
</p>

</div>
<div id="higl-ME-opt-rep">
<head>Gluschkov automata for repetitions and options</head>

<p>Syntactically, an option is an expression to which a question mark
has been added.  So any option &E; has the form (&F;?).  &E; is
nullable regardless of whether &F; is or not, and &E; has the same
first, final, and follow sets as &F;.
Note than an <gi>option</gi> should only ever have one child element:
a terminal symbol (inclusion, exclusion, literal), a nonterminal
symbol, or a set of alternatives (<gi>alts</gi>).  If we ever see
anything else, this case will not process it and it will fall through
to the error case.
<scrap id="gl-ME-option"
       name="Handle options">
if ($E/self::option
    [count(*) eq 1]
    [child::*[self::inclusion
              or self::exclusion
              or self::literal 
              or self::nonterminal 
	      or self::alts]])
then
     let $id := 'exp_option_' || (1 + count($E/preceding::option))
     return element option {
       $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @follow:*)),
       attribute xml:id { $id },
       attribute nullable { true() },
       attribute first { $children/@first },
       attribute last { $children/@last },
       for $follow-att in $children/@follow:* 
       return $follow-att,
       $children
     }</scrap>
</p>

<p>Repeats will have either one child element or two.  The
first will be a terminal, a nonterminal, or a set of alternatives;
the optional second child is a separator.  If anything else is
encountered, we are not ready for it and we'll fall through to
the error case.</p>

<p>In the 2013 grammar, a set of alternatives was a
<gi>def</gi> element: 
<scrap id="gl-ME-repeats-2013"
       name="Handle repetitions (v0.1)">
if ($E[self::repeat0 or self::repeat1]
      [*[1][self::terminal or self::nonterminal or self::def]]
      [count(*) eq 1 or child::*[2][self::sep]]
         ) 
then
     let $gi := name($E)
     let $id := 'exp_' || $gi || '_' 
                || (1 + count($E/preceding::*[name() = $gi])),
         $F := gl:notrace($ch[1], "repetition factor F: "),
         $G := gl:notrace($ch[2], "repetition sep G: ")
     return element {$gi} {
       $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @follow:*)),
       attribute xml:id { $id },
       attribute nullable { 
         if ($gi = 'repeat0') 
         then true() 
         else $F/@nullable
       },
       attribute first { 
         if (xs:boolean($F/@nullable) = true())
         then concat($F/@first, ' ', $G/@first)
         else $F/@first
       },
       attribute last { 
         if (xs:boolean($F/@nullable) = true())
         then concat($F/@last, ' ', $G/@last)
         else $F/@last
       },
       <ptr target="gl-ME-rep-follow"/>
       ,
       $children
     }
</scrap></p>

<p>In 2021, the functionality is the same, but the
choice element is named <gi>alts</gi>:
<scrap id="gl-ME-repeats"
       name="Handle repetitions">
if ($E[self::repeat0 or self::repeat1]
      [*[1]
        [self::inclusion or self::exclusion
        or self::literal
        or self::nonterminal
	or self::alts]]
      [count(*) eq 1 
      or child::*[2][self::sep]]) 
then let $gi := name($E)
     let $id := 'exp_' || $gi || '_' 
                || (1 + count($E/preceding::*[name() = $gi])),
         $F := gl:notrace($ch[1], "F: "),
         $G := gl:notrace($ch[2], "G: ")
     return element {$gi} {
       $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @follow:*)),
       attribute xml:id { $id },
       attribute nullable { 
         if ($gi = 'repeat0') 
         then true() 
         else $F/@nullable
       },
       attribute first { 
         if (xs:boolean($F/@nullable) = true())
         then concat($F/@first, ' ', $G/@first)
         else $F/@first
       },
       attribute last { 
         if (xs:boolean($F/@nullable) = true())
         then concat($F/@last, ' ', $G/@last)
         else $F/@last
       },
       <ptr target="gl-ME-rep-follow"/>
       ,         
       $children
     }
</scrap>
</p>

<p>The calculation of the follow set here has several
cases.  Watch carefully.  First case:  no separator.
So for all positions &p; in the expression &E;,
<list>
<item>if &p; is in last(&E;)
then follow(&E;*, &p;) is 
the union of follow(&E;, &p;) with first(&E;)</item>
<item>otherwise
follow(&E;*, &p;) is  
just follow(&E;, &p;)
with no additions.</item>
</list>
<scrap id="gl-ME-rep-follow"
       name="Calculate follow:* attributes for repetitions">
       if (count($ch) eq 1)
       then
         let $lastF := tokenize($F/@last,'\s+'),
             $firstF := tokenize($F/@first,'\s+')
         for $a in $F/@follow:*
         return if (local-name($a) = $lastF)
           then attribute { 
               QName($gl:follow-ns, "follow:"||local-name($a) ) 
             } { 
               gl:merge((tokenize($a,'\s+'), $firstF))    
             }
           else $a
</scrap>
</p>

<p>If there is a separator, then the same principle
applies, but things are complicated by the presence
of the separator in the way.
For all &p;
in &F;*&G; or &F;+&G;, its follow-set depends
on <list>
<item>whether &p; is in &F; or in &G;,</item>
<item>whether it's in last(&F;) or last(&G;),
and </item>
<item>whether &F; and &G; are nullable.</item>
</list>
So we break out the detailed calculations.
The overall pattern is as follows.  We pre-calculate
<list>
<item>the two <ident>last()</ident> sets,</item>
<item>the two <ident>first()</ident> sets,</item>
<item>whether &F; and &G; are nullable, and</item>
<item>for each position in &F; or &G;, its local
name and its follow-set within &F; or &G;.</item>
</list>
<scrap prev="gl-ME-rep-follow"
       name="Calculate follow-set for repetition with separator">
       else (: count($children) eq 2 :)
         let $lastF := tokenize($F/@last,'\s+'),
             $lastG := tokenize($G/@last,'\s+'),
             $firstF := tokenize($F/@first,'\s+'),
             $firstG := tokenize($G/@first,'\s+'),
             $nullableF := (xs:boolean($F/@nullable) = true()), 
             $nullableG := (xs:boolean($G/@nullable) = true())
         return 
           for $a in $children/@follow:* 
           let $p := local-name($a),
               $follow0 := tokenize($a,'\s+')
           let $followset :=  
             <ptr target="gl-ME-rep-follow-sep-1"/>
             <ptr target="gl-ME-rep-follow-sep-2"/>
             <ptr target="gl-ME-rep-follow-sep-3"/>
             <ptr target="gl-ME-rep-follow-sep-4"/>
             <ptr target="gl-ME-rep-follow-sep-5"/>
           return attribute { 
                    QName($gl:follow-ns, 
                          "follow:"||local-name($a) ) 
                } { 
                    $followset    
                    }</scrap>
</p>

<p>If &p; is final in &F; and &G; is nullable, then it's final
in &F;*&G; or &F;+&G; and can thus be followed by any first
state of &G; and any first state of &F;, as well as (naturally)
its follow-set within &F;:
<scrap id="gl-ME-rep-follow-sep-1"
       name="Follow set when p in last(F), G nullable">
             if ($p = $lastF and $nullableG) 
             then gl:merge(($follow0, $firstG, $firstF))
</scrap></p>

<p>If &p; is final in &F; and &G; is <emph>not</emph> nullable, 
then its follow-set omits the first sets of &F;. 
<scrap id="gl-ME-rep-follow-sep-2"
       name="Follow set when p in last(F), G not nullable">
             else if ($p = $lastF and not($nullableG))
             then gl:merge(($follow0, $firstG))
</scrap></p>

<p>If &p; is final in &G; and &F; is nullable, 
then we again have a three-way merge for its follow-set:
its follow-set within &G;, the first-set of &F;, and
(skipping &F; entirely, since it's nullable)
the first-set of &G;. 
<scrap id="gl-ME-rep-follow-sep-3"
       name="Follow set when p in last(G), F nullable">
             else if ($p = $lastG and $nullableF)
             then gl:merge(($follow0, $firstG, $firstF))
</scrap></p>

<p>If &p; is final in &G; and &F; is <emph>not</emph> nullable, 
then the first-set of &G; is not included in the follow-set
of &p;.
<scrap id="gl-ME-rep-follow-sep-4"
       name="Follow set when p in last(G), F not nullable">
             else if ($p = $lastG and not($nullableF))
             then gl:merge(($follow0, $firstF))
</scrap></p>

<p>Finally, if none of the above are true, then &p;
is non-final in either &F; or &G; and its follow-set is
unaffected by the repetition operator, so we just copy it
out again.
<scrap id="gl-ME-rep-follow-sep-5"
       name="Follow set when p non-final in F or G">
             else string($a)
</scrap></p>

<p>We have appealed to a little utility function for merging
sets of IDs.  It's quite straightforward, really, thanks
to <ident>distinct-values()</ident>.
<scrap id="gl-merge"
       name="Define gl:merge()">
declare function gl:merge(
  $ids as xs:string*
) as xs:string {
  string-join(distinct-values($ids),' ')
};
</scrap>
</p>

<p>The <gi>sep</gi> element contains a single factor and
changes none of its properties.
<scrap id="gl-ME-sep"
       name="Handle separator expressions">
if ($E/self::sep
           [count(*) eq 1]
           [child::*[self::inclusion
                     or self::exclusion 
                     or self::literal 
                     or self::nonterminal 
                     or self::alts]]
          ) then
     let $id := 'exp_sep_'
                || (1 + count($E/preceding::sep)) 
     return element sep {
       $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @follow:*)),
       attribute xml:id { $id },
       $ch/@nullable,
       $ch/@first,
       $ch/@last,
       $ch/@follow:*,
       $children
     }
</scrap>
</p>

<p>In 2013 the element names were different.  (Yawn.)
<scrap id="gl-ME-sep-2013"
       name="Handle separator expressions (v0.1)">
if ($E/self::sep
           [count(*) eq 1]
           [child::*[self::terminal 
                     or self::nonterminal
                     or self::def]]
          ) then
     let $id := 'exp_sep_'
                || (1 + count($E/preceding::sep)) 
     return element sep {
       $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @follow:*)),
       attribute xml:id { $id },
       attribute nullable { $ch/@nullable },
       attribute first { $ch/@first },
       attribute last { $ch/@last },
       for $follow-att in $ch/@follow:* 
       return $follow-att,
       $children
     }
</scrap>
</p>

</div>

<div id="higl-ME-sequences">
<head>Gluschkov automata for sequences (<gi>alt</gi>)</head>

<p>An <gi>alt</gi> is one choice among (sometimes) several; it
contains a sequence of terms (i.e. terminal, nonterminal, repetition,
option, nested set of alternatives).  Since it's an arbitrary-length
sequence, not a binary operator, the calculation of first and last and
follow gets a bit tricky.  We may end up needing to normalize to
binary form just to keep things simple.
<scrap id="gl-ME-alt"
       name="Handle alt elements">
if ($E/self::alt) then
     let $id := 'exp_alt_'
                || (1 + count($E/preceding::alt)) 
     return element alt {
       $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @follow:*)),
       attribute xml:id { $id },
       attribute nullable { 
         every $c in $ch
         satisfies (xs:boolean($c/@nullable) eq true())
       },
       attribute first { 
         string-join(
           for $c at $pos in $ch
           return if (every $lsib
	              in $ch[position() lt $pos]
                      satisfies
		      (xs:boolean($lsib/@nullable)
		      eq true() ))
                  then $c/@first
                  else (),
           ' '
         )
       },
       attribute last { 
         string-join(
           for $c at $pos in $ch
           return if (every $rsib
	              in $ch[position() gt $pos]
                      satisfies
		      (xs:boolean($rsib/@nullable)
		      eq true() ))
                  then $c/@last
                  else (),
           ' '
         )
       },
       <ptr target="gl-ME-alt-follow"/>
       ,
       $children
     }
</scrap>
</p>

<p>Again, calculating the follow-set is the most complicated
of the subcalculations for this type of expression.  So let's
take it slowly.
<list>
<item>For every position &p; in each child &c;, the follow set 
follow(&E;,&p;) includes follow(&c;,&p;).</item>
<item>In addition, if &p; is in last(&c;) and &c; has a following sibling,
then follow(&E;,&p;) should include start(next-sibling(&c;)).</item>
<item>
In addition, if &p; is in last(&c;) and &c; has a following sibling,
and also next-sibling(&c;) is nullable, 
then follow(&E;,&p;) should include start(nextsib(nextsib(&c;))).
</item>
<item>
And so forth.</item>
</list>

<scrap id="gl-ME-alt-follow"
       name="Calculate follow:* attributes for alt">
       for $c at $cpos in $ch 
       for $a in $c/@follow:*
       let $p := local-name($a),
           $lastC := tokenize($c/@last,'\s+'),
           $rightsibs := $ch[position() gt $cpos],
           $followset := if ($p = $lastC)
	   then string-join(
             (  $a,
                for $rsib at $rpos in $rightsibs
                let $inbetweens := $rightsibs
		                   [position() lt $rpos]
                return if (every $msib in $inbetweens
                           satisfies
                           (xs:boolean($msib/@nullable)
			   = true() ))
                       then $rsib/@first
                       else ()
             ),
             ' '
           )
           else
             $a
       return attribute { 
             QName($gl:follow-ns, "follow:"||$p )
         } { 
             $followset    
         }
</scrap>
</p>
</div>

<div id="higl-ME-choice">
<head>Gluschkov automata for choice (<gi>alts</gi>)</head>

<p>An <gi>alts</gi> element contains a set of alternatives,
each an <gi>alt</gi> element.
The 2013 alternative was the <gi>def</gi> element,
but note that <gi>def</gi> was required as the top-level
element of a right-hand side, which <gi>alts</gi> is not.
That doesn't affect the treatment of this element,
but it does affect
the treatment of rules, below. 
<scrap id="gl-ME-def"
       name="Handle alts elements (= def)">
if ($E[self::<ptr target="gl-alts-gi"/>]) then
     let $id := 'exp_' || name($E) || '_' 
                || (1 + count(
                $E/preceding::<ptr target="gl-alts-gi"/>)
		) 
     <ptr target="gl-ME-alternatives"/>
</scrap>
We factor out the treatment of alternatives
so that we can re-use it for rules, below.
The properties should all be self-explanatory.
<scrap id="gl-ME-alternatives"
       name="Handle alternatives">
     return element {name($E)} {
       $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @follow:*)),
       attribute xml:id { $id },
       attribute nullable { 
         some $c in $ch
         satisfies
	 (xs:boolean($c/@nullable) eq true() )
       },
       attribute first { 
         string-join($ch/@first, ' ')
       },
       attribute last { 
         string-join($ch/@last, ' ')
       },
       
       (: follow-set is simple here. :) 
       for $a in $ch/@follow:*
       return $a,
       $children
     }
</scrap></p>

<p>As an experiment, I am putting the generic identifier
for the element in a scrap.  If this works, much of the
duplication earlier in this section can be removed.
(Why do ideas come so late?)
<scrap id="gl-alts-gi"
       name="GI for alts element">alts</scrap>
In 2013, it was <gi>def</gi>:
<scrap id="gl-alts-gi-2013"
       name="GI for alts element (v0.1)">def</scrap>
</p>

<p>Since the alternatives inside a rule are not now wrapped
in a <gi>def</gi> or <gi>alts</gi> elements, we need to
put the properties for the rule as a whole on the <gi>rule</gi>
element.
<scrap id="gl-ME-rule"
       name="Handle rule elements">
if ($E/self::rule) then
    let $id := $E/@name
    <ptr target="gl-ME-alternatives"/>
</scrap>
</p>

<p>In 2013, it was simpler.
<scrap id="gl-ME-rule-2013"
       name="Handle rule elements (v0.1)">
if ($E/self::rule) then 
    element rule {
      $E/@*,
      $children
    }</scrap>
</p>

</div>

<div id="higl-ME-choice">
<head>Gluschkov automata for other elements</head>

<p>Finally, a few miscellaneous elements.  Comments
require no annotation.
<scrap id="gl-ME-comment"
       name="Handle comment elements">
if ($E/self::comment) then
    $E
</scrap>
</p>

<p>The <gi>ixml</gi> element also requires no
annotation.
<scrap id="gl-ME-ixml"
       name="Handle ixml elements (grammars)">
if ($E/self::ixml) then 
    element ixml {
      attribute follow:info { 
        "auxiliary namespace for FSA description"
      },
      $E/@*,
      $children
    }
</scrap>
</p>

<p>And finally, at the bottom of the if-then-else ladder,
we handle unexpected elements.
<scrap id="gl-ME-whahhh"
       name="Handle unexpected elements">
if ($E/self::option or $E/self::sep)
then &lt;error>Element {name($E)} with unexpected content: {$E}&lt;/error>
else if ($E/(self::repeat1 or self::repeat0))
then &lt;error>Element {name($E)} with unexpected content: {$E}&lt;/error>
else &lt;error>Unexpected element {$E}&lt;/error></scrap>
</p>
</div>

</div>

<div id="hi-check-compiled-grammar">
<head>Checking the compiled grammar</head>

<p>The grammar needs to be checked for problems. Most of this could
in principle be done either before or after compilation, but since
we allow the user to supply a compiled grammar we do it after.</p>

<p>What is checked for in the grammar is pretty much the same in all
cases, but what is done when problems are found depends in part on the
user's options.
<list>
<item><p><label>structural problems</label>: The grammar needs to be
structurally sound and usable for parsing; the grammar should also
satisfy the spec's requirement that a conforming XML grammar <q>can be
derived from an ixml grammar in ixml form by parsing as described in
this specification</q>.
<list>
<item>If <q><kw>conformance</kw></q> = <q><kw>pedantic</kw></q> or
<q><kw>strict</kw></q>, then we check every element in the grammar to
ensure that it conforms to the implicit requirements of the ixml
specification grammar, with respect to:
<list>
<item>its children and their sequence</item>
<item>its attributes and their lexical form</item>
</list>
This should be at least approximately equivalent to validation against
a DTD or schema derived mechanically from the ixml grammar.</item>
<item>If <q><kw>conformance</kw></q> = <q><kw>tolerant</kw></q>,
the same checks are performed, but 
<list>
<item>pragmas and namespace-qualified elements are ignored</item>
<item>namespace-qualified attributes are ignored</item>
</list>
</item>
</list>
</p>
</item>

<item><p><label>compilation artifacts</label>: Every rule should have
the attributes supplied by the compiler.  We can't check them for
integrity, of course; this is just a sanity check in case the user
accidentally supplies an uncompiled grammar when we expect a compiled
one.</p></item>

<item><p><label>non-XML names</label>: All nonterminals must either be
acceptable as XML names or marked <q><code>-</code></q>.</p></item>
<item><p><label>uniqueness of rules</label>: Any two <gi>rule</gi>
elements must have different names.</p></item>
<item><p><label>character classes</label>: Any character class
appearing as a member of a character set (an <gi>inclusion</gi> or an
<gi>exclusion</gi>) must be one listed in Unicode.</p></item>
<item><p><label>undefined nonterminals</label>: Every nonterminal
referred to should be defined.</p></item>
<item><p><label>unreachable nonterminals</label>: Every nonterminal
defined should be reachable from the start symbol.</p></item>
<item><p><label>unproductive nonterminals</label>: Every nonterminal
defined should generate some set of strings.</p></item>
</list>
</p>

<p>The ixml specification defines grammars as non-conforming if they
contain multiple rules for the same nonterminal or undefined
nonterminals, on the grounds that these often signal that the grammar
writer slipped up somewhere. Students of formal languages (e.g. <ptr
target="GJ"/>) describe undefined, unreachable, and non-productive
nonterminals as <term>useless nonterminals</term> and treat them under
the heading <q>Hygiene in context-free grammars</q>, together with an
algorithm for cleaning up a grammar that contains them.<note
place="foot">
<p>Note that the class of hygiene problems catalogued in formal
language theory does not coincide exactly with the class of grammars
ixml defines as non-conforming: nothing in the ixml spec appears to
forbid unproductive nonterminals, or terminals which are referred to
but not reachable.</p>
<p>And unlike ixml, formal language theory does not regard the
existence of multiple rules for a nonterminal as any sort of problem
at all.</p>
<p>To be blunt, I am inclined to think that the spec is here too
paternalistic, and that these peculiarities merit a warning, not an
error.  They pose no barrier to successful parsing: undefined
nonterminals will be dead ends in the derivation process, and
unreferenced rules will never play a role in any successful
derivation, but unless every rule in the grammar is useless, parsing
can go on regardless.</p>
<p>So Aparecium has user-settable options to treat multiple definitions,
undefined nonterminals, unreachable nonterminals, and unproductive
nonterminals as errors, as things eliciting warnings, or as things
to be accepted silently.</p>
</note>
The code in this section will (at user option) detect these issues,
warn the user (or raise an error), and clean up the grammar.<note
place="foot">
<p>It is not essential to clean the grammar, but it will make the
grammar smaller and in some cases will avoid useless work by the
Earley parser.</p>
</note>
</p>

<p>The user can <hi>[will be able to]</hi> control some of what
happens here by setting the following options:
<list>
<item><kw>multiple-definitions</kw></item>
<item><kw>undefined-nonterminals</kw></item>
<item><kw>unreachable-rules</kw></item>
<item><kw>unproductive-nonterminals</kw></item>
</list>

For all four, possible values are <q><kw>error</kw></q>,
<q><kw>warning</kw></q>, or <q><kw>silence</kw></q>.  All four default
will eventually default to <q><kw>warning</kw></q>, unless the user
specifies strict conformance to the ixml spec, in which case the first
two will be set to <q><kw>error</kw></q>.  For the moment, however, we
define the default options to be what the spec requires and no more.
<scrap id="aparecium-other-default-options"
       name="Other default options">
        'multiple-definitions': 'error',
        'undefined-symbols': 'error',
        'unreachable-symbols': 'silence',
        'unproductive-symbols': 'silence',
</scrap>
</p>
<p>We will also need to define an option to control how pedantically
Aparecium should adhere to the spec.  The neutral term is <q>strict</q>
conformance, but sometimes nothing but <q><kw>pedantic</kw></q> is
going to feel satisfactory.
<scrap prev="aparecium-other-default-options">
        'conformance': 'tolerant' 
</scrap>
<hi>Thanks to Merriam-Webster for help finding something between
<q>strict</q> (<q>punctilious</q>, <q>heavy-handed</q>)
and <q>lax</q> (<q>loose</q>, <q>slipshod</q>).</hi>
</p>

<p>All of the grammar checking is managed by the Aparecium
<ident>grammar-ok()</ident> function.  The basic plan is
simple: we collect several lists of error elements
(<q><code>lee-...</code></q>), and if at the end all lists are empty,
we succeed.  If we find errors, we wrap them with the grammar
and return an <gi>aparecium:error</gi> element.
<scrap id="ap-grok"
       name="The grammar-ok() function">
(: grammar-ok(): check grammar 
:)
declare function aparecium:grammar-ok(
  $G as element()
) as element() {
  if ($G/self::ixml)
  then 
  let $dummy := trace($G/rule[1]/@name/string(),
                'grammar-ok() called on grammar for: ')
  <ptr target="ap-grok-str"/>
  <ptr target="ap-grok-comp"/>
  <ptr target="ap-grok-names"/>
  <ptr target="ap-grok-uniqdef"/>
  <ptr target="ap-grok-charclass"/>
  <ptr target="ap-grok-alldef"/>
  <ptr target="ap-grok-reach"/>
  <ptr target="ap-grok-prod"/>
  let $lee-all := ($lee-struc, $lee-comp,
                   $lee-names,  
                   $lee-uniqdef, $lee-charclass,
                   $lee-alldef, 
                   $lee-reachable, $lee-productive)
  return if (empty($lee-all/self::aparecium:error))
  then $G
  else element aparecium:error {
    attribute id { "ap:tbd06" },
    element p { "Errors found in grammar." },
    $lee-all,
    $G
  }
  else element aparecium:error {
    attribute id { "ap:tbd07" },
    element p { "This is not a grammar." },
    $G
  }
};
</scrap>
</p>

<p>For now, our structural checks are rudimentary, more symbolic than
real.  We have already checked that <ident>$G</ident> is an
<gi>ixml</gi> element; here we check that all the children of
<gi>ixml</gi> are rules or comments or pragmas, and all the
children of <gi>rule</gi> elements are <gi>alt</gi> or
comments or pragmas.
<scrap id="ap-grok-str"
       name="Check for structural problems">
  let $lee-struc := (
      let $le0 := $G/*
          [not(self::rule or self::comment or self::pragma)]
      for $e in $le0 
      return element aparecium:error {
        attribute id { "ap:tbd08" },
        "Unexpected " || $e/name() 
        || " element as child of ixml."
      },

      let $le0 := $G/rule/*
          [not(self::alt or self::comment or self::pragma)]
      for $e in $le0 
      return element aparecium:error {
        attribute id { "ap:tbd09" },
        "Unexpected " || $e/name() 
        || " element as child of rule."
      }

  )
      
</scrap>
Later, this will be replaced with code to validate every
child against the appropriate content model and check
attributes.
</p>
<p>Since we cannot check the compilation of the grammar
in detail, we limit ourselves to checking that every
rule has the attributes assigned by the compiler.
<scrap id="ap-grok-comp"
       name="Check for compiler attributes">
  let $lee-comp := ()
</scrap>
<hi>The data flow has gotten confused. Let's leave this out for
now.</hi>
<scrap name="Check for compiler attributes">
  let $lee-comp := (
      for $r in $G/rule[not(@xml:id)
          or not(@nullable)
          or not(@first)
          or not(@last)
          ]
      return element aparecium:error { 
        attribute id { "ap:tbd10" },
        "Compilation problem?  Rule " || $r/@name 
        || " lacks compiler attributes."
      }
  )
</scrap>
</p>
<p>The ixml spec makes it a dynamic error in the grammar
for a nonterminal with a non-XML name to be serialized.
We detect the problem statically:  if a name is not
castable as xs:NCName, then it must be marked as hidden,
either on the <gi>rule</gi> element or on all
references to it.<note place="foot">
<p>Strictly speaking, a nonterminal which is only
ever used in an attribute value can use any mark
desired, since the mark is ignored.  In this case,
Aparecium will flag an error even though the dynamic
error case cannot arise.</p>
<p>Somehow, this does not worry me much.</p></note>
<scrap id="ap-grok-names"
       name="Check for non-XML names">
  let $lee-names := (
      for $r in $G/rule
                [not(@name castable as xs:NCName)]
      let $nt := $r/@name/string(),
          $mark := string($r/@mark),
          $references := $G//nonterminal[@name eq $nt],
          $rmarks := distinct-values(
	      for $ref in $references
              return string($ref/@mark)
          )
      where (( ($mark = ('^', '@', ''))
               and ($rmarks = ('^', '@', '')) )
            or ( ($mark eq '-')
               and ($rmarks = ('^', '@')) ))
      return element aparecium:error {
               attribute id { "ap:tbd11" },
               $nt || " is not allowed as an XML name."
               || " It must be marked as hidden."
             }
  ) 
</scrap>
</p>
<p>The ixml spec requires that no nonterminal have
two <gi>rule</gi> elements.  So we group by name and
seek groups with count greater than one.
<scrap id="ap-grok-uniqdef"
       name="Check rules for uniqueness">
  let $lee-uniqdef := (
      for $r in $G/rule
      let $nt := string($r/@name)
      group by $nt
      return if (count($r) gt 1)
      then (
        trace((), 
           "Symbol " || $nt 
           || " defined " || count($r) || "&#215;: "),
        element aparecium:error {
        attribute id { "ap:tbd12" },
        $nt || " is defined " ||
        (if (count($r) eq 2)
        then "twice"
        else count($r) || " times")
        || "."
      })
      else ()
  )
</scrap>
</p>
<p>In character sets, classes referred to must be
classes listed in Unicode.  The XML representation of
classes is changing, so this code will (for now)
check both forms.
<scrap id="ap-grok-charclass"
       name="Check character classes">
  let $lee-charclass := (
      for $cc in ($G//class/@code,
                  $G//member/@code)
      let $nt := string($cc/ancestor::rule/@name)
      where not(matches($cc,
                '^(L[ulmo]?'
                || '|M[nce]?'
                || '|N[dlo]?'
                || '|P[cdseifo]?'
                || '|Z[slp]?'
                || '|S[mcko]?'
                || '|C[cfon]?)$'))
      return element aparecium:error {
        attribute id { "ap:tbd16" },
        "Character class", string($cc), 
        "in the definition of", $nt, 
        "is not known."
      }
  )
</scrap>
</p>
<p>The spec forbids references to undefined
nonterminals; here we group references by name
and look each name up.
<scrap id="ap-grok-alldef"
       name="Check for undefined symbols">
  let $lee-alldef := (
      for $ref in $G//nonterminal
      let $nt := string($ref/@name)
      group by $nt
      return if (empty($G/rule[@name eq $nt]))
      then element aparecium:error {
        attribute id { "ap:tbd13" },
        $nt || " is referred to but not defined." 
      }
      else ()
  )
</scrap>
</p>
<p>Unreachable nonterminals are not defined as an error
by the ixml spec.  They should be detected and warnings
should be issued, but for now we simply ignore them.
<scrap id="ap-grok-reach"
       name="Check for unreachable symbols (rsn)">
  let $lee-reachable := ()
</scrap>
</p>
<p>Unproductive nonterminals are not defined as an error
by the ixml spec.  They should be detected and warnings
should be issued, but for now we simply ignore them,
just as for unreachable nonterminals.
<scrap id="ap-grok-prod"
       name="Check for unproductive symbols (rsn)">
  let $lee-productive := ()
</scrap>
</p>
<p>
That code should clear the hygiene problems.
</p>

</div>
</div>

<div id="hi-earley-set">
<head>Generating the Earley set</head>
<p>Watch this space.</p>

<div id="hies-scan">
<head>The scanner</head>

<p>There are two versions of the scanner.  The basic version
consults <ident>ixi:fMatchesIPT()</ident> to see whether we have a
match; if so, we get the match length and return the advance over
the terminal.
<scrap id="er-scan"
       name="Define scan()">
(: ****************************************************** 
   * ix:scan($E, $I)
   ****************************************************** :)
(: If $E expects any terminals which occur as expected, 
   return the advance of E over those terminals.  There 
   may be more than one. :)
   
declare function ix:scan(
  $E as item() (: ITEM :),
  $I as item() (: INPUT :)
) as item()* (: ITEM? :) {
  let $p := ixi:pToXEi($E),
      $lt := ixi:lsymExpectedXEi($E)[ixi:fTerminal(.)]
  for $t in $lt
  return
    if (ixi:fMatchesIPT($I, $p, $t))
    then ixi:leiAdvanceEiSymP($E,$t,$p + ixi:match-length($I,$p,$t))
    else ()
};

</scrap>
The double call seems wasteful; it seems simpler to ask the matching
function to tell us how many characters of the input the terminal
consumed.</p>

<p>The <ident>pfg</ident> version of the code uses a single call
<ident>ixi:cMatchesIPT()</ident> to see whether we have a match and
how long it is.  If we have a match, we return both the advance over
the terminal and a new form of item, with a terminal rather than a
nonterminal in the rule position, and <q><code>#terminal</code></q>
as the rule index.

<scrap corresp="er-scan" id="er-scan-pfg"
       version="pfg"
       name="Define scan()">
(: ****************************************************** 
   * ix:scan($E, $I)
   ****************************************************** :)
(: If $E expects any terminals which occur as expected, 
   return the advance of E over those terminals.  There 
   may be more than one. :)
   
declare function ix:scan(
  $E as item() (: ITEM :),
  $I as item() (: INPUT :)
) as item()* (: ITEM? :) {
  let $p := ixi:pToXEi($E),
      $lt := ixi:lsymExpectedXEi($E)[ixi:fTerminal(.)]
  for $t in $lt
  return
    let $c := ixi:cMatchesIPT($I, $p, $t)
    return 
    if ($c ge 0)
    then (ixi:leiAdvanceEiSymP($E, $t, $p + $c),
         ixi:eiMakePPT($p, $p + $c, $t))
    else ()
};

</scrap>
</p>
</div>
<div id="hies-pred">
<head>The predictor</head>

<p>
<scrap id="er-pred"
       name="Define pred()">
(: ****************************************************** 
   * ix:pred($E, $G)
   ****************************************************** :)
(: If $E predicts any non-terminals, return items which 
   expect those non-terminals at the appropriate location. 
   :)
   
declare function ix:pred(
  $E as item() (: ITEM :),
  $G as item() (: GRAMMAR :)
) as item()* (: ITEM :) {
  (: iterate over
       $ln nonterminals expected by $E,
       $lr rules in $G for $n,
       $lri initial positions in $r
     also return advance of $E for nullable $n
   :)
   let $p := ixi:pToXEi($E),
       $ln := ixi:lsymExpectedXEi($E)[ixi:fNonterminal(.)]
   for $n in $ln
   let $fNullable := ixi:fNullableNG($n/@name, $G),
       $lr := ixi:lrulesXNG($n,$G)
   return (
     (: first, return advance of $E if $n nullable :)
     if ($fNullable)
     then ixi:leiAdvanceEiSymP($E,$n,$p)
     else (),
       
     (: then iterate over rules and initial locations for $n :)
     for $r in $lr
     let $lri := ixi:lriStartstatesXR($r)
     for $ri in $lri
     return ixi:eiMakePPRRi($p, $p, $r, $ri)
   )
};
</scrap></p>
</div>

<div id="hies-comp">
<head>The completer</head>

<p>
<scrap id="er-comp"
       name="Define comp()">
(: ****************************************************** 
   * ix:comp($Ec, $Ep)
   ****************************************************** :)
(: If $Ec and $Ep are a prediction/completion pair, return
   the advance of $Ep over the non-terminal predicted by 
   $Ec. :)
   
(: comp($Ec, $Ep): if $Ec is a completion item, 
   and $Ep a prediction item,
   and $Ep predicts a nonterminal $n at position $pPTo,
   and $Ec completes $n starting at $pCFrom=$pPTo,
   then advance $Ep over $n and place the new to-position
   at the to-position of $Ec.
   
   The test for whether $Ep expects $n is handled
   by leiAdvanceEiSymP, so we need not make it here.
:)
declare function ix:comp(
  $Ec as item() (: ITEM :),
  $Ep as item() (: ITEM :)
) as item()* (: ITEM :) {
  let $pCFrom := ixi:pFromXEi($Ec),
      $pCTo   := ixi:pToXEi($Ec),
      (: $pPFrom := ixi:pFromXEi($Ep), :)
      $pPTo   := ixi:pToXEi($Ep),
      $n      := ixi:nLhsXEi($Ec),
      $RESULT := if (ixi:fFinalEi($Ec)
                    and $pPTo eq $pCFrom)
                 then ixi:leiAdvanceEiSymP($Ep, $n, $pCTo)
                 else ()
  return $RESULT
};

</scrap>
</p>
</div>

<div id="hies-recognizer">
<head>The recognizer</head>
<p>The <ident>ix:recognize()</ident> function accepts an input string
and a grammar, and returns a boolean: true if the input is a sentence
in the language defined by the grammar, false otherwise.  On the way
to reaching that result, of course, a lot of intermediate results will
be calculated, some of them of interest for other purposes (e.g. for
the parser as a whole).  So there are two recognition functions: one
to calculate and expose all the intermediate results, and one to
expose only the boolean result, which calls the other function to do
the preliminary work.  The <ident>ix:recognize()</ident> function
works as a kind of wrapper around the other function:
<scrap id="er-recognize"
       name="Define recognize()">
declare function ix:recognize(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as xs:boolean {
  let $m := ix:recognizeX($I, $G)
  return $m('Result')
};

</scrap>
</p>
<p>The <ident>ix:recognizeX()</ident> function (an extended
recognizer, if you will)
<scrap prev="er-recognize"
       name="Define recognizeX()">
declare function ix:recognizeX(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as map(*) {
  let $G2 := ixi:augment-grammar($G),
      $symStart0 := ixi:symStartG($G),
      $symStart2 := ixi:symStartG($G2),
      $rInitial := ixi:lrulesXNG(
        &lt;nonterminal name="{$symStart2}"/>, 
        $G2)[1],
      $riInitial := ixi:lriStartstatesXR($rInitial)[1],
      $eiInitial := ixi:eiMakePPRRi(0, 0, 
                                    $rInitial, 
                                    $riInitial),
      $len := ixi:inputlength($I),
      
      $meiClosure := 
          ixi:earley-closure($eiInitial, $I, $G2),
      (: $leiCompletions := $meiClosure
         [ixi:fFinalEiPPN(.,0,$len,$symStart2)], :)
      $leiCompletions := $meiClosure('from')(0)
                         [ixi:fFinalEiPPN(., 0,
                                          $len,
                                          $symStart2)],
      $result := exists($leiCompletions)

  return map {
    'Grammar' : $G2,
    'Initial-Item' : $eiInitial,
    'Input' : $I,
    'Input-Length' : $len,
    'Closure' : $meiClosure,
    'Completions' : $leiCompletions,
    'Result' : $result
  }
};
</scrap>
</p>
</div>
</div>

<div id="hi-ptc">
<head>Direct generation of parse tree</head>
<p>In version 0.2 of Aparecium, we generate one
or more parse trees directly from the Earley set.
(In future versions, it is expected that we will
generate a parse-forest grammar from the Earley
set, and generate trees from that grammar, or
return the grammar to the user.  But at the moment
that's just pie in the sky.)</p>
<p>We generate the parse trees in two steps.
From the Earley set, we generate a raw parse tree
which records every nonterminal used (we may
regret this, eventually).  From the raw parse tree,
we create the abstract syntax tree by attending to
the marks on the nonterminals.
</p>
<div id="hi-ptc-raw">
<head>Raw parse trees</head>
<p>For raw parse trees, we use a generic XML
representation with two element types:
<list>
<item><gi>nt</gi> elements record that a given nonterminal was parsed
at a given location, with attributes providing details:
<list>
<item><att>name</att> gives the nonterminal symbol.</item>
<item><att>_from</att> and <att>_to</att> give the
range in the input.</item>
<item><att>mark</att> records the mark effective for this instance of
the nonterminal.  If a nonterminal in a right-hand side carries a
mark, we record it here; if not, we fetch the default value; if no
default value is specified, we supply the value
<q><code>^</code></q>.</item>
</list>
</item>
<item><gi>lit</gi>, <gi>inc</gi>, and <gi>exc</gi> elements record
that a given terminal was found at a given location, with attributes
providing details:
<list>
<item><att>name</att> gives the nonterminal symbol.</item>
<item><att>_from</att> and <att>_to</att> give the
range in the input.  For <gi>inc</gi> and <gi>exc</gi>
the two values will be the same, but not necessarily so
for literals.</item>
<item><att>tmark</att> records the terminal mark effective for this
the nonterminal.  This is what makes it possible to suppress
terminals marked <q><code>-</code></q> (or inject
terminals marked <q><code>+</code></q>, which doesn't seem
to have made it into the spec yet).</item>
</list>
</item>
</list>
Representing nonterminal nodes as <gi>nt</gi> elements
instead of elements with the nonterminal itself as a name
allows terminals marked for suppression to be distinguished
reliably from nonterminals marked <q><code>-</code></q>.
(It also allows the raw parse tree to be produced even if
the nonterminal is not a legal XML name.)
</p>
<p>N.B. The initial implementation of raw parse trees
used nonterminals as element names; there may be traces
of that state of affairs in this document.</p>
<p><hi>all-node-sequences() should be described here.</hi>
For the moment, see <ptr target="epi-all-nodes"/>.</p>
</div>
<div id="hi-ptc-ast">
<head>Abstract syntax trees</head>
<p><hi>The epi:astXparsetree() function should
go here.  For now, see <ptr target="epi-ast-from-raw"/>.</hi></p>
</div>

</div>

<div id="hi-pfg">
<head>Generating the parse-forest grammar</head>

<p>Another way to describe a set of derivations is to use a
parse-forest grammar.  It may be helpful to begin with a
brief description.</p>

<div id="hi-pfg-intro">
<head>Short description of parse-forest grammars</head>

<p>A parse-forest grammar is a way of describing the parse trees for
exactly one sentence in some language defined by another grammar (what
we may call its <soCalled>base grammar</soCalled>.</p>

<p>It is perhaps best explained by example. Consider the sentence
<q><code>7-4+2</code></q> parsed against the following simple and
ambiguous grammar:
<eg>S = expr.
expr = num; expr, addop, expr.
num = ["0" - "9"]+.
addop = "+"; "-".
</eg></p>
<p>One parse tree for the sentence is<eg><![CDATA[  <S>
    <expr>
      <expr>
        <expr><num>7</num></expr>
        <addop>-</addop>
        <expr><num>4</num></expr>
      </expr>    
      <addop>+</addop>
      <expr><num>2</num></expr>
    </expr>
  </S>]]></eg>
Another is:
<eg><![CDATA[  <S>
    <expr>
      <expr><num>7</num></expr>
      <addop>-</addop>
      <expr>     
        <expr><num>4</num></expr>
        <addop>+</addop>
        <expr><num>2</num></expr>
      </expr>
    </expr>
  </S>]]></eg>
</p>
<p>Each parse tree can be described in a parse-tree grammar which has
a structure similar to that of the original grammar.  For every
nonterminal &N; in the parse tree which dominates some substring from
position &x; to position &y; in the sentence, the parse-tree grammar
will have a nonterminal with a name constructed from &N;, &x;, and &y;
with a rule showing how &N; produces that segment.  The first parse tree, for example,
can be written as a parse-tree grammar thus:<eg>
S·0·5 = expr·0·5.
expr·0·5 = expr·0·3, addop·3·4, expr·4·5.
expr·0·3 = expr·0·1, addop·1·2, expr·2·3.
expr·0·1 = num·0·1.
expr·2·3 = num·2·3.
expr·4·5 = num·4·5.
num·0·1 = "7".
num·2·3 = "4".
num·4·5 = "2".
addop·1·2 = "-".
addop·3·4 = "+".
</eg></p>
<p>The second tree can likewise be described in a grammar, which
shares a great many of the rules from the first parse-tree grammar.
It may be obvious to the reader that both trees can be described in
the same grammar, thus:<eg>
S·0·5 = expr·0·5.
expr·0·5 = expr·0·3, addop·3·4, expr·4·5
         | expr·0·1, addop·1·2, expr·2·5.
expr·0·3 = expr·0·1, addop·1·2, expr·2·3.
expr·2·5 = expr·2·3, addop·3·4, expr·4·5.
expr·0·1 = num·0·1.
expr·2·3 = num·2·3.
expr·4·5 = num·4·5.
num·0·1 = "7".
num·2·3 = "4".
num·4·5 = "2".
addop·1·2 = "-".
addop·3·4 = "+".
</eg></p>

<p>Note that in the grammar describing a single tree, every rule has
exactly one right-hand side; in the grammar describing multiple trees,
<ident>expr·0·5</ident> has two right-hand sides, reflecting the fact
that it can produce the string in two different ways.</p>
</div>

<div id="hi-pfg-const">
<head>Constructing a parse-forest grammar</head>

<p>Our overarching task here can be described thus:  We are given
<list>
<item>an Earley set closed under the <ident>scan</ident>,
<ident>pred</ident>, and <ident>comp</ident> relations, and</item>
<item>a completion item in that set.</item>
</list>
From these, we are to construct a parse-forest grammar
describing the set of parse trees whose existence is
implied by the completion item.</p>

<p>A brute-force approach would simply construct a grammar rule for
every possible realization of every completion item in the Earley set,
but that would produce rules for matches that never made it into a
successful parse.<note place="foot">
<p>Since those rules would be a potentially
informative description of the garden paths followed by the parser
before they reached a dead end, they might be useful as a
grammar-debugging measure.  But for now we are interested only in
completions that actually play a role in a successful derivation of
the input.</p></note></p>

<p>Since we are given a completion item of the form (&x; &y; &N;
&qf;)<note place="foot"><p>Here &qf; is any final state in the
definition of &N;.</p></note> a simple way to handle the task is:
<list>
<item>
<p>Construct the production rule for &N;·&x;·&y;.</p>
</item>
<item>
<p>For each nonterminal in the right-hand side of the rule just
constructed, construct the production rule for that nonterminal.</p>
</item>
</list>
</p>

<p>The first step will entail finding a sequence of completion items
that correspond to a <term>satisfactory walk</term> through the
right-hand side of the production rule for &N; in the base
grammar.<note place="foot"> <p>I call it a
<mentioned>satisfactory</mentioned> walk because (a) the sequence of
nonterminals satisfies the constraints of the right-hand side, and
(b) the walk is acceptable to the needs of further processing.  And
I need a short way to refer to the class of walks I'm looking
for.</p>
<p>I often slip and refer to these as <term>paths</term> through
the right-hand side, but in graph theory a <term>path</term>
denotes a walk in which no vertex appears more than once.  If
the input grammar is BNF, any walk through any right-hand side
will be a path.  But we are working with EBNF.</p>
</note> That is a walk through the RHS
<list>
<item>beginning in the start state &q0;,</item>
<item>ending in some final state &qf;, and</item>
<item>in which the steps collectively cover the input segment from
&x; to &y;.</item>
</list>
For each item in the walk an appropriate new nonterminal can be
constructed, and those nonterminals will be written into into the
right-hand side of the production rule, in the appropriate sequence.
If there is more than one such walk through the rule for &N;, then
&N; is ambiguous, and we want all of those walks.<note
place="foot"><p>At the moment, there are some infinitely ambiguous
sentences for which we will not in fact get all of the walks
(informally, those involving infinite
<soCalled>horizontal</soCalled> ambiguity, as in <q><code>S = A*,
'a'. A = .</code></q>).  Our inability to capture horizontal
ambiguities completely appears to be a disadvantage of working
directly with EBNF instead of rewriting the grammar to BNF.  (An
equivalent BNF like <q><code>S = _star_A, 'a'. _star_A = {}; A,
_star_A.  A = {}.</code></q> does not present the
problem.)</p><p>The key appears to be that in an EBNF grammar there
may be an infinite number of walks through a right-hand side,
whereas in a BNF grammar that can never be so, because BNF lacks
repetition operators.</p> <p>Note also that the user does
<emph>not</emph> in fact always want all the walks.  Sometimes any
one will do, with or without the knowledge that the sentence is
ambiguous.</p></note></p>

<p>The second step can be handled by calling the same function we
called to handle the completion we started with.  Since in cases of
ambiguity the same nonterminal may appear in more than one walk
through &N; and thus in more than one right-hand side for &N.x.y;, we
should keep track of what nonterminals we have already constructed or
already placed in the queue.</p>

</div>

<div id="hi-pfgc-top">
<head>The parse-forest-grammar() function</head>
<p>The top-level function for making the parse-forest grammar will
thus place the initial completion item in a work queue and delegate
responsibility for generating the appropriate production rules to a
separate recursive function, wrapping the result in an <gi>ixml</gi>
element or an <gi>error</gi> element.</p>
<p>To simplify later operations, </p>

<p>
<scrap id="epi-parse-forest-grammar"
       name="Define parse-forest-grammar()">
declare function epi:parse-forest-grammar(
  $leiCompletions as <ptr target="adt-list-ei"/>,
  $leiClosure as <ptr target="adt-eiclosure"/>,
  $I as <ptr target="adt-input"/>
) as element() {
  let $rules := epi:make-pfg-rules(
                    $leiCompletions,
                    $leiClosure,
		    $I, 
                    ())
		    
  return 
    <ptr target="epi-pfg-return"/>
};
<ptr target="epi-make-pfg-rules"/>
<ptr target="epi-find-walks"/>
<ptr target="epi-rhs-from-walk"/>
<ptr target="epi-lei-from-walk"/>
<ptr target="epi-find-dups-in-walk"/>
</scrap>
</p>

<p>After the work has been done, the <ident>parse-forest-grammar()</ident>
function returns the result:  either an error element or the
desired ixml element.
<scrap id="epi-pfg-return"
       name="Return parse-forest grammar containing $rules">

    (: if we got an error back, pass it along :)
    <ptr target="epi-pfg-error-return"/>

    (: if we are error-free, wrap it in ixml :)
    else element ixml {
           element comment {
             "Parse-forest grammar generated ",
             current-dateTime()
           },
           $rules                
         }
</scrap>
</p>
<p>The error checking is currently very simple:  if there is an
error element among the rules, we wrap the entire set of rules in
an enclosing error element.
<scrap id="epi-pfg-error-return"
       name="If there is an error, return an error element">
    if ($rules/self::ap:error)
    then element ap:error {
           element comment {
             "Failure generating PFG. ",
             "Sorry!" 
           },
           $rules                
           }
</scrap></p>
</div>

<div id="hi-pfgc-make-rules">
<head>The <ident>make-pfg-rules()</ident> function</head>

<p>The <ident>epi:make-pfg-rules()</ident> function has a familiar
basic structure: if there is work in the queue, we do it, we check to
see whether it has generated further work, and we recur to handle the
remaining items in the queue.  If the queue is empty, we are done and
can return the accumulated intermediate results.
<scrap id="epi-make-pfg-rules"
       name="Define function epi:make-pfg-rules()">
declare function epi:make-pfg-rules(
  $leiQueue as <ptr target="adt-list-ei"/>,
  $leiClosure as <ptr target="adt-eiclosure"/>,
  $I as <ptr target="adt-input"/>,
  $leRules as element()*
    (: accumulator, element(rule|error)* :)
) as element()* {
  <ptr target="epi-mpr-stop"/>
  else 
  let $ei := head($leiQueue)
  
  let $dummy := eri:notrace(eri:sXei($ei), 'Making production rule for item: ')

  <ptr target="epi-mpr-find-walk"/>
  <ptr target="epi-mpr-make-rule"/>
  <ptr target="epi-mpr-update-queue"/>
  <ptr target="epi-mpr-recur"/>

};
</scrap></p>

<p>The base case is unsurprising:
<scrap id="epi-mpr-stop"
       name="If PFG queue is empty, return accumulator">
  if (empty($leiQueue))
  then $leRules
</scrap></p>
<p>When there is work to be done, of course, the case is more
complex.  The following subsections describe it.</p>

</div>

<div id="hi-pfgc-walks">
<head>Finding walks through a rule's right-hand-side</head>
<p>The core task of making the parse-forest grammar seems to be
finding the sequences of completion items which represent the
parse-tree children of the node represented by the current completion
item.  It's complicated by several factors:
<list>

<item><p>We must move back and forth continually between the parent
level, moving forward state by state in the FSA for the parent
nonterminal &N;, and the child level, identifying completion items
for each child &C;.  The information we want is never where we are
at any time, figuratively speaking.</p>

<p>Concretely: at any given point, the state of our effort to find
walks depends on the set of walks we have accumulated, and for each
walk &w; some relevant properties are given by the most recent
completion item &i; and others by the state &q; in the FSA reached
by the walk:
<list>
<item>Does &w; end in a final state of the FSA? (i.e. is &q; &isin;
&F; for this FSA?)</item>
<item>Does &w; cover the required range of input? (i.e. is
&ei;('to') = &ei;('to'), where &ei; is the completion item
represented by the left-hand side of the rule?)</item>
<item>Can &w; be extended? (i.e. is <ident>follow(&q;)</ident>
empty?)</item>
</list></p></item>

<item><p>We would like to be able to find all the walks, not just
one.  The ixml spec wants us to report ambiguity, and that means we
must at least know whether more than one walk exists.</p>
</item>

<item><p>We need to be alert for cycles in the walk.  These will
always be edge cases: they can arise only if repeatable sequences of
children can and do produce the empty string.  But they can
occur.</p></item>

<item><p>Each walk is (notionally at least) a sequence of completion
items describing parse-tree children.  But we can't return a set of
walks by returning a sequence of sequences, so we need to some other
representation.</p>

<p>Candidates include:
<list>

<item><label>arrays of sequences</label>:<list>
<item><label>sequences of Earley items</label>: walks as sequences
of completion items, sets of walks as arrays of sequences</item>
<item><label>sequences of pairs</label>: walks as sequences of pairs
consisting of a completion item and a state, sets of walks as arrays
of such sequences</item>
<item><label>sequences of strings</label>: walks as sequences of
strings of the form <q>&x;&#xB7;&y;&#xB7;&N;</q> (or
<q>&N;&#xB7;&x;&#xB7;&y;</q>, or
<q>&x;&#xB7;&y;&#xB7;&N;&rArr;&q;</q>, or
<q>&N;&#xB7;&x;&#xB7;&y;&rArr;&q;</q>), sets of walks as arrays of
such sequences</item>
</list>
</item>

<item><label>sequences of strings</label>:<list>
<item><label>long strings</label>: walks as strings made by joining
strings of the form <q>&x;&#xB7;&y;&#xB7;&N;</q> together with
<q><code>/</code></q> or <q><code>+</code></q> or
<q><code>,&amp;#x20;</code></q> or some other concatenation mark,
sets of walks as sequences of such string</item>
</list></item>

<item><label>maps</label>:<list>
<item><label>prefix trees</label>: a set of walks as a map
representing a prefix tree, each walk then a path from the root of
the tree to a leaf; the trees will contain either just completion
items or a mix of completion items and state in the FSA we are
walking through</item>
<item><label>step lists with shared tails</label>: each walk as a
map representing one step in the walk, with keys
<q><kw>state</kw></q> (= &q;), <q><kw>item</kw></q> (=&i;),
<q><kw>pred</kw></q> (a pointer to the map for the preceding step in
the walk, empty for the first step); a set of walks is just a set of
such maps.  Walks which share a prefix will use the same map to
represent that shared prefix, so this is effectively just an
upside-down tree, which we hold by its leaves and not its
root.</item></list>
</item>

<item><label>elements</label>:<list>
<item><label><gi>walks</gi> and <gi>step</gi> elements</label>: a
set of walks as a <gi>walks</gi> element, contain a set of
<gi>step</gi> elements, which in turn may each contain a
<gi>walks</gi> element.  Each <gi>walks</gi> element specifies a
starting state and position, each step a destination state and
position.  If a step has no successors, it has no <gi>walks</gi>
element.  If a step's destination state is final in the FSA and its
destination position is the desired ending position, the path from
the root to that step is a complete walk through the FSA and
represents a right-hand side of a rule in the PFG.</item>
</list></item>

</list>
The current implementation uses step lists with shared
tails.</p></item>
</list>
</p>

<p>The basic plan is an iterative function<note place="foot">
<p>By <mentioned>iterative function</mentioned> I mean a recursive
function where recursion serves only to provide a looping
construct.</p>
</note> which performs a breadth-first search and assembles the
result.<note place="foot">
<p>If we are not trying to return all walks but only a finite number
of walks, a depth-first search might be better.  But at the moment I
am reacting, and possibly over-reacting, against the problems in the
depth-first implementation of the
<ident>all-node-sequences()</ident> function.</p>
</note> We have an accumulator of some sort that holds a set of
walks found so far, each of which is either complete (it goes all
the way to a final state in the right-hand side of &N;) or not, and
either extensible or not.<note place="foot">

<p>In principle, a walk can be extended if the last state reached by
the walk has follow states.  But since right-hand sides in an EBNF can
have cycles, we cut off any walk if its last state has already been
visited more than &n; times.</p>

<p>If we set &n; to 0, then we eliminate all loops; that's sufficient
for all normal grammars.  If we set &n; higher, then we traverse each
loop at most &n; times; this may be interesting for people fascinated
by ambiguity.</p>

</note> The result is complete when no walks can be extended,
or when we have found enough walks to go on with.
<list>
<item><p>If the result is complete, return all of the complete walks
found so far.</p></item>
<item><p>Otherwise, for each walk &w; that can be extended:
<list>
<item><p>Find all possible extensions to &w;.</p></item>
<item><p>For each possible extension &e;, make a new walk &w-; by
adding &e; to the end of &w;.</p></item>
<item><p>For each new walk &w-;, see if &w-; is complete and mark it
appropriately so it can be found again.</p></item>
</list></p></item>
</list>
When a complete walk is extended, the original walk needs to be
kept around unchanged so it can be returned in the result.
When incomplete walks are extended, the original walks can be
discarded.</p>

<p>Each walk is a step list, and each step is represented
by a map:
<scrap id="pfg-adt-walk" name="Type: walk in a RHS">
map(xs:string, item()*)
</scrap>
A collection of walks is just a sequence of walks:
<scrap id="pfg-adt-walks" name="Type: collection of walks">
map(xs:string, item()*)*
</scrap>
</p>

<p>Since we will need recursion to iterate over the steps in the
walks we are constructing, the task of generating child sequences
for &ei; will just be delegated to a separate function,
<ident>epi:find-walks()</ident>.  We prime the pump by creating a
walk with a single step.  And if the parent FSA is nullable, we add that walk to the 

<scrap id="epi-mpr-find-walk"
       name="Set $walks to possible child sequences for $ei">

  let $r0 := $ei('rule')
  let $w  := map { 'item': $ei, 
                   'state': 'q0',
                   'follow-states': 
                       tokenize($r0/@first),
                   'final': 
                       xs:boolean($r0/@nullable)
             }

  let $walks := epi:find-walks(
                  $ei       (: completion for parent :),
                  $leiClosure, 
                  $I, 
                  $w                        (: queue :),
                  if (xs:boolean($r0/@nullable)
                      and ($ei('from') eq $ei('to'))) 
                  then $w 
                  else ()             (: accumulator :),
                  map { 'tree-count': 2 } (: options :)
                )

   let $dummy := if (count($walks) gt 1)
                 then (eri:trace(count($walks), 'Find-walks found # walks'
                       || ' for ' || eri:sXei($ei)),
                     for $w at $walknum in $walks 
                     return eri:trace($w, 'Walk no. ' || $walknum || ' is:'))
                 else ()
</scrap>
The <q><kw>follow-states</kw></q> and <q><kw>final</kw></q>
values are redundant; we store them in the map to avoid
calculating them repeatedly.
The last argument (a map of options) should be replaced
in due course with options supplied by the user.
</p>
<p></p>
<p>The <ident>epi:find-walks()</ident> function will be defined <ref
target="hi-pfgc-find-walks">below</ref>.</p>

</div>

<div id="hi-pfgc-makerule">
<head>Making a production rule for a given walk</head>

<p>Given a completion item (&x; &y; &N; &qf;) and a set of walks
through the rule for &N;, we now make a production rule for &N.x.y; with an
appropriate expression on the right-hand side.

<scrap id="epi-mpr-make-rule"
       name="Set $rule to production rule for $ei">
  let $rule := element rule {
                   attribute name {
                       concat($r0/@name,
                           '&#xB7;',
                           $ei('from'),
                           '&#xB7;',
                           $ei('to') (: ,
                           '&#xB7;',
                           $ei('ri') :)
                       )
                   },
                   $r0/@mark,
                   if (empty($walks))
                   then element ap:error {
                     element p { "make-pfg-rules here." },
                     element p { "find-walks() failed." },
                     element p { "Here is what I know." },
                     element dump { 
                       element var {
                         attribute name { "ei" },
                         eri:eXei($ei)
                       },
                       element var {
                         attribute name { "ei?rule" },
                         $r0
                       },
                       element var {
                         attribute name { "closure" },
                         for $n in map:keys($leiClosure('to'))
  		         order by $n descending
  		         for $ei in $leiClosure('to')($n)
  		         return eri:eXei($ei)
                       }
                     }
                   } 
                   else for $w in $walks
                   return element alt { 
                       epi:rhs-from-walk($w, $I, ())
                   }
               }
</scrap>
</p>
<p>The <ident>epi:rhs-from-walk()</ident> function will be defined
<ref target="hi-pfgc-make-rhs">below</ref>.</p>

</div>

<div id="hi-pfgc-recur">
<head>Preparing for the next iteration</head>

<p>Given a queue, an accumulator, and a new production rule (or the
set of walks that produced it), identify which completion items need
to be added to the queue.  That would be: all the completion items in
the walks, unless they are already in the queue or already handled in
the accumulator.  First we extract them all, and dedup them, then
we filter them against the items already in the queue, and finally
against the items we already have rules for.
<scrap id="epi-mpr-update-queue"
       name="Set $new-queue to include new completions">

  let $lei0 := for $w in $walks
               return epi:lei-from-walk($w, ()), 
               (: all completion items in $walks :)
	       
      $lei1 := $lei0[
                 not(some $i in 1 to (position() - 1)
                  satisfies deep-equal(., $lei0[$i]) 
                  (: satisfies .?sig eq $lei0[$i]?sig :)
		  (: satisfies ((.?from eq $lei0[$i]?from)
                    and      (.?to   eq $lei0[$i]?to  )
                    and deep-equal(
                              .?rule,   $lei0[$i]?rule)) :)
                 )
               ],
               (: list of distinct completion items :)

      $lei2 := $lei1[
                 not(some $i in 2 to (count($leiQueue))
                   satisfies deep-equal(., $leiQueue[$i]) 
                   (: satisfies .?sig eq $leiQueue[$i]?sig   :)
		   (: satisfies ((.?from eq $lei0[$i]?from)
                     and      (.?to   eq $lei0[$i]?to  )
                     and deep-equal(
                              .?rule,   $lei0[$i]?rule)) :)
                 )
               ]
               (: completion items not in the queue :)

  let $ls-defined := ($leRules, $rule)
                     /@name/string(),

      $lei3 := for $ei in $lei2
               let $s := $ei('rule')/@name/string()
                         || '&#xB7;'
                         || $ei('from')
                         || '&#xB7;'
                         || $ei('to') (:
                         || '&#xB7;'
                         || $ei('ri') :)
               where not($s = $ls-defined)
               return $ei
               (: new completion items, 
                  not in queue and not already done :)

  let $new-queue := (tail($leiQueue), $lei3)

</scrap>
</p>
<p>Given a production rule <ident>$rule</ident> and and the updated
queue <ident>$new-queue</ident>, call
<ident>make-pfg-rules()</ident> recursively.
<scrap id="epi-mpr-recur"
       name="Recursive call with new queue and accumulator">
  return epi:make-pfg-rules(
           $new-queue,
           $leiClosure,
           $I,
           ($leRules, $rule)
         )
</scrap>
</p>

</div>
<div id="hi-pfgc-find-walks">
<head>The <ident>find-walks()</ident> function</head>
<p>This bit is, frankly, the part of parse-forest extraction
I have had the most trouble thinking through clearly.</p>
<p>We are given:
<list>
<item>an Earley item, which should be a completion (i.e.
<ident>ri</ident> &isin; &F; for the FSA)</item>
<item>an Earley closure</item>
<item>an input string</item>
<item>a queue of walks which begin at the
start state and are attested by appropriate completion
items, which may or may not be satisfactory</item>
<item>an accumulator of acceptable walks</item>
<item>a map of options, in particular the <q><kw>tree-count</kw></q>
option</item>
</list>
From these we are to generate a set of walks, represent as step
lists.  The accumulator is needed because we extend everything in
the queue if we can, and that may cause a satisfactory walk to be
lost.
<hi>To do: check for loops.</hi>
<scrap id="epi-find-walks"
       name="The find-walks() function">
declare function epi:find-walks(
  $eiParent as <ptr target="adt-ei"/>,
  $mei as <ptr target="adt-eiclosure"/>,
  $I as <ptr target="adt-input"/>,
  $queue as <ptr target="pfg-adt-walks"/>,
  $acc as <ptr target="pfg-adt-walks"/>,
  $options as map(*)
) as <ptr target="pfg-adt-walks"/> {
  <ptr target="pfg-fw-if-done"/>
  else 
  <ptr target="pfg-fw-set-new-queue"/>
  <ptr target="pfg-fw-set-new-acc"/>
  return epi:find-walks(
      $eiParent, 
      $mei,
      $I,
      $new-queue,
      $new-acc,
      $options
  )
};
</scrap>
</p>

<p>We stop when we have as many walks as are specified in the
<q><kw>tree-count</kw></q> option, or when the queue is empty.<note
place="foot">
<p>If this is the only source of ambiguity in the parse, returning
&n; walks will give us &n; trees.  If there are multiple sources of
ambiguity, the parse-forest grammar will generate more than &n;
trees, but the cost of returning a richer parse-forest grammar than
needed is lower than the cost of keeping track of how many trees we
could generate from the walks we have so far.  It's worth
remembering that ambiguities are not necessarily independent: having
two two-way ambiguities does not guarantee four trees.</p>
</note>
<scrap id="pfg-fw-if-done"
       name="If we have all our walks, return">
  if (($options('tree-count') ne -1)
      and 
      (count($acc) ge $options('tree-count')))
  then $acc
  else if (empty($queue))
  then $acc
</scrap>
</p>

<p>Otherwise, we attempt to extend each walk in the queue.  To
reduce the number of times we have to do a search in the Earley
closure, we group the walks by their current position (here
&x;),<note place="foot"><p>Note that the current position is the
<q><kw>from</kw></q> value for the starter step (a completion for
the parent) but the <q><kw>to</kw></q> value for any other
step.</p></note> their follow state (here <ident>qNext</ident>), and
the nonterminal (or terminal) we are seeking to match (here &N; and
&T;<note place="foot"><p>Note that &N; and &T; are uniquely
determined by <ident>qNext</ident> and thus redundant, but including
them as grouping keys allows them to be referred to without
subscripts.</p></note>
<scrap id="pfg-fw-set-new-queue"
       name="Set new queue by extending all walks in the queue">

  let $new-queue := 
      for $w in $queue
      let $x := if ($w?state eq 'q0')
                then $w('item')('from')
                else $w('item')('to'),
          $qqNext := $w('follow-states')

      for $qNext in $qqNext
      let $symbol := $eiParent('rule')//*[@xml:id=$qNext],
          $N := $symbol/self::nonterminal/@name/string(),
          $T := $symbol[eri:fTerminal(.)]/@xml:id/string(),
	  $symbol-mark := $symbol/(@mark, @tmark)/string()

      let $dummy := if (exists($T)) then eri:notrace($T,
          'find-walks: seeking completion items for this terminal:')
          else ()

      group by $x, $qNext, $N, $T
</scrap>
We can now do a single search that will work for every
walk that is expecting a given symbol at a given location.
We look for items in the closure which:
<list>
<item>start at &x;,</item>
<item>relate to the given terminal or nonterminal,</item>
<item>are final, and</item>
<item>advance no further than the endpoint of the
parent completion item.</item>
</list>
And then we de-dup them:  if any items differ only in
their rule index, we take only one of them.
<scrap prev="pfg-fw-set-new-queue"
       name="Find follow-on completion items">

      let $items0 := $mei('from')($x)
                     [(.?rule/@name eq $N)
                      or (.?rule/@xml:id eq $T)]
                     [eri:fFinalEi(.) 
                      or (.?ri eq '#terminal')]
                     [.?to le $eiParent('to')],
          $items  := for $i at $index in $items0
                     where not(
                       some $j in 1 to ($index - 1) 
                       satisfies (
                         $items0[$j]?from eq $i?from
                         and 
                         $items0[$j]?to eq $i?to
                         and deep-equal(
                           $items0[$j]?rule, $i?rule
                         )
                       )
                     )
                     return $i

</scrap>
For each such item, we extend the walk we started with:
<scrap prev="pfg-fw-set-new-queue"
       name="Extend the walk">

      for $i in $items
      let $fNull := ($i('to') eq $i('from')),
          $leiDups := if ($fNull)
                      then epi:dups-from-walk(
                               $qNext, $i, $w[1], ()
                           )
                      else ()

      let $qqNextfollow := tokenize(
                               $eiParent('rule')
                               /attribute::follow:*
                               [local-name() eq $qNext]
                           ),
          $f-qnext-final := ($qNext = 
                           eri:lriFinalstatesXR(
                               $eiParent('rule')
                           ))

      return if ($fNull and count($leiDups) gt 1)
      then ()
      else map {
                 'item' : $i,
                 'state' : $qNext,
                 'follow-states' : $qqNextfollow,
                 'final' : $f-qnext-final,
                 'mark'  : $symbol-mark,
                 'pred'  : $w[1]
             }

</scrap></p>
<p>Some of the extensions we just made may be satisfactory walks;
if so, we add them to the accumulator:
<scrap id="pfg-fw-set-new-acc"
       name="Add satisfactory walks to the accumulator">

  let $new-acc := ($acc, $new-queue
                         [ .?final ]
                         [ .?item?to eq $eiParent?to ])

</scrap>
</p>
</div>
<div id="hi-pfgc-make-rhs">
<head>The <ident>rhs-from-walk()</ident> function</head>
<p>We are given a walk &w; represented as a map describing one
step and pointing to its predecessor; we are to return an ixml
right-hand side for the sequence.</p>
<p>We do this by walking through the list step by step, pushing the
appropriate symbol onto the front of the accumulator.
<scrap id="epi-rhs-from-walk"
       name="The rhs-from-walk() function">
declare function epi:rhs-from-walk(
  $w as <ptr target="pfg-adt-walk"/>?,
  $I as <ptr target="adt-input"/>,
  $acc as element()*
) as element()* {

  <ptr target="epi-rfw-stop"/>
  else <ptr target="epi-rfw-terminal"/>
  else <ptr target="epi-rfw-nonterminal"/>
};
</scrap>
</p>

<p>The termination condition is evident: if we are out of steps,
then we are done.  We are out of steps when we are looking at state
&q0; (and of course if somehow we have run off the edge).
<scrap id="epi-rfw-stop"
       name="If we're done, return">
  if (empty($w) or ($w('state') eq 'q0')) 
  then $acc
</scrap>
</p>
<p>If the walk includes a completion item for a terminal,
of the form (&x; &y; _t_&n; '#terminal'), then we
construct a <gi>literal</gi> element and recur.
<scrap id="epi-rfw-terminal"
       name="If this step is a terminal, return a literal">
  if ($w('item')('ri') eq '#terminal')
  then let $ei := $w('item')
       let $x := $ei('from'),
           $y := $ei('to'),
           $symbol := element literal {
               attribute tmark { $w('mark') },
               attribute string {
                   substring($I, $x+1, ($y - $x))              
               }
           },

           $new-acc := ($symbol, $acc),
	   $next-step := $w('pred')
       return epi:rhs-from-walk($next-step, $I, $new-acc)
</scrap>
</p>
<p>Otherwise, we extract the nonterminal symbol from
the rule in the item, append start and end positions,
construct an ixml <gi>nonterminal</gi> element for the
newly constructed nonterminal name, and recur.
<scrap id="epi-rfw-nonterminal"
       name="If this step is a nonterminal, return a nonterminal">
  if (exists($w('item')('rule')/self::rule[@name]))
  then let $ei := $w('item'),

           $symbol := element nonterminal {
               attribute name {
                   $ei('rule')/@name/string()
                   || '&#xB7;'
                   || $ei('from')
                   || '&#xB7;'
                   || $ei('to') (:
                   || '&#xB7;'
                   || $ei('ri') :)
               },
               if (exists($w('mark')))
               then attribute mark { $w('mark') }
               else ()
           },
           $new-acc := ($symbol, $acc),
           $next-step := $w('pred')
       return epi:rhs-from-walk($next-step, $I, $new-acc)
</scrap>
And as a catch-all, if we have a step but cannot
treat it as a terminal or as a nonterminal,
then we return an error.
<scrap prev="epi-rfw-nonterminal"
       name="Otherwise, something has gone very wrong">

  else 
let $dummy := eri:trace($w('item'), 'rhs-from-walk:  item fell through!') return
       element ap:error {
           element p { 'Unexpected failure 83' },
           $acc,
           $w?state
       }
</scrap>
<hi>BaseX will serialize $w, but Saxon will not,
so we trace just $w?state, not $w.  This should be
cleaner, probably; I'm beginning to hack at things
in order to get the program to run under Saxon.</hi>
</p>
</div>
<div id="hi-pfgc-make-lei">
<head>The <ident>lei-from-walk()</ident> function</head>
<p>We are given a walk &w; represented as a map describing one
step and pointing to its predecessor; we are to return a sequence
of the Earley items (they will all be completions) in that
sequence, leaving out the one at the very end that represents
the parent node.<note place="foot">
<p>Might it be faster to do this at the same time we
generate the right-hand side from the walk?</p></note></p>

<p>We do this by walking through the list step by step, pushing each
item onto the front of the accumulator.
<scrap id="epi-lei-from-walk"
       name="The lei-from-walk() function">
declare function epi:lei-from-walk(
  $w as <ptr target="pfg-adt-walk"/>?,
  $acc as <ptr target="adt-list-ei"/>
) as <ptr target="adt-list-ei"/> {
  if (empty($w)) 
  then $acc
  else if ($w('state') eq 'q0')
  then $acc
  else if ($w('item')('ri') eq '#terminal')
  then epi:lei-from-walk($w('pred'), $acc)
  else epi:lei-from-walk($w('pred'),
                         ($w('item'), $acc))
};
</scrap>
</p>
<p><hi>To do:  move de-duping into lei-from-walk()?
Every item we can avoid adding to the accumulator
is an item we don't need to carry around.</hi></p>
</div>
<div id="hi-pfgc-find-dups">
<head>The <ident>dups-from-walk()</ident> function</head>
<p>We are given a state &q;, an item &ei;, and a walk &w;;
we are to return the steps in &w; that have the same
state and item.  If there is more than one (or some
threshold), the caller will detect a loop in the walk
and cut the walk off to avoid going round the loop
indefinitely.</p>

<p>We do this by walking through the list step by step, pushing the
duplicate steps onto the front of the accumulator.

<scrap id="epi-find-dups-in-walk"
       name="The dups-from-walk() function">
declare function epi:dups-from-walk(
  $q as xs:string,
  $ei as <ptr target="adt-ei"/>,
  $w as <ptr target="pfg-adt-walk"/>?,
  $acc as item()*
) as <ptr target="pfg-adt-walks"/> {
  if (empty($w)) 
  then $acc
  else if ($w('state') eq 'q0')
  then $acc
  else if ( 
            (: $ei?sig eq $w?item?sig :)
            deep-equal($ei, $w('item')) 
            and 
            $q eq $w('state')
          )
  then epi:dups-from-walk($q, $ei, $w('pred'), ($w, $acc))
  else epi:dups-from-walk($q, $ei, $w('pred'), $acc)
};
</scrap>
</p>
</div>

</div>

<div id="hi-rpt-ex-pfg">
<head>Extracting a parse tree from the parse-forest grammar</head>

<p>If the user asks for a parse-forest grammar instead of a parse
tree, we can just return the grammar.  But if the user asks for a
tree, or a forest, we need to turn the grammar into a parse tree.
Since the current code for direct construction of the tree behaves
very badly in some cases, constructing the grammar and then from it
the tree is likely to be faster.  At least, I hope so.</p>
<p>So we want a function to extract a tree.  For now, we extract
just one tree, selected at random. <hi>To do: construct &n;
trees; construct tree-cursor.</hi></p>
<p>The initial call to <ident>epi:tree-from-pfg()</ident> function
supplies a parse-forest grammar and returns a parse tree.  Recursive
calls will supply elements from the parse-forest grammar and
use a <ident>nodetype</ident> parameter to specify what they
are interested in getting back; the nodetype value may be any of
<q><kw>document</kw></q> (expected only on the initial call), 
<q><kw>element</kw></q>, 
<q><kw>attribute</kw></q>, 
<q><kw>value</kw></q>, or
<q><kw>content</kw></q>.
<scrap id="epi-tree-from-pfg"
       name="The epi:tree-from-pfg() function">

declare function epi:tree-from-pfg(
  $pfg as element() 
      (: ixml, rule, alt, nonterminal, literal :),
  $nodetype as xs:string,
  $mark as xs:string?
) as node()* {
  if ($pfg/self::ixml)
  then <ptr target="epi-tfg-ixml"/>
  else if ($pfg/self::rule)
  then <ptr target="epi-tfg-rule"/>
  else if ($pfg/self::alt)
  then <ptr target="epi-tfg-alt"/>
  else if ($pfg/self::nonterminal)
  then <ptr target="epi-tfg-nonterminal"/>
  else if ($pfg/self::literal)
  then <ptr target="epi-tfg-literal"/>
  else element eek {
      element desc {
          "tree-from-pfg got "
          || "an unexpected argument."
      },
      eri:trace($pfg, 'Unexpected argument!')
  }
};
</scrap>
</p>

<p>We start with the parse-forest grammar itself, an <gi>ixml</gi>
element.  We check to see whether the grammar is ambiguous or not by
looking for rules with multiple right-hand sides.  Then we start
serialization.  To avoid producing a <gi>Goal</gi> element for the
start-symbol introduced by the Earley recognizer, we start work with
the nonterminal on the right-hand side of the first rule.<note
place="foot"> <p>Actually, <ident>Goal</ident> should carry
<q><code>mark="-"</code></q> in any case.</p></note> If the
parse-forest grammar describes more than one tree, we should mark
the tree we return with <code>ixml:state="ambiguous"</code>.
<scrap id="epi-tfg-ixml"
       name="Extract tree from ixml parse-forest grammar">

      let $f-ambig := exists($pfg//rule[count(alt) gt 1]),
          $tree0 := epi:tree-from-pfg(
                        $pfg/rule[1]/alt/nonterminal,
                        'element',
                        ()
                    )
      return if (not($f-ambig))
      then $tree0
      else element { name($tree0) } {
        attribute ixml:state { "ambiguous" },
        $tree0/attribute::*,
        $tree0/child::node()
      }
</scrap></p>

<p>Another version of this code uses XQuery Update to inject the
attribute.  I took this out because Saxon PE and HE don't seem to
support the update facility.
<scrap 
       name="Extract tree from ixml parse-forest grammar">

      let $f-ambig := exists($pfg//rule[count(alt) gt 1]),
          $tree0 := epi:tree-from-pfg(
                        $pfg/rule[1]/alt/nonterminal,
                        'element',
                        ()
                    ),
          $tree1 := copy $x-tree := $tree0
                   modify insert node 
                       attribute ixml:state { "ambiguous" }
                       into $x-tree
                   return $x-tree
      return if ($f-ambig) then $tree1 else $tree0
</scrap>
</p>
<p>
<hi>To do: check to make sure there are no top-exposed attributes or
text nodes.</hi>
The code just given does not test on <ident>$nodetype</ident>:
since an <gi>ixml</gi> element should never be consulted
when constructing an attribute, we assume <q><kw>document</kw></q>.
<hi>To do:  check anyway, just in case?</hi>
</p>

<p>For a rule with multiple right-hand sides, the <gi>alt</gi>
element to use is chosen at random.  If the current nodetype is
<q><kw>element</kw></q>, multiple passes over the content will be
needed, and they should all use the same right-hand side.  So
element and attribute construction is handled here, not on
nonterminal references.
<scrap id="epi-tfg-rule"
       name="Extract subtree from rule element">

      if ($pfg/ap:error)
      then $pfg
      else
      let $mark := ($mark, 
                    $pfg/@mark/string(),
                    '^')[1]
      let $n := count($pfg/alt),     
          $ran := <ptr target="epi-tfg-random"/>,
          $i := 1 + $ran,
          $ccc := $pfg/alt[$i]/*,
          $ls0 := tokenize($pfg/@name, '&#xB7;'),
          $nm0 := $ls0[1],
          $fr  := $ls0[2],
          $to  := $ls0[3],
          $nm  := if ($nm0 castable as xs:Name)
                  then $nm0
                  else xs:QName('ap:error')
      return <ptr target="epi-tfg-rule-elem"/>
          else <ptr target="epi-tfg-rule-attr"/>
          else <ptr target="epi-tfg-rule-content"/>
          else <ptr target="epi-tfg-rule-av"/>
          else <ptr target="epi-tfg-rule-zero"/>
          else <ptr target="epi-tfg-rule-wha"/>
</scrap>
</p>
<p>The generation of a random number is vendor-specific, so
we factor it out into a separate bit of code.
<scrap id="epi-tfg-random"
       name="Select random integer in 0..$n">
(: What random number function is available? :)
let $f1 := function-lookup(
              QName('http://basex.org/modules/random', 
                    'integer'), 
              1),
    $f2 := function-lookup(
              QName('http://exslt.org/random', 
                    'random-sequence'), 
           2),
    $f3 := function-lookup(
              QName('http://exslt.org/math', 
                    'random'), 
           0)

return 

(: basex random:integer() :)
if (exists($f1)) 
then $f1($n)

(: exslt-random:random-sequence() returns fraction 
   in 0..1; multiply by $n and take the floor to
   get the number we need :)
else if (exists($f2)) 
then let $frac := $f2(1,seconds-from-dateTime(current-dateTime()))
     return if ($frac eq 1) 
            then 0 
            else floor($frac * $n)

(: exslt-math:random(); use same procedure :)
else if (exists($f3)) 
then let $frac := $f3()
     return if ($frac eq 1) 
            then 0 
            else floor($frac * $n)

else error(QName(
"http://blackmesatech.com/2019/iXML/Aparecium",
"tbd17"), 'No random number generator found!')
</scrap>
<hi>To do: move this into a library of vendor-sensitive
functions.</hi>
This code prefers EXSLT's <ident>random-sequence()</ident>
function to their <ident>random()</ident> function,
because Saxonica's documentation says explicitly that
their optimization sometimes ensures that <ident>random()</ident>
always returns the same number. That would be disastrous
here, if the number chosen were one that led to a loop.
</p>
<p>When the rule is marked <q><code>^</code></q>
and <ident>$nodetype</ident> is <q><kw>element</kw></q>
or <q><kw>content</kw></q>, the rule is serialized
as an element.
<scrap id="epi-tfg-rule-elem"
       name="Serialize rule as element">
if (($nodetype = ('element', 'content'))
                 and ($mark eq '^'))
          then element { $nm } {
                   if ($nm0 ne $nm)
                   then attribute ap:gi { $nm0 }
                   else (),
                   <ptr target="epi-tfgre-get-atts"/>,
                   <ptr target="epi-tfgre-get-children"/>
               }
</scrap>
</p>
<p>Fetching the children is simple: we just recur on each
child and return the results.
<scrap id="epi-tfgre-get-children"
       name="Create and serialize children">
                   for $c in $ccc
                   return epi:tree-from-pfg(
                              $c, 
                              'content',
                              ()
                   )
</scrap>
</p>
<p>Fetching the attributes is a bit more complicated;
it requires checking to make sure we are not
being asked to serialize two attribute nodes with the same name.
<scrap id="epi-tfgre-get-atts"
       name="Collect and serialize attributes">

                   let $lnAtts := 
                      for $c in $ccc
                      return epi:tree-from-pfg(
                                 $c, 
                                 'attribute',
                                 ()
                      )
                   let $lnAok := 
                       $lnAtts
                       [every $i in 1 to (position() - 1)
                        satisfies
                        $lnAtts[$i]/name() ne ./name()]
	           let $lnAdups := $lnAtts[not(. = $lnAok)]
                   return ($lnAok,
		       for $n in $lnAdups
                       return element ap:error {
                          attribute id { "ap:tbd18" },
                          $n,
                          "Duplicate attribute name"
                       })
</scrap>
</p>

<p>When the rule is marked <q><code>@</code></q> and
<ident>$nodetype</ident> is <q><kw>attribute</kw></q>, the rule is
serialized as an attribute.
<scrap id="epi-tfg-rule-attr"
       name="Serialize rule as attribute">
if (($nodetype = ('attribute'))
                 and ($mark eq '@'))
          then attribute { $nm } {
                   if ($nm0 ne $nm)
                   then text { concat('[', $nm0, ']=') }
                   else (),
		   (: hack :)
                   string-join(
                   for $c in $ccc
                   let $node := epi:tree-from-pfg(
                              $c, 
                              'value',
                              ()
                   )
                   return $node
                   , '')
               }
</scrap>
</p>

<p>When the rule is marked <q><code>-</code></q> and
<ident>$nodetype</ident> is <q><kw>content</kw></q>, the rule is
serialized without an enclosing element.
<scrap id="epi-tfg-rule-content"
       name="Serialize rule as content">
if (($nodetype = ('content', 'element', 'attribute'))
                 and ($mark eq '-'))
          then for $c in $ccc
               return epi:tree-from-pfg(
                          $c, 
                          $nodetype,
                          ()
               )
</scrap>
</p>

<p>When <ident>$nodetype</ident> is <q><kw>value</kw></q>, the
marking on the rule is ignored and the content is serialized as part
of the attribute value.
<scrap id="epi-tfg-rule-av"
       name="Serialize rule as attribute value">
if (($nodetype = ('value')))
          then for $c in $ccc
               return epi:tree-from-pfg(
                          $c,
                          'value',
                          ()
               ) 
</scrap>
</p>

<p>When <ident>$nodetype</ident> and the mark are incompatible,
the rule is not serialized at all.
<scrap id="epi-tfg-rule-zero"
       name="Serialize nothing, stop recursion">
if (($nodetype = ('content'))
                 and ($mark = ('@')))
          then ()
          else if (($nodetype = ('attribute'))
                 and ($mark = ('^')))
          then ()
</scrap>
</p>
<p>
If we encounter a combination we have not specified,
then something is wrong.  Say so.
<scrap id="epi-tfg-rule-wha"
       name="Return an error element">
if (($nodetype = ('element'))
                 and ($mark = ('@')))
          then element ap:error {
                 attribute ap:desc {
                   "Attribute cannot be root.",
                   if ($nm ne $nm0)
                   then "&amp;#xA;Also, the attribute"
                        || " name is not a legal"
                        || " XML name."
                   else ()
                 },
                 attribute ap:attribute-name {
                   $nm0
                 },
                 attribute ap:attribute-value {
                   for $c in $ccc
                   return epi:tree-from-pfg(
                              $c,
                              'value',
                              ()
                   )
                 }
               }
          else element ap:error {
            "Ran off a cliff, ",
            "I don't remember a thing. ",
            "Nodetype is '" || $nodetype || "'",
            "and mark is '" || $mark || "'."
          }
</scrap>
</p>

<p>An <gi>alt</gi> element is similarly transparent:  we
just process all the children.  (Actually, the function
should never be called with <gi>alt</gi>, since
rule handling skips straight to the children.)
<scrap id="epi-tfg-alt"
       name="Extract sequence of nodes from alt element">
      for $c in $pfg/*
      return epi:tree-from-pfg($c, $nodetype, ())
</scrap>
</p>

<p>When we encounter a nonterminal element, we just recur
on the relevant rule, passing along any mark we find.
<scrap id="epi-tfg-nonterminal"
       name="Extract subtree from nonterminal element">

      let $nt := $pfg/@name/string(),
          $rule := $pfg/ancestor::ixml[1]
                   /rule[@name eq $nt]
      return epi:tree-from-pfg($rule, 
                   $nodetype, 
                   $pfg/@mark/string())
</scrap>
</p>
<p>
Extracting a literal is simple:  it's always literally present
in the <att>string</att> attribute, or else in the <att>hex</att>
attribute.
<scrap id="epi-tfg-literal"
       name="Extract character data from literal element">
       let $s := if (exists($pfg/@string))
           then string($pfg/@string)
           else if (exists($pfg/@hex))
           then eri:charXhex($pfg/@hex)
           else '&amp;#x1D350;' (: tetragram for failure U+1D350 :)

       return if ($pfg/@tmark eq '-') 
              then ()
              else if ($nodetype = ('element', 'attribute'))
              then () (: is this an error? :)
              else text { $s }
</scrap>
</p>
</div>

<div id="hi-ast-ex-rpt">
<head>Extracting an abstract syntax tree from a raw parse tree</head>
<p>Watch this space.</p>
<p>We have this code; it's just someplace else</p>
</div>
</div>


<div id="lowlevel">
<head>Low-level utility routines</head>

<div id="ll-types">
<head>Abstract types</head>
<p>XQuery does not allow for user-defined types, so we cannot
hide the details of our representations behind type names.
But for purposes of exposition, we can perhaps hide them behind
scrap names, to keep internal details out of the high-level
code at least within this document.</p>
<p><hi>N.B. At the moment none of the high-level scraps refer
to these scraps.  That's to be done.  I'm starting by defining
the scraps.</hi></p>

<p>We sporadically use some type-related naming conventions, in
a sort of Hungarian notation, at least some of the time.
<list>
<item><term>ei</term>: Earley item (aka ITEM, map(xs:string, item())</item>
<item><term>e</term>:  Earley item</item>
<item><term>f</term>:  Boolean (flag)</item>
<item><term>G</term>:  the grammar</item>
<item><term>I</term>:  the input</item>
<item><term>mei</term>:  map of Earley items (= map(xs:integer, map(xs:string, ITEM*))
       = map(xs:integer, map(xs:string, map(xs:string, item())*))</item>
<item><term>n</term>:  non-terminal symbol (may sometimes be nt)</item>
<item><term>p</term>:  position in input (to, from)</item>
<item><term>pt</term>:  raw parse tree (or subtree)</item>
<item><term>r</term>:  rule in grammar</item>
<item><term>ri</term>:  rule index (position in rule)  </item>
<item><term>s</term>:  string</item>
<item><term>sym</term>:  symbol from grammar</item>
<item><term>t</term>:  terminal symbol   </item>
</list>
</p>
<p>Functions:
<list>
<item><term>aXb</term>: return thing A from thing B</item>
</list></p>

<p>An Earley item is represented as a map, with
keys <q><code>from</code></q>, <q><code>to</code></q>,
<q><code>rule</code></q>, and <q><code>ri</code></q>
(<gloss>rule index</gloss>, or state).  
<scrap id="adt-ei" name="Type: Earley item"
       >map(*)</scrap>
A sequence of them is the obvious:
<scrap id="adt-list-ei" name="Type: list of Earley items"
       >map(*)*</scrap>
The first version of the code used elements, not maps;
maps are slightly faster.
</p>

<p>The Earley set we are constructing is itself a map, of maps.
At the moment the outer map has keys <q><code>from</code></q>
and <q><code>to</code></q>, which denote maps indexed by integer,
whose values are Earley items.  
<scrap id="adt-eiclosure" name="Type:  Earley closure">
map(xs:string,
    map(xs:integer,
        map(xs:string, item())*)) </scrap>
</p>

<p>The input we are parsing is just a string:
<scrap id="adt-input" name="Type: input string"
       >xs:string</scrap>
</p>
</div>

<div id="ll-items">
<head>Working with Earley items</head>
<div id="ll-items-con">
<head>Earley items - constructors</head>
<p>
<scrap id="eri-items"
       name="Earley items (constructors, extractors, etc.)">
(: ****************************************************** 
   * Earley items
   ****************************************************** :)
(: We represent an Earley item as a map with keys 'from', 
   'to', 'rule', and 'ri' (rule index).  For any item $ei, 
   $ei('from') and $ei('to') are integers, $ei('rule') is 
   element() (either a rule or a terminal symbol), and 
   $ei('ri') is a string (an NCName, in fact, but typed 
   only as a string).
:)

(: ******************************************************
   * Earley items:  constructors
  :)

<ptr target="eri-make-p-p-r-ri"/>
<ptr target="eri-lei-advance-ei-sym-p"/>
</scrap>
</p>
<p>To construct an Earley function from known values, we call
<ident>eiMakePPRRi</ident>:
<scrap id="eri-make-p-p-r-ri"
       name="Define eiMakePPRRi()">
(: ......................................................
   ei Make P P R Ri: make an Earley item from two 
   positions, a rule, and a rule index
  :)
declare function ixi:eiMakePPRRi(
  $From as xs:integer,
  $To as xs:integer,
  $r as element(rule),
  $ri as xs:string
) as map(xs:string, item()) {  
  map {
    'from' : $From,
    'to' : $To,
    'rule' : $r,
    'ri' : $ri 
    (: ,
    'sig' : concat('(', $From, 
                   '.', $To,
                   '.', $r/@name,
                   '/', $ri
            )
    :)(: ,
    'final' : (($ri = tokenize($r/@last, '\s+')
                      [normalize-space()])
               or (($ri eq 'q0') 
                  and 
                  ($r/@nullable = ('true', '1')))),
    'extensible' : ('' ne normalize-space(
                       $r/attribute::follow:*
                       [local-name() eq $ri]
                   ))
     :)
  }
};
</scrap>
We provide the <q><kw>sig</kw></q> field to provide a simple way of
comparing Earley items for equality, and the <q><kw>final</kw></q>
and <q><kw>extensible</kw></q> fields to speed up some frequent
operations.  <hi>At the moment, neither <q><kw>final</kw></q> nor
<q><kw>extensible</kw></q> is actually used elsewhere.</hi>
</p>
<p>In special cases, we also make items for terminal symbols:
<scrap prev="eri-make-p-p-r-ri"
       name="Define eiMakePPT()">
(: ......................................................
   ei Make P P T: make an Earley item from two 
   positions and a terminal.
  :)
declare function ixi:eiMakePPT(
  $From as xs:integer,
  $To as xs:integer,
  $t as element()
) as map(xs:string, item()) {  
  map {
    'from' : $From,
    'to' : $To,
    'rule' : $t,
    'ri' : "#terminal" (:,
    'sig' : concat('(', $From, 
                   '.', $To,
                   '.', $t,
                   '/', '#terminal'
            )
    :)(:
    'final' : true(),
    'extensible' : false()
    :)
  }
};
</scrap>
</p>
<p>The function <ident>leiAdvanceEiSymP()</ident>
takes (as its name signals) an Earley item, a symbol,
and a position, and returns the list of Earley items
which are advances from that position on that symbol.
<scrap id="eri-lei-advance-ei-sym-p"
       name="Define leiAdvanceEiSymP()">
(: ......................................................
   ixi:lei Advance Ei Sym P($E, $sym, $p): return the 
   set of Earley items (lei) that arise if you advance 
   $E over $sym, or over any equivalent symbol, to reach 
   position $p.
:)
declare function ixi:leiAdvanceEiSymP(
  $E as map(xs:string, item()),
  $sym as element(),
  $pNew as xs:integer
) as map(xs:string, item())* {
  let $pFr := $E('from'),
      $pTo := $E('to')
  return if ($pNew lt xs:integer($pTo))
      then () (: $E cannot advance backwards :)
      else 
  let $r := $E('rule'),
      $ri0 := $E('ri'),
      $lriFollow := if ($ri0 eq 'q0')
                    then $r/@first
                    else $r/@follow:*[local-name() = $ri0],
      $lri := tokenize($lriFollow,'\s+')[normalize-space()]
  for $ri in $lri
  where ixi:fSymbolmatchRRiSym($r,$ri,$sym)
    (: and $pNew ge xs:integer($pTo) :)
  return ixi:eiMakePPRRi($pFr, $pNew, $r, $ri) 
};
</scrap>
</p>
</div>
<div id="ll-items-extr">
<head>Earley items - extractors</head>
<p>For the <term>to</term> and <term>from</term> pointers,
the rule, and the rule's nonterminal, the extractor
functions are very straightforward.
<scrap prev="eri-items"
       name="Extractors for Earley items">
(: ******************************************************
   * Earley items:  extractors
   :)

(: See also sXei() below under Utilities :)

(: ......................................................
   pTo X Ei($E): extract 'to' position from item
   :)
declare function ixi:pToXEi(
  $E as map(xs:string, item())
) as xs:integer {
  $E('to')
};

(: ......................................................
   pFrom X Ei($E): extract 'from' position from item
   :)
declare function ixi:pFromXEi(
  $E as map(xs:string, item())
) as xs:integer {
  $E('from')
};

(: ......................................................
   r X Ei($E): extract rule from item
   :)
declare function ixi:rXEi(
  $E as map(xs:string, item())
) as element() {
  $E('rule')
};

(: ......................................................
   nLhs X Ei($E): extract nonterminal on lhs of rule 
   from item
   :)
declare function ixi:nLhsXEi(
  $E as map(xs:string, item())
) as element(nonterminal) {
  element nonterminal {
    attribute name { $E('rule')/@name }
  }
};
</scrap>
</p>
<p>To get the list of expected symbols, more work is needed.
<scrap prev="eri-items"
       name="Extractors for Earley items">
 (: ......................................................
   lsymExpected X Ei($E): extract list of expected 
   symbols from item
   :)
declare function ixi:lsymExpectedXEi(
  $E as map(xs:string, item())
) as element()* {
  (: results will be element() or element(nonterminal). :)
  let $symCur := $E('ri'),
      $r := $E('rule'),
      $sFollowset := if ($symCur = 'q0') 
                     then $r/@first
                     else $r/@follow:*[local-name()=$symCur],
      $lsymFollow := tokenize($sFollowset,'\s+')[normalize-space(.)]
  for $sym in $lsymFollow
  let $e := $r//*[@xml:id = $sym]
  return $e
};
</scrap>
</p>
<p>Q. would this be faster with the <kw>for</kw> loop replaced by
<code>return $r/descendant::*[@xml:id =
tokenize($sFollowset,'\s+')]</code> or <code>return
$r/descendant::*[@xml:id = $lsymFollow]</code>, maybe?
</p>
<p>A. Let's see.
<list>
<item><label>Loop:</label>  1:13.6 user time (two runs, same time),
            1:09.8 / 1:10.8 real time (?)</item>
<item><label>XPath:</label>  <code>$r/descendant::*
            [@xml:id = tokenize($sFollowset,'\s+')]</code>:
            1:19.9, 1:21.8 user</item>
<item><label>XPath:</label>  <code>$r/descendant::*
            [@xml:id = $lsymFollow]</code>:
1:12.5, 1:12.4</item>
</list>
So:  not, it would not be noticeably faster,
and might be slower.
</p>
</div>
<div id="ll-items-predicates">
<head>Earley items - predicates</head>
<p>We use predicate functions to ask several questions
about Earley items:
<list>
<item>Is it final?  Does it mark the completion of the rule?
Sometimes we specify the left-hand side of the rule,
sometimes also the position.</item>
<item>Does it expect any nonterminals?</item>
<item>Does the scan relation hold between two given Earley items?</item>
<item>Does the advance-over-symbol-S relation hold between two given
Earley items?</item>
</list>
</p>
<p>There are several functions for asking whether an item is
a completion.
<scrap prev="eri-items"
       name="Predicates for Earley items">
(: ******************************************************
   * Earley items:  predicates
   :)
(: ......................................................
   fFinal Ei P P N($E, $pFr, $pTo, $N): is $E a
   completion item for symbol N, running between the 
   two positions? (Used just once, in recognizeX, to 
   check for completions of the start symbol that cover 
   the entire input string.)
   :)
declare function ixi:fFinalEiPPN(
  $E as map(xs:string, item()),
  $pFrom as xs:integer,
  $pTo as xs:integer,
  $sym as xs:string
) as xs:boolean {
  (xs:integer($E('from')) eq $pFrom)
  and (xs:integer($E('to')) eq $pTo)
  and ($E('rule')/@name eq $sym)
  and ($E('ri') = ixi:lriFinalstatesXR($E('rule')))
};

(: ......................................................
   ixi:fFinalEiPN($E, $pTo, $sym):  true iff $E is a 
   completion item ending at position $P for nonterminal 
   $N 
   :)
declare function ixi:fFinalEiPN(
  $E as map(xs:string, item()),
  $pTo as xs:integer,
  $n as element(nonterminal)
) as xs:boolean {
  let $f := xs:integer($E('to')) eq $pTo
            and $E('rule')/@name eq $n/@name
            and $E('ri') = ixi:lriFinalstatesXR($E('rule'))

  return $f
};

(: ......................................................
   fFinal Ei($E): is $E a completion item?  I.e. is its 
   rule index in a final location?
   :)
declare function ixi:fFinalEi(
  $E as map(xs:string, item())
) as xs:boolean {
  $E('ri') = ixi:lriFinalstatesXR($E('rule'))
};
</scrap>
</p>
<p><scrap prev="eri-items"
       name="Define fExpectsN-Ei()">
(: ......................................................
   fExpectsN - Ei($E):  does $E expect any nonterminals?
   :)
declare function ixi:fExpectsN-Ei(
  $E as map(xs:string, item())
) as xs:boolean {
  exists(ixi:lsymExpectedXEi($E)[ixi:fNonterminal(.)])
};
</scrap>
</p>
<p>Abstractly, the scan relation scan(E1,E2) holds iff
<list>
<item>E1 expects terminal T</item>
<item>and E1 wins</item>
<item>and E2 = advance(E1, T)</item>
</list>
And E2 = advance(E1, T) iff
<list>
<item>from(E1) = from(E2)</item>
<item>and rule(E1) = rule(E2)</item>
<item>and seen-so-far(E1) || T = seen-so-far(E2)</item>
<item>and E1 wins on T [redundant, why?]</item>
<item>else advance(E1, T) = empty set.</item>
</list>
So:
<scrap prev="eri-items"
       name="Define fScanrelEE()">
(: ......................................................
   fScanrel E E($E1, $E2):  does the scan relation hold 
   for E1, E2?
   (Used once, in Earley parser internals, to find 
   related items.)
   :)
   (: N.B. does not test that the symbol in question 
      is a terminal. Does it matter?
   :)   
declare function ixi:fScanrelEE(
  $E1 as map(xs:string, item()),
  $E2 as map(xs:string, item())
) as xs:boolean {
  let $fFrom := ($E1('from') eq $E2('from')),
        (: test 1 of advance() :)
      $lsymFollow := ixi:lsymExpectedXEi($E1), 
      $lSsymFollow := for $e in $lsymFollow return $e/@xml:id,
      $fStates1 := ($E2('ri') = $lSsymFollow),
        (: test 3, 4 of advance(), 1,2 of scan() :)
      $fRules := deep-equal($E1('rule'), $E2('rule')),
	(: test 2 of advance() :)
      $f := ($fFrom and $fStates1 and $fRules), 
      $trace := ($f,
                'fScanrelEE(' 
                || ixi:sXei($E1) || ',' 
                || ixi:sXei($E2) || ') ==> '
                )
  return $f
      (: 
               .('from') = $Ecur('from')
               and .('to') = $pMedial
               and .('ri') = $lsPrevstates
               and deep-equal(./rule, $Ecur/rule)
      :)
};

</scrap>
</p>
<p>
<scrap prev="eri-items"
       name="Define fAdvanceNrelEE()">
(: ......................................................
   fAdvanceNrel E E ($E1, $E2):  does the 
   advance-over-symbol-N relation hold for E1, E2?
   (Used once, in Earley parser internals, to find 
   related items.)

   By definition (see paper) E2 = advance(E1, T) iff
      * from(E1) = from(E2)
      * and rule(E1) = rule(E2)
      * and seen-so-far(E1) || T = seen-so-far(E2)
      * and E1 wins on T
      * else advance(E1, T) = empty set.

   Note that for the "E1 wins" clause we rely on the 
   truth of all items in the closure.  E1 must be  
   winning, because otherwise an E2 that satisfies 
   the other tests would not be in the closure.
   :)
declare function ixi:fAdvanceNrelEE(
  $E1 as map(xs:string, item()),
  $E2 as map(xs:string, item())
) as xs:boolean {
  let $fFrom := ($E1('from') eq $E2('from')),
      $lsymFollow := ixi:lsymExpectedXEi($E1),
      $lSsymFollow := for $e in $lsymFollow 
                      return $e/@xml:id,
      $fStates1 := ($E2('ri') = $lSsymFollow),
      $fRules := deep-equal($E1('rule'), $E2('rule')),
      $f := ($fFrom and $fStates1 and $fRules),
      $trace := ($f,
                'fScanrelEE(' 
                || ixi:sXei($E1) || ',' 
                || ixi:sXei($E2) || ') ==> '
                )
  return $f
      (: 
               .('from') = $Ecur('from')
               and .('to') = $eiCC('from')
               and .('ri') = $lsPrevstates 
               and deep-equal(./rule, $Ecur/rule)
      :)
};
</scrap>
</p>
</div>
<div id="ll-items-closure">
<head>Earley set closure</head>
<p>The heart of the Earley algorithm is the calculating the
closure of the Earley set.
<scrap prev="eri-items"
       id="eri-items-closure"
       name="Calculating the closure of an Earley set">
(: *******************************************************
   * Earley items:  closure (the big kahuna)
   :)
</scrap>
</p>
<p>We will want an accumulator to hold the set, so the
user's call to <ident>earley-closure</ident> merely
initializes an accumulator and calls another function to
do the work.
<scrap prev="eri-items-closure"
       name="Define earley-closure($lei, $I, $G)">
 (: ......................................................
   ixi:earley-closure($lei, $I, $G2): 
   Calculate closure of $lei over the relations scan(), 
   pred(), and comp().
:)
declare function ixi:earley-closure(
  $leiPending as map(xs:string, item())* (: ITEM* :), 
  $I as xs:string,
  $G as element(ixml)
) as map(xs:string,
         map(xs:integer,
             map(xs:string,
                 item())*)) (:MEI:) {
  let $meiAcc := map { 
                   'from' : map:merge(
                     for $ei in $leiPending
		     return map:entry($ei('from'), $ei),
                     $ixi:combinedups
                   ),
                   'to' : map:merge(
                     for $ei in $leiPending
		     return map:entry($ei('to'), $ei),
                     $ixi:combinedups
		   ) }
		       
  return ixi:earley-closure($leiPending, $meiAcc, $I, $G)
};
</scrap>
</p>
<p>The larger function is this one.</p>
<p>We calculate the closure of the set of Earley items in $accumulator
over the relations scan(), pred(), and comp().
</p>
<p>Every item in $pending is also in $accumulator.  The items in
$pending have not yet been examined; the other items in $accumulator
have been dealt with and need not be dealt with again.
</p>
<p>N.B. To keep the control flow simple, this function does not
attempt to handle all of the items at position $p before moving to $p
+ 1, and it does not assume that all predictions of a nonterminal $n
beginning at position $p are present when a completion for $n at $p is
found.
</p>
<p>One immediate consequence of this is that every item making a
prediction must also check for completions of its predicted
non-terminals, which increases the number of times we must scan
through the accumulator and offers a low-hanging target for improving
speed. <hi>TO DO: pluck that low-hanging fruit.</hi></p>

<p>The function has two cases: either we are done, or we are not yet
done.
<scrap prev="eri-items-closure"
       name="Define earley-closure($pending, $accumulator, $I, $G)">

(: ......................................................
   ixi:earley-closure($pending, $accumulator, $I, $G2):
:)
declare function ixi:earley-closure(
  $leiPending as map(xs:string, item())* (: pending items :),
  $meiAccum as map(xs:string, map(xs:integer, map(xs:string, item())*))
            (: accumulator of type MEI :),
  $I as xs:string,
  $G as element(ixml)
) as map(xs:string, map(xs:integer, map(xs:string, item())*)) (:MEI:) {
  <ptr target="eri-items-closure-termination"/>
  else <ptr target="eri-items-closure-normal"/>};
</scrap>
</p>
<p>The base case arises when the pending list is done.  If nothing
remains to be done, then we are done and can return the accumulator.
<scrap id="eri-items-closure-termination"
       name="Terminating case for Earley closure">
  if (empty($leiPending))
  then $meiAccum
</scrap>
</p>
<p>In the normal case, we have items to process.  We
<list>
<item>take the head of the pending list,</item>
<item>run the PCS function on it,</item>
<item>dedup the returned items,</item>
<item>drop any items that are already in the accumulator, and</item>
<item>recur, while adding new items to the accumulator.</item>
</list>
<note type="block">
<p>Note, February 2022.</p>
<p>When trying to find out where time is going in the recognizer, the
first step is to wrap each step here in prof:time().  The conjecture
before examining the results is that 80% of the time, or more, will be
spent in <ident>ixi:leiPCSrel()</ident>, and minimal time in the
deduping steps.</p>
<p>If this conjecture holds true, the second step will be to
instrument <ident>leiPCSrel()</ident>.  But: one thing at a time.</p>
</note>
<note type="block">
<p>Note, February 2022.</p>
<p>Results of one run on test0 (trivial examples):
<list>
<item>1.63 ms checking PCS results against accumulator</item>
<item>0.54 ms deduping PCS results</item>
<item>35.48 ms running PCS function</item>
</list>
So nearer 94% than 80% of the time.  (It might be nice to have an
automated way of getting these numbers, but for now what I did is
copy and paste the messages out of the GUI's info window, use an
impromptu Emacs keyboard macro to change lines like
<q><code>PCS: 0.87 ms</code></q> to
<q><code>0.87 ; ms PCS:</code></q>, sort to get the
different measurements together, and wrap each set of
messages in <q><code>(+</code></q> ... <q><code>)</code></q>.
Then ^x^e to evaluate the Lisp expression.)
</p>
<p>On a longer test set (test2), which ran for 1215 seconds,
the results were:
<list>
<item>1,782.91 ms checking PCS results against accumulator</item>
<item>357.39 ms deduping PCS results</item>
<item>19,967.69 ms running PCS function</item>
<!-- (let ((c 1782.91) (d 357.39) (r 19967.69)) (/ r (+ c d r))) -->
</list>
As the accumulator gets larger, searching it for items already present
appears to become more expensive.  But running PCS is still taking 90%
of the measured time.
</p>
<p>Further testing seems unnecessary.</p>
<!-- <p>And on ixml-corr, the results were:
<list>
<item> ms checking PCS results against accumulator</item>
<item> ms deduping PCS results</item>
<item> ms running PCS function</item>
</list>
</p>-->
</note>
<scrap id="eri-items-closure-normal"
       name="Normal case for Earley closure">

  let $E := head($leiPending), 

      (: get everything from leiPCSrel :)
      $leiCs0 := ixi:leiPCSrel($E,$meiAccum,$I,$G),
                 
      
      (: dedup results from leiPCSrel :) 
      $leiCs := $leiCs0[
                   not(some $i in 1 to (position() - 1)
                       satisfies deep-equal(., $leiCs0[$i])
                   )],
        	
      (: remove non-new results from leiPCSrel :)
      $leiNew := for $ei in $leiCs
	         let $from := $ei('from')
		 where not(some $e in $meiAccum('from')($from)
		           satisfies deep-equal($e, $ei))
		 return $ei,

      <ptr target="eri-itcl-traces"/>
		 
      $meiNewaccum := map {
	'from' : map:merge(
	  ( $meiAccum('from'),
	  for $ei in $leiNew return map:entry($ei('from'), $ei) ),
	  $ixi:combinedups),
        'to' : map:merge(
	  ( $meiAccum('to'),
	  for $ei in $leiNew return map:entry($ei('to'), $ei) ),
	  $ixi:combinedups) }
      
  return ixi:earley-closure(
    (tail($leiPending), $leiNew),
    $meiNewaccum,
    $I,
    $G)
</scrap>
</p>

<p>When debugging this, it is helpful to have trace messages showing
each step in this process.
<scrap id="eri-itcl-traces"
       name="Issue trace messages for earley-closure()">

      $dummy := ixi:notrace(count($leiPending), 
                            'e-c() has pending items: '), 
      $dummy := ixi:notrace(
                    ixi:sXei($E),
                    'ixi:earley-closure running on item: '), 
      $dummy := ixi:notrace(count($leiCs0), 
                    'e-c() initial closure has items: '), 
      $dummy := ixi:notrace(count($leiCs), 
                     'e-c() deduped closure has items: '), 
      $dummy := ixi:notrace(count($leiNew), 
                     'e-c() New items: '), 
</scrap>
</p>
<p>The function <ident>leiPCSrel()</ident> takes an Earley
item (and an accumulator, the input, and the grammar) and
returns all the items that stand in the scan, pred, or
comp relations to the given item.
<note place="block">
<p>February 2022: timings within this function on test0:
<list>
<item>89.09 ms in ix:scan()</item>
<item>173.29 ms in ix:pred()</item>
<item>118.13 ms looking for completion and performing comp()</item>
<item>186.01 ms looking for prediction and performing comp()</item>
</list>
and on ABNF.ixml (which ran 1675 seconds):
<list>
<item>3972.56 ms in ix:scan()</item>
<item>6868.14 ms in ix:pred()</item>
<item>4076.04 ms looking for completion and performing comp()</item>
<item>11520.97 ms looking for prediction and performing comp()</item>
</list>
That's only 27 seconds out of 1675 - where did that time all
go?!
</p>
</note>
<scrap prev="eri-items-closure"
       name="Define earley-closure($pending, $accumulator, $I, $G)">

(: ......................................................
   leiPCSrel($E, $leiA, $I, $G): return all items $E2 
   such that 
   $E2 = scan($E, $I)
   or $E2 = pred($E, $G)
   or comp($E1, $E3) for some $E3 in $leiA
   or comp($E3, $E1) for some $E3 in $leiA
:)
declare function ixi:leiPCSrel(
  $E as map(xs:string, item()),
  $meiAccum as map(xs:string, item())*,
  $I as xs:string,
  $G as element(ixml)
) as map(xs:string, item())* {
  (: If $E expects terminals, perform scan :)
  
  ix:scan($E,$I),
  
  
  (: If $E expects nonterminals, perform prediction :)
  
  ix:pred($E,$G), 
  
  
  (: If $E expects a nonterminal, look for a 
     completion $Ec and perform comp($Ec,$E) :)
  
  if (ixi:fExpectsN-Ei($E))
  then for $Ec in $meiAccum('from')($E('to'))
       where ixi:fFinalEi($Ec)
       return ix:comp($Ec,$E)
  else (), 
  
    
  (: If $E is a completion, look for a prediction $Ep 
     and perform comp($E,$Ep) :)
  
  if (ixi:fFinalEi($E)) 
  then for $Ep in $meiAccum('to')($E('from'))
       where ixi:fExpectsN-Ei($Ep)
       return ix:comp($E,$Ep)
  else ()
  
    
  (: N.B. In BNF, $E can only expect one symbol, so 
     either scan or pred applies, but not both.  But 
     we are expecting EBNF and $E can predict several 
     things at the same time as being a completion. :)
};
</scrap>
</p>
</div>
</div>

<div id="ll-grammars">
<head>Working with grammars</head>

<p>
<scrap id="eri-grammars"
       name="Grammars (constructors, extractors, etc.)">
(: ****************************************************** 
   * Grammars
   ****************************************************** :)
(: A grammar is an ixml element with no namespace. :)

<ptr target="eri-grammars-constructors"/>
<ptr target="eri-grammars-extractors"/>
<ptr target="eri-grammars-predicates"/>
</scrap>
</p>
<p>We have just one routine that constructs grammars; it takes an
existing grammar and gives it a new start-symbol with a single rule.
This allows us to know without any further analysis that the start
symbol of the augmented grammar is non-recursive and has just one
rule. [<hi>To do:</hi> write a version of this that accepts a
start-symbol as a parameter.]</p>
<p>This is the same in v0.1 and v0.2 except that we use a different
element name to wrap the right-hand side of the rule.
<scrap id="eri-grammars-constructors"
       name="Functions that construct or return grammars">
 (: ******************************************************
   * Grammars: constructors
   :)
   
(: ......................................................
   augment-grammar($G):  given grammar, augment it as 
   Earley prescribes.
   :)
declare function ixi:augment-grammar(
  $G as element(ixml)
) as element(ixml) {
  let $symStart := ixi:symStartG($G),
      $symGoal := ixi:makeGoalsymbolG($G),
      $fNullable := ixi:fNullableNG($symStart, $G)
  return element ixml {
    element rule {
      attribute name {$symGoal}, 
      attribute xml:id {$symGoal || '_rule'},
      attribute nullable { false() },
      attribute first {$symStart || '_0'},
      attribute last {$symStart || '_0'},
      attribute { xs:QName('follow:'||$symStart||'_0') } 
                {()},        
      element <ptr target="gl-alts-gi"/> {
        attribute xml:id {$symGoal || '_def_0'},
        attribute nullable { false() },
        attribute first {$symStart || '_0'},
        attribute last {$symStart || '_0'},
        attribute { xs:QName('follow:'||$symStart||'_0') } 
                  {()},
        element alt {
          attribute xml:id {$symGoal || '_alt_0'},
          attribute nullable { false() },
          attribute first {$symStart || '_0'},
          attribute last {$symStart || '_0'},
          element nonterminal {
            attribute name { $symStart },
            attribute xml:id {$symStart || '_0'},
            attribute nullable { false() },
            attribute first {$symStart || '_0'},
            attribute last {$symStart || '_0'}
          } (: end nonterminal :)
        } (: end alt :)
      } (: end def :)
    }, (: end rule :)
    $G/rule
  } (: end ixml :)
};
</scrap>
</p>
<p>We have a small utility function for making a new
goal symbol that differs from all existing symbols.
<scrap prev="eri-grammars-constructors"
       name="Goal-symbol construction">
 (: ......................................................
   makeGoalsymbolG($G):  make a new goal symbol for 
   grammar G, ensuring that it's not the same as any 
   existing symbol.
   :)
declare function ixi:makeGoalsymbolG(
  $G as element(ixml)
) as xs:string {
  let $ln := distinct-values($G/rule/@name),
      $n := ('Goal', '_Goal_', '_G_o_a_l_', '_G-o-a-l_')
            [not(. = $ln)][1]
  return if (exists($n)) 
    then $n 
    else ixi:mungesymbol(ixi:symStartG($G), $ln)
};
</scrap>
</p>
<p>And another utility for munging a given symbol.
<scrap prev="eri-grammars-constructors"
       name="Goal-symbol construction">
(: ......................................................
   mungesymbol:  given a symbol, munge it (by adding _ 
   fore and aft) until it is no longer in the list of 
   symbols $ln (which is the symbols already in the 
   grammar).
   :)
declare function ixi:mungesymbol(
  $n as xs:string,
  $ln as xs:string*
) as xs:string {
  if ($n = $ln)
    then ixi:mungesymbol('_' || $n || '_', $ln)
    else $n
};

</scrap>
</p>
<p>
<scrap id="eri-grammars-extractors"
       name="Functions that extract information from grammars">
(: ******************************************************
   * Grammars: extractors
   :)
   
(: ......................................................
   symStart G():  return start symbol(s) of G
   :)
declare function ixi:symStartG(
  $G as element(ixml)
) as xs:string+ {
  $G/rule[1]/@name/normalize-space()
};
</scrap>
</p>
<p>
<scrap id="eri-grammars-predicates"
       name="Functions that check grammar properties">
(: ******************************************************
   * Grammars:  predicates
   *
   * Note that predicates relating to symbols in context 
   * are here, not under symbol.  (Test:  is $G a 
   * parameter?)
   :)
(: ixi:fNullableNG($n, $G):  is nonterminal n nullable 
   in G? 

   For non-terminal N, fNullableNG(N,G) means an N 
   element in the result tree may be empty.

   Here 'nullable' means it has a right-hand side whose
   regex matches the empty string, which means in turn
   that the parse tree may be empty, and non-terminal N
   may appear as an N element in the result.
   
   N.B. this is not the same as fGES.
  
:)
declare function  ixi:fNullableNG(
  $n as xs:string, (: element(nonterminal), :)
  $G as element(ixml)
) as xs:boolean {
  exists($G/rule[@name = $n][@nullable = ('true', '1')])
};


(: ixi:fGesNG($n, $G):  does nonterminal n generate the 
   empty string in G? 
   
   N.B. this is not the same as fNullable.
   
   Discussions of parsing often use 'nullable' for 
   nonterminals that generate the empty string, but in 
   the grammar 
     S: X. X: .
   X is nullable and GES, S is GES but not nullable.
   
   For non-terminal N, fGesNG(N,G) means an N element
   in the result tree may have string(N) = ''.
   
:)
(: this is a transitive closure algorithm and will 
   require more work (including an accumulator to 
   avoid looping).
   
   For now, suppress it and do without it.
:)
(:
declare function  ixi:fGesNG(
  $n as element(), 
  $G as element(ixml)
) as xs:boolean {
  ($n/self::nonterminal 
     and ixi:fNullable($n, $G)
         or 
         (some $d 
          in $G/rule[@name=$n]/alt
          satisfies ixi:fGesNG($d,$G)))
  or ($n/self::def
     and ($n/@nullable = ('true','1'))
  or 
  ()
 
};
:)

(: ixi:lrulesXNG($n,$G) :)
declare function ixi:lrulesXNG(
  $n as element(nonterminal),
  $G as element(ixml)
) as element(rule)* {
  $G/rule[@name = $n/@name]
};


(: ******************************************************
   * Grammars: predicates
   :)

</scrap>
</p>
</div>

<div id="ll-rules">
<head>Working with rules</head>

<p>
<scrap id="eri-rules"
       name="Rules (constructors, extractors, etc.)">
(: ****************************************************** 
   * Rules and rule indexes
   ****************************************************** :)
(: A rule is a rule element as defined in the ixml DTD, but 
   augmented with glushkov attributes.
   
   Note that functions relating to rules in context are 
   not here but under Grammars above.  (Test: is $G a 
   parameter?) Functions here relate solely to the rule 
   in isolation. That may be why there are so few of them.
:)

(: ******************************************************
   * Rules and rule indexes: constructors
   :)
   
(: ******************************************************
   * Rules and rule indexes: extractors
   :)

(: ixi:lriFinalstatesXR($r) :)
declare function ixi:lriFinalstatesXR(
  $r as element()
) as xs:string* {
  if ($r/self::rule)
  then 
  (
    if ($r/@nullable = ('true', '1'))
    then 'q0' else (),
    tokenize($r/@last,'\s+')[normalize-space()]
  )
  else ()

};

(: ixi:lriStartstatesXR($Rule):  return list of 
   start-position identifiers.
 :)
declare function ixi:lriStartstatesXR(
  $r as element()
) as xs:string* {
  'q0'
};

(: ******************************************************
   * Rules and rule indexes: predicates
   :)
</scrap>
</p>
</div>

<div id="ll-symbols">
<head>Working with symbols</head>

<p>A symbol is (represented by) an element: one of <gi>nonterminal</gi>,
<gi>literal</gi>, <gi>inclusion</gi>, or <gi>exclusion</gi>.
</p>
<p>(Any reference to elements named <q><gi>terminal</gi></q> is a
relic from the 2016 grammar of ixml and now constitutes an error.)
</p>

<p>Note that functions relating to symbols in context are not here but
under Grammars above.  (If <ident>$G</ident> is a parameter, it's with
grammars.)  Functions here relate solely to the symbol in isolation.
That may be why there are so few of them.</p>

<p>Similarly any function that involves the input string is not here
but under Input, below.
<scrap id="eri-symbols"
       name="Symbols (constructors, extractors, etc.)">
(: ****************************************************** 
   * Symbols
   ****************************************************** :)

(: ******************************************************
   * Symbols: constructors
   :)
   
(: ******************************************************
   * Symbols: extractors
   :)
<ptr target="eri-sym-match-length"/>
<ptr target="eri-sym-reXTerminal"/>
 
(: ******************************************************
   * Symbols: predicates
   :)
<ptr target="eri-sym-fTerminal"/>
<ptr target="eri-sym-fNonterminal"/>
<ptr target="eri-sym-fSymbolmatchRRiSym"/>
</scrap>
</p>

<div id="ll-sym-match-length">
<head>The <ident>match-length()</ident> function</head>
<p>In tree-builder, we want match-length info just from terminal; we
don't have access to $I.  If terminals ever become variable-length,
this will break. <hi>Is this still true, or does <ident>scan()</ident>
now produce Earley items from which the length and the string
can be found without <ident>$I</ident>?</hi></p>
<p>See also match-length#3 below under Input.
<scrap id="eri-sym-match-length"
       name="Define match-length()">
(: ......................................................
   match-length($t):  return length of any string that 
   matches the specified terminal.  
   :)
declare function ixi:match-length(
  $t as element()
) as xs:integer {
  if ($t/self::literal) then ixi:string-length($t)
  else 1
};
</scrap>
</p>
</div>

<div>
<head>Making regular expressions from terminal symbols</head>
<p>The function <ident>reXTerminal($t)</ident> returns a regular
expression, given a terminal element.  Note that the regular
expression will match one character (or none) in the input; we don't
have terminal symbols with indeterminate length in the input.
</p>
<p>This function is initially needed only for character sets
(<gi>inclusion</gi> and <gi>exclusion</gi>), but let's make it handle
literals as well, just in case.</p>
<p>To do: make the compilation step do this once for all for each
terminal, so that we're not doing it again and again.
<scrap id="eri-sym-reXTerminal"
       name="Define reXTerminal(), regex from terminal">
(: ......................................................
   re X Terminal($t): return a regular expression, given 
   a terminal element.
   :)
declare function ixi:reXTerminal(
  $t as element() (: incl, excl, literal :)
) as xs:string {
  if ($t/self::literal) 
  then <ptr target="eri-sym-reXT-literal"/>
  else 
  let $le := $t/*,
      $lsRegexbits := 
          for $e in $le
          return if ($e/self::range
                    or $e/self::member/@from)
                 then <ptr target="eri-sym-reXT-range"/>
                 else if ($e/self::literal
                    or $e/self::member/@string
                    or $e/self::member/@hex) 
                 then <ptr target="eri-sym-reXT-lit"/>
                 else if ($e/self::class
                    or $e/self::member/@code)
                 then ixi:catescXS($e/@code) 
                 else () (: error :)
  return if ($t/self::inclusion
             and exists($lsRegexbits))
    then "[" || string-join($lsRegexbits,'') || "]"
    else if ($t/self::exclusion
             and exists($lsRegexbits))
    then "[^" || string-join($lsRegexbits,'') || "]"
    else if ($t/self::inclusion)
    then "[^\s\S]" (: empty inclusion matches nothing :)
    else if ($t/self::exclusion)
    then "[\s\S]" (: empty inclusion excludes nothing :)
    else "--error in reXTerminal--"
};
</scrap>
We use <q><code>[\s\S]</code></q> and <q><code>[^\s\S]</code></q>
as XPath representations of the empty inclusion and the empty
exclusion, respectively.  Any pair of complementary character
class escapes would work as well:  <q><code>\w\W</code></q>
<q><code>\i\I</code></q>, etc.
</p>

<p>An important wrinkle is that not every integer between #0000 and
#10FFFF (0..1114111) can be turned into an XML character.  So we need
to check that hex-encoded characters are in fact XML characters, and
adapt the regular expression accordingly if they are not.
</p>
<p>A literal with a <att>string</att> attribute cannot contain a
non-XML character: by the time we have a compiled grammar, we are
looking at XDM instances and any non-XML characters will have caused
failures earlier on.  So any <att>string</att> attribute just needs to
be escaped.
<scrap id="eri-sym-reXT-literal"
       name="Make character-escaped string from literal">

      if (exists($t/@string))
      then ixi:sceXS($t/@string)
</scrap>
A hex value, on the other hand, must be checked.  For encoded
terminals, a hex value denoting a non-XML character cannot match
anything in the input and is therefore equivalent to a regular
expression matching nothing (not to be confused with matching
the empty string).  We'll use <q><code>[^\s\S]</code></q>
for that case: since <q><code>\s</code></q> and <q><code>\S</code></q>
are complements and together match every XML character,
<q><code>[^\s\S]</code></q> will not match anything at all.
<scrap prev="eri-sym-reXT-literal">
      else try { ixi:sceXS(
                    codepoints-to-string(
                       d2x:x2d($t/@hex)
                    ) 
                 )
               } catch * {
                  "[^\s\S]"
               }
</scrap>
</p>
<p>For what it's worth, the original version of the code just
given was too trusting:
<q><code>ixi:sceXS( ixi:string-value($t) )</code></q>.
When a hex-encoded literal referred to a non-XML character,
things blew up.
</p>
<p>Ranges require special care, because if hex-encoded the range ends
may involve non-XML characters.  If so, we find the nearest XML
character guaranteed to produce the same rules on XML strings, and
then build the range.  In the process, we may end up missing one or
both ends of the range (if <att>from</att> is greater than #10FFFF or
<att>to</att> is less than 9), or the two may move past each other
(as they would for <q><code>[#10 - #1F]</code></q>); in that case,
we return nothing at all.
<scrap id="eri-sym-reXT-range"
       name="Make positive character group for range">
                      <ptr target="eri-sym-reXT-from"/>
                      <ptr target="eri-sym-reXT-to"/>
                      return if (exists($cpFrom)
                          and exists($cpTo)
                          and ($cpFrom le $cpTo))
                      then ixi:sceXS($sFrom)
                           || "-"
                           || ixi:sceXS($sTo)
                      else ()
</scrap></p>
<p>
To handle a non-XML <att>from</att> value, we bump it up to
the next higher XML character, because that is where the effective
range begins.  For example, if the range is specified as
<q><code>[#00 - #FF]</code></q>, the lowest code point it can match
is #09, the first XML character greater than #00.
<scrap id="eri-sym-reXT-from"
       name="Set $cpFrom, $sFrom to effective codepoint and string">

        let $cpFrom0 := 
               if (matches($e/@from, 
                           '^#[0-9a-fA-F]+$'))
               then d2x:x2d(substring($e/@from, 2))
               else string-to-codepoints(
                       $e/@from/string()), 
            $cpFrom := try {
                  string-to-codepoints(
                     codepoints-to-string(
                        $cpFrom0))       
               } catch * {
                  (: bump it up to one of:
                     #9, #D, #20, #E000, #10000 :)
                  (9, 13, 32, 57344, 65536)
                  [$cpFrom0 le .][1]
               },
            $sFrom := codepoints-to-string($cpFrom)
</scrap>
The ranges allowed for XML characters are, in ixml notation,
<q><code>[#9 - #A; #D; #20 - #D7FF; #E000 - #FFFD; #10000 -
#10FFFF]</code></q>.  As may be seen, we simply find the lowest range
whose starting point is above the non-XML code point.  <hi>(Strictly
speaking, we should perhaps catch only error FOCH0001, to avoid making
this adjustment for other unrelated errors.)</hi>
</p>
<p>
Conversely, for the <att>to</att> value, we bump a non-XML
codepoint down to the top of next range of XML characters.
<scrap id="eri-sym-reXT-to"
       name="Set $cpTo, $sTo to effective codepoint and string">

        let $cpTo0 :=
               if (matches($e/@to, 
                           '^#[0-9a-fA-F]+$'))
               then d2x:x2d(substring($e/@to, 2))
               else string-to-codepoints(
                       $e/@to/string()), 
            $cpTo := try {
                  string-to-codepoints(
                     codepoints-to-string(
                        $cpTo0))       
               } catch * {
                  (: bump it down to one of:
                     #10FFFF, #FFFD, #D7FF, #D, #A :)
                  (1114111, 65533, 55295, 13, 10)
                  [$cpTo0 ge .] [1]
               },
            $sTo := codepoints-to-string($cpTo)
</scrap>
For range ends specified as literals, we engage in a little
unnecessary work of turning them into code points and then
back into strings.
</p>
<p>Literal character-set members also require special handling if they
are hex-encoded.  If they are XML characters, they are treated
normally; if they are not XML characters, they are dropped:  they
cannot match anything in an inclusion, and they cannot exclude
anything in an exclusion.
<scrap id="eri-sym-reXT-lit"
       name="Make positive character group from literal">

                             try {
                                ixi:sceXS(
                                   $e/ixi:string-value(
                                     $e))
                             } catch * {
                                ()
                             } 
</scrap>
</p>
</div>

<div>
<head>Testing for symbol type</head>
<p>The function <ident>fTerminal()</ident> returns true iff the
argument is a terminal symbol.  This version supports both my
interpretation of the 2016 syntax (with element type
<gi>terminal</gi>) and the 2019 syntax (literal, inclusion,
exclusion).
<scrap id="eri-sym-fTerminal"
       name="Define fTerminal()">
(: ......................................................
   f Terminal($sym):  is $sym a terminal symbol?
   :)
declare function ixi:fTerminal(
  $sym as item()
) as xs:boolean {
  exists($sym/self::element()[self::terminal
    or self::literal
    or self::inclusion
    or self::exclusion
  ])
};
</scrap>
</p>
<p>The function <ident>fNonterminal()</ident> performs
a similar function for nonterminals.
<scrap id="eri-sym-fNonterminal"
       name="Define fNonterminal()">
(: ......................................................
   f Nonterminal($sym):  is $sym a nonterminal symbol?
   :)
declare function ixi:fNonterminal(
  $sym as item()
) as xs:boolean {
  exists($sym/self::element()/self::nonterminal)
};
</scrap>
</p>
</div>
<div>
<head>Matching symbols against rule indices</head>
<p>The function <ident>fSymbolmatchRRiSym($r, $ri, $sym)</ident>
determines whether a symbol element $sym matches rule index $ri in
rule $r.  Equivalently: in the FSA for rule $r, does state $ri mean
"we have just read (a string generated by) $sym"?</p>
<p>N.B. $sym is an element, not a name or string, so simple comparison 
is not enough here; we need a bit more.
</p>
<p>Called once, from ixi:leiAdvanceEiSymP(), called in turn thrice
from Earley-recognizer:
<list>
<item>in ix:scan() with terminal from rule (so 'terminal' element),</item>
<item>in ix:pred() with nullable nonterminal from rule,</item>
<item>in ix:comp() with constructed nonterminal element created
for the call.</item>
</list>
So for nonterminals, we need to compare the @name attributes.
</p>
<p>For terminals, the likelihood is that $sym is the element we just
tested the input against, so we will use deep equality as a test.
</p>
<p>Note that this means that in a rule like 
<eg>a: 'b', 'c'; 'b', 'd'.</eg>
we will not be advancing both paths on a 'b'.  The caller will
(or: must) call this once for each prediction, so with two different
'terminal' elements.  Since we may be dealing with a copy of the
terminal element, not the original, we must avoid reliance on
element identity.
</p>
<p>Note that this will not be called with a state of 'q0'; it's always
called with a state name corresponding to a symbol.  (We are,
as it were, always checking from the end of the arc, not the start.)</p>
<p>
To do: adjust to 2019 syntax, which no longer has a single 'terminal' 
element type but has 'quoted', 'inclusion', and 'exclusion'.
<scrap id="eri-sym-fSymbolmatchRRiSym"
       name="Define fSymbolmatchRRiSym()">
(: ......................................................
   fSymbolmatch R Ri Sym($r, $ri, $sym): does symbol 
   element $sym match rule index $ri in rule $r?  
   
   :)
declare function ixi:fSymbolmatchRRiSym(
  $r as element(rule),
  $ri as xs:string,
  $sym as element() (: nonterminal or terminal :)
) as xs:boolean {  
  if ($sym/@xml:id = $ri)
  then true()
  else let $state := $r/descendant::*[@xml:id = $ri]
       return if (local-name($sym) ne local-name($state))
           (: we have a terminal trying to match a nonterminal,
              or vice versa, or different kinds of terminal;
              return false :)
         then false()
         
         else if (ixi:fTerminal($sym))
           (: we have terminals; they match if their children 
              are deep-equal.  NB we are relying on the fact
              that we have just extracted the terminal element
              from the rule we are working on, so it really
              ought to be deep-equal to itself.
              :)
         then deep-equal($state, $sym)
         (: was: 
         then deep-equal($state/*, $sym/*) 
         but when the terminal element is empty, that doesn't work.
         :)
         
         else if (ixi:fNonterminal($sym))
           (: we have non-terminals, they match on name :)
         then ($sym/@name eq $state/@name) 
         
         else (: something wrong :) false()
};
</scrap>
</p>
</div>
</div>

<div id="ll-input">
<head>Dealing with the input</head>

<p>There are no useful constructors for the input.
<scrap id="eri-input"
       name="Input (constructors, extractors, etc.)">

(: ****************************************************** 
   * Input
   ****************************************************** :)
(: For now, the input is always a string. :)

(: ******************************************************
   * Input: constructors
   :)
</scrap>
</p>
<p>And not much by way of extractors.
<scrap id="eri-input-ext"
       prev="eri-input"
       name="Extractors for input">

(: ******************************************************
   * Input: extractors
   :)
(: ......................................................
   inputlength(): how long is the input?
   
   Used (once) for construction of an Earley item 
   signaling completion
   :)
declare function ixi:inputlength(
  $I as xs:string
) as xs:integer {
  string-length($I)
};
</scrap>
</p>

<p>On the other hand, knowing whether the input at a
particular position matches a given terminal symbol is
central to parsing.  For this task, we have two versions
of the function.  The original just returned a Boolean
value, and matched either a literal string or matched a
single character against a character-set expression.


<scrap id="eri-input-pred"
       prev="eri-input"
       name="Predicates for input: fMatchesIPT()">

(: ******************************************************
   * Input: predicates
   :)

(: ......................................................
   fMatches I P T($I, $P, $T): does input $I match 
   terminal $T at position $P?

   The terminals are elements in a rule's right-hand side (not
   strings).  Possible forms:
   In 2016 syntax:  terminal[quoted/@dstring], 
     terminal[quoted/@sstring],
     terminal[quoted/text()], charset, exclude.
   In 2019 syntax:  literal[@dstring], literal[@sstring],
     literal[@hex], inclusion, exclusion.
   In 2022 syntax:  literal[@string], literal[@hex], 
     inclusion, exclusion.
   
   Note that position is 0-based, not 1-based, so we add 1 to it
   for XQuery substring calls.
   :)
declare function ixi:fMatchesIPT( 
  $I as xs:string, 
  $p as xs:integer,
  $t as element()
) as xs:boolean {
  if ($t/self::literal) then
     if (1 eq 0) then (: tracing code :)
     let $sProbe := ixi:string-value($t),
         $cPrLen := string-length($sProbe),
         $sInseg := substring($I,$p+1,$cPrLen),
         $fYesno := ($sProbe eq $sInseg)
     return $fYesno
     else (: normal code :)
     let $sProbe := ixi:string-value($t),
         $cPrLen := string-length($sProbe),
         $sInseg := substring($I,$p+1,$cPrLen),
         $fYesno := ($sProbe eq $sInseg)
     return $fYesno
  else if ($t/self::inclusion or $t/self::exclusion) then
     let $sProbe := ixi:notrace(ixi:reXTerminal($t), 
                              'regex for char set:'), 
         $sInseg := ixi:notrace(substring($I,$p+1,1), 
                              'substring (1 char):'),
         $fYesno := ixi:notrace(matches($sInseg,'^'||$sProbe||'$'),
	                      'matches?')
     return $fYesno
  else (: error :) false()
  (: :)
  (: 
  $cMatchlength := if ($t/self::literal)
  let $s := substring($I,$p + 1), 
            (: Earley is 0-based, XPath 1-based :)
      $f := if ($t/self::literal) 
            then starts-with($s,ixi:string-value($t/quoted))
            else if ($t/self::inclusion or $t/self::exclusion)
            then let $re := ixi:reXTerminal($t)
                 return matches($s,$re)
            else (: error :) false(),
       $trace := ixi:notrace($f,
       concat(
         '&amp;#xA;### fMatchesIPT: &amp;#xA;',
         '  Input = ', $I, '&amp;#xA;',
         '  p =', $p, '&amp;#xA;',
         '  quoted = ', if ($t/self::literal) 
                      then ixi:string-value($t) 
                      else '(SEE RE)', '&amp;#xA;',
         '  re = ', if ($t/self::inclusion or $t/self::exclusion)
           then ixi:reXTermin
al($t)
           else '(SEE LITERAL)',
         '&amp;#xA;Result: '
       )
       )
  return $f
  :)
};
</scrap></p>

<p>It will however simplify the construction of the parse tree if
the Earley set contains an item recording that this particular
terminal symbol matched a particular substring of the input.  That
will also simplify the <ident>match-length()</ident> functions, or
more likely render them unnecessary.  So in version
<ident>pfg</ident>, we return a match length, not a Boolean, and
rename the function accordingly.  We use -1, not 0, as the failure
signal, in case we ever end up using this for arbitrary regular
expressions which might succeed and match zero characters.

<scrap corresp="eri-input-pred" id="eri-inpred-pfg"
       version="pfg"
       name="Predicates for input: cMatchIPT()">

(: ******************************************************
   * Input: predicates
   :)

(: ......................................................
   cMatches I P T($I, $P, $T): does input $I match 
   terminal $T at position $P?  For how many characters?
   
   Note that position is 0-based, not 1-based, so we add 1 to it
   for XQuery substring calls.
   :)
declare function ixi:cMatchesIPT( 
  $I as xs:string, 
  $p as xs:integer,
  $t as element()
) as xs:integer {
  if ($t/self::literal) then
     let $sProbe := ixi:string-value($t),
         $cPrLen := string-length($sProbe),
         $sInseg := substring($I,$p+1,$cPrLen),
         $fYesno := ($sProbe eq $sInseg)
     return if ($fYesno) 
            then $cPrLen 
            else -1
  else if ($t/self::inclusion or $t/self::exclusion) then
     let $sProbe := ixi:notrace(ixi:reXTerminal($t), 
                              'regex for char set:'), 
         $sInseg := ixi:notrace(substring($I,$p+1,1), 
                              'substring (1 char):'),
         $fYesno := ixi:notrace(matches($sInseg,'^'||$sProbe||'$'),
	                      'matches?')
     return if ($fYesno)
            then 1
            else -1
  else (: error :) -1
};
</scrap>
</p>

<p>

<scrap id="eri-input-pred-matchlength"
       prev="eri-input-pred"
       name="match-length(I,p,t)">

(: ......................................................
   match-length($I,$p,$t): return length of the match in
   input $I at position $p of terminal $t.

   In practice, this is called only when we know there
   is a match, but because of the name, and the
   theoretical possibility of input-dependent answers
   (if we were to allow repetition operators inside
   terminals), we also support cases where there is no
   match and the answer is 0.

   If we later allow repetition operators inside
   terminals, this will become more complex, but for
   now, the value is always 1 if there is a match at all
   for charset and exclude non-terminals, and
   string-length of the literal for quoted strings.

   To do: adjust for 2019 syntax.
 :)
declare function ixi:match-length(
  $I as xs:string,
  $p as xs:integer,
  $t as element()
) as xs:integer {
  if (not(ixi:fMatchesIPT($I, $p, $t))) then 0
  else if ($t/self::literal) then ixi:string-length($t)
  else 1
};

(: See also match-length#1 above under Symbols. :)
</scrap>
</p></div>

<div id="ll-utils">
<head>Utilities and miscellaneous</head>

<p>
<scrap id="eri-utils-and-misc"
       name="Utilities for recognizer internals module">
(: ****************************************************** 
   * Utilities
   ****************************************************** :)
(: Things with no other obvious home. :)

(: ******************************************************
   * Utilities: string to regex conversion, 
   * string-length, string-value, ...
   :)
</scrap>
</p>
<div id="ll-utils-strings">
<head>Routines for strings and characters</head>
<p>The function <ident>sceXS()</ident>
<scrap prev="eri-utils-and-misc"
       name="Define sceXS() to read range ends">
(: ......................................................
   sce X S($s) : given a string or hex
   expression $s (e.g. from a character terminal), check
   to see if it's a hex expression (in which case expand
   and recur) or a magic character (in which case escape
   it) or is best represented for purposes of regex
   mapping) with a single-character escape (in which
   case escape it).
   
   N.B. this is more than strictly necessary for
   character class escapes, but it seems better to be
   more general.
   
:)
declare function ixi:sceXS(
  $s as xs:string
) as xs:string {
  (: reEscapists:  regex matching characters 
     which must or may be escaped. :)  
  if (matches($s,'^#[0-9a-fA-F]+$'))
  then ixi:sceXS(ixi:charXhex(
    $s
    (: ixi:notrace($s,'sceXS calling charXhex on ' || $s)) :)
  ))
  else if (string-length($s) gt 1)
  then ixi:escapedstringXS($s) 
  else if (not(contains("&amp;#xA;&amp;#xD;&amp;#x9;\|.-^?$*+{}()[]",$s))) 
  then $s
  else if (contains("\|.-^?$*+{}()[]",$s)) 
  then concat("\" (:":), $s)   (: commented dq helps emacs :) 
  else if ($s eq '&amp;#xA;')
  then "\n"
  else if ($s eq '&amp;#xD;')
  then "\r"
  else if ($s eq '&amp;#x9;')
  then "\t"
  else $s

};

declare function ixi:escapedstringXS(
  $s as xs:string
) as xs:string {
  let $reEscapists := concat('[',
                      '&amp;#xA;&amp;#xD;&amp;#x9;', 
                      '\\\|\.\-\^\?\$\*\+',
		      '\{\}\(\)\[\]',
                      ']') 
  return if (matches($s, $reEscapists))
  then string-join(
    for $i in 1 to string-length($s)
    return ixi:sceXS(substring($s, $i, 1)),
    '')
  else $s
};

</scrap>
</p>
<p>
<scrap prev="eri-utils-and-misc"
       name="Define catescXS() to build category escape">
(: ......................................................
   catesc X S($s): given a one- or two-character string
   from a class element, return the appropriate category
   escape in XSD/XPath notation.

   I should do some sanity checking here, but at the
   moment I'm impatient, so I just wrap it in braces
   with \p in front.

   The 2019 spec says "it is an error if there is no
   such class", so probably I should raise an error if
   the category given does not match the list.  But for
   now, I'll just ignore it and return '.'  to match one
   character, on the theory of "carry on irregardless."

   To do:  figure out how Aparecium should handle errors.
:)
declare function ixi:catescXS(
  $s as xs:string
) as xs:string {
  if (matches($s,'^(L[ulmo]?'
     || '|M[nce]?'
     || '|N[dlo]?'
     || '|P[cdseifo]?'
     || '|Z[slp]?'
     || '|S[mcko]?'
     || '|C[cfon]?)$'))
  then '\p{' || $s || '}'
  else '.'
  (: Letters: u[pper] l[ower] t[itlecase] m[odifier] o[other]
     Marks: n[onspacing], [spacing ]c[ombining], e[nclosing]
     Numbers: d[ecimal digit] l[etter] o[ther]
     Punctuation: c[onnector] d[ash] s [= open]
         e [= close] i[nitial quote] f[inal quote] o[ther]
     Z separators: s[pace] l[ine] p[aragraph]
     Symbols: m[ath] c[urrency] k[=modifier] o[ther]
     C other: c[ontrol] f[ormat] o[=private  use] n[ot assigned]
  :)
};
</scrap>
</p>
<p>
<scrap prev="eri-utils-and-misc"
       name="Define charXhex() to get character given hex expression">
(: ......................................................
   char X hex ($s): accept a hex expression, return the
   character.
:)
declare function ixi:charXhex(
  $s0 as xs:string
) as xs:string {
  (: let $tracing := ixi:notrace($s0,
     'charXhex called with |' || $s0 || '|') :)
  let $s := if (starts-with($s0,'#'))
            then substring($s0,2)
            else $s0
  return if (not(matches($s, '^[0-9a-fA-F]+$')))
         then '---error in charXhex---'
         else codepoints-to-string(d2x:x2d($s))
};
</scrap>
</p>
<p>
<scrap prev="eri-utils-and-misc"
       name="Define string-length()">
(: ......................................................
   string-length:  calculate 'real' length of string.

   We use this to hide possible variation in the form of
   'quoted' strings.  (Q. Does that mean we are
   expecting quote doubling to show up in the XML form
   of the literal?  It shouldn't.)

   To do: sanity check this, and delete if unnecessary.
   :)
declare function ixi:string-length(
  $q as element(literal)
) as xs:integer {
  string-length(ixi:string-value($q))
};
</scrap>
</p>
<p>
<scrap prev="eri-utils-and-misc"
       name="Define string-value()">
(: ......................................................
   string-value:  calculate 'real' value of string.

   We use this to hide possible variation in the form of
   quoted strings.  (Q. Does that mean we are expecting
   quote doubling to show up in the XML form of the
   literal?  It shouldn't.)

   To do:  sanity check this, and delete if unnecessary.
   :)
declare function ixi:string-value(
  $q as element(literal)
) as xs:string {
  let $s := if ($q/@string)
            then string($q/@string)
            else if ($q/@dstring)
            then replace($q/@dstring,'""','"') (:":)
            else if ($q/@sstring) 
            then replace($q/@sstring,"''", "'") 
            else if ($q/@hex) 
            then ixi:charXhex($q/@hex)
            else string($q)
  return if (matches($s,'^#[0-9a-fA-F]+$'))
         then ixi:charXhex(
               ixi:notrace($s,'string-value calls cXh on ' || $s) 
             )
         else $s
};
</scrap>
</p>
</div>
<div id="ll-utils-tracing">
<head>Trace routines</head>
<p>For debugging, it's helpful to make traces a little easier.</p>
<p>First, a function to display an Earley item as a string.
<scrap prev="eri-utils-and-misc"
       name="Define s X ei() to build string form of Earley item">
(: ......................................................
   s X ei($E): a utility function to help make traces
   more legible.
   :)
declare function ixi:sXei(
  $E as map(xs:string, item())
) as xs:string {
  'item('
  || $E('from') || ' ' 
  || $E('to') || ' '
  || $E('rule')/@name || '/' || $E('ri')
  || ')'
};
</scrap>
</p>
<p>Next, a function to build an XML element representing an Earley
item.  This is used less in tracing than in returning verbose results.
<scrap prev="eri-utils-and-misc"
       name="Define eXei() to build 'item' element for Earley item">
(: ......................................................
   e X ei($E):  a utility function to help make traces 
   and dumps more legible.
   :)
declare function ixi:eXei(
  $E as map(xs:string, item())
) as element(item) {
  element item {
    attribute from { $E('from') },
    attribute to { $E('to') },
    attribute rulemark { 
        $E('rule')/(@mark, @tmark)[1] 
    },
    attribute rulename { 
        $E('rule')/(@name, @xml:id)[1] 
    },
    attribute ri { $E('ri') }
    }
};
</scrap>
</p>
<p>The actual trace function has two forms:  one for when
we want debugging and tracing turned on, and one for when
we want to turn it off globally.  There probably should be
better ways of turning tracing on and off. 
<scrap prev="eri-utils-and-misc"
       name="Define trace() function for debugging">
<ptr target="eri-trace-function"/>
<ptr target="eri-notrace-function"/>
</scrap></p>
<p>The <ident>ixi:trace()</ident> function is just a wrapper around
the built-in trace function which inserts newlines. 
<scrap id="eri-trace-function"
       name="Define trace() function">
(: ......................................................
   trace($i, $s):  a utility function to help make code 
   being traced stay more legible.
   :)
declare function ixi:trace(
  $x as item()?,
  $s as xs:string
) as item()? {
  trace($x, '&amp;#xA;' || $s || '&amp;#xA;')
};
</scrap>
An alternative form also inserts asterisks, but in general that proves
a little too busy.
<scrap name="Starry trace() function">
declare function ixi:trace(
  $x as item()?, 
  $s as xs:string
) as item()? {
  trace(($x,'')[1], 
    '&amp;#xA;&amp;#xA;********&amp;#xA;' || $s || '&amp;#xA;')
};
</scrap>
</p>
<p>It will be easier to turn tracing on and off at particular
locations if we also define a <ident>notrace()</ident> function, which
discards the string and returns the first argument. The dummy form
just throws away the string and returns the item in the first
argument.
<scrap id="eri-notrace-function"
       name="Define notrace() function for debugging">
(: ......................................................
   notrace($i, $s):  a utility function to help make 
   code being traced stay more legible.
   :)
declare function ixi:notrace(
  $x as item()?,
  $s as xs:string
) as item()? {
  $x 
}; 
</scrap>
</p>
<p>The dummy form of <ident>trace()</ident> does the same thing
as <ident>notrace()</ident>
<scrap id="eri-trace-dummy"
       name="Define trace() function for debugging">
(: ......................................................
   trace($i, $s):  a utility function to help make code 
   being traced stay more legible.
   :)
declare function ixi:trace(
  $x as item()?,
  $s as xs:string
) as item()? {
  $x 
}; 
</scrap>
</p>
<p>We also want these available in other modules, like the
Gluschkov module.
<scrap id="gl-trace"
       name="Define trace() function for debugging">
(: ......................................................
   trace($i, $s):  a utility function to help make code 
   being traced stay more legible.
   :)
declare function gl:trace(
  $x as item()?,
  $s as xs:string
) as item() {
  trace($x, '&amp;#xA;' || $s || '&amp;#xA;')  
};  
declare function gl:notrace(
  $x as item()?,
  $s as xs:string
) as item()? {
  $x 
}; 
(:
declare function gl:trace($x as item()?, $s as xs:string) as item() {
  $x 
};
:)
</scrap>
</p>

</div>
</div>
</div>

<div id="alt-calls">
<head>Alternative interfaces</head>
<p>The file Aparecium.xqm offers several different calls
intended for users of the library.  They are defined here.</p>

<div id="alt-calls-secondary">
<head>Secondary user-facing calls</head>

<p>There are a number of high-level functions for parsing and
compiling grammars; they are used by the primary interfaces and they
may be useful for users in particular circumstances; they are
defined here.
<scrap id="aparecium-secondary"
       name="Secondary interfaces (a bit specialized)">
(: ******************************************************
   * Secondary interfaces (a bit more specialized) 
   ******************************************************
   :)
<ptr target="ap2-pgfu"/>
<ptr target="ap2-pgfs"/>
<ptr target="ap2-cgfu"/>
<ptr target="ap2-cgfs"/>
<ptr target="ap2-cgfx"/>
</scrap>
</p>
<p>The <ident>parse-grammar-from-uri()</ident> function
is given the URI of an ixml grammar and returns the XML 
representation of the grammar.  It   
retrieves the grammar and parses it by calling
<ident>parse-grammar-from-string()</ident>.
<scrap id="ap2-pgfu"
       name="Define parse-grammar-from-uri()">

(: ......................................................
   parse-grammar-from-uri($ixmlGrammar)
   ......................................................
:)
declare function aparecium:parse-grammar-from-uri(
  $uriG as xs:string
) as element() {
  let $sG := if (unparsed-text-available($uriG))
             then unparsed-text($uriG)
             else ()
  return if (exists($sG)) 
         then aparecium:parse-grammar-from-string($sG)
         else element aparecium:error {
           attribute id { "ap:tbd14" },
           "Grammar (" || $uriG || ") not found."
         }
};
</scrap>
</p>

<p>The <ident>parse-grammar-from-string()</ident> function is given
an ixml grammar as a string and returns the XML representation of
the grammar.  It parses the input grammar by calling
<ident>parse-string-with-compiled-grammar()</ident> with the ixml
grammar for ixml grammars.
<scrap id="ap2-pgfs"
       name="Define parse-grammar-from-string()">

(: ......................................................
   parse-grammar-from-string($ixmlGrammar)
   ......................................................
:)

declare function aparecium:parse-grammar-from-string(
  $G as xs:string
) as element() {
  (: CGIG:  compiled grammar for ixml grammars :)
  let $CGIG := doc($aparecium:ixml.gl.xml)/ixml,
      (: PG: parsed grammar :)
      $PG0 := aparecium:parse-string-with-compiled-grammar($G,$CGIG),
      $PG := &STAT;prof:time( &TATS;
             aparecium:grammar-ok($PG0)
             &STAT;, 'pgfs() calling grammar-ok():') &TATS;
  return $PG
};
</scrap>
The call to <ident>grammar-ok()</ident> replaces
some earlier rudimentary checking, retained here
for the moment in case it's needed.
<scrap name="Old code for result">
if ($PG/self::forest) 
      then trace($PG/ixml,
                 'Warning:  submitted grammar was ambiguous.') 
      else if ($PG/self::Goal) 
      then $PG/ixml 
      else if ($PG/self::ixml) 
      then $PG
      else &lt;ixml>
        &lt;!--* Something is very wrong here *-->
        { $PG }
      &lt;/ixml>
</scrap>
</p>
<p>The <ident>compile-grammar-from-uri()</ident> function
is given the URI of an ixml grammar and returns the
<soCalled>compiled</soCalled> form of the grammar.
<scrap id="ap2-cgfu"
       name="Define compile-grammar-from-uri()">

(: ......................................................
   compile-grammar-from-uri($ixmlGrammar)
   ......................................................
:)  

declare function aparecium:compile-grammar-from-uri(
  $uriG as xs:string
) as element() {
  let $xmlG := aparecium:parse-grammar-from-uri($uriG)
  return gluschkov:ME($xmlG)
};
</scrap>
</p>
<p>The <ident>compile-grammar-from-string()</ident>
function takes an ixml grammar in string form and
returns the compiled representation of the grammar.  
<scrap id="ap2-cgfs"
       name="Define compile-grammar-from-string()">

(: ......................................................
   compile-grammar-from-string($ixmlGrammar)
   ......................................................
:)  
 
declare function aparecium:compile-grammar-from-string(
  $sG as xs:string
) as element() {
  let $xmlG := aparecium:parse-grammar-from-string($sG)
  return gluschkov:ME($xmlG)
};
</scrap>
</p>

<p>The <ident>compile-grammar-from-xml()</ident> function takes an
ixml grammar in XML form (a <soCalled>vxml grammar</soCalled>) and
returns its compiled representation.
<scrap id="ap2-cgfx"
       name="Define compile-grammar-from-xml()">

(: ......................................................
   compile-grammar-from-xml($ixmlGrammar)
   ......................................................
   Given the XML representation of an ixml grammar,
   returns an annotated representation of the grammar
   that makes it usable by the Earley parser.
:)   

declare function aparecium:compile-grammar-from-xml(
  $xmlG as element()
) as element(ixml) {
  let $G := &STAT;prof:time( &TATS;
            aparecium:grammar-ok($xmlG)
            &STAT;, 'cgfx() calling grammar-ok():') &TATS;
  return if ($G/self::ixml)
         then gluschkov:ME($xmlG)
         else element aparecium:error {
           attribute id { "ap:tbd15" },
           "compile-grammar-from-xml(): ",
           "Unable to compile grammar: ",
	   "grammar not ok."
         }
};

</scrap>
</p>
</div>
<div id="alt-calls-other">
<head>Non-user-facing functions</head>
<p>Some things are in the Aparecium module because
they have to be, even though they are of no interest
to library users.</p>
<p>
<scrap id="aparecium-tertiary"
       name="Tertiary interfaces (of interest only for maintainer)">

(: ******************************************************
   * Tertiary interfaces (of interest only for maintainer) 
   ******************************************************
   :)

(: This is bootstrapping code (for building the Gluschkov
   automaton of the ixml grammar for ixml grammars.  It 
   should be run once whenever the grammar changes -- that 
   is, almost never.  But for now, it's here. 
   :)
  
(: Note that these don't save the result to disk; that's
   not automated yet.
   :)

   (: reparse-ixml-grammar(): produce fresh XML version :)
   
   (: The path starting from Goal on all these is a 
      temporary hack. :)
   
declare function aparecium:reparse-ixml-grammar(
) as element(ixml) {
  aparecium:parse-grammar-from-uri(
      $aparecium:ixml.ixml
  )/Goal/ixml
};
 
(: recompile-ixml-grammar(): produce fresh annotated XML
:)
declare function aparecium:recompile-ixml-grammar(
) as element(ixml) {
  aparecium:compile-grammar-from-uri(
      $aparecium:ixml.ixml
  )/Goal/ixml
};

<ptr target="ap-grok"/>
</scrap>
</p>
<p>Where are these things we may need? They really should be in a
collection, but collections are more complicated.  Maybe later.  So we
use global variables (sigh).
</p>
<p>It is embarrassing to move things around by changing these
strings, but ... that's what currently happens.
First, what directory are these things in?
<scrap prev="aparecium-variables"
       name="Location of library">
declare variable $aparecium:libloc as xs:string
  := '../lib';
</scrap>
(Earlier values include 'http://blackmesatech.com/2018/demos/lib'
and 'http://localhost/~cmsmcq/blackmesatech.com/2019/demos/lib'.
The call <code>Q{org.basex.util.Prop}HOMEDIR()</code> is
helpful in BaseX.)
</p>
<p>Where is the master (local) copy of the ixml grammar 
for ixml grammars?  We have three forms:  the ixml grammar,
the <soCalled>visible XML</soCalled> representation of
the grammar, and the <soCalled>compiled</soCalled>
representation, with annotations describing each RHS as
an FSA.
<scrap prev="aparecium-variables"
       name="Location of ixml grammar">
declare variable $aparecium:ixml.ixml as xs:string
  := $aparecium:libloc || '/ixml.2022-01-25.ixml';

declare variable $aparecium:ixml.xml as xs:string
  := $aparecium:libloc || '/ixml.2022-01-25.ixml.xml';
  
declare variable $aparecium:ixml.gl.xml as xs:string
  := $aparecium:libloc || '/ixml.2022-01-25.ixml.compiled.xml';  
</scrap>
</p>
<p>Maintenance note: to move to a new version of the ixml grammar, the
following steps should suffice:
<list type="ordered">
  <item>Place the new ixml.ixml and ixml.xml into the library
  directory (embedding the date into the file name to reduce confusion
  later).</item>
  <item>Update the scrap above to show the new filenames.</item>
  <item>Compile the new grammar to the ...compiled.xml file.</item>
  <item>Run regression tests.</item>
  <item>Make comparison copy of compiled grammar; recompile; compare.
  Since the first compilation used the old grammar, and the second
  used the new grammar, the first and second compiled versions may
  differ; the second and third should not.</item>
</list>
</p>
</div>
</div>

<div id="quarry">
<head>Unsorted bits of legacy code</head>	
<p>The first version of this document is being made
by taking the existing code and embedding it in
this document.  This section and its subsections
contain portions of the code that have not yet
been broken out into pieces.</p>


<div id="legacy-Earley-parser.xqm">
<head>Earley parser</head>
<p>The file Earley-parser.xqm has the top-level
function definitions for the parser.  These
functions call the recognizer and construct
a parse tree to return.</p>
<p>General remarks:
</p>
<p>We have a few problems, for which we might as well sketch our
solutions.
<list>
<item><p>Some sentences are infinitely ambiguous; they have loops in their
derivation tree:  A is parent of sole child B is parent of sole child
A.</p>
<p>Solution;  cut out those loops, return only loopless trees.</p>
<p>Mechanism:  keep track of the set of ancestors in progress, don't
accept another node for the same nonterminal with the same frontier.</p>
<p>Alternative solution:  fix maximum height of a tree for a given frontier,
e.g. at 1 + number of non-terminals.  (Not an overall limit, just
a limit for a subtree with a fixed frontier.)</p>
</item>
<item><p>Some sentences are infinitely ambiguous: there may be zero or more
adjacent instances of nodes generating the empty string, e.g. in 
the RHS X*, Y, Z*.  (This is an EBNF-specific problem, not possible
for BNF.)</p>
<p>Solution:  cut out loops, return only loopless paths through a RHS.</p>
<p>Mechanism:  keep track of the states you have visited, don't accept
another node for the same state (RHS position, *not* nonterminal)
and the same frontier.</p>
<p>Alternative solution:  fix maximum width for sequence of zero-width
sibling nodes, e.t. at twice the number of positions in the RHS. </p>
</item>
<item><p>The user may want all trees, or one arbitrarily chosen tree, or one
tree with the option to fetch more.</p>
</item>
</list>
</p>
<p><hi>Delete or revise this:  it's out of date.</hi>
We will offer four functions (names subject to change):
<list>
<item><p>ep:all-trees($I,$G) will return all loopless parse
trees</p></item>
<item><p>ep:any-tree($I, $G) will return the first tree it finds and
stop</p></item>
<item><p>ep:tree-cursor($I, $G) will return two items: the first tree
it finds and a function to call for the next tree (and the next
function); this involves wrapping up continuations and passing them
around.  (It may be helpful to do a five-finger exercise fetching the
items of a sequence one at a time.)</p></item>
<item><p>ep:parse-forest-grammar($I, $G) will return a parse-forest grammar for
the trees.  It can and should include the looped parse trees.  It may
have clean/dirty variants that do or don't bother to clean the grammar
up (tbd; dunno yet).</p></item>
</list>
</p>
<p>These are all intended to be user-facing; there will be
corresponding functions internal to the module not intended to be
called by the user.
<scrap file="Earley-parser.xqm">

(: Goal:  to return the set of parse trees recorded implicitly in the
   Earley closure.
   :)
<ptr target="ep-alltrees"/>
<ptr target="ep-anytree"/>
<ptr target="ep-tree-cursor"/>
<ptr target="ep-parse-forest-map"/>
<ptr target="ep-parse-forest-grammar"/>
</scrap>
</p>
<p>The <ident>alltrees()</ident> function calls
the internal <ident>earley-parse()</ident> function
and passes options to it to signal what should be done
with the Earley set.
<scrap id="ep-alltrees"
       name="Declare ep:all-trees() function">
(: ep:all-trees($I,$G):  return all loopless parse trees :)
declare function ep:all-trees(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as element()+ {

  epi:earley-parse($I, $G, 
      map { 'return': 'all-trees',
            'tree-count': -1,
            'failure-dump': 'closure'
      }
  )
  
};

</scrap></p>

<p>The <ident>anytree()</ident> function similarly
calls <ident>earley-parse()</ident> with a different
option.
<scrap id="ep-anytree"
       name="Declare ep:any-tree() function">
(: ep:any-tree($I,$G):  return one (loopless) parse tree, 
   whichever is found first 
:)
declare function ep:any-tree(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as element()? {
  epi:earley-parse($I, $G, 
      map { 'return': 'any-tree',
            'tree-count': 1,
            'ambiguity-test': true(),
            'failure-dump': 'closure',
            'tree-constructor': 'pfg'
      }
  )
};
</scrap></p>

<p>The <ident>tree-cursor()</ident> function (not yet
implemented) is intended to return a pair consisting of
(1) a parse tree, and (2) a function that will return
another pair for the next parse tree.  When there are
no more trees, a <q><kw>no-more-trees</kw></q> signal
will be returned instead of a function.</p>
<p>The name is intended to recall the cursor notion of SQL
results.</p>
<p>If you keep track of the number of trees delivered, the
no-more-trees signal can distinguish there-were-no-trees
from all-done-now signals.
<scrap id="ep-tree-cursor"
       name="Declare ep:tree-cursor() function">

declare function ep:tree-cursor(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as item()* {
  epi:earley-parse($I, $G,  
      map { 'return': 'tree-cursor',
            'failure-dump': 'closure' }
  )
};
</scrap>
</p>
<p>The idea of the <ident>parse-forest-map()</ident>
function is to return not a parse tree but a parse forest,
in the form of a map.  It is currently not implemented,
and may be unnecessary.  The <ident>parse-forest grammar()</ident>
function may suffice.
<scrap id="ep-parse-forest-map"
       name="Declare ep:parse-forest-map() function">

(: ep:parse-forest-map($I,$G):  return a map containing an and/or tree
   representing the set of all parses.
:)
declare function ep:parse-forest-map(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as element()* {
  epi:earley-parse($I, $G, 
      map { 'return': 'parse-forest-map', 
            'tree-count': -1,
            'failure-dump': 'closure'
      }
  )
};
</scrap>
</p>
<p>The <ident>parse-forest-grammar()</ident> function
returns an ixml grammar describing a single sentence, from
which parse trees can be constructed.
<scrap id="ep-parse-forest-grammar"
       name="Declare ep:parse-forest-grammar() function">
(: ep:parse-forest-grammar($I,$G):  return a BNF (not EBNF[?]) grammar
   describing the set of all parses of $I against $G.
:)
declare function ep:parse-forest-grammar(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as element()* {
  epi:earley-parse($I, $G, 
      map { 'return': 'parse-forest-grammar',
            'tree-count': -1,
            'failure-dump': 'closure'
      }
  )
};
</scrap>
</p>
<p>Let us pause for a moment to summarize the options
these functions are assuming.  Options and their values
include:
<list>
<item><label><kw>return</kw></label>:  one of
<q><kw>all-trees</kw></q>,
<q><kw>any-tree</kw></q>,
<q><kw>tree-cursor</kw></q>,
<q><kw>parse-forest-map</kw></q>,
<q><kw>parse-forest-grammar</kw></q>.</item>

<item><label><kw>tree-count</kw></label>: an integer specifying a
maximum number of trees to (find and) return.  The magic number -1
is used to signal that all (or as many as possible) should be
returned.</item>

<item><label><kw>ambiguity-test</kw></label>: an boolean value used
when the <q><kw>tree-count</kw></q> option is 1, to indicate whether
a second tree should be searched for (though not returned), so as to
correctly detect amgiguity.</item>

<item><label><kw>failure-dump</kw></label>: one of
<q><kw>yes</kw></q>, <q><kw>no</kw></q>, <q><kw>closure</kw></q>.
Used in case of parse failures to indicate whether all data
structures should be dumped; <q><kw>closure</kw></q> indicates that
just the closure should be provided.</item>

</list>
</p>
</div>
<div id="legacy-Earley-parser-internals.xqm">
<head>Parser internals</head>
<p>The file Earley-parser-internals has low-level
function definitions for the parser,
which are intended to be subject to change
with minimal or no effect on the higher-level
functions.</p>
<div id="epi-earley-parse-function">
<head>The <ident>earley-parse()</ident> function</head>
<p>The function <ident>earley-parse()</ident> runs the Earley
recognizer on the input and returns results as specified
by the user.  
<scrap id="epi-earley-parse"
       name="Define earley-parse()">
(: ******************************************************
   earley-parse($I, $G, $f);  run Earley recognizer on 
   input $I and grammar $G, return results using 
   $f($leiClosure, $Ec, $I, $G)
:)
declare function epi:earley-parse(
  $I as xs:string,
  $G as element(ixml),
  $options as map(xs:string, item()*)?
) as item()* {
  let $dummy := eri:notrace((), 'epi:earley-parse() ...') 

  let $options := 
      if (empty($options))
      then map { 'return': 'any-tree',
                 'tree-count': 2,
                 'failure-dump': 'closure' }
      else $options

  let $mapResult := &STAT;prof:time( &TATS;
                    er:recognizeX($I, $G),
                    &STAT;'0a recognize(): '),&TATS;

      $meiClosure := $mapResult('Closure'),
      $leiCompletions := $mapResult('Completions')

  return 
  <ptr target="epi-ep-success"/>
  else <ptr target="epi-ep-failure"/>
        
};
</scrap>
An earlier version of <ident>earley-parse()</ident> that used
higher-level functions is reproduced in <ref target="obs-hlf" >an
appendix</ref>.  In order to support engines that do not implement
higher-level functions, the code has been revised so the standard
interfaces don't use higher-level functions.</p>

<p>In the case of parsing success, the <ident>mapResult</ident>
will have a <q><code>Result</code></q> value.  How we return
it depends on what option the user specified.
<scrap id="epi-ep-success"
       name="If we have a parse result, return it">
  if ($mapResult('Result'))
  then if ($options?return = 'all-trees')
       then <ptr target="epi-ep-all-trees"/>
       else if ($options?return = 'tree-cursor')
       then <ptr target="epi-ep-tree-cursor"/>
       else if ($options?return = 'parse-forest-map')
       then <ptr target="epi-ep-parse-forest-map"/>
       else if ($options?return = 'parse-forest-grammar')
       then <ptr target="epi-ep-parse-forest-grammar"/>
       else (: default to any-tree :)
            <ptr target="epi-ep-any-tree"/>
</scrap>
</p>
<p>But first, let's talk about the failure case.
As P.J. Brown points out, in real life the failure case
is much more common that the <soCalled>success</soCalled> case, so
the primary job of a program like Aparecium is to report errors and
help the user understand them; a secondary task is, occasionally, to
produce the prescribed results for error-free input.</p>
<p>At the moment, we just return a <gi>no-parse</gi> element, and if
the user asks for a verbose dump we provide it.
<scrap id="epi-ep-failure"
       name="Return parse-failure result">
 (: otherwise, send an apology and explanation :)
  let $closure := &lt;Closure>{
      let $mei := $mapResult('Closure')
      for $n in map:keys($mei('to'))
      order by $n descending
      for $ei in $mei('to')($n)
      return eri:eXei($ei)
  }&lt;/Closure>

  let $high-water := $closure/item[1]/@to/number()
  let $start := max((1, (1 + $high-water - 30))),
      $end := min((string-length($I),
                   ($high-water + 30))),
      $cL := min(($high-water, 30)),
      $cR := min(($end - $high-water, 30)),
      $sL := concat(if ($high-water gt 30)
                    then '...'
                    else '',
                    substring($I, $start, $cL)
             ),
      $sR := concat(substring($I, $high-water+1, 30 (: $cR :) ),
                    if ($cR lt 30)
                    then ''
                    else '...'
             )
  return     
  &lt;no-parse xmlns:ixml="http://invisiblexml.org/NS" ixml:state="failed">
    &lt;p>Sorry, no parse for this string and grammar.&lt;/p>
    &lt;p>The parser gave up at character {$high-water}:
        parsing succeeded up through &lt;q>{
          replace($sL,'&#xA;','&amp;amp;#xA;')
        }&lt;/q>
        but failed on &lt;q>{
          replace($sR, '&#xA;', '&amp;amp;#xA;')
        }&lt;/q>&lt;/p>
    &lt;p>Expecting one of: {
        string-join(
           for $ei in $mapResult('Closure')('to')($high-water)
           for $sym in eri:lsymExpectedXEi($ei)[eri:fTerminal(.)]
           return concat('"', eri:reXTerminal($sym), '"'),
           ', ')
        }&lt;/p>{
    if ($options?failure-dump eq 'no')
    then ()
    else if ($options?failure-dump eq 'closure')
    then $closure    
    else if ($options?failure-dump eq 'yes')
    then &lt;dump>
    &lt;p>The map is:&lt;/p>
   
    &lt;Initial-Item>{eri:eXei($mapResult('Initial-Item'))}&lt;/Initial-Item>
    &lt;Input>{$mapResult('Input')}&lt;/Input>
    &lt;Input-Length>{$mapResult('Input-Length')}&lt;/Input-Length>
    &lt;Completions>{
       for $ei in $mapResult('Completions')
       return eri:eXei($ei)
    }&lt;/Completions>
    &lt;Result>{$mapResult('Result')}&lt;/Result>
    &lt;Closure>{$closure}&lt;/Closure>
    &lt;grammar>{(: 'Omitted.' :) $mapResult('Grammar') }&lt;/grammar>
    &lt;/dump>
    else ()
  }&lt;/no-parse>
</scrap>
Further work is needed here, I think (but this is
better than it used to be).
</p>
<p>Now back to the success cases.
</p>
<p>If the user asks for <q><kw>all-trees</kw></q>,
we call <ident>epi:all-trees()</ident> to make a
list of (raw) parse trees, then turn them into
the required XML.
<scrap id="epi-ep-all-trees"
       name="Return (approximately) all trees">
        let $dummy := eri:notrace((), 
                      'epi:earley-parse() has result') 

        let $lpt := &STAT;prof:time(&TATS;
                    epi:all-trees($leiCompletions, $meiClosure, $I)
                    &STAT;, '0b making trees: ')&TATS;
        let $dummy := eri:notrace((), 
                      'epi:earley-parse() returning a result') 
        for $rpt at $npt in $lpt
        return if ($options?tree-form eq 'raw')
        then $rpt
        else if ($options?tree-form eq 'both')
        then ($rpt, epi:astXparsetree($rpt, count($lpt)))
        else epi:astXparsetree($rpt, count($lpt))
</scrap>
The current implementation of <ident>epi:all-trees()</ident> is
sometimes very slow.  An alternative method would be: construct a
parse-forest grammar, and from it construct the trees required.
Another alternative would be to rewrite the direct construction of
parse trees to be smarter and faster.</p>

<p>The <q><kw>any-tree</kw></q> option has not been implemented
separately. As a stop-gap we can call <ident>all-trees()</ident> and
throw all but the first away.  In pathological cases that will waste
a lot of cycles, but not in most normal cases.
Or we can call <ident>parse-forest-grammar()</ident> and
then extract an arbitrary tree from that.  We choose based
on the user's options, but default to the indirect approach,
which I expect to be faster.
<scrap id="epi-ep-any-tree"
       name="Return any tree">
        if ($options?tree-constructor eq 'direct')
        then <ptr target="epi-ep-any-direct"/>
        else <ptr target="epi-ep-any-via-pfg"/>
</scrap>
</p>
<p>The <soCalled>direct</soCalled> approach is not
really very direct: we call <ident>all-trees()</ident>
to construct all the trees, and then choose one.
<scrap id="epi-ep-any-direct"
       name="Construct one tree directly">

        let $lpt := &STAT;prof:time(&TATS;
                    epi:all-trees($leiCompletions, $meiClosure, $I)
                    &STAT;, '0b making trees: ')&TATS;
        let $dummy := eri:notrace((), 
                      'epi:earley-parse() returning a result') 
        for $rpt in $lpt[1]
        return if ($options?tree-form eq 'raw')
        then $rpt
        else if ($options?tree-form eq 'both')
        then ($rpt, epi:astXparsetree($rpt, count($lpt)))
        else epi:astXparsetree($rpt, count($lpt))
</scrap>
</p>
<p>The <soCalled>indirect</soCalled> approach via the parse-forest
grammar involves first a call to construct the grammar and then
a call to extract the tree.
<scrap id="epi-ep-any-via-pfg"
       name="Construct one tree via parse-forest-grammar">

        let $pfg := &STAT;prof:time(&TATS;
                    epi:parse-forest-grammar($leiCompletions, $meiClosure, $I),
                    &STAT;'0b making pfg: '),&TATS;
            $ast := &STAT;prof:time(&TATS;
                    epi:tree-from-pfg($pfg, 'document', ())
                    &STAT;, '0c extracting tree: ')&TATS;
		    
        let $dummy := eri:notrace((), 
                      'epi:earley-parse() returning a result') 

        return if (1 eq 0) (: debugging hack, delete sometime :)
        then element ap:wrap { 
                   element ap:ast { $ast }, 
                   element ap:pfg { $pfg }
        } 
        else $ast

</scrap>
</p>
<p>Parse-forest grammars require no post-processing.
<scrap id="epi-ep-parse-forest-grammar"
       name="Return a tree cursor">
        let $dummy := eri:notrace((), 
                      'epi:earley-parse() has result') 

        let $pfg := &STAT;prof:time(&TATS;
                    epi:parse-forest-grammar($leiCompletions, $meiClosure, $I)
                    &STAT;, '0b making pfg: ')&TATS;
        let $dummy := eri:notrace((), 
                      'epi:earley-parse() returning a parse-forest grammart') 
        return $pfg
</scrap>
</p>
<p>The tree cursor has not been implemented yet.
<scrap id="epi-ep-tree-cursor"
       name="Return a tree cursor">
  &lt;tree-cursor-not-available/>
</scrap>
</p>
<p>Parse-forest maps have not been implemented
yet.
<scrap id="epi-ep-parse-forest-map"
       name="Return a parse-forest map">
  &lt;parse-forest-map-not-available/>
</scrap>
</p>

</div>
<div id="epi-tree-returns">
<head>Functions to return one or more trees</head>

<div id="epi-trf-all-trees">
<head>The <ident>all-trees()</ident> function</head>
<p>If the user wants all trees, we call the <ident>all-trees()</ident>
function.</p>
<p>For each completion item in $Ec, we return all parse trees for the
nonterminal $n in $Ec's left-hand side, as documented by $Closure
(a set of Earley items closed over scan(), pred(), and comp().</p>
<p>The result will be one or more elements for nonterminal <code>$n</code>.</p>
<p>The main function generates an empty vertical stack (to prevent
looping on infinite sets of trees with unbounded vertical depth)
and calls an auxiliary function to do the work.
<scrap id="epi-all-trees"
       name="Define all-trees()">
(: ******************************************************
   all-trees($Closure, $Ec, $I, $G):  
:)
declare function epi:all-trees(
  $leiCompletions as map(*)*,
  $meiClosure as map(xs:string,
                     map(xs:integer,
                         map(xs:string, item())*)) 
                 (:MEI:),
  $I as xs:string
  (: $G as element(ixml) :)
) as element()* {
  (: Call auxiliary routine with a vertical stack for
     loop prevention. :)
  epi:all-trees($leiCompletions, $meiClosure, $I, ())
};
</scrap></p>
<p>The auxiliary function for generating all trees is initially called
for the item (0 $n Goal $q_final), but it's called again recursively,
once for every completion relevant to the tree(s) we are constructing.
<scrap prev="epi-all-trees"
       name="Define auxiliary function for all-trees()">
(: ******************************************************
   all-trees#5:  auxiliary function (more args, does the 
   work) 
:)
   
declare function epi:all-trees(
  $leiCompletions as map(*)*,
  $meiClosure as map(xs:string,
                     map(xs:integer,
                         map(xs:string, item())*)) (:MEI:),
  $I as xs:string,
  $leiVStack as map(*)*
  (: $G as element(ixml) :)
) as element()* {
  <ptr target="epi-all-trees-for"/>
  <ptr target="epi-all-trees-call-ans"/>
  <ptr target="epi-all-trees-return-trees"/>
}; 
</scrap>
</p>
<p>For every original completion item in <code>$leiCompletions</code>,
return parse trees for its nonterminal.
<scrap id="epi-all-trees-for"
       name="Iterate over the list of completion items">
  for $Ec at $nEc in $leiCompletions
             [not(
               some $eiV in $leiVStack
               satisfies deep-equal(.,$eiV)
             )]
  
  let $dummy := eri:notrace($Ec,
    'all-trees called with item '
    || $nEc || ' (of ' || count($leiCompletions)
    || ') = ' || eri:sXei($Ec) 
  )
</scrap></p>
<p>Here, <code>$Ec</code> is the completion item for
a nonterminal <code>$n</code>.
Its LHS tells us which nonterminal.
Its <ident>from</ident> and
<ident>to</ident> positions tell us the frontier
generated by <code>$n</code>.
</p>
<p>For each sequence <code>$ln</code> of adjacent nodes that
<list>
<item>span the range <ident>From</ident> .. <ident>To</ident>, and</item>
<item>constitute a path through the RHS of <code>$n</code>,</item>
</list>
return a raw parse-tree element for <code>$n</code> with content
<code>$ln</code>.
</p>
<p>
We want one parse tree for each possible sequence <code>$ln</code>,
but in order to iterate over them, we need to wrap them up in
something (since XDM sequences don't nest).  We will wrap them up in
elements (of type <gi>nt</gi>).  So in fact when we get the sequences
back, they will already be wrapped up in the element; all we need to
do is return them.
<scrap id="epi-all-trees-call-ans"
       name="Get the sequences, or rather raw parse trees">
  let $parsetrees := epi:all-node-sequences(
    $Ec,
    $meiClosure,
    (),
    $Ec('from'), 
    $Ec('to'), 
    $I,
    ($Ec, $leiVStack),
    ()
  )</scrap></p>
<p>Once we get the trees, we just return them.
<scrap id="epi-all-trees-return-trees"
       name="Return the raw parse trees">
  for $parsetree in $parsetrees
  let $dummy := eri:notrace($parsetree,
    'all-trees got this parsetree back from item Ec = ' || eri:sXei($Ec))
  return $parsetree 
</scrap></p>
</div>
<div id="epi-trf-anytree">
<head>The <ident>any-tree()</ident> function</head>
<p>If the user wants an arbitrary tree -- well, for now they are 
out of luck. 
<scrap id="epi-any-tree"
       name="Define any-tree()">
declare function epi:any-tree(
  $leiCompletions as map(*)*,
  $leiClosure as map(*)*,
  $I as xs:string
) as element()* {
  &lt;any-tree-not-implemented-yet/>
};
</scrap></p>
</div>
<div id="epi-trf-cursor">
<head>The <ident>tree-cursor()</ident> function</head>
<p>We want (eventually) to provide an interface for a kind of
<soCalled>tree cursor</soCalled>, which will allow the user to
iterate over the set of parse trees in the same way as a cursor
in SQL allows the application to read a sequence of results.
In XQuery, the basic idea is to return not a tree but a pair
consisting of (a) a tree and (b) a function to call to get
the next pair.  If there is a finite set of trees, then on
the last tree no function will be returned (or a special function
that raises a particular error when called?).</p>
<p>But for the moment, this is just a stub.
<scrap id="epi-tree-cursor"
       name="Define tree-cursor()">
declare function epi:tree-cursor(
  $leiCompletions as map(*)*,
  $leiClosure as map(*)*,
  $I as xs:string
) as element()* {
  &lt;tree-cursor-not-implemented-yet/>
};
</scrap></p>
</div>
<div id="epi-trf-pfm">
<head>The <ident>parse-forest-map()</ident> function</head>
<p>Also a stub are functions to return results in the form
of parse forests.  One is a function which when completed
should return a parse-forest map, that is a data structure
with a directed graph containing all parse trees as sub-graphs.
<scrap id="epi-parse-forest-map"
       name="Define parse-forest-map()">
declare function epi:parse-forest-map(
  $leiCompletions as map(*)*,
  $leiClosure as map(*)*,
  $I as xs:string
) as map(*) {
  map { 'Result' : &lt;parse-forest-map-not-implemented-yet/> }
};
</scrap></p>
</div>
</div>
<div id="epi-all-nodes">
<head>Finding a sequence of items for a single right-hand side</head>
<p>One crucial step in finding a tree in the Earley set is
to identify a sequence of items that describe a path through
the right-hand side of a given rule.</p>
<p>The inspiration for the approach used here
is Maarten van Emden's solution to the Eight Queens problem at 
<xref href="https://vanemden.wordpress.com/2008/04/27/programming-language-x/"
      >https://vanemden.wordpress.com/2008/04/27/programming-language-x/</xref>.
There is no code for stopping when you get a solution, no
overt backtracking,
just full speed ahead over all possibilities.</p>
<p>The result is a depth-first search which turns out in hindsight to
have some very unfortunate properties.  It's harder to understand than
I would like, and it has no form of memoization so given appropriate
input it may solve some subproblems many many times, with horrifying
effects on run time.</p>
<p>To perform this task, we define a function
<ident>epi:all-node-sequences</ident>(<code>$item</code>,
<code>$closure</code>, <code>$acc</code>, <code>$from</code>,
<code>$to</code>, <code>$I</code>), which iterates selectively (by
recursion) over elements in <code>$closure</code> to find items which
form a path through the RHS of a given rule in &G;.  The items have
the following properties.
<list>
<item>All items in the path-sequence have locations in the same rule
for some non-terminal <code>$n</code>, namely
<code>$item('rule')</code>.  (If they didn't have that rule, they
could not describe a path through its RHS.)</item>
<item>All items in the path-sequence have the same
<ident>from</ident>-position (= <code>$from</code>).  (If they did
not, they would not describe a single instance of the rule's
nonterminal.)</item>
<item>The first item has <ident>from</ident>-position =
<ident>to</ident>-position = <code>$from</code>; that is, it is the
item produced by the predictor for an instance of the
nonterminal.</item>
<item>The last item has <ident>from</ident>-position =
<code>$from</code> and <ident>to</ident>-position =
<code>$to</code>; that is, it's the completion item for
one instance of the nonterminal.</item>
<item>Each item in the path-sequence advances the path by one symbol;
that is, for any two adjacent items
<ident>EI</ident>[<ident>i</ident>]
with <ident>to</ident> = <ident>p1</ident> 
and
<ident>EI</ident>[<ident>i</ident>+1]
with <ident>to</ident> = <ident>p2</ident>, either
<list>
<item><ident>EI</ident>[<ident>i</ident>+1] will be the value of
<ident>scan</ident>(<ident>E</ident>[<ident>i</ident>],
<code>$I</code>) &mdash; in this case,
<code>$I</code>[<ident>p1</ident> .. <ident>p2</ident>] matches the
terminal <ident>EI</ident>[<ident>i</ident>+1]('ri') &mdash; or </item>
<item><ident>EI</ident>[<ident>i</ident>+1] will be the value of
<ident>comp</ident>(<ident>EIc</ident>,
<ident>EI</ident>[<ident>i</ident>]) for some <ident>EIc</ident> in
<code>$closure</code>.  In this case, <code>$closure</code> will
include some completion item <ident>EIc</ident> with
<ident>from</ident> = <ident>p1</ident>, <ident>to</ident> =
<ident>p2</ident>, <ident>nonterminal</ident> =
<ident>EI</ident>[<ident>i</ident>+1]('ri').</item>
</list>
</item>
</list>
</p>
<p>At each step (i.e. on each call to this function) we identify one
more item in the sequence.  There may be more than one (because there
may be multiple paths); if so, we iterate recursively on each of them
because we want all node sequences.
</p>
<p>The sequence we find is not represented explicitly, but implicitly
by the sequence of items passed as the current $item (in reverse
order, since we start with the completion).
</p>
<p>Along the way, we accumulate (in <code>$acc</code>) raw parse-tree
nodes corresponding to the path:
<list>
<item><p>For normal <ident>scan()</ident> steps,
<!-- text nodes with the
     appropriate substring of <code>$I</code> -->
we create <gi>lit</gi>, <gi>incl</gi>, or <gi>excl</gi> elements
recording the matching string, with the <att>tmark</att> of the
terminal symbol </p></item>
<!--
<item><p>for <ident>scan()</ident> steps marked <q><code>-</code></q>,
element nodes for element ix:tacet (NB once this works, these can be
omitted; for now we ignore that.)</p></item>
-->
<item><p>For <ident>comp()</ident> steps, we create <gi>nt</gi>
elements, with <att>name</att> and <att>mark</att> recording the
appropriate GI and annotation, and with content (found by a recursive
call) showing the raw parse tree for that nonterminal; if there is
more than one, we iterate over all of them.</p></item>
<!--
<item><p>for normal comp() steps, element nodes with the appropriate
GI and content (found by a recursive call to all-trees()); if there is
more than one, we iterate over all of them</p></item>
<item><p>for comp() steps whose nonterminal symbol is marked "@", the element 
node returned by all-trees() is converted to an attribute node before
the recursive call; </p>
<p>N.B. the marking may be either on our RHS position or present
as the ix:mark attribute on the element returned by all-trees</p>
</item>
<item><p>for comp() steps whose nonterminal symbol is marked "-", the
children of the element node(s) returned by all-trees() are placed in
the accumulator, not the element node.  Again, the mark can be either
on the RHS symbol or on the LHS of the defining rule.</p></item>
-->
</list>
</p>
<p>The function returns zero or more elements whose name is that on
the left-hand-side of <code>$item</code>, whose string value is the
input substring <code>$from</code> .. <code>$to</code>, and whose
children are the concatenation of (a) the children found by the
recursive call, with (b) those in the accumulator.
<scrap id="epi-all-node-sequences"
       name="Define all-node-sequences()">
(: ******************************************************
   epi:all-node-sequences($item, $closure, 
                          $acc, 
                          $from, $to, $I)
:)
declare function epi:all-node-sequences(
  $Ecur as map(*),
  $meiClosure as map(xs:string, 
                     map(xs:integer, 
                         map(xs:string, 
                             item())*)),
  $lnAcc as item()*,
  $pFrom as xs:integer,
  $pTo as xs:integer,
  $I as xs:string,
  $leiVStack as map(*)*,
  $leiHStack as map(*)*
) as element()* {
  
  let $dummy := eri:notrace(eri:sXei($Ecur),
    'all-node-seqs (0) called with Ecur:')
  return 
  <ptr target="epi-ans-loopcheck"/>
  <ptr target="epi-ans-basecase"/>
  <ptr target="epi-ans-recursive"/>  
};
</scrap>
</p>
<p>Before we do any work, we should check to see whether we have
already dealt with this item, in this sequence of nodes.  If we have,
then we are looking at a sentence with an infinite number of parse
trees, and we need to snip the loop.
<scrap id="epi-ans-loopcheck"
       name="Check for loops, which mean infinite ambiguity">
  (: 1. Before anything else, loop detection:  have we already 
     dealt with this item, in this sequence of nodes? :)
  if (some $eiH in $leiHStack satisfies deep-equal($Ecur, $eiH) )
  then let $dummy := eri:notrace(eri:sXei($Ecur),
           'all-node-seqs (case 1) returns empty sequence, '
           || 'current item has been seen before.')
       return ()
</scrap></p>
<p>The base case, on which we terminate because it means we have
completed the node sequence, is when the current Earley item is
initial.  The detection of this case is simplified by the fact that
all initial states are named q0, and only initial states are named q0.
So when we find such a state, we just wrap everything up and return it
to the caller.</p>
<p>N.B. we always return an element, regardless of how our
non-terminal is marked, but we pass the @mark attribute along
so the caller can convert the element to an attribute, or
replace it with its children, in a later pass which constructs
the AST from the raw parse tree.
<scrap id="epi-ans-basecase"
       name="Handle base case:  current item is initial">
  (: 2. Base case:  $Ecur is initial. :)
  else if ($Ecur('ri') = 'q0'
      and $Ecur('from') eq $Ecur('to')
      and $Ecur('from') eq $pFrom)
</scrap>
For a state named q0, from = to should always be true.
And for all q0, from = $pFrom should also always be true,
or should follow from the tests made by the caller. 
But we check anyway.  I don't trust this belt, and I don't trust 
these suspenders. </p>
<p>On the output element, we record the input span in
attributes named <att>_from</att> and <att>_to</att>,
and the mark.
<hi>And for the moment, as a debugging measure, we also
see whether we can successfully identify the RHS nonterminal
that led to the prediction of this nonterminal.  We already
have a little context information in the form of 
the vertical stack <code>$leiVStack</code>,
the horizontal stack <code>$leiHStack</code>,
and the node list <code>$lnAcc</code>.
Let's examine the tops of those stacks.</hi>
<scrap prev="epi-ans-basecase"
       name="Construct an element holding the node sequence">
  then 
    let $e := element nt {
                 $Ecur('rule')/@name,
                 attribute _from { $pFrom }, 
                 attribute _to { $pTo }, 
                 ( $Ecur('rule')/descendant::*
                                [@xml:id = $Ecur('ri')]
				/@mark
                   ,
                   $Ecur('rule')/@mark,
		   attribute mark { '^' }
                 )[1],
                 $lnAcc
               },
        $trace := eri:notrace(eri:sXei($Ecur),
                      'all-node-seqs (case 2) returns element ' 
		      || 'named ' || name($e) || ' for Ecur:')
    return $e
</scrap>
</p>
<p>For safekeeping, here is the earlier version of this.
It used the nonterminal name as the GI for the element,
and it tried to handle attributes first.  Both of those
should now be handled by the AST constructor.
<scrap prev="epi-ans-basecase-2016"
       name="Construct an element holding the node sequence">
  then 
    let $e := element {$Ecur('rule')/@name} {
                 attribute _from { $pFrom },
                 attribute _to { $pTo },
                 ( $Ecur('rule')/descendant::*
                                [@xml:id = $Ecur('ri')]
				/@mark
                   ,
                   $Ecur('rule')/@mark
                 )[1],
                 $lnAcc[self::attribute()],
                 $lnAcc[not(self::attribute())]                 
               },
        $trace := eri:notrace(eri:sXei($Ecur),
                      'all-node-seqs (case 2) returns element ' 
		      || 'named ' || name($e) || ' for Ecur:')
    return $e
</scrap>
</p>

<p>In the recursive case, <code>$Ecur</code> shows, in its rule
location (= FSA state name or position), what symbol <code>$sym</code>
we must jump back past.  For example, if <code>$Ecur</code> is <q>(0 8
Goal/ixml_0)</q> (as it will be when we are constructing an XML
representation of an ixml grammar eight characters long), then we know
from the rule index <code>ixml_0</code> that we now need to find a
parse for <ident>ixml</ident> ending at position 8, and then
work out where that instance of <ident>ixml</ident> started.
</p>
<p>Find the item <code>$eiPrev</code> that was expecting that symbol
(there may be many); for each such item <code>$eiPrev</code>, the
Earley set documents a parse of <code>$sym</code> that dominates (or
generates) the input range from <code>$eiPrev('to')</code> to
<code>$Ecur('to')</code>.  In the example, we will first find
<code>$sym</code>, the nonterminal with an ID of <code>ixml_0</code>
in the rule for <ident>Goal</ident>.  How we look for
<code>$eiPrev</code> depends on what <code>$sym</code> is.
<scrap id="epi-ans-recursive"
       name="Handle recursive case">
  (: 3. Recursive case. :)
  else (: 3. $Ecur('ri') is not a q0 / initial state :)
    (: 3.a some preparation common to T and N alike :)
    let $riCur := $Ecur('ri'),
        $sym := $Ecur('rule')/descendant::*[@xml:id = $riCur],
        $nParent := $Ecur('rule')/@name/string()
    return
      <ptr target="epi-ans-rec-terminal"/>
      <ptr target="epi-ans-rec-nonterminal"/>
      <ptr target="epi-ans-rec-whazzat"/>
</scrap>
</p>

<p>If <code>$sym</code> is terminal, then our clue for finding <code>$eiPrev</code>
is that the relation <code>scan($eiPrev, $I) =
$Ecur</code> holds. Find it, and then push
appropriate raw parse nodes <!-- Not, any longer, the string 
<code>$I[$eiPrev('to')</code> .. <code>$Ecur('to')]</code> -->
onto the accumulator and recur.
Or rather, since there may be more than one,
find <emph>them</emph> (in <code>$leiPrev</code>) and then
recur on each of them, pushing the newly created parse node
<code>$textnode</code> onto the accumulator.
<scrap id="epi-ans-rec-terminal"
       name="Handle recursion on terminal">
      (: 3.b current $sym is terminal :)
      if (eri:fTerminal($sym)) then
         let $trace := eri:notrace(eri:sXei($Ecur),
                       'all-node-seqs (case 3b) '
                       || 'unscanning terminal symbol '
		       || $riCur) 
         let $cSymlength := eri:match-length($sym),
             $pMedial := xs:integer($Ecur('to')) - $cSymlength,
             $leiPrev := $meiClosure('to')($pMedial)[ 
                eri:fScanrelEE(.,$Ecur)
                (: and xs:integer(.('to')) eq $pMedial :)
             ],
	     $sVal := substring($I,$pMedial+1,$cSymlength),
	     
             $textnode := element { 
                (: Rename the terminal to reduce confusion
                between grammar and parse tree :)
                if ($sym/self::inclusion) 
                then 'incl' 
                else if ($sym/self::exclusion) 
                then 'excl' 
                else if ($sym/self::literal)
                then 'lit' 
		else 'terminal---'
	     } {
	        $sym/@xml:id, 
		$sym/@tmark,
	        $sym/@regex, 
		attribute string { $sVal },
		attribute cps { string-to-codepoints($sVal) }
             }

         (: recur on each possible previous node :)
         for $eiPrev in $leiPrev
         let $trace := if (count($leiPrev) gt 1)
	               then eri:notrace(eri:sXei($Ecur),
                            'all-node-seqs (case 3b) finds '
			    || count($leiPrev)
                            || ' predecessors, now recurring on eiPrev='
			    || eri:sXei($eiPrev))
		       else eri:notrace(eri:sXei($Ecur),
                            'all-node-seqs (case 3b) finds '
		            || count($leiPrev)
                            || ' predecessors, now recurring on eiPrev='
			    || eri:sXei($eiPrev))

         return epi:all-node-sequences($eiPrev,
                                       $meiClosure,
                                       ($textnode, $lnAcc),
                                       $pFrom,
                                       $pTo,
                                       $I,
                                       $leiVStack,
                                       ($Ecur, $leiHStack)
                                      )
</scrap></p>
<p>The initial version rendered terminals as text nodes and not as
elements.  So it had no place to put a <att>tmark</att>.
<scrap id="epi-ans-rec-terminal-2016"
       name="Handle recursion on terminal">
      (: 3.b current $sym is terminal :)
      if (eri:fTerminal($sym)) then
         let $trace := eri:notrace(eri:sXei($Ecur),
                       'all-node-seqs (case 3b) '
                       || 'unscanning terminal symbol '
		       || $riCur) 
         let $cSymlength := eri:match-length($sym),
             $pMedial := xs:integer($Ecur('to')) - $cSymlength,
             $leiPrev := $meiClosure('to')($pMedial)[ 
                eri:fScanrelEE(.,$Ecur)
                (: and xs:integer(.('to')) eq $pMedial :)
              ],
             $textnode := text { substring($I,$pMedial+1,$cSymlength) }
             (: let $trace := eri:notrace($textnode,
	                      'Adding a text node: ') :)
         (: recur on each possible previous node :)
         for $eiPrev in $leiPrev
         let $trace := if (count($leiPrev) gt 1)
	               then eri:notrace(eri:sXei($Ecur),
                            'all-node-seqs (case 3b) finds '
			    || count($leiPrev)
                            || ' predecessors, now recurring on eiPrev='
			    || eri:sXei($eiPrev))
		       else eri:notrace(eri:sXei($Ecur),
                            'all-node-seqs (case 3b) finds '
		            || count($leiPrev)
                            || ' predecessors, now recurring on eiPrev='
			    || eri:sXei($eiPrev))

         return epi:all-node-sequences($eiPrev,
                                       $meiClosure,
                                       ($textnode, $lnAcc),
                                       $pFrom,
                                       $pTo,
                                       $I,
                                       $leiVStack,
                                       ($Ecur, $leiHStack)
                                      )
</scrap>
</p>
<p>If <code>$sym</code> is nonterminal, we can find
<code>$eiPrev</code> by exploiting the fact that the relation
<code>comp($EComp, $eiPrev, $G) = $Ecur</code> holds.  The closure
should include at least one completion item of the form
(<code>$eiPrev('to')</code>, <code>$Ecur('to')</code>,
<code>$sym</code>, <code>$ri</code>), where <code>$ri</code> is a
final state of a rule for <code>$sym</code>.
</p>
<p>We're going to break this down into steps.
First, just identify this case (and possibly issue
a trace message).
<scrap id="epi-ans-rec-nonterminal"
       name="Handle recursion on nonterminal">
      (: 3.c current $sym is nonterminal :)
      else if ($sym/self::nonterminal) then 
         let $trace := eri:notrace(eri:sXei($Ecur), 
                       'all-node-seqs (case 3c) '
		       || 'trying to unparse nonterminal '
		       || $riCur) 
         <ptr target="epi-ans-recnt-leiprev"/>
         <ptr target="epi-ans-recnt-lnodechild"/>
         <ptr target="epi-ans-recnt-recur"/>
</scrap></p>
<p>Then find all completion items (<code>$leiPrev</code>) for
nonterminal <code>$sym</code> finishing at this position.  That is, if
<code>$sym</code> is a RHS reference to <ident>ixml</ident>, the
completion items will have the form (<ident>start</ident>,
<ident>to</ident>, <ident>ixml</ident>/<ident>q_f</ident>).  What we
want is every item in the closure which (a) has the right
<ident>to</ident>-position and (b) is final for the right nonterminal.
<scrap id="epi-ans-recnt-leiprev"
       name="Find the child completions for $sym">
         let $leiPrev := $meiClosure('to')($Ecur('to'))[
           eri:fFinalEiPN(.,$Ecur('to'),$sym)
         ]
</scrap>
</p>
<p>Now, for each child completion, find all possible parse trees, and
then find all possible predictor items for <code>$sym</code> at the
start position of the completion item.  That is, all items ending
at that position, for which <code>$sym</code> is in the follow set.
<scrap id="epi-ans-recnt-lnodechild"
       name="Find parse trees for the child completions">
         for $eiCC at $nEiCC in $leiPrev
         let $trace := eri:notrace(eri:sXei($Ecur),
	       'all-node-seqs (case 3c) finds completion item '
               || '(' || $nEiCC || ' of '
	       || count($leiPrev) || ')'
               || ' for ' || $sym/@name
	       || ', namely ' || eri:sXei($eiCC)
	       || ' and calls all-trees for it.')
         let $lnodeChild := epi:all-trees($eiCC,
                                          $meiClosure,
	                                  $I,
					  $leiVStack), 
             $leiPredictors := $meiClosure('to')($eiCC('from'))
	                       [eri:fAdvanceNrelEE(.,$Ecur)
                                (: and .('to') eq $eiCC('from') :)]

	 (:
         let $trace := for $nCh in $lnodeChild
                       return eri:notrace($nCh,
                              'all-node-seqs got this back'
			      || ' from all-trees:') 
         :)
</scrap>
</p>
<p>For each pair of parse tree and predictor item,
we need to recur appropriately.
<scrap id="epi-ans-recnt-recur"
       name="Recur on each predictor">
         for $eiPred at $nEiP in $leiPredictors
         let $trace := eri:notrace(eri:sXei($Ecur),
	       'all-node-seqs (case 3c) finds predictor '
               || '(' || $nEiP || ' of '
	       || count($leiPredictors) || ')'
               || ' for ' || $sym/@name
	       || ', namely ' || eri:sXei($eiPred))
         
         for $nodeCh0 at $nNch in $lnodeChild
         <ptr target="epi-ans-recnt-munge-mark"/>
         let $trace := eri:notrace(eri:sXei($Ecur),
	       'all-node-seqs recurs on child'
               || '(' || $nNch
	       || ' of ' || count($lnodeChild) || '),'
               || ' (predictor' || $nEiP
	       || ' of ' || count($leiPredictors) || '),'
               || ' (Completion' || $nEiCC
	       || ' of ' || count($leiPrev) || '),'
			   )

         return epi:all-node-sequences($eiPred,
                                       $meiClosure,
                                       ($nodeCh, $lnAcc),
                                       $pFrom,
                                       $pTo,
                                       $I,
                                       $leiVStack,
                                       ($Ecur, $leiHStack)
                                      )
</scrap></p>
<p>There's one more complication.  The trees produced
by the call to <ident>all-trees()</ident> have <att>mark</att>
attributes reflecting the mark on the rule for the nonterminal.
If a mark is specified on the RHS reference to the nonterminal
(that would be the <code>$sym</code> element), it needs to
over-ride the mark on the rule.  So before we pop the
child nodes into the accumulator, we make sure their
<att>mark</att> attribute is correct.
<scrap id="epi-ans-recnt-munge-mark"
       name="Adjust mark attribute on $nodeCh as needed">
         let $nodeCh := 
             if (exists($sym/@mark)) 
             then element { name($nodeCh0) } {
	         $nodeCh0/(@* except @mark), 
	         $sym/@mark,
		 $nodeCh0/node()
	     }
             else $nodeCh0
</scrap>
</p>
<p>If what we are looking at has not been recognized
as a terminal or a nonterminal, then we are out of luck
and can only report a problem.
<scrap id="epi-ans-rec-whazzat"
       name="Raise error if neither terminal nor nonterminal">
      else (: not terminal, not nonterminal, we have a problem :)
        &lt;error-in-all-node-sequences
          from="{$pFrom}" to="{$pTo}">{
            eri:sXei($Ecur)
          }&lt;/error-in-all-node-sequences>
</scrap>
</p>
<p>Here we appear to have some cruft that has been commented
out but not removed.
<scrap id="epi-lnDepXCleC"
       name="Define lnDepXClEc()">
(: lnDepXClEc($Closure, $Ec):  from the Earley closure $Closure,
   extract the dependents of the node completed by $Ec.
:)
(: 
declare function epi:lnDepXClEc(
  $leiClosure as map(*)*, 
  $Ec as map(*)
) as item()* {
  &lt;lnDepXClEc-not-implemented/>
};
  :)
(: eMakeEcLndepLaLa($Ec,$ln,$lA,$lC):  given a completion item $Ec,
   a (possibly partial) list of dependent nodes $ln, and 
   accumulated lists of attributes and children, construct an
   element.
 :)
 (:
declare function epi:eMakeEcLndepLaLc(
  $Ec as map(*),
  $lnDep as item()*
) as element() {
  let $gi := $Ec('rule')/@name,
      $lAtts := $lnDep[self::attribute()],
      $lChildren := $lnDep[self::element() 
                     or self::text() 
                     or self::comment() 
                     or self::processing-instruction()]
  return element {$gi} { $lAtts, $lChildren }
};

:)  
</scrap></p>
</div>
<div id="epi-ast-from-raw">
<head>Extracting the abstract syntax tree from the raw parse tree</head>
<p>The parse tree extraction routines defined elsewhere produce
the raw parse tree, but ixml requires that we return an abstract
syntax tree.  So we need a function to take a raw parse tree
and return the corresponding AST.</p>
<p>There are several different functions, depending on which
situation we are in.
<list>
<item><p>The initial call expects to find the 'Goal' nonterminal at
the root of the raw parse tree; it then passes its child element to a
function that seeks to make the document element.</p>
<p>If that function returns multiple children, the function
provides an <gi>ixml:multiple-roots</gi> wrapper.</p></item>
<item><p>The function to make a document element
<soCalled>knows</soCalled> that so far we don't have any parent
element, so in the normal case it just recurs looking for a
nonterminal marked as an element.  It deals differently with
different cases:
<list>
<item>A nonterminal marked <q><code>^</code></q> is passed to
an element constructor.</item>
<item>A nonterminal marked <q><code>-</code></q> is skipped; the
function recurs on its children.  (It is this recursion which
makes it possible for the function to return multiple results.)</item>
<item>A nonterminal marked <q><code>@</code></q> is serialized as an
element (as required by the spec).</item>
<item>A terminal is wrapped in an <gi>ixml:wrapper</gi>
element.</item>
</list>
</p></item>
<item><p>The element constructor should be called only on nonterminals
marked as elements.  It serializes the nonterminal as an element and
calls other functions to collect its attributes and its
content.</p></item>
<item><p>The function to collect attributes for a parent element
just constructed will recur through the relevant subtree of the raw
parse tree, looking for nonterminals marked as attributes.  It will
recur through hidden nonterminals, stop the recursion on
element nonterminals, raise an error on terminals, and call an
attribute-value constructor when it finds a nonterminal marked as an
attribute.</p></item>
<item><p>The attribute-value constructor function recurs, gathering
character data from terminals and ignoring the markings on all
intervening nodes.</p></item>
<item><p>The function to gather content for a parent element just
constructed will recur through the relevant subtree of the raw parse
tree, ignoring attributes, serializing terminals, recurring through
hidden nonterminals, and calling the element constructor on
serializable nonterminals.</p></item>
</list>
</p>
<div id="epi-ast-init">
<head>The initial call</head>

<p>The top-level AST constructor function descends past the Goal
wrapper and passes its one descendant to the document-element
constructor.  It assigns the result to a variable, so it can check how
many nodes came back: if more than one, a special wrapper is needed.
It also rewrites the outer element if needed, adding an ambiguity
flag.</p>
<p>To handle the ambiguity flag, we accept a parameter showing how
many parse trees the caller got back from the
<ident>recognizeX()</ident> function; if it's greater than one, we
mark the result with <code>ixml:state="ambiguous"</code>, declaring
the namespace as <code>xmlns:ixml="http://invisiblexml.org/NS"</code>.
<scrap id="epi-astXparsetree"
       name="Define astXparsetree() to make AST from raw parse">
declare function epi:astXparsetree(
  $E as element(nt),
  $cpt as xs:integer
) as node()* {
  if (empty($E/nt)) 
  then
      element error {
          text {
              "Parse tree had wrapper",
              "but no content."
          }
      }
  else
      let $doc0 :=
              for $c in $E/*
              return epi:doc-elementXpt($c),
          $doc1 :=
	      if (count($doc0) eq 1) 
              then $doc0 
	      else if (count($doc0) eq 0) 
              then element ixml:no-roots {}
	      else element ixml:multiple-roots {
	          $doc0
	      }
      return
          if ($cpt eq 1) 
          then $doc1
	  else element { name($doc1) } {
	       attribute ixml:state { 'ambiguous' },
	       $doc1/@*, 
	       $doc1/node()
	  }
};
<ptr target="epi-docelXpt"/>
<ptr target="epi-elXpt"/>
<ptr target="epi-attsXpt"/>
<ptr target="epi-avXpt"/>
<ptr target="epi-contentXpt"/>
</scrap></p>
</div>
<div id="epi-ast-outer">
<head>The document-element constructor</head>
<p>The constructor for the document element is distinct from the
ordinary element constructor because in the special case that the
top-most node of the result is an attribute or a terminal symbol, we
want to coerce the result into an element.</p>
<p>
<scrap id="epi-docelXpt"
       name="Define doc-elementXpt() to make AST for document element">
declare function epi:doc-elementXpt(
  $E as element()*
) as node()* {
  (: Normal case :)
  if ($E/self::nt[@mark = '^' or not(@mark)]) 
  then epi:elementXpt($E)
  
  (: Hidden wrapper, recur :) 
  else if ($E/self::nt[@mark = '-']) 
  then for $c in $E/*
      return epi:doc-elementXpt($c) 

  (: Attribute (sic) :) 
  else if ($E/self::nt[@mark = '@']) 
  then element { $E/@name } {
      attribute ixml:warning {
          'Attribute found as root of AST'
      }
  }

  (: Terminal (sic) :) 
  else if ($E/self::*[name() = ('lit', 'incl', 'excl')])  
  then element ixml:terminal {
      attribute warning { 
          'Terminal found as root of AST'
      }, 
      text { <ptr target="epi-sXpt"/> } 
  }
  
  (: Unexpected input: what? :)
  else &lt;oops>{$E}&lt;/oops>
};
</scrap>
</p>
<p>There are a couple of places where we will need to
make a string from a raw parse tree terminal. This
involves checking that the terminal is not marked
hidden and then serializing from the list of code points.
(An approximation of the string value will be in the

<scrap id="epi-sXpt"
       name="Make string from raw parse tree terminal $E">
if ($E/@tmark = '-')  
       then ()  
       else codepoints-to-string(
               for $t in tokenize(
                   normalize-space($E/@cps),
	           '\s')  
               return xs:integer($t)
       )
</scrap>
</p>
</div>
<div id="epi-ast-element">
<head>The element constructor</head>
<p>The ordinary element constructor creates an element with the
appropriate name, then calls two functions to traverse the current
part of the raw parse tree and collect attributes and content,
respectively.  The argument is required to be an <gi>nt</gi>
element and expected to be marked <q><code>^</code></q>.</p>
<p>
<scrap id="epi-elXpt"
       name="Define elementXpt() to make AST for one element">
declare function epi:elementXpt(
  $E as element()
) as node()* {
  element { $E/@name } {
      if ($E/@mark = ('-', '@'))
      then attribute ixml:warning {
          'Wrong mark (' || $E/@mark 
          || ') on nonterminal'
      }
      else (),
      for $c in $E/*
      return epi:attributesXpt($c), 
      for $c in $E/*
      let $dummy := eri:notrace(
          concat(name($c), '/', $c/@name, '/', $c/@xml:id),
          'constructing content from:') 
      let $n := epi:contentXpt($c)
      let $dummy := for $chunk in $n return
          if ($chunk instance of text())
          then eri:notrace(concat('/',
	       string-join(string-to-codepoints($chunk),' '), 
               '/'), 
               'eXpt got text node') 
          else if ($chunk instance of element())
	  then eri:notrace($chunk/name(), 'eXpt gets element:') 
	  else eri:notrace($chunk, 'eXpt gets unknown item:') 
      return $n
  }
};
</scrap></p>
</div>
<div id="epi-ast-attcoll">
<head>The attribute collector</head>
<p>The attribute collector traverses the subtree looking for things to
serialize as attributes on the current element.  For
each such nonterminal, it constructs the attribute and
called the attribute value constructor to construct
the value.
<scrap id="epi-attsXpt"
       name="Define attributesXpt() to collect attributes"> 
declare function epi:attributesXpt(
  $E as element()
) as attribute()* {
  (: Main case: make an attribute :)
  if ($E/self::nt[@mark = '@']) 
  then attribute { $E/@name } {
      string-join(
          (for $c in $E/*
          return epi:avXpt($c)),
	  '')
  }

  (: skip terminals and elements :)
  else if ($E/name() = ('lit', 'incl', 'excl')) 
  then () 
  else if ($E/self::nt[@mark = '^' or not(@mark)])
  then ()

  (: recur through hidden nt :)
  else if ($E/self::nt[@mark = '-']) 
      then for $c in $E/*
      return epi:attributesXpt($c)

  else eri:trace((),
      '! unexpected argument to attributesXpt()') 
     
};
</scrap></p>
</div>
<div id="epi-ast-attvalue">
<head>The attribute value constructor</head>
<p>The attribute value constructor traverses a subtree constructing
the string value of an attribute.  The spec says we serialize <q>all
non-hidden terminal descendants of the node (regardless of marking of
intermediate nonterminals)</q>. So we ignore the <q><code>^</code></q>
marking and treats it the same as <q><code>-</code></q>, recurring
through it. For an example of this treatment, see the handling of
<ident>dchar</ident> and <ident>schar</ident> in the current ixml
grammar.
<scrap id="epi-avXpt"
       name="Define avXpt() to collect attribute value">
declare function epi:avXpt(
  $E as element()
) as xs:string* {
  if ($E/(self::incl or self::excl or self::lit))
  then <ptr target="epi-sXpt"/> 
  else for $c in $E/*
       return epi:avXpt($c)
};
</scrap>
</p>
</div>
<div id="epi-ast-content">
<head>The content collector</head>
<p>The content collector traverses the subtree looking for things to
serialize as content of the current element and either
serializing them itself (if terminals) or passing them to the
element constructor.
<scrap id="epi-contentXpt"
       name="Define contentXpt()">
declare function epi:contentXpt(
  $E as element()
) as item()* {
  if ($E/self::nt[@mark = '^' or not(@mark)])
  then epi:elementXpt($E)
  else if ($E/self::nt[@mark = '-'])
  then for $c in $E/*
       return epi:contentXpt($c)
  else if ($E/self::nt[@mark = '@'])
  then ()
  else if ($E[self::incl or self::excl or self::lit])
  then text { <ptr target="epi-sXpt"/> }
  else element ixml:unexpected {
       attribute f { "epi:contentXpt" }, 
       $E
  }
};
</scrap>
</p>
</div>
</div>
</div>
<!--
<div id="legacy-Gluschkov.xqm">
<head>Construction of the Gluschkov automaton</head>
</div>
-->

</div>


</body>
<back>

<div id="references">
<head>References</head>
<p><hi>Incomplete.</hi></p>
<listBibl>

<bibl id="ABK1993" n="Br&uuml;ggemann-Klein 1993">
<author>Anne Br&uuml;ggemann-Klein</author>,
<title level="a">Regular expressions into finite automata,</title>
<title level="j">Theoretical Computer Science</title>
120.2 (1993): 197-213.
</bibl>

<bibl id="GJ" n="Grune / Jacobs 2007">
<author>Dick Grune and Ceriel J. H. Jacobs</author>,
<title level="m">Parsing techniques:  a practical guide</title>
(New York, et al.: Ellis Horwood, 1990;
Second edition New York:  Springer, 2007).</bibl>

<bibl id="Knuth-1984" n="Knuth 1984">
<author>Donald E. Knuth</author>,
<title level="a">Literate Programming,</title>
<title level="j">The Computer Journal</title>
27 (1984):  97-111,
rpt. [rev.] in his
<title level="m">Literate Programming</title>,
<title level="s">CSLI Lecture Notes</title> Number 27
([Stanford, California]:  Center for the Study of Language and
Information, 1992), pp. 99-136, here p. 99.</bibl>

<bibl id="pemberton-2013" n="Pemberton 2013">
<author>Pemberton, Steven</author>.
<date>2013</date>.
<title level="a">Invisible XML</title>.
Presented at Balisage: The Markup Conference 2013,
Montréal, Canada, August 6 - 9, 2013.
In
<title level="m">Proceedings of Balisage: The Markup Conference 2013.</title>
Balisage Series on Markup Technologies, vol. 10 (2013).
DOI: 10.4242/BalisageVol10.Pemberton01.
On the web at
<xref>http://www.balisage.net/Proceedings/vol10/html/Pemberton01/BalisageVol10-Pemberton01.html</xref>.
Revised version (January 2014) at
<xref>https://homepages.cwi.nl/~steven/Talks/2013/08-07-invisible-xml/invisible-xml-3.html</xref>
</bibl>

<bibl id="pemberton-2021" n="Pemberton 2021">
<author>Pemberton, Steven</author>.
<date>2021</date>.
<title level="a">Invisible XML Specification
(Draft)</title>.
On the web at
<xref>https://invisiblexml.org/ixml-specification.html</xref>
</bibl>

<bibl id="msm-1996" n="Sperberg-McQueen 1996">
<author>Sperberg-McQueen, C. M.</author>
<title level="u">SWEB:
an SGML Tag Set for Literate Programming</title>.
Unpublished technical report, 1993, rev. 1994, 1995, 1996.
On the web at
http://cmsmcq.com/1993/sweb.{<xref
href="http://cmsmcq.com/1993/sweb.xml"
>xml</xref>,<xref
href="http://cmsmcq.com/1993/sweb.html"
>html</xref>}.</bibl>

<bibl id="msm-2017" n="Sperberg-McQueen 2017">
<author>Sperberg-McQueen, C. M.</author>
<title level="a">Translating imperative algorithms
into declarative, functional terms:
towards Earley parsing in XSLT and XQuery</title>.
Presented at Balisage: The Markup Conference 2017,
Washington, DC, August 1 - 4, 2017.
In
<title level="m">Proceedings of Balisage:
The Markup Conference 2017.</title>
<title level="s">Balisage Series on Markup Technologies,
vol. 19 (2017)</title>.
<xref>https://doi.org/10.4242/BalisageVol19.Sperberg-McQueen01</xref>.
</bibl>

<bibl id="msm-2022" n="Sperberg-McQueen 2022">
<author>Sperberg-McQueen, C. M.</author> <title level="u">Test harness
for Aparecium</title>.  Unpublished technical report, 2022.</bibl>
</listBibl>
</div>

<!--
<div id="notation">
<head>Literate programming notation</head>
<p><hi>To be supplied:  a description of the notation used here.</hi></p>
</div>
-->

<div id="to-do">
<head>To do</head>
<p>As the reader will have noticed, in its current state this
program is not finished. Hence the following to-do lists.</p>

<div id="to-do-large">
<head>Overall plans</head>

<p>At the moment (&date.last.touched;), the primary concerns are to
improve performance and robustness.</p>
<list>

<item>
<p><label>Bug fixes</label>.  Clear all test-case failures.</p>
</item>

<item>
<p><label>Vendor neutrality</label>.  Take time to make frameworks to
run in multiple XQuery engines, both from whatever GUI interface they
provide and from the command line.  Initial targets:  BaseX, Saxon, eXist-db,
Xidel.
<!-- To do, if feasible:
<list>
<item>BaseX from BaseXGUI (done) and command line (I think this has worked in the past)</item>
<item>Saxon EE from Oxygen GUI (has worked in past, need to check again),
Saxon HE from Oxygen GUI and command line</item>
<item>(installed) eXist-db from GUI and from command line</item>
<item>MarkLogic from GUI and from command line</item>
<item>FusionDB from GUI and from command line</item>
<item>(nogo) BerkeleyDB from command line (do they have a GUI?) 
(installed, no map support)</item>
<item>Zorba?</item>
<item>xqib?</item>
</list>
-->
</p>
<p>XQilla and BerkeleyDB XML support XQuery 1.0, and possibly
3.0, but not 3.1, which means they have no support for maps,
which means they are not candidates for this work.</p>
<p>Not an atomic task; time-consuming steps should be broken up to
avoid blocking other work.</p>
<!-- The positioning of this item is contingent.
If Brown Sugar produces a sizable speedup (say, a factor of two?),
then further work on optimization can wait and is better done on
several processors.
If Brown Sugar does not produce a useful speedup, then it may be
desirable to pull the Recursive Descent task forward.  It will feel
better worrying about vendor neutrality if the tool is actually
useful.
-->
</item>

<item><p><label>Brown Sugar</label> plan.<note place="foot">
<p>So called because this is a dirty form of the
<soCalled>sugar</soCalled> plan described below.</p>
</note>
Quick and dirty ad-hoc tokenization change for ixml grammar for ixml
grammars.  Hand-modify and hand-annotate the grammar, add support for
those annotations.</p>
<p>Note that the ixml grammar has both safe and unsafe tokenization
candidates: whitespace and comment-data are safe, and names are unsafe
owing to the full stop.  So this is a quick and dirty test of both
<soCalled>Sugar</soCalled> and <soCalled>Bruno</soCalled>.</p>
</item>

<item>
<p><label>Direct tree construction</label>.  Revisit the old code for
direct construction of trees to try to fix its problems.</p>
<p>First try to restructure it in SWeb to make it easier to
understand.  Then try to isolate bottlenecks and causes of problems.
Then try to fix them.</p>
</item>

<item>
<p><label>Revise and restructure</label>.  Revise the document
thoroughly, reorganizing as appropriate.  There are two audiences:
those interested in understanding how the implementation works, and
those maintaining the code.</p>
<p>Begin by introducing scraps to represent the abstract data types
<ident>Earley item</ident>, <ident>Earley set</ident>, etc., so that
the high-level algorithm can be followed independently of the chosen
representation.  Explain the high-level algorithm, then the
internals.</p>
<p>This is not an atomic task and may be interleaved with other
things.</p>
</item>

<item>
<p><label>User options</label>.  Allow invoker to specify options, so
they can choose whether to get back one parse tree, several, a
parse-forest grammar, a raw parse tree, or the entire Earley set.</p>
<p>This will also require some extension to the test harness and
possibly to the test catalog schema.</p>
</item>

<item>
<p><label>Grammar cleanup</label>.  Implement automatic cleanup
of grammar hygiene problems (unreachable, unproductive, and
undefined symbols); improve diagnostics.</p>
</item>

<item><p><label>Robustness</label>.  Improve robustness and resistance
to unexpected error.  Not necessarily an atomic task, but worth a
concerted effort to walk through every scrap of code checking for
assumptions that need to be checked.</p></item>

<item><p><label>Sugar</label>. Improve tokenization for
<soCalled>suitable</soCalled> nonterminals.  <hi>This is only sensible
if the experience from Brown Sugar suggests it produces a useful
speedup.  I expect that it will.</hi></p>

<p>Since ixml grammars don't have a distinct token level, either
analysis by the processor or manual annotation, or both, may be
required.  The goal is to identify nonterminals which can be
recognized with a single greedy regular-expression match, and
recognize them in that way.  I believe a nonterminal &N; is suitable
for this treatment if and only if:

<list>
<item>
<p>&N; defines a regular language.  (Sufficient but not necessary
condition: no center embedding for them or any descendant.  A stronger
and easier condition: no self-embedding at all.)</p>
</item>
<item>
<p>Every nonterminal descendant of &N; is marked hidden.</p>
</item>
<item>
<p>Every terminal descendant of &N; is marked visible.</p>
</item>
<item>
<p>&N; is what we might call <term>end-stopped</term>, by analogy
with the metrical phenomenon in which syntactic and verse boundaries
fall together, thus clearly marking the boundary.  Concretely, &N; is
end-stopped if it is clear without lookahead where the end of an
occurrence of &N; falls: any legal character is either a continuation
of the &N; or the beginning of the next symbol, and no symbol can be
read in both ways.</p>

<p>Operationally, I think end-stopping can be detected as follows.
<list>

<item>
<p>Construct the FSA for the &O0; regular superset approximation of
&L.G;, in the usual way.  For each nonterminal, keep track of the set
of states that recognize that nonterminal.  (Including states in
descendant nonterminals, if they have been retained; in practice, I
expect it will make sense to rewrite the rules for &N; as a regular
expression over characters.)</p></item>

<item>
<p>For every nonterminal &N; and every state which can reach the
final state of &N; via epsilon transitions, mark that state as a
member of <ident>last</ident>(&N;).  The terminal subset of this set
we can call <ident>last</ident><hi rend="sub">&T;</hi>(&N;).</p>
</item>

<item>
<p>Remove epsilon transitions.</p>
</item>

<item>
<p>For each state &q; in <ident>last</ident><hi
rend="sub">&T;</hi>(&N;), classify the outgoing arcs: either they lead
to a state in the recognizer for &N;, or they lead to one of the
initial states in a recognizer for some nonterminal in
<ident>follow(N)</ident>.  We can call these <term>endotelic</term>
and <term>exotelic</term> arcs: they have goals inside, or outside,
the recognizer for &N;.</p>
</item>

<item>
<p>If no symbol occurs on both an endotelic and an exotelic arc,
then &N; is end-stopped: if an occurrence of &N; can be extended by
including the next character in the input, then in any correct parse
that character is included in the &N;.  If any symbol occurs on both
kinds of arc, then it is not clear without further information
whether it belongs in the &N; or outside it.</p>
</item>
</list>
</p>
</item>
</list></p>
</item>

<item>
<p><label>Bruno</label>.  A brute-force variation on Sugar.  If an
otherwise suitable nonterminal &N; is not end-stopped
(e.g. <ident>name</ident> in the ixml specification grammar), it may
still be worthwhile to use regular expressions to match it using a
brute-force method to find the appropriate stopping point: register
them all:</p>
<list>
<item>
<p>When &N; is predicted at position &p;, use a greedy match to find
the longest &N; in the input starting at &p;.  Assume this match has
length &n;.</p>
</item>
<item>
<p>For &i; in 0 to &n;:
<list>
<item>
<p>Let &s; be the substring in the input beginning at &p; with length
&i;.</p>
</item>
<item>
<p>If &s; is an instance of &N;, record a completion item for &N; of the form
(&p;, &p;+&i;, &N;, &qf;).</p>
</item>
</list>
</p>
<p>This will reduce the number of items produced for the range
&I;[&p;, &p;+&n;] by about half, and may reduce run time: in the worst
case we will have
<list>
<item>&n; calls to construct substring &s;</item>
<item>&n; + 1 calls to <ident>matches</ident>(&s;, <ident>pattern</ident>)</item>
<item>&n; completion items for &N;</item>
<item>0 searches in the Earley set</item>
</list>
for a total of &n; &times; (cost of substring construction
+ cost of regex match + cost of item construction).
In the standard Earley algorithm, the cost will be
<list>
<item>&n; inspections of &I;[&p; + &i;]</item>
<item>&n; progress or completion items for &N; (or whatever the
lowest-level parent of the repetition operator is)</item>
<item>an indeterminate number of other progress or completion items for descendants of &N;</item>
<item>one or two searches in the Earley set for each item constructed</item>
</list>
</p>
</item>
</list>
<p><hi>This is only sensible if the experience from Brown Sugar
suggests it produces a useful speedup.  I expect that it
will.</hi></p>
</item>

<item><p><label>Diagnostics</label>.  Improve diagnostics in case of
failure.</p></item>

<item><p><label>Recursive descent</label>.  Support recursive-descent
parsing.</p>

<list>

<item><p>Develop code to check whether a grammar is LL(1) or
LL(k).</p></item>

<item>
<p>Make an LL(1) grammar out of the ixml grammar.</p>
<p>Automate the grammar rewrites necessary to do this, so it can be
re-done when the ixml grammar changes.</p>
</item>

<item>
<p>Write code to generate tables from an LL(1) parser to drive a
table-driven parser.</p>
</item>

<item>
<p>Write code to generate a recursive-descent parser for an LL(1)
grammar.</p>
</item>

<item>
<p>Make a recursive-descent or table-driven LL(1) parser for the ixml
spec grammar and use it when parsing input grammars.</p>
<p>I hope that this change will produce an order of magnitude speedup
in parsing input grammars.</p>
</item>
</list>

<p>Initially, this code may be in Aparecium or in Gingersnap or in
both.  If the LL(1) checking runs fast enough, it will be needed in
Aparecium, so that when the user supplies an LL(1) grammar Aparecium
can use a faster parsing algorithm than Earley.</p>
</item>

<item><p><label>Performance</label>.  Measure time, measure frequency
of operations, look for opportunities to do better.  If calculations
can be done statically, push them into the grammar compiler.</p>

<p>By no means an atomic task.</p>

<p>Note that several other items on this list are motivated largely or
exclusively by the desire to improve time performance: Brown Sugar,
revision of direct tree construction, Sugar, Bruno, and work on
recursive descent.</p>

<!-- 
. inline all item-manipulation and item-finding functions?
. rewrite find-walks and mpr to avoid cdring down the walk multiple times?
. rewrite grammar with pseudo-tokens (Gingersnap!)
. pre-calculate predictions for any nonterminal
. gather statistics on frequency of all basic operations:  item creation,
  item tests, item searches
. conjecture:  inlining hidden nonterminals will reduce the number of items
  and speed things up, independent of tokenization.  (test on 19 Mar 22
  gave a 4x speedup on ixml.ixml)
-->

</item>

<item><p><label>SWeb upgrade</label>.  Upgrade the SWeb infrastructure
to support XSLT.</p></item>

<item><p><label>XSLT</label>.  Create XSLT version of
Aparecium.</p></item>

<item><p><label>BNF</label>.  Consider shifting to using BNF rather
than EBNF internally. This will make it simpler to handle various
forms of infinite ambiguity satisfactorily, but will have little
effect in ordinary grammars.</p>
<p>Some but not all of the effects of switching to BNF can be tested
by just comparing behavior on EBNF grammars and BNF equivalents.  This
does not however account for possibly faster compilation and
recognition; that would require alternate code.</p></item>

</list>
</div>

<div id="to-do-code">
<head>Code changes</head>
<p>Fixes / shorter-term changes to be made:</p>
<list>
<item>16 Feb 22:  make compilation place a <att>follow:info</att> attribute
or something on the <gi>ixml</gi> element, to de-clutter the
compiled grammar.</item>
<item>16 Feb 22: Weed these to-do lists!</item>

<item>Make a common-utilities module for global project-level
variables (e.g. version number, tracing level) and tracing / debugging
routines.</item>
<item>Insert GPL notices in all modules.</item>
</list>

<p>Enhancements longer-term changes to be made:</p>
<list>
<item>Make marks work correctly.  Why is S appearing in output when
ixml is parsed?</item>
<item>Allow options to turn _from and _to attributes on and off?</item>
</list>
</div>

<div id="to-do-sweb">
<head>SWeb upgrades</head>
<p>To do asap:</p>
<list>
<item>make RNC schema for p3 + SWeb + XSLT</item>
<item>ensure new schema allows any well formed XML in
scraps, but enforces parent/child relations on XSLT</item>
<item>add module to SWeb stylesheet, to handle
XSLT and other XML elements within scraps</item>
<item>when this document is a bit further along (and has
decent display / translation into XHTML), move to github.</item>
</list>
<p>To do eventually:</p>
<list>
<item>make RNC schema for TEI P5 + SWeb + XSLT</item>
<item>upgrade this document, SWeb weave processor, SWeb
tangle processor</item>
</list>
</div>

<div>
<head>To-do list from Earley recognizer internals module</head>
<p>This module has a complicated enough to-do list of its own that
I'll give it here for the moment instead of inserting these into the
general to-do lists just given.</p>
<list>
<item><p>establish coherent Hungarian type policy to distinguish 
     element and string representations of symbols.  We need
     shorthands for both.</p></item>
<item><p>fix symbol/position issue in leiAdvanceEiSymP()</p></item>
<item><p>finish minimal version</p></item>
<item><p>add support for #xxxx characters</p></item>
<item><p>clarify XML representation of terminals and other questions
with SP:
<list>
<item>grammar says -quoted, I say quoted </item>
<item>grammar says quoted/@dstring, quoted/@sstring, 
       I think I prefer quoted with PCDATA (code
       currently handles all three)</item>
<item>grammar defines -character, I want character element
       as child of terminal (-character is fine for 
       @dstring and @sstring)</item>
<item>grammar and papers don't say what ^ means</item>
<item>how is start symbol determined?  For now I
       take LHS of first rule, like yacc.</item>
<item>if a rule reads "-foo: @bar, baz.", what happens?
       does @bar percolate up to parent element? (Do you
       know how to do this?)</item>
<item>Is a grammar specifying an @ mark on a repeatable 
       non-terminal ill-formed?  Or is the @ just ignored
       in that case?  (Tentative answer: both.)</item>
<item>True or false? 
       On a nonterminal, the mark "-" means "do not tag as element",
       but do promote the children.  On a terminal, it means
       "omit the entire thing".
</item>
</list></p>
</item>
<item><p>do some sanity checking in reXTerminal to avoid having
     matches() blow up.</p></item>
<item><p>fix confusion over two senses of nullable:
<list>
<item>locally nullable = nullable within the RHS (decorated 
       with ? or *, inside optional group, etc.)</item>
       <item>generates null string in sentence</item>
</list>
</p>
<p>N.B. a required non-terminal, not nullable in first
sense, can generate empty string and thus make its
parent nullable in the second sense.</p>
<p>Use fNullable for the first sense (already established)
and fGES (to be renamed for the second.</p>
</item>
<item><p>For testing purposes, provide a recognize function that
specifies a start symbol (analogous to phrase/2 in Prolog).</p></item>
</list>
</div>

<div id="done-that">
<head>Done</head>
<p>This section records things that were on the to-do lists above
and got done, in case that information is needed later.  Maybe I
just want to remember that some things do get done.</p>
<list>
<item>
<p>Improve tree constructor. Or, rather, replace
it. Concretely:</p>
<list>
<item><p>Define a function to generate a parse-forest grammar
from the Earley set, rather than a parse tree.</p></item>
<item><p>Define a function to extract one or more parse trees
from a parse-forest grammar.</p>
</item>
</list>
<p>The parse-tree constructor currently suffers from dismal
performance on some tests; see in particular the zeroes test catalog.
It performs its work without backtracking but also without memoization
or a work queue or any mechanism to avoid doing the same task multiple
times.  The result can be a combinatorial explosion, with the same
subtrees being constructed hundreds and thousands of times even for
input of only ten characters.</p>
<p>Since I want to write a parse-forest grammar constructor in any
case, I have not attempted to instrument the current tree constructor;
my plan is just to construct a parse-forest grammar and then extract
the tree from that, if the user wishes.</p>

<p>My current expectation is that in most cases this will result in a
modest improvement in performance.  Performance should improve because
useless work will be avoided and necessary work will be performed
only once.  But the improvement will be modest, because not all
grammars cause much unnecessary or repeated work.</p>
<p>To be concrete: at the moment tree construction normally takes
between 15% and 50% of the running time, except in a few pathological
cases.  (Some timing data are in the A subdirectory of this project.)
A ten to twenty per cent improvement in the performance of tree
construction will thus provide a one to ten per cent overall
improvement.  In the pathological cases, the improvement should be
greater.
</p>
<p><hi>Parse-forest grammar constructor completed in early March
2022.  It appears not to suffer from the pathological behavior on
right-recursive grammars like some in the zeroes test set, but on
other test cases it is slower than the old code, not faster; the
overall test case times are 25% to 100% higher than for the old
code.</hi></p>
</item>
<item>
<p>The current organization based on higher-level functions should be
scrapped, in order that Aparecium can run under Saxon.</p>
<p><hi>Done in connection with parse-forest grammars, March
2022.</hi></p>
</item>
</list>

</div>
<div id="puzzles">
<head>Puzzles to come back to</head>
<p>As this project has proceeded, I have encountered some unexpected
phenomena.  Sometimes reflection or study has helped me to
understand what at first was puzzling, sometimes not.  The list
below mentions some things I have not yet understood and hope to
come back to and understand, some time.</p>
<list>
<item>
<p>The rules in Earley items sometimes appear to have no parents,
sometimes to have an <gi>ixml</gi> parent which does not have the
children I expected it to have.</p>
<p>In v0.1, when Earley items were represented by elements, putting
a rule into an item required that it be copied.  But when Earley
items are represented by maps, copying should no longer be required.
Is there code that is forcing a copy, and if so where?</p>
</item>
<item>
<p>The code for attribute values in <ident>tree-from-pfg()</ident>
collects text nodes, but if the sequence of text nodes is
serialized, they are treated as if they were strings, or as if they
were not adjacent: whitespace is injected.  Why?</p>
<p>The current workaround with <ident>string-join()</ident> means I
didn't need to solve this problem to proceed, but it's puzzling.</p>
<p>This appears not to happen in mixed content; is it the fact of
being serialized as an attribute value that is causing the
issue?</p>
</item>
<item>
<p>In Earley recognition, the rule index is a salient part of an
Earley item; in generating a parse-forest grammar, it is irrelevant
and two items are equivalent if they have the same
<ident>from</ident>, <ident>to</ident>, and <ident>rule</ident>
values.</p>
<p>So when items are de-duped in <ident>find-walks()</ident>, it is
necessary to ignore the rule index.  (When this was not done,
duplicate right-hand sides and duplicate rules appeared in the
parse-forest grammar for <q><code>a</code></q> parsed against
<q><code>S=S;'a'.</code></q>)</p>
<p>In principle, it appears that the same ought to apply to
de-duping in <ident>make-pfg-rules()</ident>.  But when the code is
changed to do that, PFG generation breaks.  Why?</p>
</item>
<item>
<p>Why is tree construction via a parse-forest grammar slower than
direct tree construction?</p>
<p>Conjecture: because in unambiguous cases the PFG has more than
twice as many element nodes:  one for the nonterminal reference, one
for the rule, plus a <gi>literal</gi> element for each text node.</p>
<p>Can empirical counts confirm this?</p>
<p>Would a parse-forest map do better?</p>
</item>
</list>
</div>
</div>

<div id="known-bugs">
<head>Known bugs and test failures</head>
<p>Known bugs and shortcomings:
<list>
<item>On inputs over a few tens of characters, Aparecium is
currently unreasonably slow.</item>
</list>
</p>

<p>Test-case failures (as of 17 Feb 22):
<list>
<item>In test catalog test2:
<list>
<item>test set ambiguity-1, test amb-1</item>
</list>
</item>
<item>In test catalog zeroes:<list>
<item>zeroes-gone-bad / t-4x0 (test-catalog error, I guess:
should expect an ambiguity label)</item>
</list>
<hi>Cleared 12 April 2022.</hi></item>
<item>In test set syntax-cagt (catalog as grammar tests):
<list>
<item>elem1 (duplicate attributes)</item>
<item>illegal-class.ixml</item>
<item>rule2 (more than one rule for a nonterminal)</item>
<item>unused-rule (unreachable and undefined nonterminals)</item>
<item>unused-rules (ditto)</item>
</list></item>
<item>In test set ixml-corr:
<list>
<item>expr1:  exception in parsing XQDY0025</item>
<item>hex3:  grammar compilation failed</item>
<item>json:  grammar compilation failed</item>
<item>range:  grammar compilation failed</item>
<item>unicode-range1:  grammar compilation failed</item>
<item>element-content</item>
<item>range-comments</item>
<item>ranges1</item>
</list></item>
<item>In test set ixml-ambi:
<list>
<item>date</item>
</list></item>

<item>In test set wisps:
<list>
<item>grammar tests on grammars 02b, 02c, 02d (non-structural
nonconformance of grammars)</item>
</list>
<hi>Cleared March 2022.</hi>
</item>
</list>
</p>
<p>And to make myself feel better, here is a list of test sets
with no failures:
<list>
<item>test0</item>
<item>test1</item>
<item>misc (as of 17 Feb 22)</item>
<item>syntax-caii (catalog as instances in ixml)</item>
<item>syntax-caix (catalog as instances in XML)</item>
</list></p>
<p>The test harness used is described in a separate document
(<ptr target="test-harness"/>).</p>
</div>

<div id="change-logs">
<head>Change logs</head>
<div id="logs-v0.2">
<head>Change log for version 0.2</head>
<list>
<item>2021-08-03 : CMSMcQ : put all (well, almost all) code into
Aparecium.xml, an SWeb document.</item>
</list>
</div>
<div id="logs-v0.1">
<head>Change log for version 0.1</head>
<p>The lists below are extracted from the revision histories
at the beginnings of the individual modules.</p>
<p>Aparecium.xqm:
<list>
<item>2021-10-03 : CMSMcQ : conversion to SWeb form.</item>
<item>2019-06-03 : CMSMcQ : rename parse-string-with-compiledgrammar as
                         parse-string-with-compiled-grammar.</item>
<item>2019-04-19 : CMSMcQ : force myself to write first version</item>
</list>
</p>
<p>Earley-parser.xqm:
<list>
<item>2021-10-03 : CMSMcQ : into sweb</item>
<item>2019-04-16 : CMSMcQ : copy to new location, use new namespace names</item>
<item>2018-04-05 : CMSMcQ : start file, hesitate a bit</item>
</list>
</p>
<p>Earley-parser-internals.xqm:
<list>
<item>2019-06-30 : CMSMcQ : remove profiling code again (done for now).</item>
<item>2019-06-29 : CMSMcQ : make item-as-map branch, change all type-aware
                         references to items.  Add profiling code.</item>
<item>2019-06-03 : CMSMcQ : first cut at trimming parse tree as specified in G</item>
<item>2019-04-22 : CMSMcQ : On error, give input in full</item>
<item>2019-04-16 : CMSMcQ : move to new location, assign new namespace name</item>
<item>2018-04-08 : CMSMcQ : when ixml.xml is corrected and smart quotes
                         corrected, parses all sample ixml grammars in
                         teststrings.xml</item>
<item>2018-04-08 : CMSMcQ : passes tests for grammars 1-4, parses most 
                         but not all sample ixml grammars.</item>
<item>2018-04-07 : CMSMcQ : made stubs of earley-parser and various
                         functions for returning parse information</item>
</list>
</p>
<p>Earley-recognizer.xqm:
<list>
<item>2019-06-30 : CMSMcQ : Remove profiling code again (done for now)</item>
<item>2019-06-29 : CMSMcQ : Add profiling code to try to find speed issues</item>
<item>2019-04-15 : CMSMcQ : Move to repo, adopt new namespace names.
                      Adjust spelling of some function calls.</item>
<item>2018-04-04 : CMSMcQ : Seem to have been interrupted in this; there is
                      almost nothing here.  Starting again, from sketch
                      made this morning away from desk.  (There are
                      earlier sketches which I am not now consulting.)
                      I'm transcribing the sketch, not trying to test.
                      item() used as type for Earley items.</item>
<item>2018-03-29 : CMSMcQ : made file.  Trying to do in XQuery what I did in
                      Prolog:  small top level ignorant of data
                      representation, lower level that knows.</item>
</list>
</p>
<p>Earley-rec-internals.xqm:
<list>
<item>2019-06-30 : CMSMcQ : remove profiling code (done for now)</item>
<item>2019-06-30 : CMSMcQ : restructure accumulator in earley-closure as
                      map indexed by both start and end points:
                      $acc($n)('from') provides all items with from=$n,
                      $acc($n)('to') all items with to=$n.
                      For now, no indexing by fFinal, fPredictive,
                      or non-terminal.</item>
<item>2019-06-29 : CMSMcQ : rewrite all Earley item constructors, extractors,
                      and functions to use maps and not elements</item>
<item>2019-06-29 : CMSMcQ : make item-as-map branch in git</item>
<item>2019-06-03 : CMSMcQ : make reXTerminal deal properly with hex characters</item>
<item>2019-05-27 : CMSMcQ : resuming work.</item>
<item>2019-04-21 : CMSMcQ : tracing and other changes</item>
<item>2019-04-17 : CMSMcQ : import d2x; add charXHex(); make fNullableNG 
                      take string, not element(nonterminal); make 
                      reXTerminal() handle quote.</item>
<item>2019-04-16 : CMSMcQ : moved to repo; adopted new namespace names.
                      Improved navigation comments.
                      Improved (or supplied) function comments.</item>
<item>2018-04-05 : CMSMcQ : fixed handling of 'quoted' to use attributes;
                      worked on supplying missing functions;
                      fixed symbol/position and initial-state 
                        confusions in functions for rules and items.</item>
<item>2018-04-04 : CMSMcQ : beginning filling out the details, guided
                      by "Unknown function" messages in earley0.xq
		      and here.</item>
<item>2018-03-29 : CMSMcQ : made file.
                      Trying to do in XQuery what I did in Prolog:
                      small top level ignorant of data representation,
                      lower level that knows.  This is the lower
                      level.  To-do list in ~/2018/Earley/status...asc</item>
</list>
</p>
<p>Gluschkov.xqm:
<list>
<item>2019-04-19 : CMSMcQ : Move to repo for easier imports.</item>
<item>2016-04-05 : CMSMcQ : Completed Gluschkov constructor for use in 
                         an Earley parser.</item>
</list>
</p>
</div>
</div>

<div id="obsolete">
<head>Older versions of some code</head>
<p>Some portions of v0.2 have been made obsolete.
In some cases, changes have been made directly in
the code; in others, scraps have been replaced but
the old scraps have been retained here for
some kind of completeness, which may or may not
make sense.</p>

<div id="obs-hlf">
<head>Code using higher-level functions</head>
<p>The earlier versions of the high-level functions
<ident>all-trees()</ident>, <ident>any-tree()</ident>, etc. used
higher-level functions.  To work with engines that don't support
higher-level functions, they have been rewritten.
The code should be self-explanatory. </p>
<p>At least, I hope it is, since I don't want to
spend any time explaining it.
<scrap corresp="ep-alltrees"
       version="v0.2"
       name="Declare ep:alltrees() function">
(: ep:alltrees($I,$G):  return all loopless parse trees :)
declare function ep:all-trees(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as element()+ {
  (: trace((), 'ep:all-trees calling epi:earley-parse'), :)

  epi:earley-parse($I, $G, epi:all-trees#3)
  
  (: trace((), 'epi:earley-parse has returned '
        || 'and ep:all-trees is about to do so.') :)
};

</scrap></p>
<p>
<scrap corresp="ep-anytree"
       version="v0.2"
       name="Declare ep:anytree() function">
(: ep:anytree($I,$G):  return one (loopless) parse tree, 
   whichever is found first 
:)
declare function ep:any-tree(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as element()? {
  epi:earley-parse($I, $G, epi:any-tree#3)
};

</scrap>
</p>
<p>
<scrap corresp="ep-tree-cursor"
       version="v0.2"
       name="Declare ep:tree-cursor() function">

declare function ep:tree-cursor(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as item()* {
  epi:earley-parse($I, $G, epi:tree-cursor#3)
};
</scrap>
</p>
<p>
<scrap corresp="ep-parse-forest-map"
       version="v0.2"
       name="Declare ep:parse-forest-map() function">
(: ep:parseforestmap($I,$G):  return a map containing an and/or tree
   representing the set of all parses.
:)
declare function ep:parse-forest-map(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as element()* {
  epi:earley-parse($I, $G, epi:parse-forest-map#3)
};

</scrap>
</p>
<p>
<scrap corresp="ep-parse-forest-grammar"
       version="v0.2"
       name="Declare ep:alltrees() function">
(: ep:parseforestgrammar($I,$G):  return a BNF (not EBNF[?]) grammar
   describing the set of all parses of $I against $G.
:)
declare function ep:parse-forest-grammar(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as element()* {
  epi:earley-parse($I, $G, epi:parse-forest-grammar#3)
};
</scrap>
</p>

<p>All of the code just given requires <ident>earley-parse()</ident>
to accept a higher-level function to do crucial parts of the work.
It still doesn't seem like a bad idea, but when version <ident>pfg</ident>
was being developed it turned out that the code embeds some false
assumptions about what that function does.  Rather than unsnarl those
assumptions, I rewrote things to use options, rather than higher-level
functions, to control what gets returned (and other things).
<scrap corresp="epi-earley-parse"
       version="v0.2"
       name="Define earley-parse()">
(: ******************************************************
   earley-parse($I, $G, $f);  run Earley recognizer on 
   input $I and grammar $G, return results using 
   $f($leiClosure, $Ec, $I, $G)
:)
declare function epi:earley-parse(
  $I as xs:string,
  $G as element(ixml),
  $f as function(
    map(*)*  (: Ec :),
    map(*)* (: Closure :),
    xs:string (: Input :)
    (: , element(ixml) (: Grammar :) :)
  ) as item()* 
) as item()* {
  let $dummy := eri:notrace((), 'epi:earley-parse() ...') 
  let $mapResult := &STAT;prof:time(&TATS;
                    er:recognizeX($I, $G), 
                    &STAT;'0a recognize(): '),&TATS;

      $meiClosure := $mapResult('Closure'),
      $leiCompletions := $mapResult('Completions')
  return if ($mapResult('Result'))
    then (: if we have a result, return each parse tree :)
        let $dummy := eri:notrace((), 
                      'epi:earley-parse() has result') 
        let $lpt := &STAT;prof:time(&TATS;
                    $f($leiCompletions, $meiClosure, $I (: , $G :) )
                    &STAT;, '0b making trees: ')&TATS;
        for $pt at $npt in $lpt
        let $dummy := eri:notrace((), 
                      'epi:earley-parse() returning a result') 
        (: return if (('raw','ast')[2] eq 'raw') 
	       then $pt  
               else epi:astXparsetree($pt, count($lpt)) :)
        (: What an ugly hack!  Clean this up! :)
        (: let $logfn := '/Users/cmsmcq/'
                      || '2021/Aparecium/tests/output/raw.'
	              || translate(
                           string(
                             adjust-dateTime-to-timezone(
                               current-dateTime(), 
                               ())),
                           ' :',
                           '__')
                      || $npt
                      || '.xml'   
        return (file:write($logfn, $pt), 
                epi:astXparsetree($pt, count($lpt))) :)
        return epi:astXparsetree($pt, count($lpt)) 
        
   else (: otherwise, send an apology and explanation :)
   &lt;no-parse>
   &lt;p>Sorry, no parse for this string and grammar.&lt;/p>
   &lt;p>The completions are:&lt;/p>
   &lt;completions>{$leiCompletions}&lt;/completions>
   &lt;p>The map is:&lt;/p>
   
   &lt;Initial-Item>{eri:eXei($mapResult('Initial-Item'))}&lt;/Initial-Item>
   &lt;Input>{$mapResult('Input')}&lt;/Input>
   &lt;Input-Length>{$mapResult('Input-Length')}&lt;/Input-Length>
   &lt;Completions>{
     for $ei in $mapResult('Completions')
     return eri:eXei($ei)
   }&lt;/Completions>
   &lt;Closure>{
     let $mei := $mapResult('Closure')
     for $n in map:keys($mei('to'))
     order by $n descending
     for $ei in $mei('to')($n)
     return eri:eXei($ei)
   }&lt;/Closure>
   &lt;Result>{$mapResult('Result')}&lt;/Result>
   &lt;grammar>{(: 'Omitted.' :) $mapResult('Grammar') }&lt;/grammar>
   &lt;/no-parse>
   (: we have to think about how to return that no-parse signal.
   :)
};
</scrap>
</p>
</div>

<div id="obs-ll-sym">
<head>Code for older versions of the ixml specification grammars</head>
<p>The ixml specification grammar and its XML representation have
changed somewhat over time.  At various times, Aparecium has tried
to support multiple versions of the grammar.  Those efforts are now, I
hope, of no further interest.  In case I need them, however, I have
moved them here.</p>

<div id="obs-ll-sym-gl-regex">
<head>2013 code for terminal symbols in the Gluschkov automaton</head>
<p>In the 2013 grammar supported by Aparecium 0.1, the elements
<gi>quoted</gi>, <gi>charset</gi>, and several others were always
assumed wrapped in a <gi>terminal</gi> element.  They thus occur below
the level of the basic symbol and need no decorations.  We need to
handle them, since when the function is called on their parent
element, it will recursively be called on them, too.  But they can and
should be returned without change. 
<scrap id="gl-ME-identity-2013"
       name="Handle leaf nodes (v0.1)">
if ($E/(self::quoted
      or self::charset or self::exclude
      or self::range
      or self::schar or self::dchar))
then 
      $E</scrap>
</p>
<p><hi>Old version of handling for terminal elements in the construction
of the Gluschkov automaton.</hi> In 2013, all terminals
were <gi>terminal</gi> elements. 
<scrap id="gl-ME-terminals-2013"
       name="Handle terminal nodes (v0.1)">
if ($E/self::terminal)
then let $id := '_t_' || (1 + count($E/preceding::terminal))
     return element terminal {
       $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @follow:*)),
       attribute xml:id { $id },
       attribute nullable { false() },
       attribute first { $id },
       attribute last { $id },
       attribute {QName($gl:follow-ns, "follow:" || $id)} { },
       $children
}</scrap></p>

<p><hi>Old code for regexes in Gluschkov module.</hi></p>
<p>For ranges, the calculation of the correct regular expression
is straightforward in the simple case:  put a hyphen
between the values of the <att>from</att> and
<att>to</att> attributes, and wrap the entire thing
in square brackets.  But while those attributes
will usually contain single characters, they can
contain doubled quotation marks or hexadecimal strings
preceded by '#'.  It would be tempting to inline this,
but it's just complicated enough that I am going to write
a utility function to do it.
<scrap id="gl-read-one-ixml-char"
       name="Define gl:read-one-char-spec()">
declare function gl:read-one-char-spec(
  $s as xs:string
) as xs:string {
  if (string-length($s) eq 1)
  then string($s)
  else if ($s eq '""') 
  then '"' 
  else if ($s eq "''") 
  then "'"
  else if (starts-with($s,'#'))
  then codepoints-to-string(d2x:x2d(substring($s, 2)))
  else ""
};
</scrap>
</p>


<p>Armed with that little function, we can easily
specify the regex for a range.
<scrap id="gl-ME-identity"
       name="Handle leaf nodes">
if ($E/self::range)
then 
   element { name($E) } {
      $E/@*, 
      attribute regex {
         '['
         || gl:read-one-char-spec(string($E/@from))
	 || '-'
         || gl:read-one-char-spec(string($E/@to))
	 || ']'	 
      },
      $E/child::node()
   }
</scrap>
</p>
</div>
</div>
</div>


<div id="indices">
<head>Indices</head>
<divGen type="index-filenames"/>
<divGen type="index-scrapnames"/>
</div>

</back>
</text>
</TEI.2>
