<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="local.xsl"?>
<!DOCTYPE TEI.2 [
<!ENTITY date.last.touched '12 February 2022' >
<!ATTLIST bibl id ID #REQUIRED>
<!ATTLIST div  id ID #REQUIRED>
<!ATTLIST scrap id ID #IMPLIED>

<!ENTITY mdash  "&#x2014;" ><!--=em dash-->

<!--* Reminder:
      (progn
        (make-variable-buffer-local 'nxml-child-indent)
        (setq 'nxml-child-indent 0))

      For now, do this manually.  I don't know how to
      make Aquamacs do it using eval-last-sexp or eval-expression.
    *-->
]>
<TEI.2>
<teiHeader>
<fileDesc>
<titleStmt>
<title>Test harness for Aparecium</title>
<author>C. M. Sperberg-McQueen</author>
</titleStmt>
<publicationStmt>
<date>2022</date>
</publicationStmt>
<sourceDesc>
<p>The XML document using the TEI P3 + Sweb vocabulary is the original
form of this document.</p>
</sourceDesc>
</fileDesc>
<revisionDesc>
<list>
<item>2022-02-09/2022-02-12 : CMSMcQ : finally reach the actual test
cases and slowly knock off rough edges here and there</item>
<item>2022-02-04 : CMSMcQ : made file, to replace earlier test harness
lost in a disk crash</item>
</list>
</revisionDesc>
</teiHeader>

<text>
<front>
<titlePage>
<docTitle>
<titlePart>Test harness</titlePart>
<titlePart>for Aparecium</titlePart>
</docTitle>

<docAuthor>C. M. Sperberg-McQueen</docAuthor>
<docDate>4 February 2022, last revised &date.last.touched;</docDate>
</titlePage>
<versionList>
<version id="qd">Quick and dirty first cut</version>
<version id="alt">Alternative formulations of some constructs</version>
</versionList>

<divGen type="toc"/>
</front>
<body>
<p>This document describes a test harness for the invisible-XML
processor Aparecium.  It is a <soCalled>literate program</soCalled>:
the executable code (in this case an XQuery module) is embedded in
English prose explaining the program.  The document assumes the reader
is either familiar with XQuery, literate programming, invisible XML,
and Aparecium, or else possessed of a remarkably high tolerance for
boredom.  For more information on literate programming, Donald Knuth's
article of that name remains a good source.</p>

<p>In its current form, this document describes an initial quick and
dirty first cut, taking a lot of shortcuts in order to get something
running.  When that's done, I expect to come back and to a v0.2
version that replaces some of those quick and dirty shortcuts with
better code.</p>

<p>
<hi>To do:</hi>
<list>
<item><hi>Revise grammar-test handling to put details where
the user asked for them.</hi></item>
<item><hi>Write out external expected/reported pairs only if there is
an error; currently the R side is too eager to write a
file.</hi></item>
<item><hi>Work through test catalogs, fixing problems in the test
harness or the tests, filing issue reports for problems in
Aparecium.</hi></item>
<item><hi>(Interleaved with the above:) Improve reports and
diagnostics as occasion warrants.  In particular, in cases of failure
record more about the test inputs.</hi></item>
<item><hi>Resume work on more test sets.</hi></item>

<!-- Keep this around in case I need it again. -->
<!-- <item><hi>Tell the processor to respect whitespace when
reading the catalog and when reading expected results.  It
appears that this can be done with an invocation-time option,
with a database command from the GUI before running the
query driver, with the pragma <code>(# db:chop false #){ ... }</code>,
with <code>declare option db:chop "false"</code></hi></item> -->

</list>
</p>

<div id="task">
<head>The task</head>
<p>Our task is to define a <soCalled>test harness</soCalled> for
Aparecium.  That involves two things: first an XQuery library module
which reads a test catalog, runs the tests, evaluates the results, and
creates a report showing which test cases passed and which failed, and
second a sample XQuery module which imports and calls the library on a
particular catalog and may save or do something with the result.</p>
<p>The overall structure of the calling module is straightforward:
<scrap id="dr-top" file="test-driver.xq">
import module namespace t =
"http://blackmesatech.com/2022/iXML/test-harness"
at "../build/test-harness.xqm";

declare namespace tc =
"https://github.com/cmsmcq/ixml-tests";

declare namespace db =
"http://basex.org/modules/db";

declare option db:chop "false";

<ref target="dr-setup">Set up variables and options</ref>

let $dummy   := file:create-dir($outdir),
    $results := t:run-tests($test-catalog-uri, $options)
    
return ($results,
        file:write($report-uri, $results))
</scrap>
</p>
<p>The overall structure of the library module is similarly
conventional:
<scrap id="lib-top" file="test-harness.xqm">
module namespace t =
"http://blackmesatech.com/2022/iXML/test-harness";
<ptr target="lib-nsdecls"/>

<ref target="lib-functions">Function declarations ...</ref>
</scrap></p>
<p>Since the test catalogs we are processing use the
ixml-tests namespace, we need to declare it.  We will also
need the BaseX <ident>db</ident> namespace, in order to
set the BaseX <ident>chop</ident> option to false.
Or maybe we won't; BaseX doesn't like that option being
set in a library module.
<scrap id="lib-nsdecls"
       name="Namespace declarations and imports for library module">
declare namespace tc =
"https://github.com/cmsmcq/ixml-tests";

declare namespace db =
"http://basex.org/modules/db";

</scrap>
</p>
<p>We can look ahead to the set of functions we will define:
<scrap id="lib-functions"
       name="Declare library functions">
<ptr target="lib-run-tests"/>
<ptr target="lib-run-test-set"/>
<ptr target="lib-test-grammar"/>
<ptr target="lib-run-test-case"/>
</scrap></p>
</div>

<div id="testcat">
<head>The structure of a test catalog and the test report</head>

<p>The test collections we are interested in running will all have
test catalogs in XML, using the vocabulary defined in the author's
<ident>ixml-tests</ident> repository on GitHub. A test catalog is an
XML document containing one or more <term>test sets</term>; in the
simple case a test set specifies an ixml grammar and a set of test
cases which use that grammar.  Each test case specifies an input
string to be parsed using the grammar and an expected result.</p>
<p>Several variations are possible:
<list>
<item>A test set may contain nested test sets, to group tests in
whatever way seems useful.</item>
<item>Test sets, input grammars, input strings, and expected results
may be embedded in the test catalog or stored externally and referred
to from the catalog.  Grammars may be given in ixml (invisible XML) or
vxml (<soCalled>visible</soCalled> XML) form.</item>
<item>At each level (test catalog, test set, test case), metadata may
be provided: prose descriptions, pointers to external documentation,
and application-specific information (embedded in an <gi>app-info</gi>
element).</item>
</list>
</p>

<p>The test report we are generating will have a similar structure,
with
<list>
<item><gi>test-report</gi> containing results for a given
<gi>test-catalog</gi></item>
<item><gi>test-set-results</gi> containing results for a given
<gi>test-set</gi></item>
<item><gi>grammar-result</gi> containing the result for a given
<gi>grammar-test</gi></item>
<item><gi>test-result</gi> containing the result for a given
<gi>test-case</gi></item>
</list>
External test sets will be brought inline, so the report does not
distinguish between <gi>test-set</gi> and <gi>test-set-ref</gi>
elements in the input.</p>

<p>The schema allows <gi>grammar-result</gi> and <gi>test-result</gi>
to record the details of the test and its results.  So a
<gi>grammar-result</gi> can contain
<list>
<item><gi>ixml-grammar</gi>, <gi>ixml-grammar-ref</gi>,
<gi>vxml-grammar</gi>, or <gi>vxml-grammar-ref</gi> (or
several of these)</item>
<item>a <gi>result</gi> element containing
any of the assertions possible in a <gi>grammar-test</gi>,
followed by any of
<list>
<item><gi>reported-xml</gi></item>
<item><gi>reported-xml-ref</gi></item>
<item><gi>reported-not-a-sentence</gi></item>
<item><gi>reported-not-a-grammar</gi></item>
</list>
of which the first two can repeat and can occur together
</item>
</list>
</p>
<p>A <gi>test-result</gi> element similarly can
repeat the test input and expected results from the test
catalog, and it can also include the grammar used
and the results actually returned by the parser.</p>
<p>I'll specify user options to control the output; see
<ref target="output-options">below</ref>.
</p>

</div>

<div id="testsets">
<head>Handling test catalogs and test sets</head>

<p>Given the test catalog structure just described, the natural
structure for the test harness is thus to iterate over top-level test
sets, and within a test set to iterate over nested test sets and test
cases.</p>

<div id="setup">
<head>Preparing to call the <ident>t:run-tests()</ident> function</head>
<p>The driver will call the library's <ident>run-tests()</ident>
function with the URI of the test catalog to be run.  Several test
catalogs are available; the driver should make it easy to switch from
one to another.  Since the easiest way to refer to a directory can
vary on different machines, I'll start by putting the relevant
directory names into variables.  I'll use relative paths where
possible.  And while we're thinking about directory names, I'll define
the directory where any output should go, including a timestamp in the
directory name to allow the results of multiple test runs to be saved
without interfering with each other.
<scrap id="dr-setup" name="Set up variables and options">
let $catalog-number := 1 (: which catalog to run? 1..31 or so :)

let $invdir := "../../ixml/tests/",
    $apadir := "../../Aparecium/tests/",
    $ixtdir := "../../ixml-tests/tests-straw/",
    $outdir := resolve-uri($apadir || 'results-' 
               || adjust-dateTime-to-timezone(
                    current-dateTime(), () )
               || '/',
               static-base-uri() ),
</scrap>
</p>
<p>Next, I'll make a list of catalogs, and choose the one I want by
indexing into the list.  It's easy to change the index.
<scrap prev="dr-setup" id="dr-catfiles"
       name="List of available test-catalog files">

    $test-catalog-path := 
        (

         (: 1 2 3 :)
         $apadir || "test0.xml",
         $apadir || "test1.xml",
         $apadir || "test2.xml",

         (: 4 5 6 :)
         $invdir || "syntax/catalog-as-grammar-tests.xml",
         $invdir || "syntax/catalog-as-instance-tests-ixml.xml",
         $invdir || "syntax/catalog-as-instance-tests-ixml.xml",

         (: 7 8 9 :)
         $invdir || "correct/test-catalog.xml",
         $invdir || "ambiguous/test-catalog.xml",
         $invdir || "parse/test-catalog.xml",

         (: 10 slow :)
         $invdir || "ixml/test-catalog.xml",

         (: 11 very slow - all of the tests in the ixml repo :)
         $invdir || "test-catalog.xml",


         (: Positive and negative catalogs for various small
            grammars :)
         (: 12 13 14 15 :)
         $ixtdir || "gxxx/g010.test-catalog.xml",
         $ixtdir || "gxxx/g010.O3.test-catalog.all.neg.xml",
         $ixtdir || "gxxx/g011.test-catalog.xml",
         $ixtdir || "gxxx/g011.O3.test-catalog.all.neg.xml",

         (: 16 - 20 :)
         $ixtdir || "gxxx/g012.test-catalog.xml",
         $ixtdir || "gxxx/g012.O3.test-catalog.all.neg.xml",
         $ixtdir || "gxxx/g022.test-catalog.xml",
         $ixtdir || "gxxx/g022.O3.test-catalog.all.neg.xml",
         $ixtdir || "gxxx/g101.test-catalog.xml",

         (: 21 - 25 :)
         $ixtdir || "gxxx/g101.O3.test-catalog.all.neg.xml",
         $ixtdir || "gxxx/g102.test-catalog.xml",
         $ixtdir || "gxxx/g102.O3.test-catalog.all.neg.xml",
         $ixtdir || "gxxx/g112.test-catalog.xml",
         $ixtdir || "gxxx/g112.O3.test-catalog.all.neg.xml",

         (: 26-30, with 2, 7638, 2886, 1020, and 338 test cases.
            The positive test cases are broken. :)
         $ixtdir || "arith/arith.test-catalog.pos.xml",
         $ixtdir || "arith/arith.O3.test-catalog.arc.neg.xml",
         $ixtdir || "arith/arith.O3.test-catalog.arc-final.neg.xml",
         $ixtdir || "arith/arith.O3.test-catalog.state.neg.xml",
         $ixtdir || "arith/arith.O3.test-catalog.state-final.neg.xml",

         (: 31:  straw-man tests on ixml itself
            (n.b. old version of ixml grammar) :)
         $ixtdir || "ixml/ixml.test-catalog.pos.xml",

         (: 32:  wisps test set (currently in progress) :)
         $ixtdir || "wisps/wisp-catalog.pos.xml"

         
         )[$catalog-number],

    $test-catalog-uri := resolve-uri($test-catalog-path, 
                                     static-base-uri()),

    $report-filename := 'test-results.' 
                        || replace($test-catalog-uri,
                                   "^(.*)/([^/]*)(\.xml)",
                                   "$2")
                        || '.xml', 
    $report-uri := $outdir || $report-filename,
</scrap>
</p>

<!--
<p>And finally, now that the file name for the test catalog
has been initialized, we can fetch the catalog in order
to pass it to the library function.
<scrap prev="dr-setup" id="dr-fetch"
       name="Read in the test catalog">
    $test-catalog := doc($catfile)/tc:test-catalog,
</scrap></p>

<p>Well, wait, not quite finally:  we need to specify the options
we want to use.  But we will define those later.</p>
-->

<p>At this point in the program, we will also want to prepare an
<gi>options</gi> element to specify the options we want to use, but we
will define those <ref target="output-options">later</ref>.</p>
</div>

<div id="run-tests">
<head>Handling one test catalog: the <ident>run-tests()</ident> function</head>

<p>Now for the top-level function of the library.  The
<ident>run-tests()</ident> function gets a test catalog element and an
<gi>options</gi> element and runs the tests in that test catalog.  It
takes an <gi>options</gi> element to control some aspects of the
library's behavior.
<scrap id="lib-run-tests"
       name="The run-tests() function">

declare function t:run-tests(
  $catalog-uri as xs:string,
  $options as element(options)
) as element(tc:test-report) {

  <ptr target="lib-rt-load-cat"/>
  return element tc:test-report {
    <ptr target="lib-rt-metadata"/>
    <ptr target="lib-rt-check-cat-read"/>
    for $test-set in $catalog/*
        [self::tc:test-set or self::tc:test-set-ref]
    return t:run-test-set($test-set, 
                          (), 
                          $catalog-uri, 
                          $options)
  }
};
</scrap></p>
<p>Let's try to be careful in our I/O.
<scrap id="lib-rt-load-cat"
       name="Load catalog file into $catalog">

  let $catalog := try { 
    doc($catalog-uri)/*
  } catch err:FODC0002 {
    &lt;no-such-catalog/>
  }
</scrap>
A simpler version of this might be:
<scrap corresp="lib-rt-load-cat"
       version="alt"
       name="Load catalog file into $catalog">

  let $catalog := if (doc-available($catalog-uri))
                  then doc($catalog-uri)/*
                  else &lt;no-such-catalog/>
</scrap>
</p>
<p>If we did not get a catalog, report that fact.
<scrap id="lib-rt-check-cat-read"
       name="Check for errors reading the catalog">

    if ($catalog/self::no-such-catalog) then
      element tc:error {
        attribute id { "tc:tbd01" },
        element tc:p {
          text { "Nothing found at "},
          $catalog-uri,
          text { "." }
        }
      }
    else
</scrap>
Note the trailing <code>else</code> here.
</p>
<p>At the top of the test report we should put some metadata:
<scrap id="lib-rt-metadata" name="Supply basic metadata for the test report">

    element tc:metadata {
      element tc:name {
        'Test results for ' || $catalog/@name
      },
      element tc:report-date { 
        current-dateTime()
      },
      element tc:processor { "Aparecium" },
      element tc:processor-version { "v0.1" },
      element tc:catalog-uri { $catalog-uri },
      element tc:catalog-date { 
        ($catalog/@release-date/string(), '??')[1] 
      },
      element tc:description {
        element tc:p {
          text { "Test report generated by test-harness.xqm." }
        }
      }
    },

</scrap>
</p>
<p>This may need further elaboration.</p>
</div>

<div id="run-test-set">
<head>Handling one test set: the <ident>run-test-set()</ident> function</head>

<p>The <ident>run-test-set()</ident> function gets a
<gi>test-set</gi> element and an <gi>options</gi> element
and runs the tests in that test set.  The function may
return more than one element, because if it's called with
a <gi>test-set-ref</gi> element, it will retrieve that catalog
and return a test-set report for each <gi>test-set</gi>
or <gi>test-set-ref</gi> in that catalog.</p>
<p>This single-argument version of the function just
calls a recursive version of the function with appropriate
additional arguments.
<scrap id="lib-run-test-set"
       name="The run-test-set() function">

declare function t:run-test-set(
  $test-set as element(),
  $options as element(options)
) as element() {
  t:run-test-set($test-set, (), (), $options)
};
</scrap>
</p>
<p>The recursive version of <ident>run-test-set()</ident> takes two
additional arguments, In addition to the test set element itself.
<list>
<item><p>The first is an optional grammar.</p>
<p>Test cases normally use the grammar specified in their containing
test set, but since test sets can nest, the grammar may have been
specified by an ancestor.  So when a test set with a grammar calls the
function recursively on nested test sets, it passes the grammar along
as an argument.</p>
</item>
<item><p>The second is a stack of URIs that we have opened.  This is
used to detect reference cycles and snip them.</p></item>
</list></p>
<p>The overall structure of the function is straightforward:
we check the element we've been handed and handle it appropriately.
<scrap prev="lib-run-test-set"
       id="lib-rts3"
       name="The recursive run-test-set() function">

declare function t:run-test-set(
  $test-set as element(),
  $grammar as element()?,
  $uri-stack as xs:string*,
  $options as element(options)
) as element()+ {

  if ($test-set/self::tc:test-set-ref)
  then <ptr target="lib-rts-do-ref"/>
  else <ptr target="lib-rts-do-inline"/>
};
</scrap>
</p>
<p>The element we are dealing with may be a <gi>test-set</gi> element
(the normal case) or a <gi>test-set-ref</gi> element.  If it's the
latter, we fetch the document and deal with its top-level test sets.
<scrap id="lib-rts-do-ref"
       name="Handle a test-set reference">

       let $uri0 := base-uri($test-set),
           $uri1 := string($test-set/@href),
           $uri2 := resolve-uri($uri1, $uri0),
           $newcat := try {
             doc($uri2)
           } catch err:FODC0002 { 
             &lt;no-such-test-set/> 
           }
       return if ($newcat/self::no-such-test-set) then
           element tc:error {
             attribute id { "tc:tbd02" },
             element tc:p {
               text { "Nothing found at "},
               $uri2,
               text { "." }
             }
           }
        else for $test-set 
             in $newcat/*/*
                [self::tc:test-set 
                or self::tc:test-set-ref]
             return t:run-test-set($test-set, 
                                   $grammar, 
                                   ($uri2, $uri-stack),
                                   $options)
</scrap></p>
<p>The main case is for a <soCalled>real</soCalled> test set.
It may contain a grammar (inline or via reference, in ixml or xml),
and it may contain test cases and nested test sets.  
<scrap id="lib-rts-do-inline"
       name="Handle an inline test-set">

    let $test-set-name := $test-set/@name/string(),
        $test-set-results := element tc:test-set-results {
          $test-set/@*, 
          <ptr target="lib-rts-grammar"/>
          return (
            $grammar-test-result,
            <ptr target="lib-rts-write-grammar-result"/>
            if (($grammar-test-result/@result = 'pass')
               or empty($grammar-test-result)) 
            then (: run the tests, handle nested sets :)
                 <ptr target="lib-rts-nested"/>
            else (: no point trying to run tests :)
                element tc:description {
                  element tc:p {
                    text { "Grammar test failed, "
                        || "test cases and nested "
                        || "test sets skipped." }
                  }
                }
          )
        }
    return $test-set-results
</scrap>
</p>
<p>Later sections will describe the handling of <ref
target="grammars">grammars</ref> and <ref target="testcases">test
cases</ref>, but the recursion on nested test sets is pretty much what
might be expected: we iterate over them and call the appropriate
function to handle them.
<scrap id="lib-rts-nested"
       name="Handle nested test sets and test cases">

      for $c in $test-set/*
          [self::tc:test-set 
          or self::tc:test-set-ref
          or self::tc:test-case]
      return if ($c/self::tc:test-set 
                or $c/self::tc:test-set-ref)
      then t:run-test-set($c, 
                          $grammar, 
                          $uri-stack, 
                          $options)
      else if ($c/self::tc:test-case)
      then t:run-test-case($c, $grammar, $options)
      else element tc:error {
        attribute id { "t:tbd03" },
        text { "The laws of logic have been abrogated?" }
      }
</scrap>
</p>

</div>
</div>

<div id="grammars">
<head>Loading and testing the grammar for a test set</head>

<p>A grammar may be given inline or externally, in ixml or in XML.
The initial steps to be taken vary among the four cases, but once the
grammar is in XML the steps are the same for all.  So we begin by
getting the grammar into XML and into memory, with a four-way branch
on the nature of the grammar specification.
The locally specified grammar unconditionally overrides any grammar
passed in as an argument, and we keep life simple by using the same
name for it.
<scrap id="lib-rts-grammar"
       name="Load and test the grammar for a test set">

      let $new-xml-grammar := if ($test-set/tc:ixml-grammar)
          then <ptr target="lib-rts-ld-ixml"/>
          else if ($test-set/tc:vxml-grammar)
          then <ptr target="lib-rts-ld-vxml"/>
          else if ($test-set/tc:ixml-grammar-ref)
          then <ptr target="lib-rts-ld-ixml-ref"/> 
          else if ($test-set/tc:vxml-grammar-ref)
          then <ptr target="lib-rts-ld-vxml-ref"/>
          else ()
</scrap>
<emph>[TO DO:  prepare for and recover from errors]</emph>
</p>
<p>Each of these needs to be done cautiously.  First is
the inline ixml case.  We just wrap it in a try/catch
and hope for the best.  (Quick and dirty, remember.)
<scrap id="lib-rts-ld-ixml"
       name="Cautiously parse ixml grammar">

          try {
                ap:parse-grammar-from-string(
                    $test-set/tc:ixml-grammar/string()
                )
          } catch * {
               element tc:error {
                 attribute id { "t:tbd04" },
                 text { "ixml compilation failed" }
               }               
          }
</scrap></p>
<p>In order to call the <ident>parse-grammar-from-string()</ident>
function (and its relatives) in the Aparecium library, we are going to
need to import that library:
<scrap prev="lib-nsdecls"
       name="Namespace declarations and imports, cont'd">
import module namespace ap =
"http://blackmesatech.com/2019/iXML/Aparecium"
at "Aparecium.xqm";
</scrap></p>
<p>The second case is the inline vxml case.  Here the grammar is
already in XML, so we just assign it.
<scrap id="lib-rts-ld-vxml"
       name="Take the inline vxml grammar">
          $test-set/tc:vxml-grammar[1]/ixml
</scrap></p>

<p>The external-ixml case has several ways to fail.
For now (quick and dirty) we don't cover them all.
<scrap id="lib-rts-ld-ixml-ref"
       name="Cautiously fetch and parse external ixml grammar">

          let $uri0 := $test-set/tc:ixml-grammar-ref
                           /@href/string(),
              $uri1 := base-uri($test-set),
              $uri2 := resolve-uri($uri0, $uri1)
              return 
                if (unparsed-text-available($uri2))
                then try {
                       ap:parse-grammar-from-uri($uri2)
                     } catch * {
                       element tc:error {
                         attribute id { "t:tbd06" },
                         text { "ixml compilation failed" }
                       }
                     }
                else element tc:error {
                       attribute id { "t:tbd07" },
                       text { "external ixml not found" }
                     }
</scrap></p>

<p>The external-vxml case also has several ways to fail, most not
covered here.
<scrap id="lib-rts-ld-vxml-ref"
       name="Cautiously fetch external vxml grammar">

          let $uri0 := $test-set/tc:vxml-grammar-ref
                           /@href/string(),
              $uri1 := base-uri($test-set),
              $uri2 := resolve-uri($uri0, $uri1)
          return if (doc-available($uri2))
                 then let $xmlTmp := doc($uri2)
                      return if (exists($xmlTmp/ixml))
                             then $xmlTmp/ixml
                             else element tc:error {
                                    attribute id {"t:tbd08"},
                                    $uri0,
                                    "(" || $uri2 || ")",
                                    " is not an ixml grammar."
                             }
                 else element tc:error {
                        attribute id { "t:tbd09" },
                        text { "external vxml grammar"
                              || " not found at " },
                        $uri0,
                        text { " (i.e. "  },
                        $uri2,
                        text { ")." }
                      }
          
</scrap></p>
<p>Once we have the new XML grammar, we need to check it
for conformance.  Aparecium currently lacks any function
to do this, so for the moment this is a nop.
<scrap prev="lib-rts-grammar"
       id="lib-rts-vxml-grammar-check"
       name="Check the XML grammar for conformance">

      let $checked-xml-grammar := 
          if (true()) (: place-holder :)
          then $new-xml-grammar
          else element tc:error {
            attribute id { "t:tbd10" },
            text { "XML grammar not conformant" }
          }
</scrap>
</p>
<p>
If a grammar is given, a <gi>grammar-test</gi> may also be specified.
We need to check the value of <ident>$new-xml-grammar</ident>; if it's a
<gi>tc:error</gi> element, the grammar test failed and the
<att>id</att> attribute should tell us roughly why.  If it's anything
other than an <gi>ixml</gi> element, the grammar test failed, and we
may or may not have any inkling of why.  <emph>Aparecium needs to do a
much better job making the compilation of grammars reliable and
robust.  It's tempting to start checking grammars for problems here,
but that work belongs in Aparecium itself, so we do not do it
here.</emph>
<scrap prev="lib-rts-grammar"
       id="lib-rts-grammar-test"
       name="Handle the grammar test, if there is one">

      let $gt := $test-set/tc:grammar-test
      let $grammar-test-result := 
          if (empty($new-xml-grammar) or empty($gt))
          then ()
          else element tc:grammar-result {

              if ($checked-xml-grammar/self::ixml) 
              then t:test-grammar($gt, 
                                  $checked-xml-grammar, 
                                  $options)

              else if ($checked-xml-grammar/self::tc:error
                      /@id = ('tc:tbd04', 'tc:tbd06'))
              then (
                  (: ixml found but did not parse.
                     May be a pass, may be a fail; let
                     t:test-grammar() decide. :)
                  t:test-grammar($gt, 
                                 $checked-xml-grammar,
                                 $options)                  
              )

              else if ($checked-xml-grammar/self::tc:error
                      /@id = ('tc:tbd07', 
                              'tc:tbd08', 
                              'tc:tbd09'))
              then (
                  (: external grammar not found :)
                  attribute result { "not-run" },
                  element tc:app-info {
                      $checked-xml-grammar
                  }
              )

              else if ($checked-xml-grammar/self::tc:error
                      /@id = ('tc:tbd10'))
              then (
                  (: parsed, but is not conformant :)
                  t:test-grammar($gt, 
                                 $checked-xml-grammar,
                                 $options)
              )

              else if (not($checked-xml-grammar/self::ixml))
              then (
                  (: parsed, but did not produce 'ixml'
                     root element :)
                  t:test-grammar($gt, 
                                 $checked-xml-grammar,
                                 $options)
              )
              else (
                  attribute result { "other" },
                  element tc:description {
                    element tc:p {
                      "what on earth happened?"
                    }
                  }
              )
          }      
</scrap>
<hi>TO DO: pass options down to this level, if user asks for
individual tests to be reported to files, then do so.  At user option,
on failure write both expected result and reported result to files, to
simplify comparison.</hi>
</p>
<p>
If the new grammar is OK so far, we need to compile it.
<scrap prev="lib-rts-grammar"
       id="lib-rts-grammar-compilation"
       name="Compile the new grammar, if there is one">

      let $grammar := if (exists($new-xml-grammar))
          then try {
            ap:compile-grammar-from-xml($checked-xml-grammar)
          } catch * {
            element tc:error {
              attribute id {"t:tbd11"},
              text { 
                "Error compiling grammar"
              }
            }
          }
      else $grammar
</scrap>
</p>
<!--
<p>The <ident>load-grammar()</ident> function ...
<scrap id="lib-load-grammar"
       name="The load-grammar() function">
       </scrap>
</p>
-->
<p>The <ident>test-grammar()</ident> function is called when we have
(a) what looks like an acceptable vxml grammar and (b) a request for a
grammar test.  We must fetch the expected result, if it's external,
and compare our result to the expected result.  For now, we assume
there will never be more than one expected XML result for a grammar.
<scrap id="lib-test-grammar"
       name="The test-grammar() function">

declare function t:test-grammar(
  $grammar-test as element(tc:grammar-test),
  $xml-grammar as element(),
  $options as element(options)
) as item()* {
  <ptr target="lib-tg-fetch"/>
  <ptr target="lib-tg-compare"/>
};
</scrap></p>
<p>First, we fetch any external result.
<scrap id="lib-tg-fetch"
       name="Fetch expected result of grammar test">

  let $e0 := $grammar-test/tc:result/*[1],
      $expectation :=
        if ($e0/self::tc:assert-xml-ref)
        then let $uri0 := $e0/@href/string(),
                 $uri1 := base-uri($grammar-test),
                 $uri2 := resolve-uri($uri0, $uri1)
             return if (doc-available($uri2))
                    then (doc($uri2)/ixml,
                         element tc:error {
                           attribute id { "t:tbd12" },
                           $uri2,
                           " is not an ixml grammar."
                         })[1]
                    else element tc:error {
                      attribute id { "t:tbd13" },
                      $uri2,
                      text { " not found." }
                    }
        else $e0
</scrap>
</p>
<p>We now have an ixml grammar in one hand and an expectation in
the other.  The core task here is to perform a deep-equal comparison
on the grammar and the expectation, but we also need to check
for error conditions of various kinds.  We break the if-then-else
chain up into several code scraps to avoid having any of them get
too long.  (Informally:  if I can't see it all on one screen, the
scrap is probably too long.)
<scrap id="lib-tg-compare"
       name="Compare the grammar with the expectation">

  return
  <ptr target="lib-tg-cf-errors"/>
  <ptr target="lib-tg-cf-ok"/>
  <ptr target="lib-tg-cf-other"/>

</scrap>
<hi>TO DO:  provide better diagnostics in case of failure.</hi>
</p>
<p>The main case is here:
<scrap id="lib-tg-cf-ok"
       name="Return pass if grammar is as expected">
  else if (deep-equal($xml-grammar, $expectation))
  then (
         (: grammar conformant and as expected :)
         attribute result { "pass" }
       )
</scrap>
</p>
<p>However, we can't just run that test without checking
first to make sure the grammar and expectation are
as they should be.  So before the comparison is run, 
we check for and weed out a lot of other cases.
<scrap id="lib-tg-cf-errors"
       name="Check for error conditions, non-conformant grammar">
  if ($expectation/self::tc:error)
  then ( 
         (: something went wrong w assert-xml-ref :)
         attribute result { "not-run" },
         element tc:result {
           $expectation 
         }
       )

  else if ($expectation[self::tc:assert-not-a-grammar
           or self::tc:assert-not-a-sentence]
           and
           ($xml-grammar/self::tc:error[@id = 
           ("t:tbd04", "t:tbd06")]
           or $xml-grammar/self::no-parse)
          )
  then (
         (: grammar did not parse :)
         attribute result { "pass" },
         () (:
         element tc:result {
           $expectation,
           $xml-grammar
         } :)
       )

  else if ($expectation[self::tc:assert-not-a-grammar]
           and
           $xml-grammar/self::tc:error
                        [@id = "t:tbd10"])
  then (
         (: grammar parsed but was nonconformant :)
         attribute result { "pass" },
         element tc:result {
           $expectation,
           $xml-grammar
         }         
       )
</scrap>
</p>
<p>Finally, if no error conditions were detected but the 
grammar was not deep-equal to the expected result, we 
have a sort of catch-all error case.
<scrap id="lib-tg-cf-other"
       name="Grammar conformant but not as expected">
  else (
         (: grammar conformant but not as expected :)
         attribute result { "fail" },
         element tc:result {
           comment {
            "diagnostics should go here"
           },
           element tc:assert-xml { $expectation },
           element tc:reported-xml { $xml-grammar }
         }
       )
</scrap>
</p>

<p>If the user has specified that results should be
written out in separate files for separate tests, we
need to write out the grammar test.
<scrap id="lib-rts-write-grammar-result"
       name="Optionally write out grammar test result">

        if (($options/@details = 'by-case')
           and exists($grammar-test-result))
        then let $outfn := 'grammar-test-' || $test-set-name 
                           || '-results.xml',
                 $out := concat(
                         $options/@output-directory, 
                         '/', $outfn)
             return file:write($out, $grammar-test-result)
        else (),
</scrap>
</p>
</div>

<div id="testcases">
<head>Running the test cases</head>
<p>Once we reach a test case, we have a compiled grammar ready.
To run and evaluate the test case:
<list>
<item>Fetch the test input string, if it's external, catching
exceptions.</item>
<item>Fetch the expected results, if they are external, catching
exceptions.</item>
<item>If we failed on either the input string or the expectations,
mark the test case as not run.</item>
<item>Otherwise, attempt to parse the string with the compiled grammar
for the test set, catching exceptions.</item>
<item>Otherwise, compare the expected result with the actual result.
<list>
<item>If an exception was raised in parsing, mark the test
case as failed.  Otherwise continue.</item>
<item>If there was no parse, then
<list>
<item>if the expected result is assert-not-a-sentence (or assert-not-a-grammar?),
then report success,</item>
<item>else (expected result is an XML document) report failure.</item>
</list>
</item>
<item>If there was one parse, then
<list>
<item>if it is deep-equal to at least one XML document among the
expected results, then report success,</item>
<item>else (does not match the expected results) report
failure.</item>
<item></item>
</list></item>
<item>If there are multiple parses, then
<list>
<item>if every parse is deep-equal to at least one XML document among the
expected results, then report success,</item>
<item>else (some parse does not match the expected results) report
failure.</item>
<item></item>
</list></item>
</list>
</item>
</list>
<hi>TO DO: find a simple way to do a comparison which ignores the
presence or absence of an <att>ixml:state</att> attribute.</hi>
</p>

<p>The <ident>run-test-case()</ident> function ...
<scrap id="lib-run-test-case"
       name="The run-test-case() function">

declare function t:run-test-case(
  $test-case as element(tc:test-case),
  $G as element()?,
  $options as element(options)
) as element() {
  <ptr target="lib-rtc-misc-var"/>
  <ptr target="lib-rtc-fetch-input"/>
  <ptr target="lib-rtc-fetch-expected"/>
  <ptr target="lib-rtc-parse"/>
  <ptr target="lib-rtc-evaluate"/>
  <ptr target="lib-rtc-errors"/>
  <ptr target="lib-rtc-details"/>
  
  return (element tc:test-result {
    $test-case/@*,
    attribute result { $result },
    <ptr target="lib-rtc-report-error"/>,
    if ($options/@details eq 'inline')
    then $details
    else ()
  },
  <ptr target="lib-rtc-write-test-result"/>
  )
};
</scrap>
</p>
<p>If the input string is external, fetch it.  If we have a problem
fetching it (i.e. if there is no text at that URI), we have a problem.
We are expecting a string, and we can't return an error element.  And
we're not set up to throw and catch exceptions.  So we use a magic
string.
<scrap id="lib-rtc-fetch-input"
       name="Set $input-string">

    let $input-string := 
        if ($test-case/tc:test-string)
        then string($test-case/tc:test-string)
        else if ($test-case/tc:test-string-ref)
        then let $uri0 := $test-case
                          /tc:test-string-ref/@href
                          /string(),
                 $uri1 := base-uri($test-case),
                 $uri2 := resolve-uri($uri0, $uri1)
             return 
                 if (unparsed-text-available($uri2))
                 then unparsed-text($uri2)
                 else $failure-string
        else "Ich versteh die Welt nicht mehr"
</scrap>
</p>
<p>As our magic string we use the words <q>NOT FOUND</q> spelled out using the
<soCalled>language tag</soCalled> characters originally put into
Unicode for inline language marking and later deprecated.  We could
use any string sufficiently unlikely to be used as an external test
input.  For example, U+1D350 <q>Tetragram for failure</q> would also
work.  (And be shorter.)
For that matter, U+FFFD <q>Replacement character</q> might be
apposite here.  It's usually used when transcoding into UCS does
not work; this is roughly analogous.
<scrap id="lib-rtc-misc-var"
       name="Set some handy variables">

  let $failure-string := ("&#xE004E;&#xE004F;&#xE0054;"
                      || "&#xE0020;&#xE0046;&#xE004F;"
                      || "&#xE0055;&#xE004E;&#xE0044;"
                         (: 'NOT FOUND' in tag block :),
                         "&#x1D350;",
                         "&#xFFFD;")[2]
</scrap>
</p>

<p>If the expected results are external, we need to fetch them, too.
We need to be careful to ensure that the value of
<ident>$expectations</ident> is an element and not a document node.
<scrap id="lib-rtc-fetch-expected"
       name="Set $expectations">

    let $expectations := 
        for $e in $test-case/tc:result/*
        return if ($e/self::tc:assert-not-a-sentence)
            then $e
            else if ($e/self::tc:assert-not-a-grammar)
            then $e
            else if ($e/self::tc:assert-xml)
            then $e/*
            else if ($e/self::tc:assert-xml-ref)
            then let $uri0 := $e/@href
                              /string(),
                     $uri1 := base-uri($test-case),
                     $uri2 := resolve-uri($uri0, $uri1)
                 return 
                 if (doc-available($uri2))
                 then doc($uri2)/*
                 else element tc:error {
                   attribute id { "t:tbd14" },
                   "Expected result at ",
                   $uri0,
                   " not found. Looked for ",
                   $uri2
                 }
            else element tc:error {
                   attribute id { "t:tbd17" },
                   "Unexpected expectation ",
                   $e
                 }
</scrap>
</p>
<p>We have input string and expectations ready,
or else we are holding error markers in their place.
Time to run the test.
<scrap id="lib-rtc-parse"
       name="Set $parse-tree by parsing the test input string">

    let $parse-tree := 
        if ($input-string eq $failure-string)
        then ()
        else if ($expectations/self::tc:error)
        then ()
        else if (not($G/self::ixml))
        then element tc:error {
               attribute id { "t:tbd18" },
               element tc:msg {
                 "This is not an ixml grammar: "
               },
               $G
             }
        else try {
          ap:parse-string-with-compiled-grammar(
            $input-string,
            $G
          )
        } catch * {
          element tc:error {
              attribute id { "t:tbd16" },
              "Parse function blew up. ",
              $err:code, $err:value, 
              " module: ",
              $err:module, 
              "(", $err:line-number, ",", 
              $err:column-number, ")"
          }
        }
</scrap>
<hi>TO DO:  in other uses of try/catch, record
the error.</hi>
</p>

</div>

<div id="evaluation">
<head>Evaluating the test case results</head>


<p>Now we compare the parse tree to the expectations and set the three
variables <ident>$result</ident>, <ident>$error-details</ident>, and
<ident>$details</ident>.  Some of the conditions will be repeated,
but I don't see a good way to avoid the repetition.
<scrap id="lib-rtc-evaluate"
       name="Set $result">

    let $result :=
        if ($input-string eq $failure-string)
        then "not-run"
        else if (exists($expectations
                   /self::tc:error)) 
        then "not-run"
        else if (exists($parse-tree
                 /self::tc:error[@id = 't:tbd18'])) 
        then "fail" (: or should this be "not-run"? :)
        else if ($parse-tree/self::no-parse
                 and $expectations
                 /self::tc:assert-not-a-sentence)
        then "pass"
        else if ($parse-tree/self::no-parse
                 and $expectations
                 /self::tc:assert-not-a-grammar)
        then "pass" (: This case should not arise :)
        else if ($parse-tree/self::forest
              and 
              empty(($expectations/self::tc:assert-not-a-grammar,
              $expectations/self::tc:assert-not-a-sentence))
              and 
              (every $e1 in $parse-tree/* satisfies
              (some $e2 in $expectations satisfies
              deep-equal($e1, $e2))))
        then "pass" 
        else if (some $e1 in $expectations satisfies
                deep-equal($e1, $parse-tree))
        then "pass"
        else "fail"
</scrap></p>
<p>We only need the error details for the conditions where we caught
an error of some kind.
<scrap id="lib-rtc-errors"
       name="Set $error-details">

    let $error-details :=
        if ($input-string eq $failure-string)
        then element tc:error {
               attribute id { "t:tbd15" },
               "External test input not found."
             }
        else if (exists($expectations
                 /self::tc:error)) 
        then $expectations/self::tc:error
        else if (exists($parse-tree
                 /self::tc:error)) 
        then $parse-tree
        else ()
</scrap>
</p>
<p>
If and only if we caught an error, we will want to wrap
it in an <gi>app-info</gi> element for reporting:
<scrap id="lib-rtc-report-error"
       name="If errors arose in a test case, report them">

    if (exists($error-details))
    then element tc:app-info {
         $error-details
    }
    else ()
</scrap>
</p>
</div>

<div id="output-options">
<head>Output options</head>
<p>At this point, we need to digress for a moment to think about the
output from specific grammar tests and test cases.</p>
<p>Experience makes me believe that when running tests is fast, and
there aren't many tests, I'm happy to have all the results in a single
document.  When running tests is slow, I find myself wishing I could
examine the results from earlier tests while waiting for the run to
finish. So I would like to have the option of having test details
written out test-by-test or not.</p>
<p>And depending on what I'm doing I may want more or less detail on
tests.  Steven Pemberton's test-result files have proven very handy,
with their repetition of the input grammar, the input string, and the
produced output.  I would like to have optional control of what
details are recorded, and where.</p>
<p>Also, when a test fails because the expected result and the
reported result differ, I frequently end up saving each to disk in a
separate file so I can use an interactive comparison program to
find differences.  I'd like an option for that, too.</p>
<p>So the basic questions seem to be:
<list>
<item>The basic information on a test, i.e.  of test name and
pass/fail/not-run result, will be given unconditionally. Should
additional details of tests be given
<list>
<item>in the main output?, or</item>
<item>test-by-test in separate files (default)?, or</item>
<item>not at all?</item>
</list>
</item>
<item>When details are given, should the grammar be recorded
<list>
<item>inline, in an <gi>ixml-grammar</gi> or <gi>xml-grammar</gi>
element?, or</item>
<item>inline if short (smaller than some user-specified threshold)
and externally otherwise?, or</item>
<item>externally, using an <gi>ixml-grammar-ref</gi> or
a <gi>vxml-grammar-ref</gi> element, or both?, or</item>
<item>not at all?</item>
</list>
When external representation is requested, the grammar will be written
out to the test-reporting directory and pointed to using a relative
URI.  The name will be generated automatically from the test-set
name.</item>
<item>When details are given, should the input string be recorded
<list>
<item>inline, in a <gi>test-input</gi> element?, or</item>
<item>inline if short (smaller than some user-specified threshold)
and externally otherwise?, or</item>
<item>externally, using a <gi>test-string-ref</gi> element?, or</item>
<item>not at all?</item>
</list>
</item>
<item>When details are given, the expected result will be recorded
if the test fails.  When given, how should it be given?
<list>
<item>inline, in an <gi>assert-*</gi> element?, or</item>
<item>inline if short (smaller than some user-specified threshold)
and externally otherwise?, or</item>
<item>externally, using a <gi>assert-xml-ref</gi> element?, or</item>
<item>not at all?</item>
</list>
</item>
<item>When details are given, should the reported result be recorded
<list>
<item>inline, in an <gi>reported-*</gi> element?, or</item>
<item>inline if short (smaller than some user-specified threshold)
and externally otherwise?, or</item>
<item>externally, using a <gi>reported-xml-ref</gi> element?, or</item>
<item>not at all?</item>
</list>
</item>
<item>In case a test is failed, should the expected and reported
results be written to disk as separate files for easier comparison,
independently of what the user specified on the previous two
questions?  Yes or no.</item>
</list>
</p>

<p>The options that control what is reported and whether individual
files are written out for each test set or each test case are set in
the driver.  In order to remind myself later of what the expected
options are, I list them all and index into them to choose the one
I want for a given run.
<scrap prev="dr-setup" id="dr-options"
       name="Set the options for the test harness">

    $options := element options {
      attribute details { 
        ('inline', 
        'by-case', 
        'none')[2]
      },
      attribute input-grammar {
        ('inline',
        'inline-if-short', 
        'external',
        'none')[2]
      },
      attribute input-string {
        ('inline', 
        'inline-if-short', 
        'external',
        'none')[2]
      },
      attribute reported-result {
        ('inline', 
        'inline-if-short',
        'external',
        'none')[1]
      },
      attribute expected-result {
        ('inline', 
        'inline-if-short',
        'external',
        'none')[1]
      },
      attribute files-on-failure {
        ('yes', 
        'no')[1]
      },
      attribute inline-string-limit {
        400 
      },
      attribute inline-xml-limit {
        10
      },
      attribute output-directory {
        ($outdir)[1]
      }
    }
</scrap>
<hi>N.B. In the current version of this test harness, not all of these
options are actually supported.  And the grammar provided is the
compiled grammar, not the grammar supplied by the user.</hi>
</p>
<p><hi>Note to future-self: if comparison of expected results to
reported results becomes a burden, it may be worthwhile to offer a
<ident>result-format</ident> option with the choices <kw>native</kw>,
<kw>reified</kw>, or <kw>both</kw>.</hi></p>
</div>

<div id="output">
<head>Reporting the results</head>

<p>The top-level function <ident>t:run-tests()</ident> returns a
<gi>tc:test-report</gi> element; the caller is responsible for writing
it out to a file if desired.</p>

<p>But when the user wants separate reports for different test cases,
the caller cannot do the work; the library must handle it.</p>

<p>If the user asked for details, we provide them.  This gets
a little tedious, so I've broken it out into smaller bits.
<scrap id="lib-rtc-details"
       name="Set $details">

    let $details :=
        if ($options/@details = 'none')
        then ()
        else (
            <ptr target="lib-rtc-rpt-grammar"/>,
            <ptr target="lib-rtc-rpt-string"/>,
            <ptr target="lib-rtc-rpt-output"/>
        )
</scrap>
</p>
<p>When the user asks for things to be written out externally, we will
need a file name.  Since test cases are supposed to be named uniquely
within a test set, and test sets within a test catalog, we should be
able to just concatenate the two names.  There are several values it
will be convenient to have available when putting together the details
of the report, including the identify the containing test set and
the test set where the current grammar appeared (not necessarily the
same set).
<scrap prev="lib-rtc-misc-var"
       id="lib-rtc-mv-testset"
       name="Set $test-set-name, $test-case-ID">

    let $test-set-parent := $test-case/parent::tc:test-set,
        $test-set-grammar-host := $test-case/
            ancestor::tc:test-set
            [tc:ixml-grammar or tc:vxml-grammar
            or tc:ixml-grammar-ref
            or tc:vxml-grammar-ref]
            [1],
        $test-set-name := $test-set-parent/@name/string(),
        $grammar-name := 'grammar-' 
                         || $test-set-grammar-host
                            /@name/string()
                         || '.xml',
        $test-case-ID := concat($test-set-name, 
                                '-', 
                                $test-case
                                /@name/string())
</scrap>
</p>
<p>I ran out of patience with the inline-if-short option, so for now
we only do the other three.</p>
<p>If the user requests that the grammar be recorded, and the ixml
grammar is easy to retrieve, then that's what we record.  Otherwise,
we use the vxml grammar, if it's easy to get.  Here <q>easy to
retrieve</q> means it was inline.  If the user-specified grammar was
external, then we end up using the compiled grammar.
<scrap id="lib-rtc-rpt-grammar"
       name="Optionally report grammar used">

            let $kw := $options/@input-grammar
            let $g0 := $test-set-grammar-host
                       /*[self::tc:ixml-grammar
                       or self::tc:vxml-grammar
                       or self::tc:ixml-grammar-ref
                       or self::tc:vxml-grammar-ref]

            return if ($kw = ('inline',
                              'inline-if-short'))
            then ($g0/self::tc:ixml-grammar, 
                  $g0/self::tc:vxml-grammar, 
                  element tc:vxml-grammar {$G})[1]
            else if ($kw eq 'external')
            then element tc:vxml-grammar-ref { 
                   attribute href { $grammar-name },
                   (: and let's write the file :)
                   file:write($options/@output-directory
                             || '/' || $grammar-name,
                             $g0)
                 }
            else ()
</scrap>
<!--
<scrap id="lib-dump-grammar">
declare function t:dump-grammar(
  $G as element(ixml)
) as element(vxml-grammar) {

};
</scrap>
--></p>

<p>For the input string, it's not too hard to support
the <kw>inline-if-short</kw> option.
<scrap id="lib-rtc-rpt-string"
       name="Optionally report input string">

            let $kw := $options/@input-string,
                $fn := $test-case-ID || '.input.txt'
            return if (($kw eq 'inline')
                       or
                       (($kw eq 'inline-if-short')
                        and
                        (string-length($input-string)
                        le 
                        ($options/@inline-string-limit
                         /number(), 400)[1])))
            then element tc:test-string {
                   $input-string
                 }
            else if ($kw = ('external', 
                            'inline-if-short'))
            then element tc:test-string-ref { 
                   attribute href { $fn },
                   (: and let's write the file :)
                   file:write($options/@output-directory
                             || '/' || $fn,
                             $input-string)
                 }
            else ()
</scrap>
</p>

<p>If the user requested that either the expected output
or the reported output, or both, be included in the report,
we need to wrap them in a <gi>tc:result</gi> element.
<scrap id="lib-rtc-rpt-output"
       name="Optionally report expected and actual output">

            if (
                ($options/@expected-result ne 'none')
                or 
                ($options/@reported-result ne 'none')
                or 
                (($options/@files-on-failure ne 'no')
                 and ($result eq 'fail'))
               )
            then element tc:result {
              <ptr target="lib-rtc-rpt-expected"/>,
              <ptr target="lib-rtc-rpt-reported"/>
            }
            else ()
</scrap>
</p>
<p>We write out the expected result only if the test case
failed, but not if there was some error.  If the
expectation is not-a-sentence or not-a-grammar, then
we report it regardless of the user's option.  If we
have an XML expectation, then
<list>
<item>If the user asked for it inline, we serialize it inline.</item>
<item>If the user asked for it externally (through
either the <ident>expected-result</ident> option
or the <ident>files-on-failure</ident> option),
we serialize it externally.</item>
</list>
<scrap id="lib-rtc-rpt-expected"
       name="Optionally report expected result">

            let $kwD := $options/@expected-result,
                $kwE := $options/@files-on-failure,
                $fn  := $test-case-ID || '.expected.xml'

            return 
            if ($result eq 'fail')

            then if ($expectations
                     [self::tc:assert-not-a-sentence
                     or
                     self::tc:assert-not-a-grammar])
                 then $expectations

                 else ( 
                      if ($kwD = ('inline',
                                  'inline-if-short'))
                      then element tc:assert-xml {
                             $expectations
                           }
                      else (),

                      if (($kwD eq 'external')
                          or
                          ($kwE eq 'yes'))
                      then element tc:assert-xml-ref {
                              attribute href {$fn},
                              file:write(
                                $options/@output-directory
                                || '/' || $fn,
                                $expectations
                              )
                            }
                      else () (: unknown option, bag it :)
                      )

            else () (: $result ne 'fail' :)            
</scrap>
</p>
<p>The logic for reported results is similar but is not
conditional on failure of the test.
<scrap id="lib-rtc-rpt-reported"
       name="Optionally report parser output">

            let $kwD := $options/@reported-result,
                $kwE := $options/@files-on-failure,
                $fn  := $test-case-ID || '.reported.xml'
            return 
            if ($parse-tree/self::no-parse)
            then (element tc:reported-not-a-sentence{},
                  element tc:app-info {
                    $parse-tree
                  })

            else ( 
                   if ($kwD = ('inline', 
                               'inline-if-short'))
                   then element tc:reported-xml {
                          $parse-tree
                        }
                   else (),

                   if (($kwD eq 'external')
                       or
                       (($kwE eq 'yes') 
                        and 
                        ($result eq 'fail'))
                      )
                   then element tc:reported-xml-ref {
                          attribute href {$fn},
                          file:write(
                            $options/@output-directory
                            || '/' || $fn,
                            $parse-tree
                          )
                        }
                   else () (: unknown option :)
                 )
</scrap>

</p>

<p>If the user has specified that results should be written out in
separate files for separate tests, we need to write out the test
result.
<scrap id="lib-rtc-write-test-result"
       name="Optionally write out test result">

        if ($options/@details = 'by-case')
        then let $outfn := $test-case-ID
                           || '-test-result.xml',
                 $out := concat(
                         $options/@output-directory, 
                         '/', $outfn)
             return file:write(
                      $out, 
                      element tc:test-result {
                        $test-case/@*,
                        attribute result { $result },
                        <ptr target="lib-rtc-report-error"/>,
                        $details
                      }
                    )
        else ()
</scrap>
</p>
</div>
</body>
<back>
<divGen type="index-filenames"/>
<divGen type="index-scrapnames"/>
<divGen type="revision-history"/>
</back>
</text>
</TEI.2>
