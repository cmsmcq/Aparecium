<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="local.xsl"?>
<!DOCTYPE TEI.2 [
<!ENTITY date.last.touched '9 February 2022' >
<!ATTLIST bibl id ID #REQUIRED>
<!ATTLIST div  id ID #REQUIRED>
<!ATTLIST scrap id ID #IMPLIED>

<!ENTITY mdash  "&#x2014;" ><!--=em dash-->

<!--* Reminder:
      (progn
        (make-variable-buffer-local 'nxml-child-indent)
        (setq 'nxml-child-indent 0))

      For now, do this manually.  I don't know how to
      make Aquamacs do it using eval-last-sexp or eval-expression.
    *-->
]>
<TEI.2>
<teiHeader>
<fileDesc>
<titleStmt>
<title>Test harness for Aparecium</title>
<author>C. M. Sperberg-McQueen</author>
</titleStmt>
<publicationStmt>
<date>2022</date>
</publicationStmt>
<sourceDesc>
<p>The XML document using the TEI P3 + Sweb vocabulary is the original
form of this document.</p>
</sourceDesc>
</fileDesc>
<revisionDesc>
<list>
<item>2022-02-09 : CMSMcQ : finally reach the actual test cases ...</item>
<item>2022-02-04 : CMSMcQ : made file, to replace earlier test harness
lost in a disk crash</item>
</list>
</revisionDesc>
</teiHeader>

<text>
<front>
<titlePage>
<docTitle>
<titlePart>Test harness</titlePart>
<titlePart>for Aparecium</titlePart>
</docTitle>

<docAuthor>C. M. Sperberg-McQueen</docAuthor>
<docDate>4 February 2022, last revised &date.last.touched;</docDate>
</titlePage>
<versionList>
<version id="qd">Quick and dirty first cut</version>
<version id="alt">Alternative formulations of some constructs</version>
</versionList>

<divGen type="toc"/>
</front>
<body>
<p>This document describes a test harness for the invisible-XML
processor Aparecium.  It is a <soCalled>literate program</soCalled>:
the executable code (in this case an XQuery module) is embedded in
English prose explaining the program.  The document assumes the reader
is either familiar with XQuery, literate programming, invisible XML,
and Aparecium, or else possessed of a remarkably high tolerance for
boredom.  For more information on literate programming, Donald Knuth's
article of that name remains a good source.</p>

<p>In its current form, this document describes an initial quick and
dirty first cut, taking a lot of shortcuts in order to get something
running.  When that's done, I expect to come back and to a v0.2
version that replaces some of those quick and dirty shortcuts with
better code.</p>
<p>
<hi>The current version of some functions is not even a quick and
dirty solution yet: the first version of each function just emits a
Kilroy-was-here place-holder element, and the second version does that
and then processes its children, who also emit place-holder elements.
Once we are traversing the entire test catalog successfully, we can
start worrying about actually running tests.</hi>
</p>

<div id="task">
<head>The task</head>
<p>Our task is to define a <soCalled>test harness</soCalled> for
Aparecium.  That involves two things: first an XQuery library module
which reads a test catalog, runs the tests, evaluates the results, and
creates a report showing which test cases passed and which failed, and
second a sample XQuery module which imports and calls the library on a
particular catalog and may save or do something with the result.</p>
<p>The overall structure of the calling module is straightforward:
<scrap id="dr-top" file="test-driver.xq">
import module namespace t =
"http://blackmesatech.com/2022/iXML/test-harness"
at "../build/test-harness.xqm";

declare namespace tc =
"https://github.com/cmsmcq/ixml-tests";

<ref target="dr-setup">Set up variables and options</ref>

let $dummy   := file:create-dir($outdir),
    $results := t:run-tests($test-catalog-uri, $options)
    
return ($results,
        file:write($report-uri, $results))
</scrap>
</p>
<p>The overall structure of the library module is similarly
conventional:
<scrap id="lib-top" file="test-harness.xqm">
module namespace t =
"http://blackmesatech.com/2022/iXML/test-harness";
<ptr target="lib-nsdecls"/>

<ref target="lib-functions">Function declarations ...</ref>
</scrap></p>
<p>Since the test catalogs we are processing use the
ixml-tests namespace, we need to declare it.
<scrap id="lib-nsdecls"
       name="Namespace declarations and imports for library module">
declare namespace tc =
"https://github.com/cmsmcq/ixml-tests";
</scrap>
</p>
<p>We can look ahead to the set of functions we will define:
<scrap id="lib-functions"
       name="Declare library functions">
<ptr target="lib-run-tests"/>
<ptr target="lib-run-test-set"/>
<ptr target="lib-test-grammar"/>
<ptr target="lib-run-test-case"/>
</scrap></p>
</div>

<div id="testcat">
<head>The structure of a test catalog</head>

<p>The test collections we are interested in running will all have
test catalogs in XML, using the vocabulary defined in the author's
<ident>ixml-tests</ident> repository on GitHub. A test catalog is an
XML document containing one or more <term>test sets</term>; in the
simple case a test set specifies an ixml grammar and a set of test
cases which use that grammar.  Each test case specifies an input
string to be parsed using the grammar and an expected result.</p>
<p>Several variations are possible:
<list>
<item>A test set may contain nested test sets, to group tests in
whatever way seems useful.</item>
<item>Test sets, input grammars, input strings, and expected results
may be embedded in the test catalog or stored externally and referred
to from the catalog.  Grammars may be given in ixml (invisible XML) or
vxml (<soCalled>visible</soCalled> XML) form.</item>
<item>At each level (test catalog, test set, test case), metadata may
be provided: prose descriptions, pointers to external documentation,
and application-specific information (embedded in an <gi>app-info</gi>
element).</item>
</list>
</p>

</div>

<div id="testsets">
<head>Handling test catalogs and test sets</head>

<p>Given the test catalog structure just described, the natural
structure for the test harness is thus to iterate over top-level test
sets, and within a test set to iterate over nested test sets and test
cases.</p>

<div id="setup">
<head>Preparing to call the <ident>t:run-tests()</ident> function</head>
<p>The driver will call the library's <ident>run-tests()</ident>
function with the URI of the test catalog to be run.  Several test
catalogs are available; the driver should make it easy to switch from
one to another.  Since the easiest way to refer to a directory can
vary on different machines, I'll start by putting the relevant
directory names into variables.  I'll use relative paths where
possible.  And while we're thinking about directory names, I'll define
the directory where any output should go, including a timestamp in the
directory name to allow the results of multiple test runs to be saved
without interfering with each other.
<scrap id="dr-setup" name="Set up variables and options">
let $syndir := "../../ixml/tests/steven/syntaxtests/",
    $sptdir := "../../ixml/tests/steven/tests-SP-MSM/",
    $spxdir := "../../ixml/tests/steven/",
    $apadir := "../../Aparecium/tests/",
    $ixtdir := "../../ixml-tests/tests-straw/",
    $outdir := resolve-uri($apadir || 'results-' 
               || adjust-dateTime-to-timezone(
                    current-dateTime(), () )
               || '/',
               static-base-uri() ),
</scrap>
</p>
<p>Next, I'll make a list of catalogs, and choose the one I want by
indexing into the list.  It's easy to change the index.
<scrap prev="dr-setup" id="dr-catfiles"
       name="List of available test-catalog files">
    $test-catalog-path := 
        ($spxdir || "catalog.xml",

         (: 2 3 4 :)
         $syndir || "catalog-as-grammar-tests.xml",
         $syndir || "catalog-as-instance-tests-ixml.xml",
         $syndir || "catalog-as-instance-tests-ixml.xml",

         (: 5 :)
         $sptdir || "tests-catalog.xml",
         
         (: 6 7 8 :)
         $apadir || "test0.xml",
         $apadir || "test1.xml",
         $apadir || "test2.xml",

         (: 9-13, with 2, 7638, 2886, 1020, and 338 test cases.
            The positive test cases are broken. :)
         $ixtdir || "arith/arith.test-catalog.pos.xml",
         $ixtdir || "arith/arith.O3.test-catalog.arc.neg.xml",
         $ixtdir || "arith/arith.O3.test-catalog.arc-final.neg.xml",
         $ixtdir || "arith/arith.O3.test-catalog.state.neg.xml",
         $ixtdir || "arith/arith.O3.test-catalog.state-final.neg.xml",

         (: Positive and negative catalogs for various small
            grammars: 14-27 :)
         $ixtdir || "gxxx/g010.test-catalog.xml",
         $ixtdir || "gxxx/g010.O3.test-catalog.all.neg.xml",
         $ixtdir || "gxxx/g011.test-catalog.xml",
         $ixtdir || "gxxx/g011.O3.test-catalog.all.neg.xml",
         $ixtdir || "gxxx/g012.test-catalog.xml",
         $ixtdir || "gxxx/g012.O3.test-catalog.all.neg.xml",
         $ixtdir || "gxxx/g022.test-catalog.xml",
         $ixtdir || "gxxx/g022.O3.test-catalog.all.neg.xml",
         $ixtdir || "gxxx/g101.test-catalog.xml",
         $ixtdir || "gxxx/g101.O3.test-catalog.all.neg.xml",
         $ixtdir || "gxxx/g102.test-catalog.xml",
         $ixtdir || "gxxx/g102.O3.test-catalog.all.neg.xml",
         $ixtdir || "gxxx/g112.test-catalog.xml",
         $ixtdir || "gxxx/g112.O3.test-catalog.all.neg.xml",

         (: 28:  straw-man tests on ixml itself
            (n.b. old version of ixml grammar) :)
         $ixtdir || "ixml/ixml.test-catalog.pos.xml"
         )[7],

    $test-catalog-uri := resolve-uri($test-catalog-path, 
                                     static-base-uri()),

    $report-filename := 'test-results.' 
                        || replace($test-catalog-uri,
                                   "^(.*)/([^/]*)(\.xml)",
                                   "$2")
                        || '.xml', 
    $report-uri := $outdir || $report-filename,
</scrap>
</p>

<!--
<p>And finally, now that the file name for the test catalog
has been initialized, we can fetch the catalog in order
to pass it to the library function.
<scrap prev="dr-setup" id="dr-fetch"
       name="Read in the test catalog">
    $test-catalog := doc($catfile)/tc:test-catalog,
</scrap></p>

<p>Well, wait, not quite finally:  we need to specify the options
we want to use.  But we will define those later.</p>
-->

<p>At this point in the program, we will also want to prepare
an <gi>options</gi> element to specify the options we want to use,
but we will define those later.</p>
</div>

<div id="run-tests">
<head>Handling one test catalog: the <ident>run-tests()</ident> function</head>

<p>Now for the top-level function of the library.  The
<ident>run-tests()</ident> function gets a test catalog element and an
<gi>options</gi> element and runs the tests in that test catalog.  It
takes an <gi>options</gi> element to control some aspects of the
library's behavior.
<scrap id="lib-run-tests"
       name="The run-tests() function">
declare function t:run-tests(
  $catalog-uri as xs:string,
  $options as element(options)
) as element(tc:test-results) {

  <ptr target="lib-rt-load-cat"/>
  return element tc:test-report {
    <ptr target="lib-rt-metadata"/>
    <ptr target="lib-rt-check-cat-read"/>
    for $test-set in $catalog/*/*
        [self::tc:test-set or self::tc:test-set-ref]
    return t:run-test-set($test-set, 
                          (), 
                          $catalog-uri, 
                          $options)
  }
};
</scrap></p>
<p>Let's try to be careful in our I/O.
<scrap id="lib-rt-load-cat"
       name="Load catalog file into $catalog">
  let $catalog := try { 
    doc($catalog-uri)
  } catch err:FODC0002 {
    &lt;no-such-catalog/>
  }
</scrap>
A simpler version of this might be:
<scrap corresp="lib-rt-load-cat"
       version="alt"
       name="Load catalog file into $catalog">
  let $catalog := if (doc-available($catalog-uri))
                  then doc($catalog-uri)
                  else &lt;no-such-catalog/>
</scrap>
</p>
<p>If we did not get a catalog, report that fact.
<scrap id="lib-rt-check-cat-read"
       name="Check for errors reading the catalog">
    if ($catalog/self::no-such-catalog) then
      element tc:error {
        attribute id { "tc:tbd01" },
        element tc:p {
          text { "Nothing found at "},
          $catalog-uri,
          text { "." }
        }
      }
    else
</scrap>
Note the trailing <code>else</code> here.
</p>
<p>At the top of the test report we should put some metadata:
<scrap id="lib-rt-metadata" name="Supply basic metadata for the test report">
    attribute name {
      'Test results for ' || $catalog/@name
    },
    attribute processor { "Aparecium" },
    attribute processor-version { "v0.1" },
    attribute catalog-uri { $catalog-uri },
    attribute catalog-date { ($catalog/@release-date, '??')[1] },
    attribute report-date { 
      current-dateTime()
    },

    element tc:description {
      element tc:p {
        text { "Test report generated by test-harness.xqm." }
      }
    },
</scrap>
</p>
<p>This may need further elaboration.</p>
</div>

<div id="run-test-set">
<head>Handling one test set: the <ident>run-test-set()</ident> function</head>

<p>The <ident>run-test-set()</ident> function gets a
<gi>test-set</gi> element and an <gi>options</gi> element
and runs the tests in that test set.  The function may
return more than one element, because if it's called with
a <gi>test-set-ref</gi> element, it will retrieve that catalog
and return a test-set report for each <gi>test-set</gi>
or <gi>test-set-ref</gi> in that catalog.</p>
<p>This single-argument version of the function just
calls a recursive version of the function with appropriate
additional arguments.
<scrap id="lib-run-test-set"
       name="The run-test-set() function">
declare function t:run-test-set(
  $test-set as element(),
  $options as element(options)
) as element() {
  t:run-test-set($test-set, (), (), $options)
};
</scrap>
</p>
<p>The recursive version of <ident>run-test-set()</ident> takes two
additional arguments, In addition to the test set element itself.
<list>
<item><p>The first is an optional grammar.</p>
<p>Test cases normally use the grammar specified in their containing
test set, but since test sets can nest, the grammar may have been
specified by an ancestor.  So when a test set with a grammar calls the
function recursively on nested test sets, it passes the grammar along
as an argument.</p>
</item>
<item><p>The second is a stack of URIs that we have opened.  This is
used to detect reference cycles and snip them.</p></item>
</list></p>
<p>The overall structure of the function is straightforward:
we check the element we've been handed and handle it appropriately.
<scrap prev="lib-run-test-set"
       id="lib-rts3"
       name="The recursive run-test-set() function">
declare function t:run-test-set(
  $test-set as element(),
  $grammar as element()?,
  $uri-stack as xs:string*,
  $options as element(options)
) as element()+ {

  if ($test-set/self::tc:test-set-ref)
  then <ptr target="lib-rts-do-ref"/>
  else <ptr target="lib-rts-do-inline"/>
};
</scrap>
</p>
<p>The element we are dealing with may be a <gi>test-set</gi> element
(the normal case) or a <gi>test-set-ref</gi> element.  If it's the
latter, we fetch the document and deal with its top-level test sets.
<scrap id="lib-rts-do-ref"
       name="Handle a test-set reference">
       let $uri0 := base-uri($test-set),
           $uri1 := string($test-set/@href),
           $uri2 := resolve-uri($uri1, $uri0),
           $newcat := try {
             doc($uri2)
           } catch err:FODC0002 { 
             &lt;no-such-test-set/> 
           }
       return if ($newcat/self::no-such-test-set) then
           element tc:error {
             attribute id { "tc:tbd02" },
             element tc:p {
               text { "Nothing found at "},
               $uri2,
               text { "." }
             }
           }
        else for $test-set 
             in $newcat/*/*
                [self::tc:test-set 
                or self::tc:test-set-ref]
             return t:run-test-set($test-set, 
                                   $grammar, 
                                   ($uri2, $uri-stack),
                                   $options)
</scrap></p>
<p>The main case is for a <soCalled>real</soCalled> test set.
It may contain a grammar (inline or via reference, in ixml or xml),
and it may contain test cases and nested test sets.  
<scrap id="lib-rts-do-inline"
       name="Handle an inline test-set">
    let $test-set-name := $test-set/@name/string(),
        $test-set-results := element tc:test-set-results {
      $test-set/@*, 
      <!-- element tc:description {
        (: temporary stub :)
        element tc:p {
          text { "Place-holder: "
               || "Results from test set " },
          $test-set/@name/string(),
          text { " will go here." }
        }
      }, -->
      <ptr target="lib-rts-grammar"/>
      return (
        $grammar-test-result,
        <ptr target="lib-rts-write-grammar-result"/>
        if (($grammar-test-result/@result = 'pass')
           or empty($grammar-test-result)) 
        then (: run the tests, handle nested sets :)
             <ptr target="lib-rts-nested"/>
        else (: no point trying to run tests :)
            element tc:description {
              element tc:p {
                text { "Grammar test failed, "
                    || "test cases and nested "
                    || "test sets skipped." }
              }
            }
      )
    }
    return (<ptr target="lib-rts-write-tsr"/>
           $test-set-results)
</scrap>
</p>
<p>Later sections will describe the handling of <ref
target="grammars">grammars</ref> and <ref target="testcases">test
cases</ref>, but the recursion on nested test sets is
pretty much what might be expected:  we iterate over them
and call the appropriate function to handle them.
<scrap id="lib-rts-nested"
       name="Handle nested test sets and test cases">
      for $c in $test-set/*
          [self::tc:test-set 
          or self::tc:test-set-ref
          or self::tc:test-case]
      return if ($c/self::tc:test-set 
                or $c/self::tc:test-set-ref)
      then t:run-test-set($c, 
                          $grammar, 
                          $uri-stack, 
                          $options)
      else if ($c/self::tc:test-case)
      then t:run-test-case($c, $grammar, $options)
      else element tc:error {
        attribute id { "t:tbd03" },
        text { "The laws of logic have been abrogated?" }
      }
</scrap>
</p>
<p>If the user has specified that results should be
written out in separate files for separate tests, we
need to write out the grammar test.
<scrap id="lib-rts-write-grammar-result"
       name="Optionally write out grammar test result">
        if ($options/@files = 'by-case')
        then let $outfn := 'grammar-test-' || $test-set-name 
                           || '-results.xml',
                 $out := concat(
                         $options/@output-directory, 
                         '/', $outfn)
             return file:write($out, $grammar-test-result)
        else (),
</scrap>
</p>
<p>And similarly, if the user has specified that results should be
written out in separate files at the test set level, then we
need to write out the results for the test set.
<scrap id="lib-rts-write-tsr"
       name="Optionally write out test set results">
        if ($options/@files = 'by-outer-set')
        then let $outfn := 'test-set-' || $test-set-name 
                           || '-results.xml',
                 $out := concat(
                         $options/@output-directory, 
                         '/', $outfn)
             return file:write($out, $test-set-results)
        else (),
</scrap>
<hi>TO DO:  either figure out how to do test set results
just for outer set, or strip the option out.</hi>
</p>

</div>
</div>

<div id="grammars">
<head>Loading and testing the grammar for a test set</head>

<p>A grammar may be given inline or externally, in ixml or in XML.
The initial steps to be taken vary among the four cases, but once the
grammar is in XML the steps are the same for all.  So we begin by
getting the grammar into XML and into memory, with a four-way branch
on the nature of the grammar specification.
The locally specified grammar unconditionally overrides any grammar
passed in as an argument, and we keep life simple by using the same
name for it.
<scrap id="lib-rts-grammar"
       name="Load and test the grammar for a test set">
      let $new-xml-grammar := if ($test-set/tc:ixml-grammar)
          then <ptr target="lib-rts-ld-ixml"/>
          else if ($test-set/tc:vxml-grammar)
          then <ptr target="lib-rts-ld-vxml"/>
          else if ($test-set/tc:ixml-grammar-ref)
          then <ptr target="lib-rts-ld-ixml-ref"/> 
          else if ($test-set/tc:vxml-grammar-ref)
          then <ptr target="lib-rts-ld-vxml-ref"/>
          else ()
</scrap>
<emph>[TO DO:  prepare for and recover from errors]</emph>
</p>
<p>Each of these needs to be done cautiously.  First is
the inline ixml case.  We just wrap it in a try/catch
and hope for the best.  (Quick and dirty, remember.)
<scrap id="lib-rts-ld-ixml"
       name="Cautiously parse ixml grammar">
          try {
                ap:parse-grammar-from-string(
                    $test-set/tc:ixml-grammar/string()
                )
          } catch * {
               element tc:error {
                 attribute id { "t:tbd04" },
                 text { "ixml compilation failed" }
               }               
          }
</scrap></p>
<p>In order to call the <ident>parse-grammar-from-string()</ident>
function (and its relatives) in the Aparecium library, we are going to
need to import that library:
<scrap prev="lib-nsdecls"
       name="Namespace declarations and imports, cont'd">
import module namespace ap =
"http://blackmesatech.com/2019/iXML/Aparecium"
at "Aparecium.xqm";
</scrap></p>
<p>The second case is the inline vxml case.  Here the grammar is
already in XML, so we just assign it.
<scrap id="lib-rts-ld-vxml"
       name="Take the inline vxml grammar">
          $test-set/tc:vxml-grammar[1]/ixml
</scrap></p>

<p>The external-ixml case has several ways to fail.
For now (quick and dirty) we don't cover them all.
<scrap id="lib-rts-ld-ixml-ref"
       name="Cautiously fetch and parse external ixml grammar">
          let $uri0 := $test-set/tc:ixml-grammar-ref
                           /@href/string(),
              $uri1 := base-uri($test-set),
              $uri2 := resolve-uri($uri0, $uri1)
              return 
                if (unparsed-text-available($uri2))
                then try {
                       ap:parse-grammar-from-uri($uri2)
                     } catch * {
                       element tc:error {
                         attribute id { "t:tbd06" },
                         text { "ixml compilation failed" }
                       }
                     }
                else element tc:error {
                       attribute id { "t:tbd07" },
                       text { "external ixml not found" }
                     }
</scrap></p>

<p>The external-vxml case also has several ways to fail, most not
covered here.
<scrap id="lib-rts-ld-vxml-ref"
       name="Cautiously fetch external vxml grammar">
          let $uri0 := $test-set/tc:vxml-grammar-ref
                           /@href/string(),
              $uri1 := base-uri($test-set),
              $uri2 := resolve-uri($uri0, $uri1)
          return if (doc-available($uri2))
                 then let $xmlTmp := doc($uri2)
                      return if (exists($xmlTmp/ixml))
                             then $xmlTmp/ixml
                             else element tc:error {
                                    attribute id {"t:tbd08"},
                                    $uri0,
                                    "(" || $uri2 || ")",
                                    " is not an ixml grammar."
                             }
                 else element tc:error {
                        attribute id { "t:tbd09" },
                        text { "external vxml grammar"
                              || " not found at " },
                        $uri0,
                        text { " (i.e. "  },
                        $uri2,
                        text { ")." }
                      }
          
</scrap></p>
<p>Once we have the new XML grammar, we need to check it
for conformance.  Aparecium currently lacks any function
to do this, so for the moment this is a nop.
<scrap prev="lib-rts-grammar"
       id="lib-rts-vxml-grammar-check"
       name="Check the XML grammar for conformance">
      let $checked-xml-grammar := 
          if (true()) (: place-holder :)
          then $new-xml-grammar
          else element tc:error {
            attribute id { "t:tbd10" },
            text { "XML grammar not conformant" }
          }
</scrap>
</p>
<p>
If a grammar is given, a <gi>grammar-test</gi> may also be specified.
We need to check the value of <ident>$new-xml-grammar</ident>; if it's a
<gi>tc:error</gi> element, the grammar test failed and the
<att>id</att> attribute should tell us roughly why.  If it's anything
other than an <gi>ixml</gi> element, the grammar test failed, and we
may or may not have any inkling of why.  <emph>Aparecium needs to do a
much better job making the compilation of grammars reliable and
robust.  It's tempting to start checking grammars for problems here,
but that work belongs in Aparecium itself, so we do not do it
here.</emph>
<scrap prev="lib-rts-grammar"
       id="lib-rts-grammar-test"
       name="Handle the grammar test, if there is one">
      let $gt := $test-set/tc:grammar-test
      let $grammar-test-result := 
          if (empty($new-xml-grammar) or empty($gt))
          then ()
          else element tc:grammar-result {

              if ($new-xml-grammar/self::ixml) 
              then t:test-grammar($gt, 
                                  $new-xml-grammar, 
                                  $options)

              else if ($new-xml-grammar/self::tc:error
                      /@id = ('tc:tbd04', 'tc:tbd06'))
              then (
                  (: ixml found but did not parse.
                     May be a pass, may be a fail; let
                     t:test-grammar() decide. :)
                  t:test-grammar($gt, 
                                 $new-xml-grammar,
                                 $options)                  
              )

              else if ($new-xml-grammar/self::tc:error
                      /@id = ('tc:tbd07', 
                              'tc:tbd08', 
                              'tc:tbd09'))
              then (
                  (: external grammar not found :)
                  attribute result { "not-run" },
                  element tc:app-info {
                      $new-xml-grammar
                  }
              )

              else if ($new-xml-grammar/self::tc:error
                      /@id = ('tc:tbd10'))
              then (
                  (: parsed, but is not conformant :)
                  t:test-grammar($gt, 
                                 $new-xml-grammar,
                                 $options)
              )

              else if (not($new-xml-grammar/self::ixml))
              then (
                  (: parsed, but did not produce 'ixml'
                     root element :)
                  t:test-grammar($gt, 
                                 $new-xml-grammar,
                                 $options)
              )
              else (
                  attribute result { "other" },
                  element tc:description {
                    element tc:p {
                      "what on earth happened?"
                    }
                  }
              )
          }      
</scrap>
<hi>TO DO: pass options down to this level, if user asks for
individual tests to be reported to files, then do so.  At user option,
on failure write both expected result and reported result to files, to
simplify comparison.</hi>
</p>
<p>
If the new grammar is OK so far, we need to compile it.
<scrap prev="lib-rts-grammar"
       id="lib-rts-grammar-compilation"
       name="Compile the new grammar, if there is one">
      let $grammar := if (exists($new-xml-grammar))
          then try {
            ap:compile-grammar-from-xml($new-xml-grammar)
          } catch * {
            element tc:error {
              attribute id {"t:tbd11"},
              text { 
                "Error compiling grammar"
              }
            }
          }
      else $grammar
</scrap>
</p>
<!--
<p>The <ident>load-grammar()</ident> function ...
<scrap id="lib-load-grammar"
       name="The load-grammar() function">
       </scrap>
</p>
-->
<p>The <ident>test-grammar()</ident> function is called when we have
(a) what looks like an acceptable vxml grammar and (b) a request for a
grammar test.  We must fetch the expected result, if it's external,
and compare our result to the expected result.  For now, we assume
there will never be more than one expected XML result for a grammar.
<scrap id="lib-test-grammar"
       name="The test-grammar() function">
declare function t:test-grammar(
  $grammar-test as element(tc:grammar-test),
  $xml-grammar as element(),
  $options as element(options)
) as item()* {
  <ptr target="lib-tc-fetch"/>
  <ptr target="lib-tc-compare"/>
};
</scrap></p>
<p>First, we fetch any external result.
<scrap id="lib-tc-fetch"
       name="Fetch expected result of grammar test">
  let $e0 := $grammar-test/tc:result/*[1],
      $expectation :=
        if ($e0/self::tc:assert-xml-ref)
        then let $uri0 := $e0/@href/string(),
                 $uri1 := base-uri($grammar-test),
                 $uri2 := resolve-uri($uri0, $uri1)
             return if (doc-available($uri2))
                    then (doc($uri2)/ixml,
                         element tc:error {
                           attribute id { "t:tbd12" },
                           $uri2,
                           " is not an ixml grammar."
                         })[1]
                    else element tc:error {
                      attribute id { "t:tbd13" },
                      $uri2,
                      text { " not found." }
                    }
        else $e0
</scrap>
</p>
<p>We now have an ixml grammar in one hand and an expectation in
the other.  We perform a deep-equal comparison, and that's it.
<scrap id="lib-tc-compare"
       name="Compare the grammar with the expectation">
  return

  if ($expectation/self::tc:error)
  then ( 
         (: something went wrong w assert-xml-ref :)
         attribute result { "not-run" },
         element tc:result {
           $expectation 
         }
       )

  else if ($expectation[self::assert-not-a-grammar
           or self::assert-not-a-sentence]
           and
           $xml-grammar/self::tc:error[@id = 
           ("t:tbd04", "t:tbd06")])
  then (
         (: grammar did not parse :)
         attribute result { "pass" },
         element tc:result {
           $expectation,
           $xml-grammar
         }         
       )

  else if ($expectation[self::assert-not-a-grammar]
           and
           $xml-grammar/self::tc:error
                        [@id = "t:tbd10"])
  then (
         (: grammar parsed but was nonconformant :)
         attribute result { "pass" },
         element tc:result {
           $expectation,
           $xml-grammar
         }         
       )

  else if (deep-equal($xml-grammar, $expectation))
  then (
         (: grammar conformant and as expected :)
         attribute result { "pass" }
       )

  else (
         (: grammar conformant but not as expected :)
         attribute result { "fail" },
         element tc:result {
           element tc:p {
            "diagnostics should go here"
           },
           $expectation,
           $xml-grammar
         }
       )
</scrap>
<hi>TO DO:  provide better diagnostics in case of failure.</hi>
</p>

</div>

<div id="testcases">
<head>Running the test cases</head>
<p>Once we reach a test case, we have a compiled grammar ready.
To run and evaluate the test case:
<list>
<item>Fetch the test input string, if it's external, catching
exceptions.</item>
<item>Fetch the expected results, if they are external, catching
exceptions.</item>
<item>If we failed on either the input string or the expectations,
mark the test case as not run.</item>
<item>Otherwise, attempt to parse the string with the compiled grammar
for the test set, catching exceptions.</item>
<item>Otherwise, compare the expected result with the actual result.
<list>
<item>If an exception was raised in parsing, mark the test
case as failed.  Otherwise continue.</item>
<item>If there was no parse, then
<list>
<item>if the expected result is not-a-sentence (or not-a-grammar?),
then report success,</item>
<item>else (expected result is an XML document) report failure.</item>
</list>
</item>
<item>If there was one parse, then
<list>
<item>if it is deep-equal to at least one XML document among the
expected results, then report success,</item>
<item>else (does not match the expected results) report
failure.</item>
<item></item>
</list></item>
<item>If there are multiple parses, then
<list>
<item>if every parse is deep-equal to at least one XML document among the
expected results, then report success,</item>
<item>else (some parse does not match the expected results) report
failure.</item>
<item></item>
</list></item>
</list>
</item>
</list>
<hi>TO DO: find a simple way to do a comparison which ignores the
presence or absence of an <att>ixml:state</att> attribute.</hi>
</p>

<p>The <ident>run-test-case()</ident> function ...
<scrap id="lib-run-test-case"
       name="The run-test-case() function">
declare function t:run-test-case(
  $test-case as element(tc:test-case),
  $G as element(ixml),
  $options as element(options)
) as element() {
  (: placeholder :)
  element tc:test-result {
    $test-case/@*,
    <ptr target="lib-rtc-fetch-input"/>
    <ptr target="lib-rtc-fetch-expected"/>
    <ptr target="lib-rtc-check-ready"/>
    <ptr target="lib-rtc-parse"/>
    <ptr target="lib-rtc-evaluate"/>
  }
};
</scrap>
</p>
<p>If the input string is external, fetch it.  If we have a problem
fetching it (i.e. if there is no text at that URI), we have a problem.
We are expecting a string, and we can't return an error element.  And
we're not set up to throw and catch exceptions.  So we use a magic
string: the words <q>NOT FOUND</q> spelled out using the
<soCalled>language tag</soCalled> characters originally put into
Unicode for inline language marking and later deprecated.  We could
use any string sufficiently unlikely to be used as an external test
input.  For example, U+1D350 <q>Tetragram for failure</q> would also
work.  (And be shorter.)
<scrap id="lib-rtc-fetch-input"
       name="Fetch the test input string">
    let $input-string := 
        if ($test-case/tc:test-string)
        then string($test-case/tc:test-string)
        else if ($test-case/tc:test-string-ref)
        then let $uri0 := $test-case
                          /tc:test-string-ref/@href
                          /string(),
                 $uri1 := base-uri($test-case),
                 $uri2 := resolve-uri($uri0, $uri1)
             return 
		 if (unparsed-text-available($uri2))
                 then unparsed-text($uri2)
                 else "&#xE004E;&#xE004F;&#xE0054;"
                   || "&#xE0020;&#xE0046;&#xE004F;"
                   || "&#xE0055;&#xE004E;&#xE0044;"
                   (: 'NOT FOUND' in tag block :)
        else "Ich versteh die Welt nicht mehr"
</scrap>
</p>

<p>If the expected results are external, we need to fetch them, too.
<scrap id="lib-rtc-fetch-expected"
       name="Fetch the expected results">
    let $expectations := 
        for $e in $test-case/tc:result/*
        return if ($e/self::tc:not-a-sentence)
            then $e
            else if ($e/self::tc:not-a-grammar)
            then $e
            else if ($e/self::tc:assert-xml)
            then $e/*
            else if ($e/self::tc:assert-xml-ref)
            then let $uri0 := $e/@href
                              /string(),
                     $uri1 := base-uri($test-case),
                     $uri2 := resolve-uri($uri0, $uri1)
                 return 
		 if (doc-available($uri2))
                 then doc($uri2)
                 else element tc:error {
                   attribute id { "t:tbd14" },
                   "Expected result at ",
                   $uri0,
                   " not found. Looked for ",
                   $uri2
                 }
            else element tc:error {
                   attribute id { "t:tbd17" },
                   "Unexpected expectation ",
                   $e
            }
</scrap>
</p>
<p>
<scrap id="lib-rtc-check-ready"
       name="Check for input and expected output">
    return if ($input-string eq 
               "&#xE004E;&#xE004F;&#xE0054;"
               || "&#xE0020;&#xE0046;&#xE004F;"
               || "&#xE0055;&#xE004E;&#xE0044;")
        then (
          attribute result { "not-run" },
          element tc:app-info {
            element tc:error {
              attribute id { "t:tbd15" },
              "External test input not found."
            }
          }
        ) else if (exists($expectations
                   [self::tc:error])) then (
          attribute result { "not-run" },
          element tc:app-info {
            $expectations[self::tc:error]
          }
        ) else 
</scrap>
</p>
<p>We have input string and expectations ready.
Time to run the test.
<scrap id="lib-rtc-parse"
       name="Parse the test input string">
    let $parse-tree := try {
          ap:parse-string-with-compiled-grammar(
            $input-string,
            $G
          )
        } catch * {
          element tc:error {
              attribute id { "t:tbd16" },
              "Parse function blew up. ",
              $err:code, $err:value, 
              " module: ",
              $err:module, 
              "(", $err:line-number, ",", 
              $err:column-number, ")"
          }
        }
</scrap>
<hi>TO DO:  in other uses of try/catch, record
the error.</hi>
</p>
<p>Now we compare the parse tree to the expectations.
<scrap id="lib-rtc-evaluate"
       name="Evaluate the test results">
    return if ($parse-tree/self::no-parse
              and $expectations/self::not-a-sentence)
    then (
            attribute result { "pass" }
            (: optionally provide details :)
    ) else if ($parse-tree/self::no-parse
              and $expectations/self::not-a-grammar)
    then (
            attribute result { "pass" }
            (: optionally provide details :)
            (: This case should not arise :)

    ) else if ($parse-tree/self::forest
              and 
              empty(($expectations/self::not-a-grammar,
	      $expectations/self::not-a-sentence))
              and 
              (some $e1 in $expectations satisfies
              (some $e2 in $parse-tree/* satisfies
              deep-equal($e1, $e2)))
              )
    then (
            attribute result { "pass" }
            (: optionally provide details :)

    ) else if (some $e1 in $expectations satisfies
              deep-equal($e1, $parse-tree))
    then (
            attribute result { "pass" }
            (: optionally provide details :)

    ) else (
            attribute result { "fail" },
            $expectations[self::tc:not-a-grammar],
            $expectations[self::tc:not-a-sentence],
            for $e in $expectations[
                not(self::tc:not-a-grammar)
                and not(self::tc:not-a-sentence)
            ] return element tc:assert-xml{$e},
            if ($parse-tree/self::not-a-parse)
            then element tc:reported-not-a-sentence {}
            else if ($parse-tree/tc:error)
            then ()
            else element tc:reported-xml {$parse-tree}
    )
</scrap>
</p>

<p>The options that control what is reported and whether individual
files are written out for each test set or each test case are set in
the driver.  In order to remind myself later of what the expected
options are, I list them all and index into them to choose the one
I want for a given run.
<scrap prev="dr-setup" id="dr-options"
       name="Set the options for the test harness">
    $options := element options {
      attribute files { 
        ('by-case', 
        'by-outer-set', 
        'none')[1]
      },
      attribute report-input-grammar {
        ('internal', 
        'all',
        'none')[2]
      },
      attribute report-input-string {
        ('internal', 
        'all',
        'none')[2]
      },
      attribute report-result {
        ('native', 
        'reified',
        'none')[2]
      },
      attribute report-expected-result {
        ('on-error',
        'always',
        'none')[1]
      },
      attribute output-directory {
        ($outdir
        )[1]
      }
    }
</scrap>
</p>
</div>

<div id="evaluation">
<head>Evaluating the test case results</head>
<p>Oops.  Already explained that.</p>
<!--
<p>The <ident>evaluate-result()</ident> function ...
<scrap id="lib-evaluate"
       name="The evaluate-result() function">
</scrap>
</p> -->
</div>

<div id="output">
<head>Reporting the results</head>
<p>...</p>


<p>The <ident>...()</ident> function ...
<scrap id="lib-report-test-case"
       name="The report-test-case() function">
</scrap>
</p>
</div>
</body>
<back>
<divGen type="index-filenames"/>
<divGen type="index-scrapnames"/>
<divGen type="revision-history"/>
</back>
</text>
</TEI.2>
