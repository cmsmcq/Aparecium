<!DOCTYPE HTML><html>
<!--Need to find a way to insert the current date-->
<head><meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<title>Aparecium:  an ixml parser for XSLT and XQuery</title>

<style type="text/css">
      p {
      margin-top: 0.6em;      
      margin-bottom: 0.6em;
    }
    p.bibl {
      margin-top: 0.6em;      
      margin-bottom: 0.6em;
      margin-left: 2em;
      text-indent: -2em;
    }
    .Real-P {
      margin-top: 0.6em;      
      margin-bottom: 0.6em;
    }
    div.sp {
      margin-top: 0.6em;      
      margin-bottom: 0.6em;
    }
    div.address {
      margin-top: 0.6em;      
      margin-bottom: 0.6em;
      margin-left: 2em;
    }
    div.note {
      margin-top: 1em;      
      margin-left: 2em;
      
    }
    pre {  
      font-family: monospace;
      margin-left: 2em 
    }  
    a:hover { 
      background: #CCF 
    }
    td.no { 
      background: #CCF 
    }
    .author { 
      font-size: x-large
    }
    .bio { 
      font-size: small;
      font-style: italic
    }
    span.decision { 
    }
    span.result { 
      font-weight: bold
    }
    span.aye { 
      display: block;
      margin-left: 2em;
    }
    span.nay { 
      display: block;
      margin-left: 2em;
    }
    span.abstain { 
      display: block;
      margin-left: 2em;
    }
    span.result { 
      display: block;
      margin-left: 2em;
      font-weight: bold
    }
    span.speaker { 
      display: inline;
    }
    span.typename { 
      display: inline;
      font-family: monospace;
    }
   
  div.scrap {
    margin-top: 0.5em; 
    background-color: #CFEFCF; 
    background-color: #E7F7E7; 
    padding: 0.6em;
    margin-bottom: 0.5em;
  }
  pre.scrapbody {
    margin-left: 0.5em; 
    margin-bottom: 0.5em;
  }
  span.scrapcontinuations {
    font-size:smaller; 
  }
  span.scrapinbound {
    font-size:smaller;
  }
  span.scrapref {
    display: inline-block;
    text-indent: -0.3em;
    font-family: New Times Roman, serif, Lucida Sans Unicode;
  }
  em.scrapptr {
    font-family: New Times Roman, serif, Lucida Sans Unicode;
  }
  dl.desclist {
    list-style-type: none;
  }
  dl.desclist > dt {
    display: run-in;
    padding-right: 0.5em;
/*
*/
  }
  dl.desclist > dd {
    text-indent: -1em;
    margin-left: 1em; 
  }
  ul.desclist { 
    list-style-type: none;
  }
  ul.desclist > li {
    margin-left: 2em;
    text-indent: -2em;
  }
  div.epigraph .Real-P {margin-top: 0em; margin-bottom: 0em;} 
  </style></head><body><div class="doc">







<h1>Aparecium</h1>
<h1>An ixml parser for XSLT and XQuery</h1>

<h3>C. M. Sperberg-McQueen</h3>
<h3>Begun 16 August 2021
<br>Last rev. 23 February 2022</h3>

<div class="versionList"><p>Versions defined:</p><ul>
<li id="v0.2" class="versionentry"><em>v0.2:</em>&nbsp;Version presented at Balisage in 2020
and at Declarative Amsterdam in 2021</li>
<li id="pfg" class="versionentry"><em>pfg:</em>&nbsp;Modifications to support
production of parse-forest grammars</li>
<li id="tok0" class="versionentry"><em>tok0:</em>&nbsp;Modifications to support
faster tokenization in user-annotated grammars (falls back to v0.2)</li>
</ul></div>
<hr><a name="toc"></a>
<ul><!-- and a 1! -->
<li>1. <a href="#intro">Introduction</a></li><li>2. <a href="#overall">Overall structure</a></li><li>3. <a href="#highlevel">High-level functions</a><ul>
<!-- and a 2! -->
<li>3.1. <a href="#hi-code-org">Organization of the code</a><ul><!-- and a 3! -->
<li>3.1.1. <a href="#files-ap">Aparecium module:  <i>Aparecium.xqm</i></a></li><li>3.1.2. <a href="#files-parser">Parser:  <i>Earley-parser.xqm</i></a></li><li>3.1.3. <a href="#files-epi">Parser internals:  <i>Earley-parser-internals.xqm</i></a></li><li>3.1.4. <a href="#files-rec">Recognizer: <i>Earley-recognizer.xqm</i></a></li><li>3.1.5. <a href="#files-eri">Recognizer internals: <i>Earley-rec-internals.xqm</i></a></li></ul></li>
<li>3.2. <a href="#hi-calling">Calling the parser</a></li>
<li>3.3. <a href="#hi-prep-input">Preparing the input</a></li>
<li>3.4. <a href="#hi-prep-grammar">Preparing the grammar</a></li>
<li>3.5. <a href="#hi-earley-set">Generating the Earley set</a><ul><!-- and a 3! -->
<li>3.5.1. <a href="#hies-scan">The scanner</a></li><li>3.5.2. <a href="#hies-pred">The predictor</a></li><li>3.5.3. <a href="#hies-comp">The completer</a></li><li>3.5.4. <a href="#hies-recognizer">The recognizer</a></li></ul></li>
<li>3.6. <a href="#hi-ptc">Direct generation of parse tree</a><ul><!-- and a 3! -->
<li>3.6.1. <a href="#hi-ptc-raw">Raw parse trees</a></li><li>3.6.2. <a href="#hi-ptc-ast">Abstract syntax trees</a></li></ul></li>
<li>3.7. <a href="#hi-pfg">Generating the parse-forest grammar</a><ul><!-- and a 3! -->
<li>3.7.1. <a href="#hi-pfg-intro">Short description of parse-forest grammars</a></li><li>3.7.2. <a href="#hi-pfg-const">Constructing a parse-forest grammar</a></li><li>3.7.3. <a href="#hi-pfgc-top">The parse-forest-grammar() function</a></li><li>3.7.4. <a href="#hi-pfgc-make-rules">The <i>make-pfg-rules()</i> function</a></li><li>3.7.5. <a href="#hi-pfgc-walks">Finding walks through a rule's right-hand-side</a></li><li>3.7.6. <a href="#hi-pfgc-makerule">Making a production rule for a given walk</a></li><li>3.7.7. <a href="#hi-pfgc-recur">Preparing for the next iteration</a></li><li>3.7.8. <a href="#hi-pfgc-find-walks">The <i>find-walks()</i> function</a></li><li>3.7.9. <a href="#hi-pfgc-make-rhs">The <i>rhs-from-walk()</i> function</a></li><li>3.7.10. <a href="#hi-pfgc-make-lei">The <i>lei-from-walk()</i> function</a></li><li>3.7.11. <a href="#hi-pfgc-find-dups">The <i>dups-from-walk()</i> function</a></li></ul></li>
<li>3.8. <a href="#hi-rpt-ex-pfg">Extracting a parse tree from the parse-forest grammar</a></li>
<li>3.9. <a href="#hi-ast-ex-rpt">Extracting an abstract syntax tree from a raw parse tree</a></li>
</ul></li><li>4. <a href="#lowlevel">Low-level utility routines</a><ul>
<!-- and a 2! -->
<li>4.1. <a href="#ll-types">Abstract types</a></li>
<li>4.2. <a href="#ll-items">Working with Earley items</a><ul><!-- and a 3! -->
<li>4.2.1. <a href="#ll-items-con">Earley items - constructors</a></li><li>4.2.2. <a href="#ll-items-extr">Earley items - extractors</a></li><li>4.2.3. <a href="#ll-items-predicates">Earley items - predicates</a></li><li>4.2.4. <a href="#ll-items-closure">Earley set closure</a></li></ul></li>
<li>4.3. <a href="#ll-grammars">Working with grammars</a></li>
<li>4.4. <a href="#ll-rules">Working with rules</a></li>
<li>4.5. <a href="#ll-symbols">Working with symbols</a></li>
<li>4.6. <a href="#ll-input">Dealing with the input</a></li>
<li>4.7. <a href="#ll-utils">Utilities and miscellaneous</a><ul><!-- and a 3! -->
<li>4.7.1. <a href="#ll-utils-strings">Routines for strings and characters</a></li><li>4.7.2. <a href="#ll-utils-tracing">Trace routines</a></li></ul></li>
</ul></li><li>5. <a href="#alt-calls">Alternative interfaces</a><ul>
<!-- and a 2! -->
<li>5.1. <a href="#alt-calls-main">Main user-facing calls</a></li>
<li>5.2. <a href="#alt-calls-secondary">Secondary user-facing calls</a></li>
<li>5.3. <a href="#alt-calls-other">Non-user-facing functions</a></li>
</ul></li><li>6. <a href="#quarry">Unsorted bits of legacy code</a><ul>
<!-- and a 2! -->
<li>6.1. <a href="#legacy-Earley-parser.xqm">Earley parser</a></li>
<li>6.2. <a href="#legacy-Earley-parser-internals.xqm">Parser internals</a><ul><!-- and a 3! -->
<li>6.2.1. <a href="#epi-earley-parse-function">The <i>earley-parse()</i> function</a></li><li>6.2.2. <a href="#epi-tree-returns">Functions to return one or more trees</a></li><li>6.2.3. <a href="#epi-all-nodes">Finding a sequence of items for a single right-hand side</a></li><li>6.2.4. <a href="#epi-ast-from-raw">Extracting the abstract syntax tree from the raw parse tree</a></li></ul></li>
<li>6.3. <a href="#legacy-Gluschkov.xqm">Construction of the Gluschkov automaton</a><ul><!-- and a 3! -->
<li>6.3.1. <a href="#leggl-prolog">Module prolog</a></li><li>6.3.2. <a href="#leggl-ME">Calculating the Gluschkov automaton <i>M</i> <sub><i>E</i></sub></a></li></ul></li>
</ul></li><li>A. <a href="#references">References</a></li>
<li>B. <a href="#notation">Literate programming notation</a></li>
<li>C. <a href="#to-do">To do</a></li>
<li>D. <a href="#known-bugs">Known bugs and test failures</a></li>
<li>E. <a href="#change-logs">Change logs</a></li>
<li>F. <a href="#obsolete">Older versions of some code</a></li>
<li>G. <a href="#indices">Indices</a></li>
</ul>

<hr>
<div class="epigraph" style="margin-top: 12 pt; text-align:left; margin-left: 30%">
<blockquote>
<div class="Real-P">... Hermione was pulling her wand out of her bag.</div>
<div class="Real-P">&#x2018;It might be invisible ink!&#x2019; she whispered.</div>
<div class="Real-P">She tapped the diary three times and said,
&#x2018;Aparecium!&#x2019;</div>
</blockquote>
<div style="margin-top: 12 pt; text-align:right; margin-left: 10%; margin-right: 10%; font-size: 80%;">
J. K. Rowling, <em>Harry Potter 
and the Chamber of Secrets</em>
</div>
</div>

<div class="Real-P">This document is the source code for Aparecium, an invisible-XML
processor written in XSLT and XQuery, as a library for use in those
languages.  Aparecium is a &#x2018;literate program&#x2019;, in
the sense defined by Donald Knuth: this document contains descriptions
of the program in English prose and in XQuery and XSLT source code.
Processed in one way, the document produces XQuery and XSLT programs;
processed another way, it produces a (rather dry) technical exposition
of their structure and coding.  Readers in search of user-level
introductions to invisible XML or the use of Aparecium to build
applications will not find here what they seek.</div>

<div class="Real-P">The specific literate programming system used here is SWeb; a
description of its notation is given in <a href="#msm-1996" title="&#xA;Sperberg-McQueen, C. M.&#xA;SWEB:&#xA;an SGML Tag Set for Literate Programming.&#xA;Unpublished technical report, 1993, rev. 1994, 1995, 1996.&#xA;On the web at&#xA;http://cmsmcq.com/1993/sweb.{xml,html}.">[Sperberg-McQueen 1996]</a>.

</div>

<div class="Real-P">In its current form, the document is incomplete and not well
organized.  It was created by making a skeletal overview of the
document as it should be and then breaking the source code of a
running version of Aparecium up into chunks and inserting them into
that skeleton.  Not everything landed where it ought in principle to
have landed; the organization of the document suffered somewhat from
that.  As time permits, I hope to revise the document to make it
easier to read and better organized.</div>
<div class="Real-P">At this revision (23 February 2022), Aparecium works and passes
the large majority of the tests available.  (A list of test-case
failures as of today is given <a href="#known-bugs">in an
appendix</a>.)  The current plans for further work are 
given <a href="#to-do">in a different appendix</a>.</div>


<div class="div">

<h2><a name="intro" id="intro">1. </a>Introduction</h2>
<div class="Real-P">Aparecium is an XQuery implementation of Invisible XML (or:
ixml).  In the usual case, it accepts a context-free grammar
and input, and it returns an XML representation of the parse
tree.  Any grammar in the grammar notation defined by the
specification for Invisible XML (<a href="#pemberton-2021" title="&#xA;Pemberton, Steven.&#xA;2021.&#xA;Invisible XML Specification&#xA;(Draft).&#xA;On the web at&#xA;https://invisiblexml.org/ixml-specification.html&#xA;">[Pemberton 2021]</a>) is accepted, and the XML
representation returned will be not the raw parse tree but the
tree as modified by annotations in the grammar.
</div>

<div class="Real-P">This paper assumes that the reader is familiar with the
ideas of Invisible XML and those of Earley parsing.  Several
accessible introductions to Invisible XML can be found at
&lt;URL:<a href="http://invisiblexml.org">http://invisiblexml.org</a>&gt;, as can the formal
specification itself (<a href="#pemberton-2021" title="&#xA;Pemberton, Steven.&#xA;2021.&#xA;Invisible XML Specification&#xA;(Draft).&#xA;On the web at&#xA;https://invisiblexml.org/ixml-specification.html&#xA;">[Pemberton 2021]</a>).
A 
discussion of the particular challenges of implementing
an Earley parser in a declarative functional language,
and a re-formulation of the Earley algorithm in declarative
terms to simplify that task, may be found in
<a href="#msm-2017" title="&#xA;Sperberg-McQueen, C. M.&#xA;Translating imperative algorithms&#xA;into declarative, functional terms:&#xA;towards Earley parsing in XSLT and XQuery.&#xA;Presented at Balisage: The Markup Conference 2017,&#xA;Washington, DC, August 1 - 4, 2017.&#xA;In&#xA;Proceedings of Balisage:&#xA;The Markup Conference 2017.&#xA;Balisage Series on Markup Technologies,&#xA;vol. 19 (2017).&#xA;https://doi.org/10.4242/BalisageVol19.Sperberg-McQueen01.&#xA;">[Sperberg-McQueen 2017]</a>.</div>
</div>


<div class="div">

<h2><a name="overall" id="overall">2. </a>Overall structure</h2>
<div class="Real-P">Aparecium divides its task into several steps:
<ul><li>
<div class="Real-P">Depending on the top-level function called, we may
start work with a string containing the input to be
parsed, or with a URI which should be dereferenced in
order to obtain the string to be parsed.  The grammar may
be provided as a string, as a URI, as an XML document
containing the standard XML representation of the ixml
grammar, or as a &#x2018;compiled&#x2019; or prepared
grammar.</div>	    
<div class="Real-P">The first step is thus to collect what is needed and
put it into the form required for further processing: a
prepared grammar <i>G</i> and a string <i>I</i> (for
&#x2018;<span>input</span>&#x2019;) to be parsed.</div>
</li>
<li>
<div class="Real-P">The second step is to calculate the Earley set, a set
of Earley items sufficient to indicate whether <i>I</i> is a
sentence in <i>L(G)</i> (the language defined by <i>G</i>).</div>
<div class="Real-P">This suffices for an Earley recognizer, which
recognizes <i>L(G)</i>, but not for a parser, which identifies
the parse trees of sentences in <i>L(G)</i>.
</div>
</li>
<li>
<div class="Real-P">The next step is to use the Earley set to construct a
parse tree for the sentence.</div>
<div class="Real-P">When the sentence has only one parse tree, this is
relatively straightforward, but there are some cases of
interest in which we can expect sentences to be ambiguous,
and in which the user may wish to inspect more than one
possible parse tree.  For example, in a programming
language, keywords might have the same lexical form as
variable or function names, and this can easily give rise
to ambiguity.  Or the grammar writer may be trying to
detect possible ambiguities in a language specification
and need to examine in detail the possible parses for
ambiguous sentences.</div>
<div class="Real-P">In some cases, the number of possible parse trees
may be unbounded.[<a name="ref-to-d3e200" href="#d3e200" title="&#xA;A simple example is the grammar S:  'a';&#xA;S.,&#xA;for which the single sentence (a)&#xA;has an infinite number of parses (one S&#xA;node, two S nodes, three, ...).&#xA;Another ">1</a>]</div>
<div class="Real-P">For this reason, Aparecium can divide this step further.	   
<ul><li>
<div class="Real-P">Aparecium can extract parse trees direct from the Earley set
(though the current implementation is rather slow).  But it can also
extract a parse-forest grammar representing all parse trees
for the sentence.</div>
<div class="Real-P">Parse-forest grammars have the convenient property that they can
concisely describe more than one parse tree over the given input, even
infinite trees.  It is relatively straightforward to tell by examining
the parse-forest grammar whether it describes a single parse tree or
multiple parse trees, and whether the number of parse trees is finite
or infinite.</div>
</li>
<li>
<div class="Real-P">A separate function extracts [er, will extract] a single parse tree
from the parse-forest grammar and returns a pair consisting of (a) the
tree extracted and (b) a function which can be called to extract
another parse tree, if there is another.</div>
</li>
</ul>
</div>
</li>
<li>
<div class="Real-P">The final step is to simplify the raw parse tree as
specified in the annotation of the ixml grammar.</div>
</li>
</ul>
</div>
<div class="Real-P">Functions performing these high-level tasks are described
below in section <a href="#highlevel" title="High-level functions">3</a>.</div>
<div class="Real-P">Lower-level functions called upon by the higher-level
routines are described in section <a href="#lowlevel" title="Low-level utility routines">4</a>.</div>
</div>


<div class="div">

<h2><a name="highlevel" id="highlevel">3. </a>High-level functions</h2>
<div class="Real-P">The following sections describe the high-level
functionality described above.</div>


<div class="div">

<h3><a name="hi-code-org" id="hi-code-org">3.1. </a>Organization of the code</h3>
<div class="Real-P">The code is organized into different modules
(and files) in an attempt to keep things organized.
<ul><li><i>Aparecium.xqm</i> declares the top-level user-facing
functions for parsing (and also some cruft most users can and should
ignore).</li>
<li><i>Earley-recognizer.xqm</i> declares the high-level
functions of an Earley recognizer.  These functions prepare the
grammar, build the initial Earley item, and construct the Earley set.
The functions here are relatively abstract and are intended to be
independent of many of the lower-level implementation details, which
are factored out into an internals module.  As a recognizer, all the
main function here does is to decide whether the input given is or is
not a sentence in the language defined by the grammar.</li>
<li><i>Earley-rec-internals.xqm</i> declares low-level
functions called by the Earley recognizer.  These routines reflect
specific implementation choices from which the recognizer itself
should ideally be insulated.</li>
<li><i>Earley-parser.xqm</i> declares the high-level
functions of the Earley parser.  The main function calls the
recognizer and constructs a parse tree from the Earley set generated
by the recognizer.</li>
<li><i>Earley-parser-internals.xqm</i> contains low-level
routines for the Earley parser.</li>
<li><i>Gluschkov.xqm</i> decorates the right-hand sides of
rules in a grammar with attributes allowing the rule to be interpreted
as a finite state automaton instead of as a regular expression.</li>
</ul>
These files are described in the following paragraphs.
</div>

<div class="div">

<h4><a name="files-ap" id="files-ap">3.1.1. </a>Aparecium module:  <i>Aparecium.xqm</i></h4>
<div class="Real-P">The file <i>Aparecium.xqm</i>
contains the module the typical user will
want to import and use.
<div class="scrap"><span><a name="d3e295">&#x3008; 1  [File Aparecium.xqm]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">module namespace aparecium =
"http://blackmesatech.com/2019/iXML/Aparecium";

(: Aparecium:  a library to make invisible XML visible.

    ... Hermione was pulling her wand out of her bag.
    "It might be invisible ink!" she whispered.
    She tapped the diary three times and said, "Aparecium!"
      
                           - J. K. Rowling, Harry Potter 
                           and the Chamber of Secrets

:)

<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#aparecium-imports">Module imports for Aparecium top-level 2</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#aparecium-main">Main interfaces for Aparecium 105</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#aparecium-secondary">Secondary interfaces (a bit specialized) 108</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#aparecium-tertiary">Tertiary interfaces (of interest only for maintainer) 114</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#aparecium-variables">Variables (of interest only for maintainer) 115</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>
</div>

<div class="Real-P">The file needs to import the Earley parser and the constructor
for Gluschkov automata.
<div class="scrap"><span><a name="aparecium-imports">&#x3008; 2 Module imports for Aparecium top-level &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">import module namespace earley
   = "http://blackmesatech.com/2019/iXML/Earley-parser"
  at "Earley-parser.xqm";
import module namespace gluschkov
   = "http://blackmesatech.com/2019/iXML/Gluschkov"
  at "Gluschkov.xqm";
  
(: Quick hack for testing ... :)
import module namespace ws
   = "http://blackmesatech.com/2019/iXML/wstrimtree"
   at "wstrimtree.xqm";
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e295">[File Aparecium.xqm] 1</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<h4><a name="files-parser" id="files-parser">3.1.2. </a>Parser:  <i>Earley-parser.xqm</i></h4>
<div class="Real-P"><i>Earley-parser.xqm</i> has the functions called
by the Aparecium module to parse the input and construct the
parse tree.</div>
<div class="Real-P">As far as I have been able, the functions defined here are ignorant
of details of how the data are represented; they call functions
defined in other modules to take care of the details.
<div class="scrap"><span><a name="d3e327">&#x3008; 3  [File Earley-parser.xqm]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">module namespace ep =
"http://blackmesatech.com/2019/iXML/Earley-parser";

(: The top-level definition of an Earley parser. :)

import module namespace epi =
"http://blackmesatech.com/2019/iXML/Earley-parser-internals"
at "Earley-parser-internals.xqm";
  
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>
</div>
</div>


<div class="div">

<h4><a name="files-epi" id="files-epi">3.1.3. </a>Parser internals:  <i>Earley-parser-internals.xqm</i></h4>
<div class="Real-P">Some lower-level functions are separated out into
<i>Earley-parser-internals.xqm</i>.  These functions are not
intended to be used by users of the Earley parsers; if I knew how to
hide their names, I would.  The functions defined here are intended to
be called by the parser proper; the internal details (in particular
the representation of data structures) are subject to change.
<div class="scrap"><span><a name="d3e341">&#x3008; 4  [File Earley-parser-internals.xqm]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">module namespace epi =
"http://blackmesatech.com/2019/iXML/Earley-parser-internals";

(: Internals of Earley parser. :)
(: Not intended for user exposure. :) 

import module namespace er =
"http://blackmesatech.com/2019/iXML/Earley-recognizer"
at "Earley-recognizer.xqm";

import module namespace eri =
"http://blackmesatech.com/2019/iXML/Earley-rec-internals"
at "Earley-rec-internals.xqm";
  
declare namespace follow = 
"http://blackmesatech.com/2016/nss/ixml-gluschkov-automata-followset"; 

declare namespace ixml = 
"http://invisiblexml.org/NS";

declare namespace ap = 
"http://blackmesatech.com/2019/iXML/Aparecium";

(: We rely on the EXPath file module, and we use maps. :)
declare namespace file =
"http://expath.org/ns/file";

declare namespace map =
"http://www.w3.org/2005/xpath-functions/map";



<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-earley-parse">Define earley-parse() 124</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-all-trees">Define all-trees() 134</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-any-tree">Define any-tree() 139</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tree-cursor">Define tree-cursor() 140</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-parse-forest-map">Define parse-forest-map() 141</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-parse-forest-grammar">Define parse-forest-grammar() 15</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tree-from-pfg">The epi:tree-from-pfg() function 39</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-all-node-sequences">Define all-node-sequences() 142</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-astXparsetree">Define astXparsetree() to make AST from raw parse 157</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>
</div>
</div>


<div class="div">

<h4><a name="files-rec" id="files-rec">3.1.4. </a>Recognizer: <i>Earley-recognizer.xqm</i></h4>

<div class="Real-P">Most of the actual work done is performed by the code in
<i>Earley-recognizer.xqm</i>: 

<div class="scrap"><span><a name="Earley-rec">&#x3008; 5  [File Earley-recognizer.xqm]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">module namespace ix =
"http://blackmesatech.com/2019/iXML/Earley-recognizer";

(: Earley parser, v0 :)

import module namespace ixi =
"http://blackmesatech.com/2019/iXML/Earley-rec-internals"
at "Earley-rec-internals.xqm";

<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#er-scan">Define scan() 9</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#er-pred">Define pred() 11</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#er-comp">Define comp() 12</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#er-recognize">Define recognize() 13</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>
</div>
</div>

<div class="div">

<h4><a name="files-eri" id="files-eri">3.1.5. </a>Recognizer internals: <i>Earley-rec-internals.xqm</i></h4>
<div class="Real-P">The low-level functions of the recognizer are in
<i>Earley-rec-internals.xqm</i>.  The
&#x2018;public&#x2019; interface (the functions intended for use
by consumers) is in Earley-recognizer.xqm; this module contains
details that are subject to change and intended to be
&#x2018;private&#x2019;.</div>

<div class="Real-P">The Earley-rec-internals module has a (cyclic) import
for the recognizer itself (why?), and also some low-level
things.
<div class="scrap"><span><a name="eri-imports">&#x3008; 6 Imports for recognizer internals &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ****************************************************** 
   * Imports and setup
   ****************************************************** :)

import module namespace ix =
"http://blackmesatech.com/2019/iXML/Earley-recognizer"
at "Earley-recognizer.xqm";
  
import module namespace d2x =
'http://blackmesatech.com/2019/iXML/d2x'
at "d2x.xqm";
  
declare namespace follow = 
"http://blackmesatech.com/2016/nss/ixml-gluschkov-automata-followset";

(: $ixi:combinedups:  convenience variable for calls to 
   map:merge. :)
declare variable $ixi:combinedups as map(*)
   := map:entry('duplicates','combine');
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e411">[File Earley-rec-internals.xqm] 7</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">
The overall structure of the internals file:
<div class="scrap"><span><a name="d3e411">&#x3008; 7  [File Earley-rec-internals.xqm]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">module namespace ixi =
"http://blackmesatech.com/2019/iXML/Earley-rec-internals";

(: Earley recognizer internals :)

declare namespace map =
"http://www.w3.org/2005/xpath-functions/map";

<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-imports">Imports for recognizer internals 6</a></em> &#x3009;</span>   
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-items">Earley items (constructors, extractors, etc.) 55</a></em> &#x3009;</span>   
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-grammars">Grammars (constructors, extractors, etc.) 72</a></em> &#x3009;</span>   
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-rules">Rules (constructors, extractors, etc.) 78</a></em> &#x3009;</span>   
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-symbols">Symbols (constructors, extractors, etc.) 79</a></em> &#x3009;</span>   
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-input">Input (constructors, extractors, etc.) 86</a></em> &#x3009;</span>   
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-utils-and-misc">Utilities for recognizer internals module 91</a></em> &#x3009;</span>   
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
</div>
</div>

<div class="div">

<h3><a name="hi-calling" id="hi-calling">3.2. </a>Calling the parser</h3>
<div class="Real-P">In the simple case, Aparecium is designed to be callable
in much the same way as the <tt>doc()</tt> function.
If the file at <i>http://example.com/local.css</i>
were in XML, the expression
<tt>doc("http://example.com/local.css")</tt>
would have a document node as its value.  But a file
named <i>local.css</i> is probably not in XML.
With Aparecium, the idea is to open it with a call like
<tt>aparecium:parse-resource( "http://example.com/local.css",
"http://example.com/grammars/css.ixml")</tt>, which will
fetch the CSS file and a grammar for CSS, use the grammar
to parse the CSS, and return the document node of an XML
document representing the resulting parse tree.</div>

<div class="Real-P">

<div class="scrap"><span><a name="ap-pr">&#x3008; 8 Define parse-resource() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   parse-resource($Input, $Grammar)
   ......................................................
   Given URIs for the input and an ixml grammar 
   describing it, returns the XML representation of 
   the resource.
:)

declare function aparecium:parse-resource(
  $uriI as xs:string,
  $uriG as xs:string
) as element() {
  let $sI := unparsed-text($uriI),
      $sG := unparsed-text($uriG)
  return aparecium:parse-string($sI, $sG)
};
   
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#aparecium-main">Main interfaces for Aparecium 105</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P"><i>Move other primary functions here.</i></div>
</div>


<div class="div">

<h3><a name="hi-prep-input" id="hi-prep-input">3.3. </a>Preparing the input</h3>
<div class="Real-P">Watch this space.</div>
</div>


<div class="div">

<h3><a name="hi-prep-grammar" id="hi-prep-grammar">3.4. </a>Preparing the grammar</h3>
<div class="Real-P">Watch this space.</div>
</div>


<div class="div">

<h3><a name="hi-earley-set" id="hi-earley-set">3.5. </a>Generating the Earley set</h3>
<div class="Real-P">Watch this space.</div>


<div class="div">

<h4><a name="hies-scan" id="hies-scan">3.5.1. </a>The scanner</h4>

<div class="Real-P">There are two versions of the scanner.  The basic version
consults <i>ixi:fMatchesIPT()</i> to see whether we have a
match; if so, we get the match length and return the advance over
the terminal.
<div class="scrap"><span><a name="er-scan">&#x3008; 9 Define scan() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ****************************************************** 
   * ix:scan($E, $I)
   ****************************************************** :)
(: If $E expects any terminals which occur as expected, 
   return the advance of E over those terminals.  There 
   may be more than one. :)
   
declare function ix:scan(
  $E as item() (: ITEM :),
  $I as item() (: INPUT :)
) as item()* (: ITEM? :) {
  let $p := ixi:pToXEi($E),
      $lt := ixi:lsymExpectedXEi($E)[ixi:fTerminal(.)]
  for $t in $lt
  return
    if (ixi:fMatchesIPT($I, $p, $t))
    then ixi:leiAdvanceEiSymP($E,$t,$p + ixi:match-length($I,$p,$t))
    else ()
};

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">Other versions of this code are in &#x3008; <a href="#er-scan-pfg">Define scan()  (v. pfg) 10</a> &#x3009; <br></span><span class="scrapinbound">This code is used in &#x3008; <a href="#Earley-rec">[File Earley-recognizer.xqm] 5</a> &#x3009; <br></span>
</div>

The double call seems wasteful; it seems simpler to ask the matching
function to tell us how many characters of the input the terminal
consumed.</div>

<div class="Real-P">The <i>pfg</i> version of the code uses a single call
<i>ixi:cMatchesIPT()</i> to see whether we have a match and
how long it is.  If we have a match, we return both the advance over
the terminal and a new form of item, with a terminal rather than a
nonterminal in the rule position, and &#x201c;<tt>#terminal</tt>&#x201d;
as the rule index.

<div class="scrap"><span><a name="er-scan-pfg">&#x3008; 10 Define scan() &#x3009; (for version <em>pfg</em>) &#x2261;</a></span>
<pre class="scrapbody">(: ****************************************************** 
   * ix:scan($E, $I)
   ****************************************************** :)
(: If $E expects any terminals which occur as expected, 
   return the advance of E over those terminals.  There 
   may be more than one. :)
   
declare function ix:scan(
  $E as item() (: ITEM :),
  $I as item() (: INPUT :)
) as item()* (: ITEM? :) {
  let $p := ixi:pToXEi($E),
      $lt := ixi:lsymExpectedXEi($E)[ixi:fTerminal(.)]
  for $t in $lt
  return
    let $c := ixi:cMatchesIPT($I, $p, $t)
    return 
    if ($c ge 0)
    then (ixi:leiAdvanceEiSymP($E, $t, $p + $c),
         ixi:eiMakePPT($p, $p + $c, $t))
    else ()
};

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#er-scan">Define scan() 9</a> &#x3009; </span>
</div>

</div>
</div>

<div class="div">

<h4><a name="hies-pred" id="hies-pred">3.5.2. </a>The predictor</h4>

<div class="Real-P">
<div class="scrap"><span><a name="er-pred">&#x3008; 11 Define pred() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ****************************************************** 
   * ix:pred($E, $G)
   ****************************************************** :)
(: If $E predicts any non-terminals, return items which 
   expect those non-terminals at the appropriate location. 
   :)
   
declare function ix:pred(
  $E as item() (: ITEM :),
  $G as item() (: GRAMMAR :)
) as item()* (: ITEM :) {
  (: iterate over
       $ln nonterminals expected by $E,
       $lr rules in $G for $n,
       $lri initial positions in $r
     also return advance of $E for nullable $n
   :)
   let $p := ixi:pToXEi($E),
       $ln := ixi:lsymExpectedXEi($E)[ixi:fNonterminal(.)]
   for $n in $ln
   let $fNullable := ixi:fNullableNG($n/@name, $G),
       $lr := ixi:lrulesXNG($n,$G)
   return (
     (: first, return advance of $E if $n nullable :)
     if ($fNullable)
     then ixi:leiAdvanceEiSymP($E,$n,$p)
     else (),
       
     (: then iterate over rules and initial locations for $n :)
     for $r in $lr
     let $lri := ixi:lriStartstatesXR($r)
     for $ri in $lri
     return ixi:eiMakePPRRi($p, $p, $r, $ri)
   )
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#Earley-rec">[File Earley-recognizer.xqm] 5</a> &#x3009; <br></span>
</div>
</div>
</div>


<div class="div">

<h4><a name="hies-comp" id="hies-comp">3.5.3. </a>The completer</h4>

<div class="Real-P">
<div class="scrap"><span><a name="er-comp">&#x3008; 12 Define comp() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ****************************************************** 
   * ix:comp($Ec, $Ep)
   ****************************************************** :)
(: If $Ec and $Ep are a prediction/completion pair, return
   the advance of $Ep over the non-terminal predicted by 
   $Ec. :)
   
(: comp($Ec, $Ep): if $Ec is a completion item, 
   and $Ep a prediction item,
   and $Ep predicts a nonterminal $n at position $pPTo,
   and $Ec completes $n starting at $pCFrom=$pPTo,
   then advance $Ep over $n and place the new to-position
   at the to-position of $Ec.
   
   The test for whether $Ep expects $n is handled
   by leiAdvanceEiSymP, so we need not make it here.
:)
declare function ix:comp(
  $Ec as item() (: ITEM :),
  $Ep as item() (: ITEM :)
) as item()* (: ITEM :) {
  let $pCFrom := ixi:pFromXEi($Ec),
      $pCTo   := ixi:pToXEi($Ec),
      (: $pPFrom := ixi:pFromXEi($Ep), :)
      $pPTo   := ixi:pToXEi($Ep),
      $n      := ixi:nLhsXEi($Ec),
      $RESULT := if (ixi:fFinalEi($Ec)
                    and $pPTo eq $pCFrom)
                 then ixi:leiAdvanceEiSymP($Ep, $n, $pCTo)
                 else ()
  return $RESULT
};

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#Earley-rec">[File Earley-recognizer.xqm] 5</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<h4><a name="hies-recognizer" id="hies-recognizer">3.5.4. </a>The recognizer</h4>
<div class="Real-P">The <i>ix:recognize()</i> function accepts an input string
and a grammar, and returns a boolean: true if the input is a sentence
in the language defined by the grammar, false otherwise.  On the way
to reaching that result, of course, a lot of intermediate results will
be calculated, some of them of interest for other purposes (e.g. for
the parser as a whole).  So there are two recognition functions: one
to calculate and expose all the intermediate results, and one to
expose only the boolean result, which calls the other function to do
the preliminary work.  The <i>ix:recognize()</i> function
works as a kind of wrapper around the other function:
<div class="scrap"><span><a name="er-recognize">&#x3008; 13 Define recognize() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function ix:recognize(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as xs:boolean {
  let $m := ix:recognizeX($I, $G)
  return $m('Result')
};

</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e548">Define recognizeX() 14</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#Earley-rec">[File Earley-recognizer.xqm] 5</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The <i>ix:recognizeX()</i> function (an extended
recognizer, if you will)
<div class="scrap"><span><a name="d3e548">&#x3008; 14 Define recognizeX() [continues <a href="#er-recognize">13 Define recognize()</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function ix:recognizeX(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as map(*) {
  let $G2 := ixi:augment-grammar($G),
      $symStart0 := ixi:symStartG($G),
      $symStart2 := ixi:symStartG($G2),
      $rInitial := ixi:lrulesXNG(
        &lt;nonterminal name="{$symStart2}"/&gt;, 
        $G2)[1],
      $riInitial := ixi:lriStartstatesXR($rInitial)[1],
      $eiInitial := ixi:eiMakePPRRi(0, 0, 
                                    $rInitial, 
                                    $riInitial),
      $len := ixi:inputlength($I),
      
      $meiClosure := 
          ixi:earley-closure($eiInitial, $I, $G2),
      (: $leiCompletions := $meiClosure
         [ixi:fFinalEiPPN(.,0,$len,$symStart2)], :)
      $leiCompletions := $meiClosure('from')(0)
                         [ixi:fFinalEiPPN(., 0,
                                          $len,
                                          $symStart2)],
      $result := exists($leiCompletions)

  return map {
    'Grammar' : $G2,
    'Initial-Item' : $eiInitial,
    'Input' : $I,
    'Input-Length' : $len,
    'Closure' : $meiClosure,
    'Completions' : $leiCompletions,
    'Result' : $result
  }
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
</div>
</div>


<div class="div">

<h3><a name="hi-ptc" id="hi-ptc">3.6. </a>Direct generation of parse tree</h3>
<div class="Real-P">In version 0.2 of Aparecium, we generate one
or more parse trees directly from the Earley set.
(In future versions, it is expected that we will
generate a parse-forest grammar from the Earley
set, and generate trees from that grammar, or
return the grammar to the user.  But at the moment
that's just pie in the sky.)</div>
<div class="Real-P">We generate the parse trees in two steps.
From the Earley set, we generate a raw parse tree
which records every nonterminal used (we may
regret this, eventually).  From the raw parse tree,
we create the abstract syntax tree by attending to
the marks on the nonterminals.
</div>

<div class="div">

<h4><a name="hi-ptc-raw" id="hi-ptc-raw">3.6.1. </a>Raw parse trees</h4>
<div class="Real-P">For raw parse trees, we use a generic XML
representation with two element types:
<ul><li>&lt;<em>nt</em>&gt; elements record that a given nonterminal was parsed
at a given location, with attributes providing details:
<ul><li><em>name</em> gives the nonterminal symbol.</li>
<li><em>_from</em> and <em>_to</em> give the
range in the input.</li>
<li><em>mark</em> records the mark effective for this instance of
the nonterminal.  If a nonterminal in a right-hand side carries a
mark, we record it here; if not, we fetch the default value; if no
default value is specified, we supply the value
&#x201c;<tt>^</tt>&#x201d;.</li>
</ul>
</li>
<li>&lt;<em>lit</em>&gt;, &lt;<em>inc</em>&gt;, and &lt;<em>exc</em>&gt; elements record
that a given terminal was found at a given location, with attributes
providing details:
<ul><li><em>name</em> gives the nonterminal symbol.</li>
<li><em>_from</em> and <em>_to</em> give the
range in the input.  For &lt;<em>inc</em>&gt; and &lt;<em>exc</em>&gt;
the two values will be the same, but not necessarily so
for literals.</li>
<li><em>tmark</em> records the terminal mark effective for this
the nonterminal.  This is what makes it possible to suppress
terminals marked &#x201c;<tt>-</tt>&#x201d; (or inject
terminals marked &#x201c;<tt>+</tt>&#x201d;, which doesn't seem
to have made it into the spec yet).</li>
</ul>
</li>
</ul>
Representing nonterminal nodes as &lt;<em>nt</em>&gt; elements
instead of elements with the nonterminal itself as a name
allows terminals marked for suppression to be distinguished
reliably from nonterminals marked &#x201c;<tt>-</tt>&#x201d;.
(It also allows the raw parse tree to be produced even if
the nonterminal is not a legal XML name.)
</div>
<div class="Real-P">N.B. The initial implementation of raw parse trees
used nonterminals as element names; there may be traces
of that state of affairs in this document.</div>
<div class="Real-P"><i>all-node-sequences() should be described here.</i>
For the moment, see <a href="#epi-all-nodes">Finding a sequence of items for a single right-hand side</a>.</div>
</div>

<div class="div">

<h4><a name="hi-ptc-ast" id="hi-ptc-ast">3.6.2. </a>Abstract syntax trees</h4>
<div class="Real-P"><i>The epi:astXparsetree() function should
go here.  For now, see <a href="#epi-ast-from-raw">Extracting the abstract syntax tree from the raw parse tree</a>.</i></div>
</div>

</div>


<div class="div">

<h3><a name="hi-pfg" id="hi-pfg">3.7. </a>Generating the parse-forest grammar</h3>

<div class="Real-P">Another way to describe a set of derivations is to use a
parse-forest grammar.  It may be helpful to begin with a
brief description.</div>


<div class="div">

<h4><a name="hi-pfg-intro" id="hi-pfg-intro">3.7.1. </a>Short description of parse-forest grammars</h4>

<div class="Real-P">A parse-forest grammar is a way of describing the parse trees for
exactly one sentence in some language defined by another grammar (what
we may call its &#x2018;base grammar&#x2019;.</div>

<div class="Real-P">It is perhaps best explained by example. Consider the sentence
&#x201c;<tt>7-4+2</tt>&#x201d; parsed against the following simple and
ambiguous grammar:
<pre style="margin-left: 2em; background-color: #CCD; margin-right: 3em;">S = expr.
expr = num; expr, addop, expr.
num = ["0" - "9"]+.
addop = "+"; "-".
</pre></div>
<div class="Real-P">One parse tree for the sentence is<pre style="margin-left: 2em; background-color: #CCD; margin-right: 3em;">  &lt;S&gt;
    &lt;expr&gt;
      &lt;expr&gt;
        &lt;expr&gt;&lt;num&gt;7&lt;/num&gt;&lt;/expr&gt;
        &lt;addop&gt;-&lt;/addop&gt;
        &lt;expr&gt;&lt;num&gt;4&lt;/num&gt;&lt;/expr&gt;
      &lt;/expr&gt;    
      &lt;addop&gt;+&lt;/addop&gt;
      &lt;expr&gt;&lt;num&gt;2&lt;/num&gt;&lt;/expr&gt;
    &lt;/expr&gt;
  &lt;/S&gt;</pre>
Another is:
<pre style="margin-left: 2em; background-color: #CCD; margin-right: 3em;">  &lt;S&gt;
    &lt;expr&gt;
      &lt;expr&gt;&lt;num&gt;7&lt;/num&gt;&lt;/expr&gt;
      &lt;addop&gt;-&lt;/addop&gt;
      &lt;expr&gt;     
        &lt;expr&gt;&lt;num&gt;4&lt;/num&gt;&lt;/expr&gt;
        &lt;addop&gt;+&lt;/addop&gt;
        &lt;expr&gt;&lt;num&gt;2&lt;/num&gt;&lt;/expr&gt;
      &lt;/expr&gt;
    &lt;/expr&gt;
  &lt;/S&gt;</pre>
</div>
<div class="Real-P">Each parse tree can be described in a parse-tree grammar which has
a structure similar to that of the original grammar.  For every
nonterminal <i>N</i> in the parse tree which dominates some substring from
position <i>x</i> to position <i>y</i> in the sentence, the parse-tree grammar
will have a nonterminal with a name constructed from <i>N</i>, <i>x</i>, and <i>y</i>
with a rule showing how <i>N</i> produces that segment.  The first parse tree, for example,
can be written as a parse-tree grammar thus:<pre style="margin-left: 2em; background-color: #CCD; margin-right: 3em;">
S&#xb7;0&#xb7;5 = expr&#xb7;0&#xb7;5.
expr&#xb7;0&#xb7;5 = expr&#xb7;0&#xb7;3, addop&#xb7;3&#xb7;4, expr&#xb7;4&#xb7;5.
expr&#xb7;0&#xb7;3 = expr&#xb7;0&#xb7;1, addop&#xb7;1&#xb7;2, expr&#xb7;2&#xb7;3.
expr&#xb7;0&#xb7;1 = num&#xb7;0&#xb7;1.
expr&#xb7;2&#xb7;3 = num&#xb7;2&#xb7;3.
expr&#xb7;4&#xb7;5 = num&#xb7;4&#xb7;5.
num&#xb7;0&#xb7;1 = "7".
num&#xb7;2&#xb7;3 = "4".
num&#xb7;4&#xb7;5 = "2".
addop&#xb7;1&#xb7;2 = "-".
addop&#xb7;3&#xb7;4 = "+".
</pre></div>
<div class="Real-P">The second tree can likewise be described in a grammar, which
shares a great many of the rules from the first parse-tree grammar.
It may be obvious to the reader that both trees can be described in
the same grammar, thus:<pre style="margin-left: 2em; background-color: #CCD; margin-right: 3em;">
S&#xb7;0&#xb7;5 = expr&#xb7;0&#xb7;5.
expr&#xb7;0&#xb7;5 = expr&#xb7;0&#xb7;3, addop&#xb7;3&#xb7;4, expr&#xb7;4&#xb7;5
         | expr&#xb7;0&#xb7;1, addop&#xb7;1&#xb7;2, expr&#xb7;2&#xb7;5.
expr&#xb7;0&#xb7;3 = expr&#xb7;0&#xb7;1, addop&#xb7;1&#xb7;2, expr&#xb7;2&#xb7;3.
expr&#xb7;2&#xb7;5 = expr&#xb7;2&#xb7;3, addop&#xb7;3&#xb7;4, expr&#xb7;4&#xb7;5.
expr&#xb7;0&#xb7;1 = num&#xb7;0&#xb7;1.
expr&#xb7;2&#xb7;3 = num&#xb7;2&#xb7;3.
expr&#xb7;4&#xb7;5 = num&#xb7;4&#xb7;5.
num&#xb7;0&#xb7;1 = "7".
num&#xb7;2&#xb7;3 = "4".
num&#xb7;4&#xb7;5 = "2".
addop&#xb7;1&#xb7;2 = "-".
addop&#xb7;3&#xb7;4 = "+".
</pre></div>

<div class="Real-P">Note that in the grammar describing a single tree, every rule has
exactly one right-hand side; in the grammar describing multiple trees,
<i>expr&#xb7;0&#xb7;5</i> has two right-hand sides, reflecting the fact
that it can produce the string in two different ways.</div>
</div>


<div class="div">

<h4><a name="hi-pfg-const" id="hi-pfg-const">3.7.2. </a>Constructing a parse-forest grammar</h4>

<div class="Real-P">Our overarching task here can be described thus:  We are given
<ul><li>an Earley set closed under the <i>scan</i>,
<i>pred</i>, and <i>comp</i> relations, and</li>
<li>a completion item in that set.</li>
</ul>
From these, we are to construct a parse-forest grammar
describing the set of parse trees whose existence is
implied by the completion item.</div>

<div class="Real-P">A brute-force approach would simply construct a grammar rule for
every possible realization of every completion item in the Earley set,
but that would produce rules for matches that never made it into a
successful parse.[<a name="ref-to-d3e725" href="#d3e725" title="&#xA;Since those rules would be a potentially&#xA;informative description of the garden paths followed by the parser&#xA;before they reached a dead end, they might be usefu">2</a>]</div>

<div class="Real-P">Since we are given a completion item of the form (<i>x</i> <i>y</i> <i>N</i>
<i>q</i><sub><i>f</i></sub>)[<a name="ref-to-d3e741" href="#d3e741" title="Here qf is any final state in the&#xA;definition of N.">3</a>] a simple way to handle the task is:
<ul><li>
<div class="Real-P">Construct the production rule for <i>N</i>&#xb7;<i>x</i>&#xb7;<i>y</i>.</div>
</li>
<li>
<div class="Real-P">For each nonterminal in the right-hand side of the rule just
constructed, construct the production rule for that nonterminal.</div>
</li>
</ul>
</div>

<div class="Real-P">The first step will entail finding a sequence of completion items
that correspond to a <em>satisfactory walk</em> through the
right-hand side of the production rule for <i>N</i> in the base
grammar.[<a name="ref-to-d3e776" href="#d3e776" title=" I call it a&#xA;satisfactory walk because (a) the sequence of&#xA;nonterminals satisfies the constraints of the right-hand side, and&#xA;(b) the walk is acceptable to the ">4</a>] That is a walk through the RHS
<ul><li>beginning in the start state <i>q</i><sub>0</sub>,</li>
<li>ending in some final state <i>q</i><sub><i>f</i></sub>, and</li>
<li>in which the steps collectively cover the input segment from
<i>x</i> to <i>y</i>.</li>
</ul>
For each item in the walk an appropriate new nonterminal can be
constructed, and those nonterminals will be written into into the
right-hand side of the production rule, in the appropriate sequence.
If there is more than one such walk through the rule for <i>N</i>, then
<i>N</i> is ambiguous, and we want all of those walks.[<a name="ref-to-d3e816" href="#d3e816" title="At the moment, there are some infinitely ambiguous&#xA;sentences for which we will not in fact get all of the walks&#xA;(informally, those involving infinite&#xA;horizontal">5</a>]</div>

<div class="Real-P">The second step can be handled by calling the same function we
called to handle the completion we started with.  Since in cases of
ambiguity the same nonterminal may appear in more than one walk
through <i>N</i> and thus in more than one right-hand side for <i>N</i>&#xb7;<i>x</i>&#xb7;<i>y</i>, we
should keep track of what nonterminals we have already constructed or
already placed in the queue.</div>

</div>


<div class="div">

<h4><a name="hi-pfgc-top" id="hi-pfgc-top">3.7.3. </a>The parse-forest-grammar() function</h4>
<div class="Real-P">The top-level function for making the parse-forest grammar will
thus place the initial completion item in a work queue and delegate
responsibility for generating the appropriate production rules to a
separate recursive function, wrapping the result in an &lt;<em>ixml</em>&gt;
element or an &lt;<em>error</em>&gt; element.</div>
<div class="Real-P">To simplify later operations, </div>

<div class="Real-P">
<div class="scrap"><span><a name="epi-parse-forest-grammar">&#x3008; 15 Define parse-forest-grammar() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:parse-forest-grammar(
  $leiCompletions as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#adt-list-ei">Type: list of Earley items 52</a></em> &#x3009;</span>,
  $leiClosure as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#adt-eiclosure">Type:  Earley closure 53</a></em> &#x3009;</span>,
  $I as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#adt-input">Type: input string 54</a></em> &#x3009;</span>
) as element() {
  let $rules := epi:make-pfg-rules(
                    $leiCompletions,
                    $leiClosure,
		    $I, 
                    ())
		    
  return 
    <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-pfg-return">Return parse-forest grammar containing $rules 16</a></em> &#x3009;</span>
};
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-make-pfg-rules">Define function epi:make-pfg-rules() 18</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-find-walks">The find-walks() function 26</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-rhs-from-walk">The rhs-from-walk() function 32</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-lei-from-walk">The lei-from-walk() function 37</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-find-dups-in-walk">The dups-from-walk() function 38</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e341">[File Earley-parser-internals.xqm] 4</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">After the work has been done, the <i>parse-forest-grammar()</i>
function returns the result:  either an error element or the
desired ixml element.
<div class="scrap"><span><a name="epi-pfg-return">&#x3008; 16 Return parse-forest grammar containing $rules &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    (: if we got an error back, pass it along :)
    <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-pfg-error-return">If there is an error, return an error element 17</a></em> &#x3009;</span>

    (: if we are error-free, wrap it in ixml :)
    else element ixml {
           element comment {
             "Parse-forest grammar generated ",
             current-dateTime()
           },
           $rules                
         }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-parse-forest-grammar">Define parse-forest-grammar() 15</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The error checking is currently very simple:  if there is an
error element among the rules, we wrap the entire set of rules in
an enclosing error element.
<div class="scrap"><span><a name="epi-pfg-error-return">&#x3008; 17 If there is an error, return an error element &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    if ($rules/self::ap:error)
    then element ap:error {
           element comment {
             "Failure generating PFG. ",
             "Sorry!" 
           },
           $rules                
           }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-pfg-return">Return parse-forest grammar containing $rules 16</a> &#x3009; <br></span>
</div>
</div>
</div>


<div class="div">

<h4><a name="hi-pfgc-make-rules" id="hi-pfgc-make-rules">3.7.4. </a>The <i>make-pfg-rules()</i> function</h4>

<div class="Real-P">The <i>epi:make-pfg-rules()</i> function has a familiar
basic structure: if there is work in the queue, we do it, we check to
see whether it has generated further work, and we recur to handle the
remaining items in the queue.  If the queue is empty, we are done and
can return the accumulated intermediate results.
<div class="scrap"><span><a name="epi-make-pfg-rules">&#x3008; 18 Define function epi:make-pfg-rules() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:make-pfg-rules(
  $leiQueue as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#adt-list-ei">Type: list of Earley items 52</a></em> &#x3009;</span>,
  $leiClosure as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#adt-eiclosure">Type:  Earley closure 53</a></em> &#x3009;</span>,
  $I as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#adt-input">Type: input string 54</a></em> &#x3009;</span>,
  $leRules as element()*
    (: accumulator, element(rule|error)* :)
) as element()* {
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-mpr-stop">If PFG queue is empty, return accumulator 19</a></em> &#x3009;</span>
  else 
  let $ei := head($leiQueue)
  
  let $dummy := eri:trace(eri:sXei($ei), 'Making production rule for item: ')

  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-mpr-find-walk">Set $walks to possible child sequences for $ei 22</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-mpr-make-rule">Set $rule to production rule for $ei 23</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-mpr-update-queue">Set $new-queue to include new completions 24</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-mpr-recur">Recursive call with new queue and accumulator 25</a></em> &#x3009;</span>

};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-parse-forest-grammar">Define parse-forest-grammar() 15</a> &#x3009; <br></span>
</div>
</div>

<div class="Real-P">The base case is unsurprising:
<div class="scrap"><span><a name="epi-mpr-stop">&#x3008; 19 If PFG queue is empty, return accumulator &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  if (empty($leiQueue))
  then $leRules
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-make-pfg-rules">Define function epi:make-pfg-rules() 18</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">When there is work to be done, of course, the case is more
complex.  The following subsections describe it.</div>

</div>


<div class="div">

<h4><a name="hi-pfgc-walks" id="hi-pfgc-walks">3.7.5. </a>Finding walks through a rule's right-hand-side</h4>
<div class="Real-P">The core task of making the parse-forest grammar seems to be
finding the sequences of completion items which represent the
parse-tree children of the node represented by the current completion
item.  It's complicated by several factors:
<ul><li><div class="Real-P">We must move back and forth continually between the parent
level, moving forward state by state in the FSA for the parent
nonterminal <i>N</i>, and the child level, identifying completion items
for each child <i>C</i>.  The information we want is never where we are
at any time, figuratively speaking.</div>

<div class="Real-P">Concretely: at any given point, the state of our effort to find
walks depends on the set of walks we have accumulated, and for each
walk <i>w</i> some relevant properties are given by the most recent
completion item <i>i</i> and others by the state <i>q</i> in the FSA reached
by the walk:
<ul><li>Does <i>w</i> end in a final state of the FSA? (i.e. is <i>q</i> &#x2208;
<i>F</i> for this FSA?)</li>
<li>Does <i>w</i> cover the required range of input? (i.e. is
<i>ei</i>('to') = <i>ei</i>('to'), where <i>ei</i> is the completion item
represented by the left-hand side of the rule?)</li>
<li>Can <i>w</i> be extended? (i.e. is <i>follow(<i>q</i>)</i>
empty?)</li>
</ul></div></li>
<li><div class="Real-P">We would like to be able to find all the walks, not just
one.  The ixml spec wants us to report ambiguity, and that means we
must at least know whether more than one walk exists.</div>
</li>
<li><div class="Real-P">We need to be alert for cycles in the walk.  These will
always be edge cases: they can arise only if repeatable sequences of
children can and do produce the empty string.  But they can
occur.</div></li>
<li><div class="Real-P">Each walk is (notionally at least) a sequence of completion
items describing parse-tree children.  But we can't return a set of
walks by returning a sequence of sequences, so we need to some other
representation.</div>

<div class="Real-P">Candidates include:
<ul><li><b>arrays of sequences</b>:<ul><li><b>sequences of Earley items</b>: walks as sequences
of completion items, sets of walks as arrays of sequences</li>
<li><b>sequences of pairs</b>: walks as sequences of pairs
consisting of a completion item and a state, sets of walks as arrays
of such sequences</li>
<li><b>sequences of strings</b>: walks as sequences of
strings of the form &#x201c;<i>x</i>&#xb7;<i>y</i>&#xb7;<i>N</i>&#x201d; (or
&#x201c;<i>N</i>&#xb7;<i>x</i>&#xb7;<i>y</i>&#x201d;, or
&#x201c;<i>x</i>&#xb7;<i>y</i>&#xb7;<i>N</i>&#x21d2;<i>q</i>&#x201d;, or
&#x201c;<i>N</i>&#xb7;<i>x</i>&#xb7;<i>y</i>&#x21d2;<i>q</i>&#x201d;), sets of walks as arrays of
such sequences</li>
</ul>
</li>
<li><b>sequences of strings</b>:<ul><li><b>long strings</b>: walks as strings made by joining
strings of the form &#x201c;<i>x</i>&#xb7;<i>y</i>&#xb7;<i>N</i>&#x201d; together with
&#x201c;<tt>/</tt>&#x201d; or &#x201c;<tt>+</tt>&#x201d; or
&#x201c;<tt>,&amp;#x20;</tt>&#x201d; or some other concatenation mark,
sets of walks as sequences of such string</li>
</ul></li>
<li><b>maps</b>:<ul><li><b>prefix trees</b>: a set of walks as a map
representing a prefix tree, each walk then a path from the root of
the tree to a leaf; the trees will contain either just completion
items or a mix of completion items and state in the FSA we are
walking through</li>
<li><b>step lists with shared tails</b>: each walk as a
map representing one step in the walk, with keys
&#x201c;<tt>state</tt>&#x201d; (= <i>q</i>), &#x201c;<tt>item</tt>&#x201d; (=<i>i</i>),
&#x201c;<tt>pred</tt>&#x201d; (a pointer to the map for the preceding step in
the walk, empty for the first step); a set of walks is just a set of
such maps.  Walks which share a prefix will use the same map to
represent that shared prefix, so this is effectively just an
upside-down tree, which we hold by its leaves and not its
root.</li>
</ul>
</li>
<li><b>elements</b>:<ul><li><b>&lt;<em>walks</em>&gt; and &lt;<em>step</em>&gt; elements</b>: a
set of walks as a &lt;<em>walks</em>&gt; element, contain a set of
&lt;<em>step</em>&gt; elements, which in turn may each contain a
&lt;<em>walks</em>&gt; element.  Each &lt;<em>walks</em>&gt; element specifies a
starting state and position, each step a destination state and
position.  If a step has no successors, it has no &lt;<em>walks</em>&gt;
element.  If a step's destination state is final in the FSA and its
destination position is the desired ending position, the path from
the root to that step is a complete walk through the FSA and
represents a right-hand side of a rule in the PFG.</li>
</ul></li>
</ul>
The current implementation uses step lists with shared
tails.</div></li>
</ul>
</div>

<div class="Real-P">The basic plan is an iterative function[<a name="ref-to-d3e1123" href="#d3e1123" title="&#xA;By iterative function I mean a recursive&#xA;function where recursion serves only to provide a looping&#xA;construct.&#xA;">6</a>] which performs a breadth-first search and assembles the
result.[<a name="ref-to-d3e1131" href="#d3e1131" title="&#xA;If we are not trying to return all walks but only a finite number&#xA;of walks, a depth-first search might be better.  But at the moment I&#xA;am reacting, and possibl">7</a>] We have an accumulator of some sort that holds a set of
walks found so far, each of which is either complete (it goes all
the way to a final state in the right-hand side of <i>N</i>) or not, and
either extensible or not.[<a name="ref-to-d3e1141" href="#d3e1141" title="&#xA;&#xA;In principle, a walk can be extended if the last state reached by&#xA;the walk has follow states.  But since right-hand sides in an EBNF can&#xA;have cycles, we cut o">8</a>] The result is complete when no walks can be extended,
or when we have found enough walks to go on with.
<ul><li><div class="Real-P">If the result is complete, return all of the complete walks
found so far.</div></li>
<li><div class="Real-P">Otherwise, for each walk <i>w</i> that can be extended:
<ul><li><div class="Real-P">Find all possible extensions to <i>w</i>.</div></li>
<li><div class="Real-P">For each possible extension <i>e</i>, make a new walk <i>w&#x2032;</i> by
adding <i>e</i> to the end of <i>w</i>.</div></li>
<li><div class="Real-P">For each new walk <i>w&#x2032;</i>, see if <i>w&#x2032;</i> is complete and mark it
appropriately so it can be found again.</div></li>
</ul></div></li>
</ul>
When a complete walk is extended, the original walk needs to be
kept around unchanged so it can be returned in the result.
When incomplete walks are extended, the original walks can be
discarded.</div>

<div class="Real-P">Each walk is a step list, and each step is represented
by a map:
<div class="scrap"><span><a name="pfg-adt-walk">&#x3008; 20 Type: walk in a RHS &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">map(xs:string, item()*)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-rhs-from-walk">The rhs-from-walk() function 32</a> &#x3009; &#x3008; <a href="#epi-lei-from-walk">The lei-from-walk() function 37</a> &#x3009; &#x3008; <a href="#epi-find-dups-in-walk">The dups-from-walk() function 38</a> &#x3009; <br></span>
</div>

A collection of walks is just a sequence of walks:
<div class="scrap"><span><a name="pfg-adt-walks">&#x3008; 21 Type: collection of walks &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">map(xs:string, item()*)*
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-find-walks">The find-walks() function 26</a> &#x3009; &#x3008; <a href="#epi-find-dups-in-walk">The dups-from-walk() function 38</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">Since we will need recursion to iterate over the steps in the
walks we are constructing, the task of generating child sequences
for <i>ei</i> will just be delegated to a separate function,
<i>epi:find-walks()</i>.  We prime the pump by creating a
walk with a single step.  And if the parent FSA is nullable, we add that walk to the 

<div class="scrap"><span><a name="epi-mpr-find-walk">&#x3008; 22 Set $walks to possible child sequences for $ei &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $r0 := $ei('rule')
  let $w  := map { 'item': $ei, 
                   'state': 'q0',
                   'follow-states': 
                       tokenize($r0/@first),
                   'final': 
                       xs:boolean($r0/@nullable)
             }

  let $walks := epi:find-walks(
                  $ei       (: completion for parent :),
                  $leiClosure, 
                  $I, 
                  $w                        (: queue :),
                  if (xs:boolean($r0/@nullable)
                      and ($ei('from') eq $ei('to'))) 
                  then $w 
                  else ()             (: accumulator :),
                  map { 'tree-count': 2 } (: options :)
                )

   let $dummy := (eri:trace(count($walks), 'Find-walks found # walks.'),
                  if (count($walks) gt 1)
                  then for $w at $walknum in $walks 
                  return eri:trace($w, 'Walk no. ' || $walknum || ' is:')
                  else ()
                 )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-make-pfg-rules">Define function epi:make-pfg-rules() 18</a> &#x3009; <br></span>
</div>

The &#x201c;<tt>follow-states</tt>&#x201d; and &#x201c;<tt>final</tt>&#x201d;
values are redundant; we store them in the map to avoid
calculating them repeatedly.
The last argument (a map of options) should be replaced
in due course with options supplied by the user.
</div>
<div class="Real-P"></div>
<div class="Real-P">The <i>epi:find-walks()</i> function will be defined <a href="#hi-pfgc-find-walks">below</a>.</div>

</div>


<div class="div">

<h4><a name="hi-pfgc-makerule" id="hi-pfgc-makerule">3.7.6. </a>Making a production rule for a given walk</h4>

<div class="Real-P">Given a completion item (<i>x</i> <i>y</i> <i>N</i> <i>q</i><sub><i>f</i></sub>) and a set of walks
through the rule for <i>N</i>, we now make a production rule for <i>N</i>&#xb7;<i>x</i>&#xb7;<i>y</i> with an
appropriate expression on the right-hand side.

<div class="scrap"><span><a name="epi-mpr-make-rule">&#x3008; 23 Set $rule to production rule for $ei &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $rule := element rule {
                   attribute name {
                       concat($r0/@name,
                           '&#xb7;',
                           $ei('from'),
                           '&#xb7;',
                           $ei('to'),
                           '&#xb7;',
                           $ei('ri')
                       )
                   },
                   $r0/@mark,
                   if (empty($walks))
                   then element ap:error {
                     element p { "make-pfg-rules here." },
                     element p { "find-walks() failed." },
                     element p { "Here is what I know." },
                     element dump { 
                       element var {
                         attribute name { "ei" },
                         eri:eXei($ei)
                       },
                       element var {
                         attribute name { "ei?rule" },
                         $r0
                       },
                       element var {
                         attribute name { "closure" },
                         for $n in map:keys($leiClosure('to'))
  		         order by $n descending
  		         for $ei in $leiClosure('to')($n)
  		         return eri:eXei($ei)
                       }
                     }
                   } 
                   else for $w in $walks
                   return element alt { 
                       epi:rhs-from-walk($w, $I, ())
                   }
               }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-make-pfg-rules">Define function epi:make-pfg-rules() 18</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The <i>epi:rhs-from-walk()</i> function will be defined
<a href="#hi-pfgc-make-rhs">below</a>.</div>

</div>


<div class="div">

<h4><a name="hi-pfgc-recur" id="hi-pfgc-recur">3.7.7. </a>Preparing for the next iteration</h4>

<div class="Real-P">Given a queue, an accumulator, and a new production rule (or the
set of walks that produced it), identify which completion items need
to be added to the queue.  That would be: all the completion items in
the walks, unless they are already in the queue or already handled in
the accumulator.  First we extract them all, and dedup them, then
we filter them against the items already in the queue, and finally
against the items we already have rules for.
<div class="scrap"><span><a name="epi-mpr-update-queue">&#x3008; 24 Set $new-queue to include new completions &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $lei0 := for $w in $walks
               return epi:lei-from-walk($w, ()), 
               (: all completion items in $walks :)
	       
      $lei1 := $lei0[
                 not(some $i in 1 to (position() - 1)
                  satisfies deep-equal(., $lei0[$i]))
                  (: satisfies .?sig eq $lei0[$i]?sig :)
		  (: satisfies ((.?from eq $lei0[$i]?from)
                    and      (.?to   eq $lei0[$i]?to  )
                    and deep-equal(
                              .?rule,   $lei0[$i]?rule)) :)
               ],
               (: list of distinct completion items :)

      $lei2 := $lei1[
                 not(some $i in 2 to (count($leiQueue))
                  satisfies deep-equal(., $leiQueue[$i]))
                  (: satisfies .?sig eq $leiQueue[$i]?sig   :)
		  (: satisfies ((.?from eq $lei0[$i]?from)
                    and      (.?to   eq $lei0[$i]?to  )
                    and deep-equal(
                              .?rule,   $lei0[$i]?rule)) :)

               ]
               (: completion items not in the queue :)

  let $ls-defined := ($leRules, $rule)
                     /@name/string(),

      $lei3 := for $ei in $lei2
               let $s := $ei('rule')/@name/string()
                         || '&#xb7;'
                         || $ei('from')
                         || '&#xb7;'
                         || $ei('to')
                         || '&#xb7;'
                         || $ei('ri')
               where not($s = $ls-defined)
               return $ei
               (: new completion items, 
                  not in queue and not already done :)

  let $new-queue := (tail($leiQueue), $lei3)

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-make-pfg-rules">Define function epi:make-pfg-rules() 18</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Given a production rule <i>$rule</i> and and the updated
queue <i>$new-queue</i>, call
<i>make-pfg-rules()</i> recursively.
<div class="scrap"><span><a name="epi-mpr-recur">&#x3008; 25 Recursive call with new queue and accumulator &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  return epi:make-pfg-rules(
           $new-queue,
           $leiClosure,
           $I,
           ($leRules, $rule)
         )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-make-pfg-rules">Define function epi:make-pfg-rules() 18</a> &#x3009; <br></span>
</div>

</div>

</div>

<div class="div">

<h4><a name="hi-pfgc-find-walks" id="hi-pfgc-find-walks">3.7.8. </a>The <i>find-walks()</i> function</h4>
<div class="Real-P">This bit is, frankly, the part of parse-forest extraction
I have had the most trouble thinking through clearly.</div>
<div class="Real-P">We are given:
<ul><li>an Earley item, which should be a completion (i.e.
<i>ri</i> &#x2208; <i>F</i> for the FSA)</li>
<li>an Earley closure</li>
<li>an input string</li>
<li>a queue of walks which begin at the
start state and are attested by appropriate completion
items, which may or may not be satisfactory</li>
<li>an accumulator of acceptable walks</li>
<li>a map of options, in particular the &#x201c;<tt>tree-count</tt>&#x201d;
option</li>
</ul>
From these we are to generate a set of walks, represent as step
lists.  The accumulator is needed because we extend everything in
the queue if we can, and that may cause a satisfactory walk to be
lost.
<i>To do: check for loops.</i>
<div class="scrap"><span><a name="epi-find-walks">&#x3008; 26 The find-walks() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:find-walks(
  $eiParent as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#adt-ei">Type: Earley item 51</a></em> &#x3009;</span>,
  $mei as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#adt-eiclosure">Type:  Earley closure 53</a></em> &#x3009;</span>,
  $I as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#adt-input">Type: input string 54</a></em> &#x3009;</span>,
  $queue as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#pfg-adt-walks">Type: collection of walks 21</a></em> &#x3009;</span>,
  $acc as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#pfg-adt-walks">Type: collection of walks 21</a></em> &#x3009;</span>,
  $options as map(*)
) as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#pfg-adt-walks">Type: collection of walks 21</a></em> &#x3009;</span> {
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#pfg-fw-if-done">If we have all our walks, return 27</a></em> &#x3009;</span>
  else 
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#pfg-fw-set-new-queue">Set new queue by extending all walks in the queue 28</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#pfg-fw-set-new-acc">Add satisfactory walks to the accumulator 31</a></em> &#x3009;</span>
  return epi:find-walks(
      $eiParent, 
      $mei,
      $I,
      $new-queue,
      $new-acc,
      $options
  )
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-parse-forest-grammar">Define parse-forest-grammar() 15</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">We stop when we have as many walks as are specified in the
&#x201c;<tt>tree-count</tt>&#x201d; option, or when the queue is empty.[<a name="ref-to-d3e1348" href="#d3e1348" title="&#xA;If this is the only source of ambiguity in the parse, returning&#xA;n walks will give us n trees.  If there are multiple sources of&#xA;ambiguity, the parse-forest gra">9</a>]
<div class="scrap"><span><a name="pfg-fw-if-done">&#x3008; 27 If we have all our walks, return &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  if (($options('tree-count') ne -1)
      and 
      (count($acc) ge $options('tree-count')))
  then $acc
  else if (empty($queue))
  then $acc
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-find-walks">The find-walks() function 26</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">Otherwise, we attempt to extend each walk in the queue.  To
reduce the number of times we have to do a search in the Earley
closure, we group the walks by their current position (here
<i>x</i>),[<a name="ref-to-d3e1368" href="#d3e1368" title="Note that the current position is the&#xA;from value for the starter step (a completion for&#xA;the parent) but the to value for any other&#xA;step.">10</a>] their follow state (here <i>qNext</i>), and
the nonterminal (or terminal) we are seeking to match (here <i>N</i> and
<i>T</i>[<a name="ref-to-d3e1383" href="#d3e1383" title="Note that N and T are uniquely&#xA;determined by qNext and thus redundant, but including&#xA;them as grouping keys allows them to be referred to without&#xA;subscripts.">11</a>]
<div class="scrap"><span><a name="pfg-fw-set-new-queue">&#x3008; 28 Set new queue by extending all walks in the queue &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $new-queue := 
      for $w in $queue
      let $x := if ($w?state eq 'q0')
                then $w('item')('from')
                else $w('item')('to'),
          $qqNext := $w('follow-states')

      for $qNext in $qqNext
      let $symbol := $eiParent('rule')//*[@xml:id=$qNext],
          $N := $symbol/self::nonterminal/@name/string(),
          $T := $symbol[eri:fTerminal(.)]/@xml:id/string(),
	  $symbol-mark := $symbol/(@mark, @tmark)/string()

      let $dummy := if (exists($T)) then eri:notrace($T,
          'find-walks: seeking completion items for this terminal:')
          else ()

      group by $x, $qNext, $N, $T
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e1406">Find follow-on completion items 29</a>&#x3009;, &#x3008;<a href="#d3e1409">Extend the walk 30</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-find-walks">The find-walks() function 26</a> &#x3009; <br></span>
</div>

We can now do a single search that will work for every
walk that is expecting a given symbol at a given location.
We look for items in the closure which:
<ul><li>start at <i>x</i>,</li>
<li>relate to the given terminal or nonterminal,</li>
<li>are final, and</li>
<li>advance no further than the endpoint of the
parent completion item.</li>
</ul>
<div class="scrap"><span><a name="d3e1406">&#x3008; 29 Find follow-on completion items [continues <a href="#pfg-fw-set-new-queue">28 Set new queue by extending all walks in the queue</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      let $items := $mei('from')($x)
                    [(.?rule/@name eq $N)
                     or (.?rule/@xml:id eq $T)]
                    [eri:fFinalEi(.) 
                     or (.?ri eq '#terminal')]
                    [.?to le $eiParent('to')]

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

For each such item, we extend the walk we started with:
<div class="scrap"><span><a name="d3e1409">&#x3008; 30 Extend the walk [continues <a href="#pfg-fw-set-new-queue">28 Set new queue by extending all walks in the queue</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      for $i in $items
      let $fNull := ($i('to') eq $i('from')),
          $leiDups := if ($fNull)
                      then epi:dups-from-walk(
                               $qNext, $i, $w[1], ()
                           )
                      else ()

      let $qqNextfollow := tokenize(
                               $eiParent('rule')
                               /attribute::follow:*
                               [local-name() eq $qNext]
                           ),
          $f-qnext-final := ($qNext = 
                           eri:lriFinalstatesXR(
                               $eiParent('rule')
                           ))

      return if ($fNull and count($leiDups) gt 1)
      then ()
      else map {
                 'item' : $i,
                 'state' : $qNext,
                 'follow-states' : $qqNextfollow,
                 'final' : $f-qnext-final,
                 'mark'  : $symbol-mark,
                 'pred'  : $w[1]
             }

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>
</div>
<div class="Real-P">Some of the extensions we just made may be satisfactory walks;
if so, we add them to the accumulator:
<div class="scrap"><span><a name="pfg-fw-set-new-acc">&#x3008; 31 Add satisfactory walks to the accumulator &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $new-acc := ($acc, $new-queue
                         [ .?final ]
                         [ .?item?to eq $eiParent?to ])

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-find-walks">The find-walks() function 26</a> &#x3009; <br></span>
</div>

</div>
</div>

<div class="div">

<h4><a name="hi-pfgc-make-rhs" id="hi-pfgc-make-rhs">3.7.9. </a>The <i>rhs-from-walk()</i> function</h4>
<div class="Real-P">We are given a walk <i>w</i> represented as a map describing one
step and pointing to its predecessor; we are to return an ixml
right-hand side for the sequence.</div>
<div class="Real-P">We do this by walking through the list step by step, pushing the
appropriate symbol onto the front of the accumulator.
<div class="scrap"><span><a name="epi-rhs-from-walk">&#x3008; 32 The rhs-from-walk() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:rhs-from-walk(
  $w as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#pfg-adt-walk">Type: walk in a RHS 20</a></em> &#x3009;</span>?,
  $I as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#adt-input">Type: input string 54</a></em> &#x3009;</span>,
  $acc as element()*
) as element()* {

  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-rfw-stop">If we're done, return 33</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-rfw-terminal">If this step is a terminal, return a literal 34</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-rfw-nonterminal">If this step is a nonterminal, return a nonterminal 35</a></em> &#x3009;</span>
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-parse-forest-grammar">Define parse-forest-grammar() 15</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">The termination condition is evident: if we are out of steps,
then we are done.  We are out of steps when we are looking at state
<i>q</i><sub>0</sub> (and of course if somehow we have run off the edge).
<div class="scrap"><span><a name="epi-rfw-stop">&#x3008; 33 If we're done, return &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  if (empty($w) or ($w('state') eq 'q0')) 
  then $acc
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-rhs-from-walk">The rhs-from-walk() function 32</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">If the walk includes a completion item for a terminal,
of the form (<i>x</i> <i>y</i> _t_<i>n</i> '#terminal'), then we
construct a &lt;<em>literal</em>&gt; element and recur.
<div class="scrap"><span><a name="epi-rfw-terminal">&#x3008; 34 If this step is a terminal, return a literal &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  if ($w('item')('ri') eq '#terminal')
  then let $ei := $w('item')
       let $x := $ei('from'),
           $y := $ei('to'),
           $symbol := element literal {
               attribute tmark { $w('mark') },
               attribute string {
                   substring($I, $x+1, ($y - $x))              
               }
           },

           $new-acc := ($symbol, $acc),
	   $next-step := $w('pred')
       return epi:rhs-from-walk($next-step, $I, $new-acc)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-rhs-from-walk">The rhs-from-walk() function 32</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Otherwise, we extract the nonterminal symbol from
the rule in the item, append start and end positions,
construct an ixml &lt;<em>nonterminal</em>&gt; element for the
newly constructed nonterminal name, and recur.
<div class="scrap"><span><a name="epi-rfw-nonterminal">&#x3008; 35 If this step is a nonterminal, return a nonterminal &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  if (exists($w('item')('rule')/self::rule[@name]))
  then let $ei := $w('item'),

           $symbol := element nonterminal {
               attribute name {
                   $ei('rule')/@name/string()
                   || '&#xb7;'
                   || $ei('from')
                   || '&#xb7;'
                   || $ei('to')
                   || '&#xb7;'
                   || $ei('ri')
               },
               if (exists($w('mark')))
               then attribute mark { $w('mark') }
               else ()
           },
           $new-acc := ($symbol, $acc),
           $next-step := $w('pred')
       return epi:rhs-from-walk($next-step, $I, $new-acc)
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e1480">Otherwise, something has gone very wrong 36</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-rhs-from-walk">The rhs-from-walk() function 32</a> &#x3009; <br></span>
</div>

And as a catch-all, if we have a step but cannot
treat it as a terminal or as a nonterminal,
then we return an error.
<div class="scrap"><span><a name="d3e1480">&#x3008; 36 Otherwise, something has gone very wrong [continues <a href="#epi-rfw-nonterminal">35 If this step is a nonterminal, return a nonterminal</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  else 
let $dummy := eri:trace($w('item'), 'rhs-from-walk:  item fell through!') return
       element ap:error {
           element p { 'Unexpected failure 83' },
           $acc,
           $w
       }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
</div>

<div class="div">

<h4><a name="hi-pfgc-make-lei" id="hi-pfgc-make-lei">3.7.10. </a>The <i>lei-from-walk()</i> function</h4>
<div class="Real-P">We are given a walk <i>w</i> represented as a map describing one
step and pointing to its predecessor; we are to return a sequence
of the Earley items (they will all be completions) in that
sequence, leaving out the one at the very end that represents
the parent node.[<a name="ref-to-d3e1497" href="#d3e1497" title="&#xA;Might it be faster to do this at the same time we&#xA;generate the right-hand side from the walk?">12</a>]</div>

<div class="Real-P">We do this by walking through the list step by step, pushing each
item onto the front of the accumulator.
<div class="scrap"><span><a name="epi-lei-from-walk">&#x3008; 37 The lei-from-walk() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:lei-from-walk(
  $w as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#pfg-adt-walk">Type: walk in a RHS 20</a></em> &#x3009;</span>?,
  $acc as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#adt-list-ei">Type: list of Earley items 52</a></em> &#x3009;</span>
) as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#adt-list-ei">Type: list of Earley items 52</a></em> &#x3009;</span> {
  if (empty($w)) 
  then $acc
  else if ($w('state') eq 'q0')
  then $acc
  else if ($w('item')('ri') eq '#terminal')
  then epi:lei-from-walk($w('pred'), $acc)
  else epi:lei-from-walk($w('pred'),
                         ($w('item'), $acc))
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-parse-forest-grammar">Define parse-forest-grammar() 15</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P"><i>To do:  move de-duping into lei-from-walk()?
Every item we can avoid adding to the accumulator
is an item we don't need to carry around.</i></div>
</div>

<div class="div">

<h4><a name="hi-pfgc-find-dups" id="hi-pfgc-find-dups">3.7.11. </a>The <i>dups-from-walk()</i> function</h4>
<div class="Real-P">We are given a state <i>q</i>, an item <i>ei</i>, and a walk <i>w</i>;
we are to return the steps in <i>w</i> that have the same
state and item.  If there is more than one (or some
threshold), the caller will detect a loop in the walk
and cut the walk off to avoid going round the loop
indefinitely.</div>

<div class="Real-P">We do this by walking through the list step by step, pushing the
duplicate steps onto the front of the accumulator.

<div class="scrap"><span><a name="epi-find-dups-in-walk">&#x3008; 38 The dups-from-walk() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:dups-from-walk(
  $q as xs:string,
  $ei as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#adt-ei">Type: Earley item 51</a></em> &#x3009;</span>,
  $w as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#pfg-adt-walk">Type: walk in a RHS 20</a></em> &#x3009;</span>?,
  $acc as item()*
) as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#pfg-adt-walks">Type: collection of walks 21</a></em> &#x3009;</span> {
  if (empty($w)) 
  then $acc
  else if ($w('state') eq 'q0')
  then $acc
  else if ( 
            (: $ei?sig eq $w?item?sig :)
            deep-equal($ei, $w('item')) 
            and 
            $q eq $w('state')
          )
  then epi:dups-from-walk($q, $ei, $w('pred'), ($w, $acc))
  else epi:dups-from-walk($q, $ei, $w('pred'), $acc)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-parse-forest-grammar">Define parse-forest-grammar() 15</a> &#x3009; <br></span>
</div>

</div>
</div>

</div>


<div class="div">

<h3><a name="hi-rpt-ex-pfg" id="hi-rpt-ex-pfg">3.8. </a>Extracting a parse tree from the parse-forest grammar</h3>

<div class="Real-P">If the user asks for a parse-forest grammar instead of a parse
tree, we can just return the grammar.  But if the user asks for a
tree, or a forest, we need to turn the grammar into a parse tree.
Since the current code for direct construction of the tree behaves
very badly in some cases, constructing the grammar and then from it
the tree is likely to be faster.  At least, I hope so.</div>
<div class="Real-P">So we want a function to extract a tree.  For now, we extract
just one tree, selected at random. <i>To do: construct <i>n</i>
trees; construct tree-cursor.</i></div>
<div class="Real-P">The initial call to <i>epi:tree-from-pfg()</i> function
supplies a parse-forest grammar and returns a parse tree.  Recursive
calls will supply elements from the parse-forest grammar and
use a <i>nodetype</i> parameter to specify what they
are interested in getting back; the nodetype value may be any of
&#x201c;<tt>document</tt>&#x201d; (expected only on the initial call), 
&#x201c;<tt>element</tt>&#x201d;, 
&#x201c;<tt>attribute</tt>&#x201d;, 
&#x201c;<tt>value</tt>&#x201d;, or
&#x201c;<tt>content</tt>&#x201d;.
<div class="scrap"><span><a name="epi-tree-from-pfg">&#x3008; 39 The epi:tree-from-pfg() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:tree-from-pfg(
  $pfg as element() 
      (: ixml, rule, alt, nonterminal, literal :),
  $nodetype as xs:string,
  $mark as xs:string?
) as node()* {
  if ($pfg/self::ixml)
  then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tfg-ixml">Extract tree from ixml parse-forest grammar 40</a></em> &#x3009;</span>
  else if ($pfg/self::rule)
  then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tfg-rule">Extract subtree from rule element 41</a></em> &#x3009;</span>
  else if ($pfg/self::alt)
  then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tfg-alt">Extract sequence of nodes from alt element 48</a></em> &#x3009;</span>
  else if ($pfg/self::nonterminal)
  then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tfg-nonterminal">Extract subtree from nonterminal element 49</a></em> &#x3009;</span>
  else if ($pfg/self::literal)
  then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tfg-literal">Extract character data from literal element 50</a></em> &#x3009;</span>
  else element eek {
      element desc {
          "tree-from-pfg got "
          || "an unexpected argument."
      },
      eri:trace($pfg, 'Unexpected argument!')
  }
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e341">[File Earley-parser-internals.xqm] 4</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">We start with the parse-forest grammar itself, an &lt;<em>ixml</em>&gt;
element.  We check to see whether the grammar is ambiguous or not by
looking for rules with multiple right-hand sides.  Then we start
serialization.  To avoid producing a &lt;<em>Goal</em>&gt; element for the
start-symbol introduced by the Earley recognizer, we start work with
the nonterminal on the right-hand side of the first rule.[<a name="ref-to-d3e1604" href="#d3e1604" title=" Actually, Goal should carry&#xA;mark=&#34;-&#34; in any case.">13</a>] If the
parse-forest grammar describes more than one tree, we should mark
the tree we return with <tt>ixml:state="ambiguous"</tt>.
<div class="scrap"><span><a name="epi-tfg-ixml">&#x3008; 40 Extract tree from ixml parse-forest grammar &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      let $f-ambig := exists($pfg//rule[count(alt) gt 1]),
          $tree0 := epi:tree-from-pfg(
                        $pfg/rule[1]/alt/nonterminal,
                        'element',
                        ()
                    ),
          $tree1 := copy $x-tree := $tree0
                   modify insert node 
                       attribute ixml:state { "ambiguous" }
                       into $x-tree
                   return $x-tree
      return if ($f-ambig) then $tree1 else $tree0
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-tree-from-pfg">The epi:tree-from-pfg() function 39</a> &#x3009; <br></span>
</div>

<i>To do: check to make sure there are no top-exposed attributes or
text nodes.</i>
The code just given does not test on <i>$nodetype</i>:
since an &lt;<em>ixml</em>&gt; element should never be consulted
when constructing an attribute, we assume &#x201c;<tt>document</tt>&#x201d;.
<i>To do:  check anyway, just in case?</i>
</div>

<div class="Real-P">For a rule with multiple right-hand sides, the &lt;<em>alt</em>&gt;
element to use is chosen at random.  If the current nodetype is
&#x201c;<tt>element</tt>&#x201d;, multiple passes over the content will be
needed, and they should all use the same right-hand side.  So
element and attribute construction is handled here, not on
nonterminal references.
<div class="scrap"><span><a name="epi-tfg-rule">&#x3008; 41 Extract subtree from rule element &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      if ($pfg/ap:error)
      then $pfg
      else
      let $mark := ($mark, 
                    $pfg/@mark/string(),
                    '^')[1]
      let $n := count($pfg/alt),
          $i := 1 + random:integer($n),
          $ccc := $pfg/alt[$i]/*,
          $ls0 := tokenize($pfg/@name, '&#xb7;'),
          $nm0 := $ls0[1],
          $fr  := $ls0[2],
          $to  := $ls0[3],
          $nm  := if ($nm0 castable as xs:Name)
                  then $nm0
                  else xs:QName('ap:error')
      return <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tfg-rule-elem">Serialize rule as element 42</a></em> &#x3009;</span>
          else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tfg-rule-attr">Serialize rule as attribute 43</a></em> &#x3009;</span>
          else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tfg-rule-content">Serialize rule as content 44</a></em> &#x3009;</span>
          else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tfg-rule-av">Serialize rule as attribute value 45</a></em> &#x3009;</span>
          else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tfg-rule-zero">Serialize nothing, stop recursion 46</a></em> &#x3009;</span>
          else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tfg-rule-wha">Return an error element 47</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-tree-from-pfg">The epi:tree-from-pfg() function 39</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">When the rule is marked &#x201c;<tt>^</tt>&#x201d;
and <i>$nodetype</i> is &#x201c;<tt>element</tt>&#x201d;
or &#x201c;<tt>content</tt>&#x201d;, the rule is serialized
as an element.
<div class="scrap"><span><a name="epi-tfg-rule-elem">&#x3008; 42 Serialize rule as element &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if (($nodetype = ('element', 'content'))
                 and ($mark eq '^'))
          then element { $nm } {
                   if ($nm0 ne $nm)
                   then attribute ap:gi { $nm0 }
                   else (),
                   for $c in $ccc
                   return epi:tree-from-pfg(
                              $c, 
                              'attribute',
                              ()
                   ),
                   for $c in $ccc
                   return epi:tree-from-pfg(
                              $c, 
                              'content',
                              ()
                   )
               }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-tfg-rule">Extract subtree from rule element 41</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">When the rule is marked &#x201c;<tt>@</tt>&#x201d; and
<i>$nodetype</i> is &#x201c;<tt>attribute</tt>&#x201d;, the rule is
serialized as an attribute.
<div class="scrap"><span><a name="epi-tfg-rule-attr">&#x3008; 43 Serialize rule as attribute &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if (($nodetype = ('attribute'))
                 and ($mark eq '@'))
          then attribute { $nm } {
                   if ($nm0 ne $nm)
                   then text { concat('[', $nm0, ']=') }
                   else (),
		   (: hack :)
                   string-join(
                   for $c in $ccc
                   let $node := epi:tree-from-pfg(
                              $c, 
                              'value',
                              ()
                   )
                   return $node
                   , '')
               }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-tfg-rule">Extract subtree from rule element 41</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">When the rule is marked &#x201c;<tt>-</tt>&#x201d; and
<i>$nodetype</i> is &#x201c;<tt>content</tt>&#x201d;, the rule is
serialized without an enclosing element.
<div class="scrap"><span><a name="epi-tfg-rule-content">&#x3008; 44 Serialize rule as content &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if (($nodetype = ('content', 'element', 'attribute'))
                 and ($mark eq '-'))
          then for $c in $ccc
               return epi:tree-from-pfg(
                          $c, 
                          $nodetype,
                          ()
               )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-tfg-rule">Extract subtree from rule element 41</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">When <i>$nodetype</i> is &#x201c;<tt>value</tt>&#x201d;, the
marking on the rule is ignored and the content is serialized as part
of the attribute value.
<div class="scrap"><span><a name="epi-tfg-rule-av">&#x3008; 45 Serialize rule as attribute value &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if (($nodetype = ('value')))
          then for $c in $ccc
               return epi:tree-from-pfg(
                          $c,
                          'value',
                          ()
               ) 
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-tfg-rule">Extract subtree from rule element 41</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">When <i>$nodetype</i> and the mark are incompatible,
the rule is not serialized at all.
<div class="scrap"><span><a name="epi-tfg-rule-zero">&#x3008; 46 Serialize nothing, stop recursion &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if (($nodetype = ('content'))
                 and ($mark = ('@')))
          then ()
          else if (($nodetype = ('attribute'))
                 and ($mark = ('^')))
          then ()
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-tfg-rule">Extract subtree from rule element 41</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">
If we encounter a combination we have not specified,
then something is wrong.  Say so.
<div class="scrap"><span><a name="epi-tfg-rule-wha">&#x3008; 47 Return an error element &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if (($nodetype = ('element'))
                 and ($mark = ('@')))
          then element ap:error {
                 attribute ap:desc {
                   "Attribute cannot be root.",
                   if ($nm ne $nm0)
                   then "&amp;#xA;Also, the attribute"
                        || " name is not a legal"
                        || " XML name."
                   else ()
                 },
                 attribute ap:attribute-name {
                   $nm0
                 },
                 attribute ap:attribute-value {
                   for $c in $ccc
                   return epi:tree-from-pfg(
                              $c,
                              'value',
                              ()
                   )
                 }
               }
          else element ap:error {
            "Ran off a cliff, ",
            "I don't remember a thing. ",
            "Nodetype is '" || $nodetype || "'",
            "and mark is '" || $mark || "'."
          }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-tfg-rule">Extract subtree from rule element 41</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">An &lt;<em>alt</em>&gt; element is similarly transparent:  we
just process all the children.  (Actually, the function
should never be called with &lt;<em>alt</em>&gt;, since
rule handling skips straight to the children.)
<div class="scrap"><span><a name="epi-tfg-alt">&#x3008; 48 Extract sequence of nodes from alt element &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      for $c in $pfg/*
      return epi:tree-from-pfg($c, $nodetype, ())
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-tree-from-pfg">The epi:tree-from-pfg() function 39</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">When we encounter a nonterminal element, we just recur
on the relevant rule, passing along any mark we find.
<div class="scrap"><span><a name="epi-tfg-nonterminal">&#x3008; 49 Extract subtree from nonterminal element &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      let $nt := $pfg/@name/string(),
          $rule := $pfg/ancestor::ixml[1]
                   /rule[@name eq $nt]
      return epi:tree-from-pfg($rule, 
                   $nodetype, 
                   $pfg/@mark/string())
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-tree-from-pfg">The epi:tree-from-pfg() function 39</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">
Extracting a literal is simple:  it's always literally present
in the <em>string</em> attribute, or else in the <em>hex</em>
attribute.
<div class="scrap"><span><a name="epi-tfg-literal">&#x3008; 50 Extract character data from literal element &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">       let $s := if (exists($pfg/@string))
           then string($pfg/@string)
           else if (exists($pfg/@hex))
           then eri:charXhex($pfg/@hex)
           else '&amp;#x1D350;' (: tetragram for failure U+1D350 :)

       return if ($pfg/@tmark eq '-') 
              then ()
              else if ($nodetype = ('element', 'attribute'))
              then () (: is this an error? :)
              else text { $s }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-tree-from-pfg">The epi:tree-from-pfg() function 39</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<h3><a name="hi-ast-ex-rpt" id="hi-ast-ex-rpt">3.9. </a>Extracting an abstract syntax tree from a raw parse tree</h3>
<div class="Real-P">Watch this space.</div>
<div class="Real-P">We have this code; it's just someplace else</div>
</div>
</div>



<div class="div">

<h2><a name="lowlevel" id="lowlevel">4. </a>Low-level utility routines</h2>


<div class="div">

<h3><a name="ll-types" id="ll-types">4.1. </a>Abstract types</h3>
<div class="Real-P">XQuery does not allow for user-defined types, so we cannot
hide the details of our representations behind type names.
But for purposes of exposition, we can perhaps hide them behind
scrap names, to keep internal details out of the high-level
code at least within this document.</div>
<div class="Real-P"><i>N.B. At the moment none of the high-level scraps refer
to these scraps.  That's to be done.  I'm starting by defining
the scraps.</i></div>

<div class="Real-P">We sporadically use some type-related naming conventions, in
a sort of Hungarian notation, at least some of the time.
<ul><li><em>ei</em>: Earley item (aka ITEM, map(xs:string, item())</li>
<li><em>e</em>:  Earley item</li>
<li><em>f</em>:  Boolean (flag)</li>
<li><em>G</em>:  the grammar</li>
<li><em>I</em>:  the input</li>
<li><em>mei</em>:  map of Earley items (= map(xs:integer, map(xs:string, ITEM*))
       = map(xs:integer, map(xs:string, map(xs:string, item())*))</li>
<li><em>n</em>:  non-terminal symbol (may sometimes be nt)</li>
<li><em>p</em>:  position in input (to, from)</li>
<li><em>pt</em>:  raw parse tree (or subtree)</li>
<li><em>r</em>:  rule in grammar</li>
<li><em>ri</em>:  rule index (position in rule)  </li>
<li><em>s</em>:  string</li>
<li><em>sym</em>:  symbol from grammar</li>
<li><em>t</em>:  terminal symbol   </li>
</ul>
</div>
<div class="Real-P">Functions:
<ul><li><em>aXb</em>: return thing A from thing B</li>
</ul></div>

<div class="Real-P">An Earley item is represented as a map, with
keys &#x201c;<tt>from</tt>&#x201d;, &#x201c;<tt>to</tt>&#x201d;,
&#x201c;<tt>rule</tt>&#x201d;, and &#x201c;<tt>ri</tt>&#x201d;
(&#x2018;<span>rule index</span>&#x2019;, or state).  
<div class="scrap"><span><a name="adt-ei">&#x3008; 51 Type: Earley item &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">map(*)</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-find-walks">The find-walks() function 26</a> &#x3009; &#x3008; <a href="#epi-find-dups-in-walk">The dups-from-walk() function 38</a> &#x3009; <br></span>
</div>

A sequence of them is the obvious:
<div class="scrap"><span><a name="adt-list-ei">&#x3008; 52 Type: list of Earley items &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">map(*)*</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-parse-forest-grammar">Define parse-forest-grammar() 15</a> &#x3009; &#x3008; <a href="#epi-make-pfg-rules">Define function epi:make-pfg-rules() 18</a> &#x3009; &#x3008; <a href="#epi-lei-from-walk">The lei-from-walk() function 37</a> &#x3009; <br></span>
</div>

The first version of the code used elements, not maps;
maps are slightly faster.
</div>

<div class="Real-P">The Earley set we are constructing is itself a map, of maps.
At the moment the outer map has keys &#x201c;<tt>from</tt>&#x201d;
and &#x201c;<tt>to</tt>&#x201d;, which denote maps indexed by integer,
whose values are Earley items.  
<div class="scrap"><span><a name="adt-eiclosure">&#x3008; 53 Type:  Earley closure &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">map(xs:string,
    map(xs:integer,
        map(xs:string, item())*)) </pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-parse-forest-grammar">Define parse-forest-grammar() 15</a> &#x3009; &#x3008; <a href="#epi-make-pfg-rules">Define function epi:make-pfg-rules() 18</a> &#x3009; &#x3008; <a href="#epi-find-walks">The find-walks() function 26</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">The input we are parsing is just a string:
<div class="scrap"><span><a name="adt-input">&#x3008; 54 Type: input string &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">xs:string</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-parse-forest-grammar">Define parse-forest-grammar() 15</a> &#x3009; &#x3008; <a href="#epi-make-pfg-rules">Define function epi:make-pfg-rules() 18</a> &#x3009; &#x3008; <a href="#epi-find-walks">The find-walks() function 26</a> &#x3009; &#x3008; <a href="#epi-rhs-from-walk">The rhs-from-walk() function 32</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<h3><a name="ll-items" id="ll-items">4.2. </a>Working with Earley items</h3>

<div class="div">

<h4><a name="ll-items-con" id="ll-items-con">4.2.1. </a>Earley items - constructors</h4>
<div class="Real-P">
<div class="scrap"><span><a name="eri-items">&#x3008; 55 Earley items (constructors, extractors, etc.) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ****************************************************** 
   * Earley items
   ****************************************************** :)
(: We represent an Earley item as a map with keys 'from', 
   'to', 'rule', and 'ri' (rule index).  For any item $ei, 
   $ei('from') and $ei('to') are integers, $ei('rule') is 
   element() (either a rule or a terminal symbol), and 
   $ei('ri') is a string (an NCName, in fact, but typed 
   only as a string).
:)

(: ******************************************************
   * Earley items:  constructors
  :)

<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-make-p-p-r-ri">Define eiMakePPRRi() 56</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-lei-advance-ei-sym-p">Define leiAdvanceEiSymP() 58</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e1947">Extractors for Earley items 59</a>&#x3009;, &#x3008;<a href="#d3e1953">Extractors for Earley items 60</a>&#x3009;, &#x3008;<a href="#d3e2000">Predicates for Earley items 61</a>&#x3009;, &#x3008;<a href="#d3e2005">Define fExpectsN-Ei() 62</a>&#x3009;, &#x3008;<a href="#d3e2023">Define fScanrelEE() 63</a>&#x3009;, &#x3008;<a href="#d3e2030">Define fAdvanceNrelEE() 64</a>&#x3009;, &#x3008;<a href="#eri-items-closure">Calculating the closure of an Earley set 65</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e411">[File Earley-rec-internals.xqm] 7</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">To construct an Earley function from known values, we call
<i>eiMakePPRRi</i>:
<div class="scrap"><span><a name="eri-make-p-p-r-ri">&#x3008; 56 Define eiMakePPRRi() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   ei Make P P R Ri: make an Earley item from two 
   positions, a rule, and a rule index
  :)
declare function ixi:eiMakePPRRi(
  $From as xs:integer,
  $To as xs:integer,
  $r as element(rule),
  $ri as xs:string
) as map(xs:string, item()) {  
  map {
    'from' : $From,
    'to' : $To,
    'rule' : $r,
    'ri' : $ri 
    (: ,
    'sig' : concat('(', $From, 
                   '.', $To,
                   '.', $r/@name,
                   '/', $ri
            )
    :)(: ,
    'final' : (($ri = tokenize($r/@last, '\s+')
                      [normalize-space()])
               or (($ri eq 'q0') 
                  and 
                  ($r/@nullable = ('true', '1')))),
    'extensible' : ('' ne normalize-space(
                       $r/attribute::follow:*
                       [local-name() eq $ri]
                   ))
     :)
  }
};
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e1924">Define eiMakePPT() 57</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#eri-items">Earley items (constructors, extractors, etc.) 55</a> &#x3009; <br></span>
</div>

We provide the &#x201c;<tt>sig</tt>&#x201d; field to provide a simple way of
comparing Earley items for equality, and the &#x201c;<tt>final</tt>&#x201d;
and &#x201c;<tt>extensible</tt>&#x201d; fields to speed up some frequent
operations.  <i>At the moment, neither &#x201c;<tt>final</tt>&#x201d; nor
&#x201c;<tt>extensible</tt>&#x201d; is actually used elsewhere.</i>
</div>
<div class="Real-P">In special cases, we also make items for terminal symbols:
<div class="scrap"><span><a name="d3e1924">&#x3008; 57 Define eiMakePPT() [continues <a href="#eri-make-p-p-r-ri">56 Define eiMakePPRRi()</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   ei Make P P T: make an Earley item from two 
   positions and a terminal.
  :)
declare function ixi:eiMakePPT(
  $From as xs:integer,
  $To as xs:integer,
  $t as element()
) as map(xs:string, item()) {  
  map {
    'from' : $From,
    'to' : $To,
    'rule' : $t,
    'ri' : "#terminal" (:,
    'sig' : concat('(', $From, 
                   '.', $To,
                   '.', $t,
                   '/', '#terminal'
            )
    :)(:
    'final' : true(),
    'extensible' : false()
    :)
  }
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">The function <i>leiAdvanceEiSymP()</i>
takes (as its name signals) an Earley item, a symbol,
and a position, and returns the list of Earley items
which are advances from that position on that symbol.
<div class="scrap"><span><a name="eri-lei-advance-ei-sym-p">&#x3008; 58 Define leiAdvanceEiSymP() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   ixi:lei Advance Ei Sym P($E, $sym, $p): return the 
   set of Earley items (lei) that arise if you advance 
   $E over $sym, or over any equivalent symbol, to reach 
   position $p.
:)
declare function ixi:leiAdvanceEiSymP(
  $E as map(xs:string, item()),
  $sym as element(),
  $pNew as xs:integer
) as map(xs:string, item())* {
  let $pFr := $E('from'),
      $pTo := $E('to')
  return if ($pNew lt xs:integer($pTo))
      then () (: $E cannot advance backwards :)
      else 
  let $r := $E('rule'),
      $ri0 := $E('ri'),
      $lriFollow := if ($ri0 eq 'q0')
                    then $r/@first
                    else $r/@follow:*[local-name() = $ri0],
      $lri := tokenize($lriFollow,'\s+')[normalize-space()]
  for $ri in $lri
  where ixi:fSymbolmatchRRiSym($r,$ri,$sym)
    (: and $pNew ge xs:integer($pTo) :)
  return ixi:eiMakePPRRi($pFr, $pNew, $r, $ri) 
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#eri-items">Earley items (constructors, extractors, etc.) 55</a> &#x3009; <br></span>
</div>

</div>
</div>

<div class="div">

<h4><a name="ll-items-extr" id="ll-items-extr">4.2.2. </a>Earley items - extractors</h4>
<div class="Real-P">For the <em>to</em> and <em>from</em> pointers,
the rule, and the rule's nonterminal, the extractor
functions are very straightforward.
<div class="scrap"><span><a name="d3e1947">&#x3008; 59 Extractors for Earley items [continues <a href="#eri-items">55 Earley items (constructors, extractors, etc.)</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   * Earley items:  extractors
   :)

(: See also sXei() below under Utilities :)

(: ......................................................
   pTo X Ei($E): extract 'to' position from item
   :)
declare function ixi:pToXEi(
  $E as map(xs:string, item())
) as xs:integer {
  $E('to')
};

(: ......................................................
   pFrom X Ei($E): extract 'from' position from item
   :)
declare function ixi:pFromXEi(
  $E as map(xs:string, item())
) as xs:integer {
  $E('from')
};

(: ......................................................
   r X Ei($E): extract rule from item
   :)
declare function ixi:rXEi(
  $E as map(xs:string, item())
) as element() {
  $E('rule')
};

(: ......................................................
   nLhs X Ei($E): extract nonterminal on lhs of rule 
   from item
   :)
declare function ixi:nLhsXEi(
  $E as map(xs:string, item())
) as element(nonterminal) {
  element nonterminal {
    attribute name { $E('rule')/@name }
  }
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">To get the list of expected symbols, more work is needed.
<div class="scrap"><span><a name="d3e1953">&#x3008; 60 Extractors for Earley items [continues <a href="#eri-items">55 Earley items (constructors, extractors, etc.)</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody"> (: ......................................................
   lsymExpected X Ei($E): extract list of expected 
   symbols from item
   :)
declare function ixi:lsymExpectedXEi(
  $E as map(xs:string, item())
) as element()* {
  (: results will be element() or element(nonterminal). :)
  let $symCur := $E('ri'),
      $r := $E('rule'),
      $sFollowset := if ($symCur = 'q0') 
                     then $r/@first
                     else $r/@follow:*[local-name()=$symCur],
      $lsymFollow := tokenize($sFollowset,'\s+')[normalize-space(.)]
  for $sym in $lsymFollow
  let $e := $r//*[@xml:id = $sym]
  return $e
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">Q. would this be faster with the <tt>for</tt> loop replaced by
<tt>return $r/descendant::*[@xml:id =
tokenize($sFollowset,'\s+')]</tt> or <tt>return
$r/descendant::*[@xml:id = $lsymFollow]</tt>, maybe?
</div>
<div class="Real-P">A. Let's see.
<ul><li><b>Loop:</b>  1:13.6 user time (two runs, same time),
            1:09.8 / 1:10.8 real time (?)</li>
<li><b>XPath:</b>  <tt>$r/descendant::*
            [@xml:id = tokenize($sFollowset,'\s+')]</tt>:
            1:19.9, 1:21.8 user</li>
<li><b>XPath:</b>  <tt>$r/descendant::*
            [@xml:id = $lsymFollow]</tt>:
1:12.5, 1:12.4</li>
</ul>
So:  not, it would not be noticeably faster,
and might be slower.
</div>
</div>

<div class="div">

<h4><a name="ll-items-predicates" id="ll-items-predicates">4.2.3. </a>Earley items - predicates</h4>
<div class="Real-P">We use predicate functions to ask several questions
about Earley items:
<ul><li>Is it final?  Does it mark the completion of the rule?
Sometimes we specify the left-hand side of the rule,
sometimes also the position.</li>
<li>Does it expect any nonterminals?</li>
<li>Does the scan relation hold between two given Earley items?</li>
<li>Does the advance-over-symbol-S relation hold between two given
Earley items?</li>
</ul>
</div>
<div class="Real-P">There are several functions for asking whether an item is
a completion.
<div class="scrap"><span><a name="d3e2000">&#x3008; 61 Predicates for Earley items [continues <a href="#eri-items">55 Earley items (constructors, extractors, etc.)</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   * Earley items:  predicates
   :)
(: ......................................................
   fFinal Ei P P N($E, $pFr, $pTo, $N): is $E a
   completion item for symbol N, running between the 
   two positions? (Used just once, in recognizeX, to 
   check for completions of the start symbol that cover 
   the entire input string.)
   :)
declare function ixi:fFinalEiPPN(
  $E as map(xs:string, item()),
  $pFrom as xs:integer,
  $pTo as xs:integer,
  $sym as xs:string
) as xs:boolean {
  (xs:integer($E('from')) eq $pFrom)
  and (xs:integer($E('to')) eq $pTo)
  and ($E('rule')/@name eq $sym)
  and ($E('ri') = ixi:lriFinalstatesXR($E('rule')))
};

(: ......................................................
   ixi:fFinalEiPN($E, $pTo, $sym):  true iff $E is a 
   completion item ending at position $P for nonterminal 
   $N 
   :)
declare function ixi:fFinalEiPN(
  $E as map(xs:string, item()),
  $pTo as xs:integer,
  $n as element(nonterminal)
) as xs:boolean {
  let $f := xs:integer($E('to')) eq $pTo
            and $E('rule')/@name eq $n/@name
            and $E('ri') = ixi:lriFinalstatesXR($E('rule'))

  return $f
};

(: ......................................................
   fFinal Ei($E): is $E a completion item?  I.e. is its 
   rule index in a final location?
   :)
declare function ixi:fFinalEi(
  $E as map(xs:string, item())
) as xs:boolean {
  $E('ri') = ixi:lriFinalstatesXR($E('rule'))
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P"><div class="scrap"><span><a name="d3e2005">&#x3008; 62 Define fExpectsN-Ei() [continues <a href="#eri-items">55 Earley items (constructors, extractors, etc.)</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   fExpectsN - Ei($E):  does $E expect any nonterminals?
   :)
declare function ixi:fExpectsN-Ei(
  $E as map(xs:string, item())
) as xs:boolean {
  exists(ixi:lsymExpectedXEi($E)[ixi:fNonterminal(.)])
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">Abstractly, the scan relation scan(E1,E2) holds iff
<ul><li>E1 expects terminal T</li>
<li>and E1 wins</li>
<li>and E2 = advance(E1, T)</li>
</ul>
And E2 = advance(E1, T) iff
<ul><li>from(E1) = from(E2)</li>
<li>and rule(E1) = rule(E2)</li>
<li>and seen-so-far(E1) || T = seen-so-far(E2)</li>
<li>and E1 wins on T [redundant, why?]</li>
<li>else advance(E1, T) = empty set.</li>
</ul>
So:
<div class="scrap"><span><a name="d3e2023">&#x3008; 63 Define fScanrelEE() [continues <a href="#eri-items">55 Earley items (constructors, extractors, etc.)</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   fScanrel E E($E1, $E2):  does the scan relation hold 
   for E1, E2?
   (Used once, in Earley parser internals, to find 
   related items.)
   :)
   (: N.B. does not test that the symbol in question 
      is a terminal. Does it matter?
   :)   
declare function ixi:fScanrelEE(
  $E1 as map(xs:string, item()),
  $E2 as map(xs:string, item())
) as xs:boolean {
  let $fFrom := ($E1('from') eq $E2('from')),
        (: test 1 of advance() :)
      $lsymFollow := ixi:lsymExpectedXEi($E1), 
      $lSsymFollow := for $e in $lsymFollow return $e/@xml:id,
      $fStates1 := ($E2('ri') = $lSsymFollow),
        (: test 3, 4 of advance(), 1,2 of scan() :)
      $fRules := deep-equal($E1('rule'), $E2('rule')),
	(: test 2 of advance() :)
      $f := ($fFrom and $fStates1 and $fRules), 
      $trace := ($f,
                'fScanrelEE(' 
                || ixi:sXei($E1) || ',' 
                || ixi:sXei($E2) || ') ==&gt; '
                )
  return $f
      (: 
               .('from') = $Ecur('from')
               and .('to') = $pMedial
               and .('ri') = $lsPrevstates
               and deep-equal(./rule, $Ecur/rule)
      :)
};

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">
<div class="scrap"><span><a name="d3e2030">&#x3008; 64 Define fAdvanceNrelEE() [continues <a href="#eri-items">55 Earley items (constructors, extractors, etc.)</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   fAdvanceNrel E E ($E1, $E2):  does the 
   advance-over-symbol-N relation hold for E1, E2?
   (Used once, in Earley parser internals, to find 
   related items.)

   By definition (see paper) E2 = advance(E1, T) iff
      * from(E1) = from(E2)
      * and rule(E1) = rule(E2)
      * and seen-so-far(E1) || T = seen-so-far(E2)
      * and E1 wins on T
      * else advance(E1, T) = empty set.

   Note that for the "E1 wins" clause we rely on the 
   truth of all items in the closure.  E1 must be  
   winning, because otherwise an E2 that satisfies 
   the other tests would not be in the closure.
   :)
declare function ixi:fAdvanceNrelEE(
  $E1 as map(xs:string, item()),
  $E2 as map(xs:string, item())
) as xs:boolean {
  let $fFrom := ($E1('from') eq $E2('from')),
      $lsymFollow := ixi:lsymExpectedXEi($E1),
      $lSsymFollow := for $e in $lsymFollow 
                      return $e/@xml:id,
      $fStates1 := ($E2('ri') = $lSsymFollow),
      $fRules := deep-equal($E1('rule'), $E2('rule')),
      $f := ($fFrom and $fStates1 and $fRules),
      $trace := ($f,
                'fScanrelEE(' 
                || ixi:sXei($E1) || ',' 
                || ixi:sXei($E2) || ') ==&gt; '
                )
  return $f
      (: 
               .('from') = $Ecur('from')
               and .('to') = $eiCC('from')
               and .('ri') = $lsPrevstates 
               and deep-equal(./rule, $Ecur/rule)
      :)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
</div>

<div class="div">

<h4><a name="ll-items-closure" id="ll-items-closure">4.2.4. </a>Earley set closure</h4>
<div class="Real-P">The heart of the Earley algorithm is the calculating the
closure of the Earley set.
<div class="scrap"><span><a name="eri-items-closure">&#x3008; 65 Calculating the closure of an Earley set [continues <a href="#eri-items">55 Earley items (constructors, extractors, etc.)</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: *******************************************************
   * Earley items:  closure (the big kahuna)
   :)
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e2049">Define earley-closure($lei, $I, $G) 66</a>&#x3009;, &#x3008;<a href="#d3e2068">Define earley-closure($pending, $accumulator, $I, $G) 67</a>&#x3009;, &#x3008;<a href="#d3e2179">Define earley-closure($pending, $accumulator, $I, $G) 71</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">We will want an accumulator to hold the set, so the
user's call to <i>earley-closure</i> merely
initializes an accumulator and calls another function to
do the work.
<div class="scrap"><span><a name="d3e2049">&#x3008; 66 Define earley-closure($lei, $I, $G) [continues <a href="#eri-items-closure">65 Calculating the closure of an Earley set</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody"> (: ......................................................
   ixi:earley-closure($lei, $I, $G2): 
   Calculate closure of $lei over the relations scan(), 
   pred(), and comp().
:)
declare function ixi:earley-closure(
  $leiPending as map(xs:string, item())* (: ITEM* :), 
  $I as xs:string,
  $G as element(ixml)
) as map(xs:string,
         map(xs:integer,
             map(xs:string,
                 item())*)) (:MEI:) {
  let $meiAcc := map { 
                   'from' : map:merge(
                     for $ei in $leiPending
		     return map:entry($ei('from'), $ei),
                     $ixi:combinedups
                   ),
                   'to' : map:merge(
                     for $ei in $leiPending
		     return map:entry($ei('to'), $ei),
                     $ixi:combinedups
		   ) }
		       
  return ixi:earley-closure($leiPending, $meiAcc, $I, $G)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">The larger function is this one.</div>
<div class="Real-P">We calculate the closure of the set of Earley items in $accumulator
over the relations scan(), pred(), and comp().
</div>
<div class="Real-P">Every item in $pending is also in $accumulator.  The items in
$pending have not yet been examined; the other items in $accumulator
have been dealt with and need not be dealt with again.
</div>
<div class="Real-P">N.B. To keep the control flow simple, this function does not
attempt to handle all of the items at position $p before moving to $p
+ 1, and it does not assume that all predictions of a nonterminal $n
beginning at position $p are present when a completion for $n at $p is
found.
</div>
<div class="Real-P">One immediate consequence of this is that every item making a
prediction must also check for completions of its predicted
non-terminals, which increases the number of times we must scan
through the accumulator and offers a low-hanging target for improving
speed. <i>TO DO: pluck that low-hanging fruit.</i></div>

<div class="Real-P">The function has two cases: either we are done, or we are not yet
done.
<div class="scrap"><span><a name="d3e2068">&#x3008; 67 Define earley-closure($pending, $accumulator, $I, $G) [continues <a href="#eri-items-closure">65 Calculating the closure of an Earley set</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   ixi:earley-closure($pending, $accumulator, $I, $G2):
:)
declare function ixi:earley-closure(
  $leiPending as map(xs:string, item())* (: pending items :),
  $meiAccum as map(xs:string, map(xs:integer, map(xs:string, item())*))
            (: accumulator of type MEI :),
  $I as xs:string,
  $G as element(ixml)
) as map(xs:string, map(xs:integer, map(xs:string, item())*)) (:MEI:) {
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-items-closure-termination">Terminating case for Earley closure 68</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-items-closure-normal">Normal case for Earley closure 69</a></em> &#x3009;</span>};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">The base case arises when the pending list is done.  If nothing
remains to be done, then we are done and can return the accumulator.
<div class="scrap"><span><a name="eri-items-closure-termination">&#x3008; 68 Terminating case for Earley closure &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  if (empty($leiPending))
  then $meiAccum
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e2068">Define earley-closure($pending, $accumulator, $I, $G) 67</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">In the normal case, we have items to process.  We
<ul><li>take the head of the pending list,</li>
<li>run the PCS function on it,</li>
<li>dedup the returned items,</li>
<li>drop any items that are already in the accumulator, and</li>
<li>recur, while adding new items to the accumulator.</li>
</ul>
<div class="block-note;" style="margin-left: 2em; font-size: smaller;"><div><b>NOTE:</b></div>
Note, February 2022.
<div class="Real-P">When trying to find out where time is going in the recognizer, the
first step is to wrap each step here in prof:time().  The conjecture
before examining the results is that 80% of the time, or more, will be
spent in <i>ixi:leiPCSrel()</i>, and minimal time in the
deduping steps.</div>
<div class="Real-P">If this conjecture holds true, the second step will be to
instrument <i>leiPCSrel()</i>.  But: one thing at a time.</div>
</div>
<div class="block-note;" style="margin-left: 2em; font-size: smaller;"><div><b>NOTE:</b></div>
Note, February 2022.
<div class="Real-P">Results of one run on test0 (trivial examples):
<ul><li>1.63 ms checking PCS results against accumulator</li>
<li>0.54 ms deduping PCS results</li>
<li>35.48 ms running PCS function</li>
</ul>
So nearer 94% than 80% of the time.  (It might be nice to have an
automated way of getting these numbers, but for now what I did is
copy and paste the messages out of the GUI's info window, use an
impromptu Emacs keyboard macro to change lines like
&#x201c;<tt>PCS: 0.87 ms</tt>&#x201d; to
&#x201c;<tt>0.87 ; ms PCS:</tt>&#x201d;, sort to get the
different measurements together, and wrap each set of
messages in &#x201c;<tt>(+</tt>&#x201d; ... &#x201c;<tt>)</tt>&#x201d;.
Then ^x^e to evaluate the Lisp expression.)
</div>
<div class="Real-P">On a longer test set (test2), which ran for 1215 seconds,
the results were:
<ul><li>1,782.91 ms checking PCS results against accumulator</li>
<li>357.39 ms deduping PCS results</li>
<li>19,967.69 ms running PCS function</li>
</ul>
As the accumulator gets larger, searching it for items already present
appears to become more expensive.  But running PCS is still taking 90%
of the measured time.
</div>
<div class="Real-P">Further testing seems unnecessary.</div>

</div>
<div class="scrap"><span><a name="eri-items-closure-normal">&#x3008; 69 Normal case for Earley closure &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $E := head($leiPending), 

      (: get everything from leiPCSrel :)
      $leiCs0 := ixi:leiPCSrel($E,$meiAccum,$I,$G),
                 
      
      (: dedup results from leiPCSrel :) 
      $leiCs := $leiCs0[
                   not(some $i in 1 to (position() - 1)
                       satisfies deep-equal(., $leiCs0[$i])
                   )],
        	
      (: remove non-new results from leiPCSrel :)
      $leiNew := for $ei in $leiCs
	         let $from := $ei('from')
		 where not(some $e in $meiAccum('from')($from)
		           satisfies deep-equal($e, $ei))
		 return $ei,

      <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-itcl-traces">Issue trace messages for earley-closure() 70</a></em> &#x3009;</span>
		 
      $meiNewaccum := map {
	'from' : map:merge(
	  ( $meiAccum('from'),
	  for $ei in $leiNew return map:entry($ei('from'), $ei) ),
	  $ixi:combinedups),
        'to' : map:merge(
	  ( $meiAccum('to'),
	  for $ei in $leiNew return map:entry($ei('to'), $ei) ),
	  $ixi:combinedups) }
      
  return ixi:earley-closure(
    (tail($leiPending), $leiNew),
    $meiNewaccum,
    $I,
    $G)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e2068">Define earley-closure($pending, $accumulator, $I, $G) 67</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">When debugging this, it is helpful to have trace messages showing
each step in this process.
<div class="scrap"><span><a name="eri-itcl-traces">&#x3008; 70 Issue trace messages for earley-closure() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      $dummy := ixi:notrace(count($leiPending), 
                            'e-c() has pending items: '), 
      $dummy := ixi:notrace(
                    ixi:sXei($E),
                    'ixi:earley-closure running on item: '), 
      $dummy := ixi:notrace(count($leiCs0), 
                    'e-c() initial closure has items: '), 
      $dummy := ixi:notrace(count($leiCs), 
                     'e-c() deduped closure has items: '), 
      $dummy := ixi:notrace(count($leiNew), 
                     'e-c() New items: '), 
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#eri-items-closure-normal">Normal case for Earley closure 69</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The function <i>leiPCSrel()</i> takes an Earley
item (and an accumulator, the input, and the grammar) and
returns all the items that stand in the scan, pred, or
comp relations to the given item.
<div class="block-note;" style="margin-left: 2em; font-size: smaller;"><div><b>NOTE:</b></div>
February 2022: timings within this function on test0:
<ul><li>89.09 ms in ix:scan()</li>
<li>173.29 ms in ix:pred()</li>
<li>118.13 ms looking for completion and performing comp()</li>
<li>186.01 ms looking for prediction and performing comp()</li>
</ul>
and on ABNF.ixml (which ran 1675 seconds):
<ul><li>3972.56 ms in ix:scan()</li>
<li>6868.14 ms in ix:pred()</li>
<li>4076.04 ms looking for completion and performing comp()</li>
<li>11520.97 ms looking for prediction and performing comp()</li>
</ul>
That's only 27 seconds out of 1675 - where did that time all
go?!

</div>
<div class="scrap"><span><a name="d3e2179">&#x3008; 71 Define earley-closure($pending, $accumulator, $I, $G) [continues <a href="#eri-items-closure">65 Calculating the closure of an Earley set</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   leiPCSrel($E, $leiA, $I, $G): return all items $E2 
   such that 
   $E2 = scan($E, $I)
   or $E2 = pred($E, $G)
   or comp($E1, $E3) for some $E3 in $leiA
   or comp($E3, $E1) for some $E3 in $leiA
:)
declare function ixi:leiPCSrel(
  $E as map(xs:string, item()),
  $meiAccum as map(xs:string, item())*,
  $I as xs:string,
  $G as element(ixml)
) as map(xs:string, item())* {
  (: If $E expects terminals, perform scan :)
  
  ix:scan($E,$I),
  
  
  (: If $E expects nonterminals, perform prediction :)
  
  ix:pred($E,$G), 
  
  
  (: If $E expects a nonterminal, look for a 
     completion $Ec and perform comp($Ec,$E) :)
  
  if (ixi:fExpectsN-Ei($E))
  then for $Ec in $meiAccum('from')($E('to'))
       where ixi:fFinalEi($Ec)
       return ix:comp($Ec,$E)
  else (), 
  
    
  (: If $E is a completion, look for a prediction $Ep 
     and perform comp($E,$Ep) :)
  
  if (ixi:fFinalEi($E)) 
  then for $Ep in $meiAccum('to')($E('from'))
       where ixi:fExpectsN-Ei($Ep)
       return ix:comp($E,$Ep)
  else ()
  
    
  (: N.B. In BNF, $E can only expect one symbol, so 
     either scan or pred applies, but not both.  But 
     we are expecting EBNF and $E can predict several 
     things at the same time as being a completion. :)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
</div>
</div>


<div class="div">

<h3><a name="ll-grammars" id="ll-grammars">4.3. </a>Working with grammars</h3>

<div class="Real-P">
<div class="scrap"><span><a name="eri-grammars">&#x3008; 72 Grammars (constructors, extractors, etc.) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ****************************************************** 
   * Grammars
   ****************************************************** :)
(: A grammar is an ixml element with no namespace. :)

<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-grammars-constructors">Functions that construct or return grammars 73</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-grammars-extractors">Functions that extract information from grammars 76</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-grammars-predicates">Functions that check grammar properties 77</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e411">[File Earley-rec-internals.xqm] 7</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">We have just one routine that constructs grammars; it takes an
existing grammar and gives it a new start-symbol with a single rule.
This allows us to know without any further analysis that the start
symbol of the augmented grammar is non-recursive and has just one
rule. [<i>To do:</i> write a version of this that accepts a
start-symbol as a parameter.]</div>
<div class="Real-P">This is the same in v0.1 and v0.2 except that we use a different
element name to wrap the right-hand side of the rule.
<div class="scrap"><span><a name="eri-grammars-constructors">&#x3008; 73 Functions that construct or return grammars &#x3009;  &#x2261;</a></span>
<pre class="scrapbody"> (: ******************************************************
   * Grammars: constructors
   :)
   
(: ......................................................
   augment-grammar($G):  given grammar, augment it as 
   Earley prescribes.
   :)
declare function ixi:augment-grammar(
  $G as element(ixml)
) as element(ixml) {
  let $symStart := ixi:symStartG($G),
      $symGoal := ixi:makeGoalsymbolG($G),
      $fNullable := ixi:fNullableNG($symStart, $G)
  return element ixml {
    element rule {
      attribute name {$symGoal}, 
      attribute xml:id {$symGoal || '_rule'},
      attribute nullable { false() },
      attribute first {$symStart || '_0'},
      attribute last {$symStart || '_0'},
      attribute { xs:QName('follow:'||$symStart||'_0') } 
                {()},        
      element <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-alts-gi">GI for alts element 191</a></em> &#x3009;</span> {
        attribute xml:id {$symGoal || '_def_0'},
        attribute nullable { false() },
        attribute first {$symStart || '_0'},
        attribute last {$symStart || '_0'},
        attribute { xs:QName('follow:'||$symStart||'_0') } 
                  {()},
        element alt {
          attribute xml:id {$symGoal || '_alt_0'},
          attribute nullable { false() },
          attribute first {$symStart || '_0'},
          attribute last {$symStart || '_0'},
          element nonterminal {
            attribute name { $symStart },
            attribute xml:id {$symStart || '_0'},
            attribute nullable { false() },
            attribute first {$symStart || '_0'},
            attribute last {$symStart || '_0'}
          } (: end nonterminal :)
        } (: end alt :)
      } (: end def :)
    }, (: end rule :)
    $G/rule
  } (: end ixml :)
};
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e2216">Goal-symbol construction 74</a>&#x3009;, &#x3008;<a href="#d3e2223">Goal-symbol construction 75</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#eri-grammars">Grammars (constructors, extractors, etc.) 72</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">We have a small utility function for making a new
goal symbol that differs from all existing symbols.
<div class="scrap"><span><a name="d3e2216">&#x3008; 74 Goal-symbol construction [continues <a href="#eri-grammars-constructors">73 Functions that construct or return grammars</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody"> (: ......................................................
   makeGoalsymbolG($G):  make a new goal symbol for 
   grammar G, ensuring that it's not the same as any 
   existing symbol.
   :)
declare function ixi:makeGoalsymbolG(
  $G as element(ixml)
) as xs:string {
  let $ln := distinct-values($G/rule/@name),
      $n := ('Goal', '_Goal_', '_G_o_a_l_', '_G-o-a-l_')
            [not(. = $ln)][1]
  return if (exists($n)) 
    then $n 
    else ixi:mungesymbol(ixi:symStartG($G), $ln)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">And another utility for munging a given symbol.
<div class="scrap"><span><a name="d3e2223">&#x3008; 75 Goal-symbol construction [continues <a href="#eri-grammars-constructors">73 Functions that construct or return grammars</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   mungesymbol:  given a symbol, munge it (by adding _ 
   fore and aft) until it is no longer in the list of 
   symbols $ln (which is the symbols already in the 
   grammar).
   :)
declare function ixi:mungesymbol(
  $n as xs:string,
  $ln as xs:string*
) as xs:string {
  if ($n = $ln)
    then ixi:mungesymbol('_' || $n || '_', $ln)
    else $n
};

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">
<div class="scrap"><span><a name="eri-grammars-extractors">&#x3008; 76 Functions that extract information from grammars &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   * Grammars: extractors
   :)
   
(: ......................................................
   symStart G():  return start symbol(s) of G
   :)
declare function ixi:symStartG(
  $G as element(ixml)
) as xs:string+ {
  $G/rule[1]/@name/normalize-space()
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#eri-grammars">Grammars (constructors, extractors, etc.) 72</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">
<div class="scrap"><span><a name="eri-grammars-predicates">&#x3008; 77 Functions that check grammar properties &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   * Grammars:  predicates
   *
   * Note that predicates relating to symbols in context 
   * are here, not under symbol.  (Test:  is $G a 
   * parameter?)
   :)
(: ixi:fNullableNG($n, $G):  is nonterminal n nullable 
   in G? 

   For non-terminal N, fNullableNG(N,G) means an N 
   element in the result tree may be empty.

   Here 'nullable' means it has a right-hand side whose
   regex matches the empty string, which means in turn
   that the parse tree may be empty, and non-terminal N
   may appear as an N element in the result.
   
   N.B. this is not the same as fGES.
  
:)
declare function  ixi:fNullableNG(
  $n as xs:string, (: element(nonterminal), :)
  $G as element(ixml)
) as xs:boolean {
  exists($G/rule[@name = $n][@nullable = ('true', '1')])
};


(: ixi:fGesNG($n, $G):  does nonterminal n generate the 
   empty string in G? 
   
   N.B. this is not the same as fNullable.
   
   Discussions of parsing often use 'nullable' for 
   nonterminals that generate the empty string, but in 
   the grammar 
     S: X. X: .
   X is nullable and GES, S is GES but not nullable.
   
   For non-terminal N, fGesNG(N,G) means an N element
   in the result tree may have string(N) = ''.
   
:)
(: this is a transitive closure algorithm and will 
   require more work (including an accumulator to 
   avoid looping).
   
   For now, suppress it and do without it.
:)
(:
declare function  ixi:fGesNG(
  $n as element(), 
  $G as element(ixml)
) as xs:boolean {
  ($n/self::nonterminal 
     and ixi:fNullable($n, $G)
         or 
         (some $d 
          in $G/rule[@name=$n]/alt
          satisfies ixi:fGesNG($d,$G)))
  or ($n/self::def
     and ($n/@nullable = ('true','1'))
  or 
  ()
 
};
:)

(: ixi:lrulesXNG($n,$G) :)
declare function ixi:lrulesXNG(
  $n as element(nonterminal),
  $G as element(ixml)
) as element(rule)* {
  $G/rule[@name = $n/@name]
};


(: ******************************************************
   * Grammars: predicates
   :)

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#eri-grammars">Grammars (constructors, extractors, etc.) 72</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<h3><a name="ll-rules" id="ll-rules">4.4. </a>Working with rules</h3>

<div class="Real-P">
<div class="scrap"><span><a name="eri-rules">&#x3008; 78 Rules (constructors, extractors, etc.) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ****************************************************** 
   * Rules and rule indexes
   ****************************************************** :)
(: A rule is a rule element as defined in the ixml DTD, but 
   augmented with glushkov attributes.
   
   Note that functions relating to rules in context are 
   not here but under Grammars above.  (Test: is $G a 
   parameter?) Functions here relate solely to the rule 
   in isolation. That may be why there are so few of them.
:)

(: ******************************************************
   * Rules and rule indexes: constructors
   :)
   
(: ******************************************************
   * Rules and rule indexes: extractors
   :)

(: ixi:lriFinalstatesXR($r) :)
declare function ixi:lriFinalstatesXR(
  $r as element()
) as xs:string* {
  if ($r/self::rule)
  then 
  (
    if ($r/@nullable = ('true', '1'))
    then 'q0' else (),
    tokenize($r/@last,'\s+')[normalize-space()]
  )
  else ()

};

(: ixi:lriStartstatesXR($Rule):  return list of 
   start-position identifiers.
 :)
declare function ixi:lriStartstatesXR(
  $r as element()
) as xs:string* {
  'q0'
};

(: ******************************************************
   * Rules and rule indexes: predicates
   :)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e411">[File Earley-rec-internals.xqm] 7</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<h3><a name="ll-symbols" id="ll-symbols">4.5. </a>Working with symbols</h3>

<div class="Real-P">A symbol is (represented by) an element: one of nonterminal,
literal, inclusion, exclusion.
</div>
<div class="Real-P">(Any references to elements named 'terminal' is a relic from the
2016 grammar of ixml and now constitutes an error.)
</div>
<div class="Real-P">Note that functions relating to symbols in context are not here but
under Grammars above.  (Test: is $G a parameter?)  Functions here
relate solely to the symbol in isolation.  That may be why there
are so few of them.</div>
<div class="Real-P">Similarly any function that involves the input string is not here
but under Input, below.
<div class="scrap"><span><a name="eri-symbols">&#x3008; 79 Symbols (constructors, extractors, etc.) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ****************************************************** 
   * Symbols
   ****************************************************** :)

(: ******************************************************
   * Symbols: constructors
   :)
   
(: ******************************************************
   * Symbols: extractors
   :)
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-sym-match-length">Define match-length() 80</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-sym-reXTerminal">Define reXTerminal(), regex from terminal 81</a></em> &#x3009;</span>
 
(: ******************************************************
   * Symbols: predicates
   :)
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-sym-fTerminal">Define fTerminal() 83</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-sym-fNonterminal">Define fNonterminal() 84</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-sym-fSymbolmatchRRiSym">Define fSymbolmatchRRiSym() 85</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e411">[File Earley-rec-internals.xqm] 7</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">In tree-builder, we want match-length info just from terminal; we
don't have access to $I.  If terminals ever become variable-length,
this will break.</div>
<div class="Real-P">See also match-length#3 below under Input.
<div class="scrap"><span><a name="eri-sym-match-length">&#x3008; 80 Define match-length() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   match-length($t):  return length of any string that 
   matches the specified terminal.  
   :)
declare function ixi:match-length(
  $t as element()
) as xs:integer {
  if ($t/self::literal) then ixi:string-length($t)
  else 1
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#eri-symbols">Symbols (constructors, extractors, etc.) 79</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The function <i>reXTerminal($t)</i> returns a regular
expression, given a terminal element.  Note that the regular
expression will match one character (or none) in the input; we don't
have terminal symbols with indeterminate length in the input.
</div>
<div class="Real-P">At the moment, this is only ever called with
character sets (&lt;<em>inclusion</em>&gt; and &lt;<em>exclusion</em>&gt;,
but I've added code to handle literals as well, just in case.
</div>
<div class="Real-P">To do:  make the code that compiles Gluschkov automata
also calculate regexes for terminals, so that we're not
doing it again and again.
<div class="scrap"><span><a name="eri-sym-reXTerminal">&#x3008; 81 Define reXTerminal(), regex from terminal &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   re X Terminal($t): return a regular expression, given 
   a character-set terminal element.
   :)
declare function ixi:reXTerminal(
  $t as element() (: incl, excl, literal :)
) as xs:string {
  (: given a terminal element, produce a regex :)
  if ($t/self::literal) then
    ixi:sceXS( ixi:string-value($t) )
  else 
  let $le := $t/*,
      $lsRegexbits := for $e in $le
                      return if ($e/self::range)
                        then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-sym-reXT-range"> 82</a></em> &#x3009;</span>
                        else if ($e/self::literal) 
                        then ixi:sceXS($e/ixi:string-value($e)) 
                        else if ($e/self::class)
                        then ixi:catescXS($e/@code) 
                        else () (: error :)
  return if ($t/self::inclusion)
    then "[" || string-join($lsRegexbits,'') || "]"
    else if ($t/self::exclusion)
    then "[^" || string-join($lsRegexbits,'') || "]"
    else "--error in reXTerminal--"
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#eri-symbols">Symbols (constructors, extractors, etc.) 79</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">
<div class="scrap"><span><a name="eri-sym-reXT-range">&#x3008; 82  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">                             ixi:sceXS($e/@from)
		             || "-" || ixi:sceXS($e/@to)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#eri-sym-reXTerminal">Define reXTerminal(), regex from terminal 81</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">The function <i>fTerminal()</i> returns true iff the
argument is a terminal symbol.  This version supports both my
interpretation of the 2016 syntax (with element type 'terminal') and
the 2019 syntax (literal, inclusion, exclusion).
<div class="scrap"><span><a name="eri-sym-fTerminal">&#x3008; 83 Define fTerminal() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   f Terminal($sym):  is $sym a terminal symbol?
   :)
declare function ixi:fTerminal(
  $sym as item()
) as xs:boolean {
  exists($sym/self::element()[self::terminal
    or self::literal
    or self::inclusion
    or self::exclusion
  ])
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#eri-symbols">Symbols (constructors, extractors, etc.) 79</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The function <i>fNonterminal()</i> performs
a similar function for nonterminals.
<div class="scrap"><span><a name="eri-sym-fNonterminal">&#x3008; 84 Define fNonterminal() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   f Nonterminal($sym):  is $sym a nonterminal symbol?
   :)
declare function ixi:fNonterminal(
  $sym as item()
) as xs:boolean {
  exists($sym/self::element()/self::nonterminal)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#eri-symbols">Symbols (constructors, extractors, etc.) 79</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The function <i>fSymbolmatchRRiSym($r, $ri, $sym)</i>
determines whether a symbol element $sym matches rule index $ri in
rule $r.  Equivalently: in the FSA for rule $r, does state $ri mean
"we have just read (a string generated by) $sym"?</div>
<div class="Real-P">N.B. $sym is an element, not a name or string, so simple comparison 
is not enough here; we need a bit more.
</div>
<div class="Real-P">Called once, from ixi:leiAdvanceEiSymP(), called in turn thrice
from Earley-recognizer:
<ul><li>in ix:scan() with terminal from rule (so 'terminal' element),</li>
<li>in ix:pred() with nullable nonterminal from rule,</li>
<li>in ix:comp() with constructed nonterminal element created
for the call.</li>
</ul>
So for nonterminals, we need to compare the @name attributes.
</div>
<div class="Real-P">For terminals, the likelihood is that $sym is the element we just
tested the input against, so we will use deep equality as a test.
</div>
<div class="Real-P">Note that this means that in a rule like 
<pre style="margin-left: 2em; background-color: #CCD; margin-right: 3em;">a: 'b', 'c'; 'b', 'd'.</pre>
we will not be advancing both paths on a 'b'.  The caller will
(or: must) call this once for each prediction, so with two different
'terminal' elements.  Since we may be dealing with a copy of the
terminal element, not the original, we must avoid reliance on
element identity.
</div>
<div class="Real-P">Note that this will not be called with a state of 'q0'; it's always
called with a state name corresponding to a symbol.  (We are,
as it were, always checking from the end of the arc, not the start.)</div>
<div class="Real-P">
To do: adjust to 2019 syntax, which no longer has a single 'terminal' 
element type but has 'quoted', 'inclusion', and 'exclusion'.
<div class="scrap"><span><a name="eri-sym-fSymbolmatchRRiSym">&#x3008; 85 Define fSymbolmatchRRiSym() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   fSymbolmatch R Ri Sym($r, $ri, $sym): does symbol 
   element $sym match rule index $ri in rule $r?  
   
   :)
declare function ixi:fSymbolmatchRRiSym(
  $r as element(rule),
  $ri as xs:string,
  $sym as element() (: nonterminal or terminal :)
) as xs:boolean {  
  if ($sym/@xml:id = $ri)
  then true()
  else let $state := $r/descendant::*[@xml:id = $ri]
       return if (local-name($sym) ne local-name($state))
           (: we have a terminal trying to match a nonterminal,
              or vice versa, or different kinds of terminal;
              return false :)
         then false()
         
         else if (ixi:fTerminal($sym))
           (: we have terminals; they match if their children 
              are deep-equal.  NB we are relying on the fact
              that we have just extracted the terminal element
              from the rule we are working on, so it really
              ought to be deep-equal to itself.
              :)
         then deep-equal($state, $sym)
         (: was: 
         then deep-equal($state/*, $sym/*) 
         but when the terminal element is empty, that doesn't work.
         :)
         
         else if (ixi:fNonterminal($sym))
           (: we have non-terminals, they match on name :)
         then ($sym/@name eq $state/@name) 
         
         else (: something wrong :) false()
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#eri-symbols">Symbols (constructors, extractors, etc.) 79</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<h3><a name="ll-input" id="ll-input">4.6. </a>Dealing with the input</h3>

<div class="Real-P">There are no useful constructors for the input.
<div class="scrap"><span><a name="eri-input">&#x3008; 86 Input (constructors, extractors, etc.) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ****************************************************** 
   * Input
   ****************************************************** :)
(: For now, the input is always a string. :)

(: ******************************************************
   * Input: constructors
   :)
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#eri-input-ext">Extractors for input 87</a>&#x3009;, &#x3008;<a href="#eri-input-pred">Predicates for input: fMatchesIPT() 88</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e411">[File Earley-rec-internals.xqm] 7</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">And not much by way of extractors.
<div class="scrap"><span><a name="eri-input-ext">&#x3008; 87 Extractors for input [continues <a href="#eri-input">86 Input (constructors, extractors, etc.)</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   * Input: extractors
   :)
(: ......................................................
   inputlength(): how long is the input?
   
   Used (once) for construction of an Earley item 
   signaling completion
   :)
declare function ixi:inputlength(
  $I as xs:string
) as xs:integer {
  string-length($I)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>

<div class="Real-P">On the other hand, knowing whether the input at a
particular position matches a given terminal symbol is
central to parsing.  For this task, we have two versions
of the function.  The original just returned a Boolean
value, and matched either a literal string or matched a
single character against a character-set expression.


<div class="scrap"><span><a name="eri-input-pred">&#x3008; 88 Predicates for input: fMatchesIPT() [continues <a href="#eri-input">86 Input (constructors, extractors, etc.)</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   * Input: predicates
   :)

(: ......................................................
   fMatches I P T($I, $P, $T): does input $I match 
   terminal $T at position $P?

   The terminals are elements in a rule's right-hand side (not
   strings).  Possible forms:
   In 2016 syntax:  terminal[quoted/@dstring], 
     terminal[quoted/@sstring],
     terminal[quoted/text()], charset, exclude.
   In 2019 syntax:  literal[@dstring], literal[@sstring],
     literal[@hex], inclusion, exclusion.
   In 2022 syntax:  literal[@string], literal[@hex], 
     inclusion, exclusion.
   
   Note that position is 0-based, not 1-based, so we add 1 to it
   for XQuery substring calls.
   :)
declare function ixi:fMatchesIPT( 
  $I as xs:string, 
  $p as xs:integer,
  $t as element()
) as xs:boolean {
  if ($t/self::literal) then
     if (1 eq 0) then (: tracing code :)
     let $sProbe := ixi:string-value($t),
         $cPrLen := string-length($sProbe),
         $sInseg := substring($I,$p+1,$cPrLen),
         $fYesno := ($sProbe eq $sInseg)
     return $fYesno
     else (: normal code :)
     let $sProbe := ixi:string-value($t),
         $cPrLen := string-length($sProbe),
         $sInseg := substring($I,$p+1,$cPrLen),
         $fYesno := ($sProbe eq $sInseg)
     return $fYesno
  else if ($t/self::inclusion or $t/self::exclusion) then
     let $sProbe := ixi:notrace(ixi:reXTerminal($t), 
                              'regex for char set:'), 
         $sInseg := ixi:notrace(substring($I,$p+1,1), 
                              'substring (1 char):'),
         $fYesno := ixi:notrace(matches($sInseg,'^'||$sProbe||'$'),
	                      'matches?')
     return $fYesno
  else (: error :) false()
  (: :)
  (: 
  $cMatchlength := if ($t/self::literal)
  let $s := substring($I,$p + 1), 
            (: Earley is 0-based, XPath 1-based :)
      $f := if ($t/self::literal) 
            then starts-with($s,ixi:string-value($t/quoted))
            else if ($t/self::inclusion or $t/self::exclusion)
            then let $re := ixi:reXTerminal($t)
                 return matches($s,$re)
            else (: error :) false(),
       $trace := ixi:notrace($f,
       concat(
         '&amp;#xA;### fMatchesIPT: &amp;#xA;',
         '  Input = ', $I, '&amp;#xA;',
         '  p =', $p, '&amp;#xA;',
         '  quoted = ', if ($t/self::literal) 
                      then ixi:string-value($t) 
                      else '(SEE RE)', '&amp;#xA;',
         '  re = ', if ($t/self::inclusion or $t/self::exclusion)
           then ixi:reXTermin
al($t)
           else '(SEE LITERAL)',
         '&amp;#xA;Result: '
       )
       )
  return $f
  :)
};
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#eri-input-pred-matchlength">match-length(I,p,t) 90</a>&#x3009;<br></span>

<span class="scrapinbound">Other versions of this code are in &#x3008; <a href="#eri-inpred-pfg">Predicates for input: cMatchIPT()  (v. pfg) 89</a> &#x3009; <br></span><span class="scrapinbound"></span>
</div>
</div>

<div class="Real-P">It will however simplify the construction of the parse tree if
the Earley set contains an item recording that this particular
terminal symbol matched a particular substring of the input.  That
will also simplify the <i>match-length()</i> functions, or
more likely render them unnecessary.  So in version
<i>pfg</i>, we return a match length, not a Boolean, and
rename the function accordingly.  We use -1, not 0, as the failure
signal, in case we ever end up using this for arbitrary regular
expressions which might succeed and match zero characters.

<div class="scrap"><span><a name="eri-inpred-pfg">&#x3008; 89 Predicates for input: cMatchIPT() &#x3009; (for version <em>pfg</em>) &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   * Input: predicates
   :)

(: ......................................................
   cMatches I P T($I, $P, $T): does input $I match 
   terminal $T at position $P?  For how many characters?
   
   Note that position is 0-based, not 1-based, so we add 1 to it
   for XQuery substring calls.
   :)
declare function ixi:cMatchesIPT( 
  $I as xs:string, 
  $p as xs:integer,
  $t as element()
) as xs:integer {
  if ($t/self::literal) then
     let $sProbe := ixi:string-value($t),
         $cPrLen := string-length($sProbe),
         $sInseg := substring($I,$p+1,$cPrLen),
         $fYesno := ($sProbe eq $sInseg)
     return if ($fYesno) 
            then $cPrLen 
            else -1
  else if ($t/self::inclusion or $t/self::exclusion) then
     let $sProbe := ixi:notrace(ixi:reXTerminal($t), 
                              'regex for char set:'), 
         $sInseg := ixi:notrace(substring($I,$p+1,1), 
                              'substring (1 char):'),
         $fYesno := ixi:notrace(matches($sInseg,'^'||$sProbe||'$'),
	                      'matches?')
     return if ($fYesno)
            then 1
            else -1
  else (: error :) -1
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#eri-input-pred">Predicates for input: fMatchesIPT() 88</a> &#x3009; </span>
</div>

</div>

<div class="Real-P">

<div class="scrap"><span><a name="eri-input-pred-matchlength">&#x3008; 90 match-length(I,p,t) [continues <a href="#eri-input-pred">88 Predicates for input: fMatchesIPT()</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   match-length($I,$p,$t): return length of the match in
   input $I at position $p of terminal $t.

   In practice, this is called only when we know there
   is a match, but because of the name, and the
   theoretical possibility of input-dependent answers
   (if we were to allow repetition operators inside
   terminals), we also support cases where there is no
   match and the answer is 0.

   If we later allow repetition operators inside
   terminals, this will become more complex, but for
   now, the value is always 1 if there is a match at all
   for charset and exclude non-terminals, and
   string-length of the literal for quoted strings.

   To do: adjust for 2019 syntax.
 :)
declare function ixi:match-length(
  $I as xs:string,
  $p as xs:integer,
  $t as element()
) as xs:integer {
  if (not(ixi:fMatchesIPT($I, $p, $t))) then 0
  else if ($t/self::literal) then ixi:string-length($t)
  else 1
};

(: See also match-length#1 above under Symbols. :)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div></div>


<div class="div">

<h3><a name="ll-utils" id="ll-utils">4.7. </a>Utilities and miscellaneous</h3>

<div class="Real-P">
<div class="scrap"><span><a name="eri-utils-and-misc">&#x3008; 91 Utilities for recognizer internals module &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ****************************************************** 
   * Utilities
   ****************************************************** :)
(: Things with no other obvious home. :)

(: ******************************************************
   * Utilities: string to regex conversion, 
   * string-length, string-value, ...
   :)
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e2415">Define sceXS() to read range ends 92</a>&#x3009;, &#x3008;<a href="#d3e2421">Define catescXS() to build category escape 93</a>&#x3009;, &#x3008;<a href="#d3e2427">Define charXhex() to get character given hex expression 94</a>&#x3009;, &#x3008;<a href="#d3e2433">Define string-length() 95</a>&#x3009;, &#x3008;<a href="#d3e2440">Define string-value() 96</a>&#x3009;, &#x3008;<a href="#d3e2453">Define s X ei() to build string form of Earley item 97</a>&#x3009;, &#x3008;<a href="#d3e2459">Define eXei() to build 'item' element for Earley item 98</a>&#x3009;, &#x3008;<a href="#d3e2465">Define trace() function for debugging 99</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e411">[File Earley-rec-internals.xqm] 7</a> &#x3009; <br></span>
</div>

</div>

<div class="div">

<h4><a name="ll-utils-strings" id="ll-utils-strings">4.7.1. </a>Routines for strings and characters</h4>
<div class="Real-P">
<div class="scrap"><span><a name="d3e2415">&#x3008; 92 Define sceXS() to read range ends [continues <a href="#eri-utils-and-misc">91 Utilities for recognizer internals module</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   sce X S($s) : given a one-character string or hex
   expression $s (e.g. from a character terminal), check
   to see if it's a hex expression (in which case expand
   and recur) or a magic character (in which case escape
   it) or is best represented for purposes of regex
   mapping) with a single-character escape (in which
   case escape it).
   
   N.B. this is more than strictly necessary for
   character class escapes, but it seems better to be
   more general.

   To do: adjust to new representation of terminals.
   
:)
declare function ixi:sceXS(
  $s as xs:string
) as xs:string {
  (: reEscapists:  regex matching characters 
     which must or may be escaped. :)  
  if (matches($s,'^#[0-9a-fA-F]+$'))
  then ixi:sceXS(ixi:charXhex(
    $s
    (: ixi:notrace($s,'sceXS calling charXhex on ' || $s)) :)
  ))
  else if (string-length($s) gt 1)
  then ixi:escapedstringXS($s) 
  else if (not(contains("&amp;#xA;&amp;#xD;&amp;#x9;\|.-^?$*+{}()[]",$s))) 
  then $s
  else if (contains("\|.-^?$*+{}()[]",$s)) 
  then concat("\" (:":), $s)   (: commented dq helps emacs :) 
  else if ($s eq '&amp;#xA;')
  then "\n"
  else if ($s eq '&amp;#xD;')
  then "\r"
  else if ($s eq '&amp;#x9;')
  then "\t"
  else $s

};

declare function ixi:escapedstringXS(
  $s as xs:string
) as xs:string {
  let $reEscapists := concat('[',
                      '&amp;#xA;&amp;#xD;&amp;#x9;', 
                      '\\\|\.\-\^\?\$\*\+',
		      '\{\}\(\)\[\]',
                      ']') 
  return if (matches($s, $reEscapists))
  then string-join(
    for $i in 1 to string-length($s)
    return ixi:sceXS(substring($s, $i, 1)),
    '')
  else $s
};

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">
<div class="scrap"><span><a name="d3e2421">&#x3008; 93 Define catescXS() to build category escape [continues <a href="#eri-utils-and-misc">91 Utilities for recognizer internals module</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   catesc X S($s): given a one- or two-character string
   from a class element, return the appropriate category
   escape in XSD/XPath notation.

   I should do some sanity checking here, but at the
   moment I'm impatient, so I just wrap it in braces
   with \p in front.

   The 2019 spec says "it is an error if there is no
   such class", so probably I should raise an error if
   the category given does not match the list.  But for
   now, I'll just ignore it and return '.'  to match one
   character, on the theory of "carry on irregardless."

   To do:  figure out how Aparecium should handle errors.
:)
declare function ixi:catescXS(
  $s as xs:string
) as xs:string {
  if (matches($s,'^(L[ulmo]?'
     || '|M[nce]?'
     || '|N[dlo]?'
     || '|P[cdseifo]?'
     || '|Z[slp]?'
     || '|S[mcko]?'
     || '|C[cfon]?)$'))
  then '\p{' || $s || '}'
  else '.'
  (: Letters: u[pper] l[ower] t[itlecase] m[odifier] o[other]
     Marks: n[onspacing], [spacing ]c[ombining], e[nclosing]
     Numbers: d[ecimal digit] l[etter] o[ther]
     Punctuation: c[onnector] d[ash] s [= open]
         e [= close] i[nitial quote] f[inal quote] o[ther]
     Z separators: s[pace] l[ine] p[aragraph]
     Symbols: m[ath] c[urrency] k[=modifier] o[ther]
     C other: c[ontrol] f[ormat] o[=private  use] n[ot assigned]
  :)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">
<div class="scrap"><span><a name="d3e2427">&#x3008; 94 Define charXhex() to get character given hex expression [continues <a href="#eri-utils-and-misc">91 Utilities for recognizer internals module</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   char X hex ($s): accept a hex expression, return the
   character.
:)
declare function ixi:charXhex(
  $s0 as xs:string
) as xs:string {
  (: let $tracing := ixi:notrace($s0,
     'charXhex called with |' || $s0 || '|') :)
  let $s := if (starts-with($s0,'#'))
            then substring($s0,2)
            else $s0
  return if (not(matches($s, '^[0-9a-fA-F]+$')))
         then '---error in charXhex---'
         else codepoints-to-string(d2x:x2d($s))
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">
<div class="scrap"><span><a name="d3e2433">&#x3008; 95 Define string-length() [continues <a href="#eri-utils-and-misc">91 Utilities for recognizer internals module</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   string-length:  calculate 'real' length of string.

   We use this to hide possible variation in the form of
   'quoted' strings.  (Q. Does that mean we are
   expecting quote doubling to show up in the XML form
   of the literal?  It shouldn't.)

   To do: sanity check this, and delete if unnecessary.
   :)
declare function ixi:string-length(
  $q as element(literal)
) as xs:integer {
  string-length(ixi:string-value($q))
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">
<div class="scrap"><span><a name="d3e2440">&#x3008; 96 Define string-value() [continues <a href="#eri-utils-and-misc">91 Utilities for recognizer internals module</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   string-value:  calculate 'real' value of string.

   We use this to hide possible variation in the form of
   quoted strings.  (Q. Does that mean we are expecting
   quote doubling to show up in the XML form of the
   literal?  It shouldn't.)

   To do:  sanity check this, and delete if unnecessary.
   :)
declare function ixi:string-value(
  $q as element(literal)
) as xs:string {
  let $s := if ($q/@string)
            then string($q/@string)
            else if ($q/@dstring)
            then replace($q/@dstring,'""','"') (:":)
            else if ($q/@sstring) 
            then replace($q/@sstring,"''", "'") 
            else if ($q/@hex) 
            then ixi:charXhex($q/@hex)
            else string($q)
  return if (matches($s,'^#[0-9a-fA-F]+$'))
         then ixi:charXhex(
               ixi:notrace($s,'string-value calls cXh on ' || $s) 
             )
         else $s
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
</div>

<div class="div">

<h4><a name="ll-utils-tracing" id="ll-utils-tracing">4.7.2. </a>Trace routines</h4>
<div class="Real-P">For debugging, it's helpful to make traces a little easier.</div>
<div class="Real-P">First, a function to display an Earley item as a string.
<div class="scrap"><span><a name="d3e2453">&#x3008; 97 Define s X ei() to build string form of Earley item [continues <a href="#eri-utils-and-misc">91 Utilities for recognizer internals module</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   s X ei($E): a utility function to help make traces
   more legible.
   :)
declare function ixi:sXei(
  $E as map(xs:string, item())
) as xs:string {
  'item('
  || $E('from') || ' ' 
  || $E('to') || ' '
  || $E('rule')/@name || '/' || $E('ri')
  || ')'
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">Next, a function to build an XML element representing an Earley
item.  This is used less in tracing than in returning verbose results.
<div class="scrap"><span><a name="d3e2459">&#x3008; 98 Define eXei() to build 'item' element for Earley item [continues <a href="#eri-utils-and-misc">91 Utilities for recognizer internals module</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   e X ei($E):  a utility function to help make traces 
   and dumps more legible.
   :)
declare function ixi:eXei(
  $E as map(xs:string, item())
) as element(item) {
  element item {
    attribute from { $E('from') },
    attribute to { $E('to') },
    attribute rulemark { 
        $E('rule')/(@mark, @tmark)[1] 
    },
    attribute rulename { 
        $E('rule')/(@name, @xml:id)[1] 
    },
    attribute ri { $E('ri') }
    }
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">The actual trace function has two forms:  one for when
we want debugging and tracing turned on, and one for when
we want to turn it off globally.  There probably should be
better ways of turning tracing on and off. 
<div class="scrap"><span><a name="d3e2465">&#x3008; 99 Define trace() function for debugging [continues <a href="#eri-utils-and-misc">91 Utilities for recognizer internals module</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody"><span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-trace-function">Define trace() function 100</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-notrace-function">Define notrace() function for debugging 102</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>
</div>
<div class="Real-P">The <i>ixi:trace()</i> function is just a wrapper around
the built-in trace function which inserts newlines. 
<div class="scrap"><span><a name="eri-trace-function">&#x3008; 100 Define trace() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   trace($i, $s):  a utility function to help make code 
   being traced stay more legible.
   :)
declare function ixi:trace(
  $x as item()?,
  $s as xs:string
) as item()? {
  trace($x, '&amp;#xA;' || $s || '&amp;#xA;')
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e2465">Define trace() function for debugging 99</a> &#x3009; <br></span>
</div>

An alternative form also inserts asterisks, but in general that proves
a little too busy.
<div class="scrap"><span><a name="d3e2480">&#x3008; 101 Starry trace() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function ixi:trace(
  $x as item()?, 
  $s as xs:string
) as item()? {
  trace(($x,'')[1], 
    '&amp;#xA;&amp;#xA;********&amp;#xA;' || $s || '&amp;#xA;')
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>

</div>
<div class="Real-P">It will be easier to turn tracing on and off at particular
locations if we also define a <i>notrace()</i> function, which
discards the string and returns the first argument. The dummy form
just throws away the string and returns the item in the first
argument.
<div class="scrap"><span><a name="eri-notrace-function">&#x3008; 102 Define notrace() function for debugging &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   notrace($i, $s):  a utility function to help make 
   code being traced stay more legible.
   :)
declare function ixi:notrace(
  $x as item()?,
  $s as xs:string
) as item()? {
  $x 
}; 
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e2465">Define trace() function for debugging 99</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The dummy form of <i>trace()</i> does the same thing
as <i>notrace()</i>
<div class="scrap"><span><a name="eri-trace-dummy">&#x3008; 103 Define trace() function for debugging &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   trace($i, $s):  a utility function to help make code 
   being traced stay more legible.
   :)
declare function ixi:trace(
  $x as item()?,
  $s as xs:string
) as item()? {
  $x 
}; 
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>

</div>
<div class="Real-P">We also want these available in other modules, like the
Gluschkov module.
<div class="scrap"><span><a name="gl-trace">&#x3008; 104 Define trace() function for debugging &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   trace($i, $s):  a utility function to help make code 
   being traced stay more legible.
   :)
declare function gl:trace(
  $x as item()?,
  $s as xs:string
) as item() {
  trace($x, '&amp;#xA;' || $s || '&amp;#xA;')  
};  
declare function gl:notrace(
  $x as item()?,
  $s as xs:string
) as item()? {
  $x 
}; 
(:
declare function gl:trace($x as item()?, $s as xs:string) as item() {
  $x 
};
:)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e3814">[File Gluschkov.xqm] 164</a> &#x3009; <br></span>
</div>

</div>

</div>
</div>
</div>


<div class="div">

<h2><a name="alt-calls" id="alt-calls">5. </a>Alternative interfaces</h2>
<div class="Real-P">The file Aparecium.xqm offers several different calls
intended for users of the library.  They are defined here.</div>

<div class="div">

<h3><a name="alt-calls-main" id="alt-calls-main">5.1. </a>Main user-facing calls</h3>
<div class="Real-P">The file Aparecium.xqm has the user-facing
function definitions for the main interface
and the alternative interfaces.  Also some
maintenance routines.  <i>To do:</i> allow options
on these to control what is returned, and how:
<ul><li>parse tree(s) or parse-forest grammar?</li>
<li>AST (as in the spec) or raw parse tree (for debugging)?</li>
<li>with or without <em>_from</em> and <em>_to</em> attributes
giving character offsets of the construct?</li>
</ul>
</div>
<div class="Real-P">The <i>aparecium:doc()</i> function is intended to be as close
as possible to the <i>fn:doc()</i> function.  It is not yet
implemented, because it requires a bit more infrastructure.
<div class="scrap"><span><a name="aparecium-main">&#x3008; 105 Main interfaces for Aparecium &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   * Main interfaces (and the simplest) 
   ******************************************************
   :)
  
(: ......................................................
   doc($InputURI)
   ......................................................
   Given the URI of the input, fetch the ixml grammar 
   describing it and return the XML representation of 
   the resource.
:)

(: TO BE IMPLEMENTED: use html fetch to get both HTTP
header and payload.  If MIME type is ixml, fetch grammar
and call parse-string.  Otherwise, if XML and 200 return
payload, otherwise return header and payload.

declare function aparecium:doc(
  $uriI as xs:string
) as element() {
  let $sI := unparsed-text($uriI),
      $sG := unparsed-text($uriG)
  return aparecium:parse-string($sI, $sG)
};
:)

<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ap-pr">Define parse-resource() 8</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ap-ps">Define parse-string() 106</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ap-pswcg">Define parse-string-with-compiled-grammar() 107</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e295">[File Aparecium.xqm] 1</a> &#x3009; <br></span>
</div>

Before it can parse the resource, the <i>doc()</i> function
will need to find a grammar for it.  There are two ways this
can happen (maybe more).
<ul><li><div class="Real-P">The web server hosting the resource can label it with an HTTP
header in which a reference to the grammar is given.  In <a href="#Pemberton-2013"></a>, the example given is a CSS stylesheet which
can be served either as <tt>text/css</tt> (which is usual)
<em>or</em> with the HTTP mediatype header
<tt>application/xml-invisible;
syntax=http://example.com/syntax/css</tt>.  The media type
<tt>application/xml-invisible</tt> (not currently standardized)
signals that the resource is an invisible XML document; the
<tt>syntax</tt> parameter gives the URI of an appropriate ixml
grammar.</div>
<div class="Real-P">This approach allows ixml to fit nicely into the architecture of
the Web.  It has the drawback that for the foreseeable future few
servers will provide such HTTP headers; of lesser importance in the
long run (but one important reason the <i>aparecium:doc()</i> function
has not yet been implemented) is that this approach requires
the implementor of an invisible-XML parser to understand
content negotiation and implement it correctly.</div>
</li>
<li><div class="Real-P">Even if the web server does not provide a pointer to an
invisible-XML grammar, an ixml parser can keep a cache or directory of
grammars for a set of known media types, and use the media type
returned by the server to find an appropriate grammar.</div>
<div class="Real-P">A parser's installation package might, for example, install
grammars for common media types (<tt>text/css</tt>,
<tt>text/csv</tt>, 
<tt>text/markdown</tt>,
<tt>application/sql</tt>,

etc.) and use them when <i>doc()</i> is called on a resource
with a known media type.  Since grammars for known media types will be
useful for all ixml users, there might be reason to make the
collection of grammars available on the web.</div>
<div class="Real-P">A parser might allow the user to add grammars to the
cache, to fill gaps in the collection.</div>
<div class="Real-P">Unfortunately, a number of notations that might be of interest to
ixml users have no MIME type registered with IANA, so this approach
does not help for TeX or LaTeX files (even ones that do not change the
default parsing rules), or for grammars in well known notations like
ABNF or Wirth's EBNF or ISO-standard EBNF.  Other notations of
possible interest for ixml users (such as SVG path expressions,
XPath expressions, XSLT match patterns, and others) do not have
registered media types because they are generally embedded in other
contexts rather than being served as stand-alone resources.</div>
</li>
<li><div class="Real-P">In an environment where a small number of grammars are very
often used, an ixml parser might emulate web browsers which sniff
content by examining the first portion of a resource and seeing
whether it &#x2018;looks&#x2019; like a known media type.  In the
same way, an ixml parser could attempt to identify the grammar of an
undocumented (or <tt>text/plain</tt>) resource by attempting to
parse the first 100 characters using several grammars.  This seems
unlikely to be generally useful, however: there are too many possible
grammars.</div>
</li>
</ul>
</div>
<div class="Real-P">Although its surface simplicity is attractive, the
<i>aparecium:doc()</i> function is not going to cover
all cases.  So we need interfaces that allow the user to specify
both a resource and a grammar.  And for cases where the notation
to be parsed is embedded in an XML document, the user needs to be
able to specify the input to be parsed, and the grammar, either
as a resource (using a URI) or as a string.
The <i>parse-string()</i> takes both as strings.
<div class="scrap"><span><a name="ap-ps">&#x3008; 106 Define parse-string() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   parse-string($Input, $Grammar)
   ......................................................
   Given strings with the input and an ixml grammar
   describing it, returns the XML representation of the
   resource.
:)

declare function aparecium:parse-string(
  $sI as xs:string,
  $sG as xs:string
) as element() {
  let $cG := aparecium:compile-grammar-from-string($sG)
  return 
    aparecium:parse-string-with-compiled-grammar($sI, $cG)
};
   
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#aparecium-main">Main interfaces for Aparecium 105</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Given a string with the input and the pre-processed form of an ixml
grammar describing it, the function
<i>parse-string-with-compiled-grammar()</i> returns the XML
representation of the string's parse tree.</div>
<div class="Real-P">This is the workhorse of the library, called by many other
functions.
<div class="scrap"><span><a name="ap-pswcg">&#x3008; 107 Define parse-string-with-compiled-grammar() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   parse-string-with-compiled-grammar($Input, $Grammar)
   ......................................................
:)
declare function aparecium:parse-string-with-compiled-grammar(
  $sI as xs:string,
  $cG as element(ixml)
) as element() {
  (: let $trace := trace((),'
parse-string-'
                   || ' with-compiled-grammar()
') :)

  let $result := prof:time(
                 (: earley:all-trees($sI, $cG)  :)
                 earley:any-tree($sI, $cG) 
                 , '0 Outer call: ')
		 
  return if (count($result) eq 1)
         then $result
         else &lt;forest 
              xmlns:ixml="http://invisiblexml.org/NS"
	      &gt;{$result}&lt;/forest&gt;
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#aparecium-main">Main interfaces for Aparecium 105</a> &#x3009; <br></span>
</div>

</div>
</div>

<div class="div">

<h3><a name="alt-calls-secondary" id="alt-calls-secondary">5.2. </a>Secondary user-facing calls</h3>

<div class="Real-P">There are a number of high-level functions for parsing and
compiling grammars; they are used by the primary interfaces and they
may be useful for users in particular circumstances; they are
defined here.
<div class="scrap"><span><a name="aparecium-secondary">&#x3008; 108 Secondary interfaces (a bit specialized) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   * Secondary interfaces (a bit more specialized) 
   ******************************************************
   :)
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ap2-pgfu">Define parse-grammar-from-uri() 109</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ap2-pgfs">Define parse-grammar-from-string() 110</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ap2-cgfu">Define compile-grammar-from-uri() 111</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ap2-cgfs">Define compile-grammar-from-string() 112</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ap2-cgfx">Define compile-grammar-from-xml() 113</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e295">[File Aparecium.xqm] 1</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The <i>parse-grammar-from-uri()</i> function
is given the URI of an ixml grammar and returns the XML 
representation of the grammar.  It   
retrieves the grammar and parses it by calling
<i>parse-grammar-from-string()</i>.
<div class="scrap"><span><a name="ap2-pgfu">&#x3008; 109 Define parse-grammar-from-uri() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   parse-grammar-from-uri($ixmlGrammar)
   ......................................................
:)
declare function aparecium:parse-grammar-from-uri(
  $uriG as xs:string
) as element() {
  let $sG := unparsed-text($uriG)
  return aparecium:parse-grammar-from-string($sG)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#aparecium-secondary">Secondary interfaces (a bit specialized) 108</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">The <i>parse-grammar-from-string()</i> function is given
an ixml grammar as a string and returns the XML representation of
the grammar.  It parses the input grammar by calling
<i>parse-string-with-compiled-grammar()</i> with the ixml
grammar for ixml grammars.
<div class="scrap"><span><a name="ap2-pgfs">&#x3008; 110 Define parse-grammar-from-string() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   parse-grammar-from-string($ixmlGrammar)
   ......................................................
:)

declare function aparecium:parse-grammar-from-string(
  $G as xs:string
) as element(ixml) {
  (: CGIG:  compiled grammar for ixml grammars :)
  let $CGIG := doc($aparecium:ixml.gl.xml)/ixml,
      (: PG: parsed grammar :)
      $PG := aparecium:parse-string-with-compiled-grammar($G,$CGIG)
  return if ($PG/self::forest) 
      then trace($PG/ixml,
                 'Warning:  submitted grammar was ambiguous.') 
      else if ($PG/self::Goal) 
      then $PG/ixml 
      else if ($PG/self::ixml) 
      then $PG
      else &lt;ixml&gt;
        &lt;!--* Something is very wrong here *--&gt;
        { $PG }
      &lt;/ixml&gt;
};   
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#aparecium-secondary">Secondary interfaces (a bit specialized) 108</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The <i>compile-grammar-from-uri()</i> function
is given the URI of an ixml grammar and returns the
&#x2018;compiled&#x2019; form of the grammar.
<div class="scrap"><span><a name="ap2-cgfu">&#x3008; 111 Define compile-grammar-from-uri() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   compile-grammar-from-uri($ixmlGrammar)
   ......................................................
:)  

declare function aparecium:compile-grammar-from-uri(
  $uriG as xs:string
) as element() {
  let $xmlG := aparecium:parse-grammar-from-uri($uriG)
  return gluschkov:ME($xmlG)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#aparecium-secondary">Secondary interfaces (a bit specialized) 108</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The <i>compile-grammar-from-string()</i>
function takes an ixml grammar in string form and
returns the compiled representation of the grammar.  
<div class="scrap"><span><a name="ap2-cgfs">&#x3008; 112 Define compile-grammar-from-string() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   compile-grammar-from-string($ixmlGrammar)
   ......................................................
:)  
 
declare function aparecium:compile-grammar-from-string(
  $sG as xs:string
) as element() {
  let $xmlG := aparecium:parse-grammar-from-string($sG)
  return gluschkov:ME($xmlG)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#aparecium-secondary">Secondary interfaces (a bit specialized) 108</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">The <i>compile-grammar-from-xml()</i> function takes an
ixml grammar in XML form (a &#x2018;vxml grammar&#x2019;) and
returns its compiled representation.
<div class="scrap"><span><a name="ap2-cgfx">&#x3008; 113 Define compile-grammar-from-xml() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   compile-grammar-from-xml($ixmlGrammar)
   ......................................................
   Given the XML representation of an ixml grammar,
   returns an annotated representation of the grammar
   that makes it usable by the Earley parser.
:)   

declare function aparecium:compile-grammar-from-xml(
  $xmlG as element(ixml)
) as element(ixml) {
  gluschkov:ME($xmlG)
};

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#aparecium-secondary">Secondary interfaces (a bit specialized) 108</a> &#x3009; <br></span>
</div>

</div>
</div>

<div class="div">

<h3><a name="alt-calls-other" id="alt-calls-other">5.3. </a>Non-user-facing functions</h3>
<div class="Real-P">Some things are in the Aparecium module because
they have to be, even though they are of no interest
to library users.</div>
<div class="Real-P">
<div class="scrap"><span><a name="aparecium-tertiary">&#x3008; 114 Tertiary interfaces (of interest only for maintainer) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   * Tertiary interfaces (of interest only for maintainer) 
   ******************************************************
   :)

(: This is bootstrapping code (for building the Gluschkov
   automaton of the ixml grammar for ixml grammars.  It 
   should be run once whenever the grammar changes -- that 
   is, almost never.  But for now, it's here. 
   :)
  
(: Note that these don't save the result to disk; that's
   not automated yet.
   :)

   (: reparse-ixml-grammar(): produce fresh XML version :)
   
   (: The path starting from Goal on all these is a 
      temporary hack. :)
   
declare function aparecium:reparse-ixml-grammar(
) as element(ixml) {
  aparecium:parse-grammar-from-uri(
      $aparecium:ixml.ixml
  )/Goal/ixml
};
 
(: recompile-ixml-grammar(): produce fresh annotated XML
:)
declare function aparecium:recompile-ixml-grammar(
) as element(ixml) {
  aparecium:compile-grammar-from-uri(
      $aparecium:ixml.ixml
  )/Goal/ixml
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e295">[File Aparecium.xqm] 1</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Where are these things? They really should be in a collection, 
but collections are more complicated.  Maybe later.
<div class="scrap"><span><a name="aparecium-variables">&#x3008; 115 Variables (of interest only for maintainer) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   * Variables (of interest only for maintainer) 
   ******************************************************
   :)
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e2724">Location of library 116</a>&#x3009;, &#x3008;<a href="#d3e2737">Location of ixml grammar 117</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e295">[File Aparecium.xqm] 1</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">It is embarrassing to move things around by changing these
strings, but ... that's what currently happens.
First, what directory are these things in?
<div class="scrap"><span><a name="d3e2724">&#x3008; 116 Location of library [continues <a href="#aparecium-variables">115 Variables (of interest only for maintainer)</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare variable $aparecium:libloc as xs:string
  := '../lib';
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

(Earlier values include 'http://blackmesatech.com/2018/demos/lib'
and 'http://localhost/~cmsmcq/blackmesatech.com/2019/demos/lib'.
The call <tt>Q{org.basex.util.Prop}HOMEDIR()</tt> is
helpful in BaseX.)
</div>
<div class="Real-P">Where is the master (local) copy of the ixml grammar 
for ixml grammars?  We have three forms:  the ixml grammar,
the &#x2018;visible XML&#x2019; representation of
the grammar, and the &#x2018;compiled&#x2019;
representation, with annotations describing each RHS as
an FSA.
<div class="scrap"><span><a name="d3e2737">&#x3008; 117 Location of ixml grammar [continues <a href="#aparecium-variables">115 Variables (of interest only for maintainer)</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare variable $aparecium:ixml.ixml as xs:string
  := $aparecium:libloc || '/ixml.2022-01-25.ixml';

declare variable $aparecium:ixml.xml as xs:string
  := $aparecium:libloc || '/ixml.2022-01-25.ixml.xml';
  
declare variable $aparecium:ixml.gl.xml as xs:string
  := $aparecium:libloc || '/ixml.2022-01-25.ixml.compiled.xml';  
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">Maintenance note: to move to a new version of the ixml grammar, the
following steps should suffice:
<ol><li>Place the new ixml.ixml and ixml.xml into the library
  directory (embedding the date into the file name to reduce confusion
  later).</li>
<li>Update the scrap above to show the new filenames.</li>
<li>Compile the new grammar to the ...compiled.xml file.</li>
<li>Run regression tests.</li>
<li>Make comparison copy of compiled grammar; recompile; compare.
  Since the first compilation used the old grammar, and the second
  used the new grammar, the first and second compiled versions may
  differ; the second and third should not.</li>
</ol>
</div>
</div>
</div>


<div class="div">

<h2><a name="quarry" id="quarry">6. </a>Unsorted bits of legacy code</h2>	
<div class="Real-P">The first version of this document is being made
by taking the existing code and embedding it in
this document.  This section and its subsections
contain portions of the code that have not yet
been broken out into pieces.</div>



<div class="div">

<h3><a name="legacy-Earley-parser.xqm" id="legacy-Earley-parser.xqm">6.1. </a>Earley parser</h3>
<div class="Real-P">The file Earley-parser.xqm has the top-level
function definitions for the parser.  These
functions call the recognizer and construct
a parse tree to return.</div>
<div class="Real-P">General remarks:
</div>
<div class="Real-P">We have a few problems, for which we might as well sketch our
solutions.
<ul><li><div class="Real-P">Some sentences are infinitely ambiguous; they have loops in their
derivation tree:  A is parent of sole child B is parent of sole child
A.</div>
<div class="Real-P">Solution;  cut out those loops, return only loopless trees.</div>
<div class="Real-P">Mechanism:  keep track of the set of ancestors in progress, don't
accept another node for the same nonterminal with the same frontier.</div>
<div class="Real-P">Alternative solution:  fix maximum height of a tree for a given frontier,
e.g. at 1 + number of non-terminals.  (Not an overall limit, just
a limit for a subtree with a fixed frontier.)</div>
</li>
<li><div class="Real-P">Some sentences are infinitely ambiguous: there may be zero or more
adjacent instances of nodes generating the empty string, e.g. in 
the RHS X*, Y, Z*.  (This is an EBNF-specific problem, not possible
for BNF.)</div>
<div class="Real-P">Solution:  cut out loops, return only loopless paths through a RHS.</div>
<div class="Real-P">Mechanism:  keep track of the states you have visited, don't accept
another node for the same state (RHS position, *not* nonterminal)
and the same frontier.</div>
<div class="Real-P">Alternative solution:  fix maximum width for sequence of zero-width
sibling nodes, e.t. at twice the number of positions in the RHS. </div>
</li>
<li><div class="Real-P">The user may want all trees, or one arbitrarily chosen tree, or one
tree with the option to fetch more.</div>
</li>
</ul>
</div>
<div class="Real-P"><i>Delete or revise this:  it's out of date.</i>
We will offer four functions (names subject to change):
<ul><li><div class="Real-P">ep:all-trees($I,$G) will return all loopless parse
trees</div></li>
<li><div class="Real-P">ep:any-tree($I, $G) will return the first tree it finds and
stop</div></li>
<li><div class="Real-P">ep:tree-cursor($I, $G) will return two items: the first tree
it finds and a function to call for the next tree (and the next
function); this involves wrapping up continuations and passing them
around.  (It may be helpful to do a five-finger exercise fetching the
items of a sequence one at a time.)</div></li>
<li><div class="Real-P">ep:parse-forest-grammar($I, $G) will return a parse-forest grammar for
the trees.  It can and should include the looped parse trees.  It may
have clean/dirty variants that do or don't bother to clean the grammar
up (tbd; dunno yet).</div></li>
</ul>
</div>
<div class="Real-P">These are all intended to be user-facing; there will be
corresponding functions internal to the module not intended to be
called by the user.
<div class="scrap"><span><a name="d3e2810">&#x3008; 118  [File Earley-parser.xqm]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: Goal:  to return the set of parse trees recorded implicitly in the
   Earley closure.
   :)
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ep-alltrees">Declare ep:all-trees() function 119</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ep-anytree">Declare ep:any-tree() function 120</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ep-tree-cursor">Declare ep:tree-cursor() function 121</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ep-parse-forest-map">Declare ep:parse-forest-map() function 122</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ep-parse-forest-grammar">Declare ep:parse-forest-grammar() function 123</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">The <i>alltrees()</i> function calls
the internal <i>earley-parse()</i> function
and passes options to it to signal what should be done
with the Earley set.
<div class="scrap"><span><a name="ep-alltrees">&#x3008; 119 Declare ep:all-trees() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ep:all-trees($I,$G):  return all loopless parse trees :)
declare function ep:all-trees(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as element()+ {

  epi:earley-parse($I, $G, 
      map { 'return': 'all-trees',
            'tree-count': -1,
            'failure-dump': 'closure'
      }
  )
  
};

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">Other versions of this code are in &#x3008; <a href="#d3e5017">Declare ep:alltrees() function  (v. v0.2) 198</a> &#x3009; <br></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e2810">[File Earley-parser.xqm] 118</a> &#x3009; <br></span>
</div>
</div>

<div class="Real-P">The <i>anytree()</i> function similarly
calls <i>earley-parse()</i> with a different
option.
<div class="scrap"><span><a name="ep-anytree">&#x3008; 120 Declare ep:any-tree() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ep:any-tree($I,$G):  return one (loopless) parse tree, 
   whichever is found first 
:)
declare function ep:any-tree(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as element()? {
  epi:earley-parse($I, $G, 
      map { 'return': 'any-tree',
            'tree-count': 1,
            'ambiguity-test': true(),
            'failure-dump': 'closure',
            'tree-constructor': 'pfg'
      }
  )
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">Other versions of this code are in &#x3008; <a href="#d3e5022">Declare ep:anytree() function  (v. v0.2) 199</a> &#x3009; <br></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e2810">[File Earley-parser.xqm] 118</a> &#x3009; <br></span>
</div>
</div>

<div class="Real-P">The <i>tree-cursor()</i> function (not yet
implemented) is intended to return a pair consisting of
(1) a parse tree, and (2) a function that will return
another pair for the next parse tree.  When there are
no more trees, a &#x201c;<tt>no-more-trees</tt>&#x201d; signal
will be returned instead of a function.</div>
<div class="Real-P">The name is intended to recall the cursor notion of SQL
results.</div>
<div class="Real-P">If you keep track of the number of trees delivered, the
no-more-trees signal can distinguish there-were-no-trees
from all-done-now signals.
<div class="scrap"><span><a name="ep-tree-cursor">&#x3008; 121 Declare ep:tree-cursor() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function ep:tree-cursor(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as item()* {
  epi:earley-parse($I, $G,  
      map { 'return': 'tree-cursor',
            'failure-dump': 'closure' }
  )
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">Other versions of this code are in &#x3008; <a href="#d3e5028">Declare ep:tree-cursor() function  (v. v0.2) 200</a> &#x3009; <br></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e2810">[File Earley-parser.xqm] 118</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The idea of the <i>parse-forest-map()</i>
function is to return not a parse tree but a parse forest,
in the form of a map.  It is currently not implemented,
and may be unnecessary.  The <i>parse-forest grammar()</i>
function may suffice.
<div class="scrap"><span><a name="ep-parse-forest-map">&#x3008; 122 Declare ep:parse-forest-map() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ep:parse-forest-map($I,$G):  return a map containing an and/or tree
   representing the set of all parses.
:)
declare function ep:parse-forest-map(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as element()* {
  epi:earley-parse($I, $G, 
      map { 'return': 'parse-forest-map', 
            'tree-count': -1,
            'failure-dump': 'closure'
      }
  )
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">Other versions of this code are in &#x3008; <a href="#d3e5035">Declare ep:parse-forest-map() function  (v. v0.2) 201</a> &#x3009; <br></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e2810">[File Earley-parser.xqm] 118</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The <i>parse-forest-grammar()</i> function
returns an ixml grammar describing a single sentence, from
which parse trees can be constructed.
<div class="scrap"><span><a name="ep-parse-forest-grammar">&#x3008; 123 Declare ep:parse-forest-grammar() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ep:parse-forest-grammar($I,$G):  return a BNF (not EBNF[?]) grammar
   describing the set of all parses of $I against $G.
:)
declare function ep:parse-forest-grammar(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as element()* {
  epi:earley-parse($I, $G, 
      map { 'return': 'parse-forest-grammar',
            'tree-count': -1,
            'failure-dump': 'closure'
      }
  )
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">Other versions of this code are in &#x3008; <a href="#d3e5041">Declare ep:alltrees() function  (v. v0.2) 202</a> &#x3009; <br></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e2810">[File Earley-parser.xqm] 118</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Let us pause for a moment to summarize the options
these functions are assuming.  Options and their values
include:
<ul><li><b><tt>return</tt></b>:  one of
&#x201c;<tt>all-trees</tt>&#x201d;,
&#x201c;<tt>any-tree</tt>&#x201d;,
&#x201c;<tt>tree-cursor</tt>&#x201d;,
&#x201c;<tt>parse-forest-map</tt>&#x201d;,
&#x201c;<tt>parse-forest-grammar</tt>&#x201d;.</li>
<li><b><tt>tree-count</tt></b>: an integer specifying a
maximum number of trees to (find and) return.  The magic number -1
is used to signal that all (or as many as possible) should be
returned.</li>
<li><b><tt>ambiguity-test</tt></b>: an boolean value used
when the &#x201c;<tt>tree-count</tt>&#x201d; option is 1, to indicate whether
a second tree should be searched for (though not returned), so as to
correctly detect amgiguity.</li>
<li><b><tt>failure-dump</tt></b>: one of
&#x201c;<tt>yes</tt>&#x201d;, &#x201c;<tt>no</tt>&#x201d;, &#x201c;<tt>closure</tt>&#x201d;.
Used in case of parse failures to indicate whether all data
structures should be dumped; &#x201c;<tt>closure</tt>&#x201d; indicates that
just the closure should be provided.</li>
</ul>
</div>
</div>

<div class="div">

<h3><a name="legacy-Earley-parser-internals.xqm" id="legacy-Earley-parser-internals.xqm">6.2. </a>Parser internals</h3>
<div class="Real-P">The file Earley-parser-internals has low-level
function definitions for the parser,
which are intended to be subject to change
with minimal or no effect on the higher-level
functions.</div>

<div class="div">

<h4><a name="epi-earley-parse-function" id="epi-earley-parse-function">6.2.1. </a>The <i>earley-parse()</i> function</h4>
<div class="Real-P">The function <i>earley-parse()</i> runs the Earley
recognizer on the input and returns results as specified
by the user.  
<div class="scrap"><span><a name="epi-earley-parse">&#x3008; 124 Define earley-parse() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   earley-parse($I, $G, $f);  run Earley recognizer on 
   input $I and grammar $G, return results using 
   $f($leiClosure, $Ec, $I, $G)
:)
declare function epi:earley-parse(
  $I as xs:string,
  $G as element(ixml),
  $options as map(xs:string, item()*)?
) as item()* {
  let $dummy := eri:notrace((), 'epi:earley-parse() ...') 

  let $options := 
      if (empty($options))
      then map { 'return': 'any-tree',
                 'tree-count': 2,
                 'failure-dump': 'closure' }
      else $options

  let $mapResult := prof:time(
                    er:recognizeX($I, $G), 
                    '0a recognize(): '),

      $meiClosure := $mapResult('Closure'),
      $leiCompletions := $mapResult('Completions')

  return 
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ep-success">If we have a parse result, return it 125</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ep-failure">Return parse-failure result 126</a></em> &#x3009;</span>
        
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">Other versions of this code are in &#x3008; <a href="#d3e5047">Define earley-parse()  (v. v0.2) 203</a> &#x3009; <br></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e341">[File Earley-parser-internals.xqm] 4</a> &#x3009; <br></span>
</div>

An earlier version of <i>earley-parse()</i> that used
higher-level functions is reproduced in <a href="#obs-hlf">an
appendix</a>.  In order to support engines that do not implement
higher-level functions, the code has been revised so the standard
interfaces don't use higher-level functions.</div>

<div class="Real-P">In the case of parsing success, the <i>mapResult</i>
will have a &#x201c;<tt>Result</tt>&#x201d; value.  How we return
it depends on what option the user specified.
<div class="scrap"><span><a name="epi-ep-success">&#x3008; 125 If we have a parse result, return it &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  if ($mapResult('Result'))
  then if ($options?return = 'all-trees')
       then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ep-all-trees">Return (approximately) all trees 127</a></em> &#x3009;</span>
       else if ($options?return = 'tree-cursor')
       then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ep-tree-cursor">Return a tree cursor 132</a></em> &#x3009;</span>
       else if ($options?return = 'parse-forest-map')
       then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ep-parse-forest-map">Return a parse-forest map 133</a></em> &#x3009;</span>
       else if ($options?return = 'parse-forest-grammar')
       then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ep-parse-forest-grammar">Return a tree cursor 131</a></em> &#x3009;</span>
       else (: default to any-tree :)
            <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ep-any-tree">Return any tree 128</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-earley-parse">Define earley-parse() 124</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">But first, let's talk about the failure case.
As P.J. Brown points out, in real life the failure case
is much more common that the &#x2018;success&#x2019; case, so
the primary job of a program like Aparecium is to report errors and
help the user understand them; a secondary task is, occasionally, to
produce the prescribed results for error-free input.</div>
<div class="Real-P">At the moment, we just return a &lt;<em>no-parse</em>&gt; element, and if
the user asks for a verbose dump we provide it.
<div class="scrap"><span><a name="epi-ep-failure">&#x3008; 126 Return parse-failure result &#x3009;  &#x2261;</a></span>
<pre class="scrapbody"> (: otherwise, send an apology and explanation :)
  let $closure := &lt;Closure&gt;{
      let $mei := $mapResult('Closure')
      for $n in map:keys($mei('to'))
      order by $n descending
      for $ei in $mei('to')($n)
      return eri:eXei($ei)
  }&lt;/Closure&gt;

  let $high-water := $closure/item[1]/@to/number()
  let $start := max((1, ($high-water - 30))),
      $end := min((string-length($I),
                   ($high-water + 30))),
      $cL := min(($high-water, 30)),
      $cR := min(($end - $high-water, 30)),
      $sL := concat(if ($high-water gt 30)
                    then '...'
                    else '',
                    substring($I, $start, $cL)
             ),
      $sR := concat(substring($I, $high-water+1, 30 (: $cR :) ),
                    if ($cR lt 30)
                    then ''
                    else '...'
             )
  return     
  &lt;no-parse xmlns:ixml="http://invisiblexml.org/NS" ixml:state="failed"&gt;
    &lt;p&gt;Sorry, no parse for this string and grammar.&lt;/p&gt;
    &lt;p&gt;The parser gave up at character {$high-water}:
        parsing succeed up through &lt;q&gt;{
          replace($sL,'
','&amp;#xA;')
        }&lt;/q&gt;
        but failed on &lt;q&gt;{
          replace($sR, '
', '&amp;#xA;')
        }&lt;/q&gt;&lt;/p&gt;{
    if ($options?failure-dump eq 'no')
    then ()
    else if ($options?failure-dump eq 'closure')
    then $closure    
    else if ($options?failure-dump eq 'yes')
    then &lt;dump&gt;
    &lt;p&gt;The map is:&lt;/p&gt;
   
    &lt;Initial-Item&gt;{eri:eXei($mapResult('Initial-Item'))}&lt;/Initial-Item&gt;
    &lt;Input&gt;{$mapResult('Input')}&lt;/Input&gt;
    &lt;Input-Length&gt;{$mapResult('Input-Length')}&lt;/Input-Length&gt;
    &lt;Completions&gt;{
       for $ei in $mapResult('Completions')
       return eri:eXei($ei)
    }&lt;/Completions&gt;
    &lt;Result&gt;{$mapResult('Result')}&lt;/Result&gt;
    &lt;Closure&gt;{$closure}&lt;/Closure&gt;
    &lt;grammar&gt;{(: 'Omitted.' :) $mapResult('Grammar') }&lt;/grammar&gt;
    &lt;/dump&gt;
    else ()
  }&lt;/no-parse&gt;
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-earley-parse">Define earley-parse() 124</a> &#x3009; <br></span>
</div>

Further work is needed here, I think (but this is
better than it used to be).
</div>
<div class="Real-P">Now back to the success cases.
</div>
<div class="Real-P">If the user asks for &#x201c;<tt>all-trees</tt>&#x201d;,
we call <i>epi:all-trees()</i> to make a
list of (raw) parse trees, then turn them into
the required XML.
<div class="scrap"><span><a name="epi-ep-all-trees">&#x3008; 127 Return (approximately) all trees &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">        let $dummy := eri:notrace((), 
                      'epi:earley-parse() has result') 

        let $lpt := prof:time(
                    epi:all-trees($leiCompletions, $meiClosure, $I)
                    , '0b making trees: ')
        let $dummy := eri:notrace((), 
                      'epi:earley-parse() returning a result') 
        for $rpt at $npt in $lpt
        return if ($options?tree-form eq 'raw')
        then $rpt
        else if ($options?tree-form eq 'both')
        then ($rpt, epi:astXparsetree($rpt, count($lpt)))
        else epi:astXparsetree($rpt, count($lpt))
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ep-success">If we have a parse result, return it 125</a> &#x3009; <br></span>
</div>

The current implementation of <i>epi:all-trees()</i> is
sometimes very slow.  An alternative method would be: construct a
parse-forest grammar, and from it construct the trees required.
Another alternative would be to rewrite the direct construction of
parse trees to be smarter and faster.</div>

<div class="Real-P">The &#x201c;<tt>any-tree</tt>&#x201d; option has not been implemented
separately. As a stop-gap we can call <i>all-trees()</i> and
throw all but the first away.  In pathological cases that will waste
a lot of cycles, but not in most normal cases.
Or we can call <i>parse-forest-grammar()</i> and
then extract an arbitrary tree from that.  We choose based
on the user's options, but default to the indirect approach,
which I expect to be faster.
<div class="scrap"><span><a name="epi-ep-any-tree">&#x3008; 128 Return any tree &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">        if ($options?tree-constructor eq 'direct')
        then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ep-any-direct">Construct one tree directly 129</a></em> &#x3009;</span>
        else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ep-any-via-pfg">Construct one tree via parse-forest-grammar 130</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ep-success">If we have a parse result, return it 125</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The &#x2018;direct&#x2019; approach is not
really very direct: we call <i>all-trees()</i>
to construct all the trees, and then choose one.
<div class="scrap"><span><a name="epi-ep-any-direct">&#x3008; 129 Construct one tree directly &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">        let $lpt := prof:time(
                    epi:all-trees($leiCompletions, $meiClosure, $I)
                    , '0b making trees: ')
        let $dummy := eri:notrace((), 
                      'epi:earley-parse() returning a result') 
        for $rpt in $lpt[1]
        return if ($options?tree-form eq 'raw')
        then $rpt
        else if ($options?tree-form eq 'both')
        then ($rpt, epi:astXparsetree($rpt, count($lpt)))
        else epi:astXparsetree($rpt, count($lpt))
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ep-any-tree">Return any tree 128</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The &#x2018;indirect&#x2019; approach via the parse-forest
grammar involves first a call to construct the grammar and then
a call to extract the tree.
<div class="scrap"><span><a name="epi-ep-any-via-pfg">&#x3008; 130 Construct one tree via parse-forest-grammar &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">        let $pfg := prof:time(
                    epi:parse-forest-grammar($leiCompletions, $meiClosure, $I)
                    , '0b making pfg: '),
            $ast := prof:time(
                    epi:tree-from-pfg($pfg, 'document', ())
                    , '0c extracting tree: ')
		    
        let $dummy := eri:notrace((), 
                      'epi:earley-parse() returning a result') 

        return if (1 eq 0) (: debugging hack, delete sometime :)
        then element ap:wrap { 
                   element ap:ast { $ast }, 
                   element ap:pfg { $pfg }
        } 
        else $ast

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ep-any-tree">Return any tree 128</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Parse-forest grammars require no post-processing.
<div class="scrap"><span><a name="epi-ep-parse-forest-grammar">&#x3008; 131 Return a tree cursor &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">        let $dummy := eri:notrace((), 
                      'epi:earley-parse() has result') 

        let $pfg := prof:time(
                    epi:parse-forest-grammar($leiCompletions, $meiClosure, $I)
                    , '0b making pfg: ')
        let $dummy := eri:notrace((), 
                      'epi:earley-parse() returning a parse-forest grammart') 
        return $pfg
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ep-success">If we have a parse result, return it 125</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The tree cursor has not been implemented yet.
<div class="scrap"><span><a name="epi-ep-tree-cursor">&#x3008; 132 Return a tree cursor &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  &lt;tree-cursor-not-available/&gt;
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ep-success">If we have a parse result, return it 125</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Parse-forest maps have not been implemented
yet.
<div class="scrap"><span><a name="epi-ep-parse-forest-map">&#x3008; 133 Return a parse-forest map &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  &lt;parse-forest-map-not-available/&gt;
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ep-success">If we have a parse result, return it 125</a> &#x3009; <br></span>
</div>

</div>

</div>

<div class="div">

<h4><a name="epi-tree-returns" id="epi-tree-returns">6.2.2. </a>Functions to return one or more trees</h4>


<div class="div">

<h5><a name="epi-trf-all-trees" id="epi-trf-all-trees">6.2.2.1. </a>The <i>all-trees()</i> function</h5>
<div class="Real-P">If the user wants all trees, we call the <i>all-trees()</i>
function.</div>
<div class="Real-P">For each completion item in $Ec, we return all parse trees for the
nonterminal $n in $Ec's left-hand side, as documented by $Closure
(a set of Earley items closed over scan(), pred(), and comp().</div>
<div class="Real-P">The result will be one or more elements for nonterminal <tt>$n</tt>.</div>
<div class="Real-P">The main function generates an empty vertical stack (to prevent
looping on infinite sets of trees with unbounded vertical depth)
and calls an auxiliary function to do the work.
<div class="scrap"><span><a name="epi-all-trees">&#x3008; 134 Define all-trees() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   all-trees($Closure, $Ec, $I, $G):  
:)
declare function epi:all-trees(
  $leiCompletions as map(*)*,
  $meiClosure as map(xs:string,
                     map(xs:integer,
                         map(xs:string, item())*)) 
                 (:MEI:),
  $I as xs:string
  (: $G as element(ixml) :)
) as element()* {
  (: Call auxiliary routine with a vertical stack for
     loop prevention. :)
  epi:all-trees($leiCompletions, $meiClosure, $I, ())
};
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e3095">Define auxiliary function for all-trees() 135</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e341">[File Earley-parser-internals.xqm] 4</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">The auxiliary function for generating all trees is initially called
for the item (0 $n Goal $q_final), but it's called again recursively,
once for every completion relevant to the tree(s) we are constructing.
<div class="scrap"><span><a name="d3e3095">&#x3008; 135 Define auxiliary function for all-trees() [continues <a href="#epi-all-trees">134 Define all-trees()</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   all-trees#5:  auxiliary function (more args, does the 
   work) 
:)
   
declare function epi:all-trees(
  $leiCompletions as map(*)*,
  $meiClosure as map(xs:string,
                     map(xs:integer,
                         map(xs:string, item())*)) (:MEI:),
  $I as xs:string,
  $leiVStack as map(*)*
  (: $G as element(ixml) :)
) as element()* {
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-all-trees-for">Iterate over the list of completion items 136</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-all-trees-call-ans">Get the sequences, or rather raw parse trees 137</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-all-trees-return-trees">Return the raw parse trees 138</a></em> &#x3009;</span>
}; 
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">For every original completion item in <tt>$leiCompletions</tt>,
return parse trees for its nonterminal.
<div class="scrap"><span><a name="epi-all-trees-for">&#x3008; 136 Iterate over the list of completion items &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  for $Ec at $nEc in $leiCompletions
             [not(
               some $eiV in $leiVStack
               satisfies deep-equal(.,$eiV)
             )]
  
  let $dummy := eri:notrace($Ec,
    'all-trees called with item '
    || $nEc || ' (of ' || count($leiCompletions)
    || ') = ' || eri:sXei($Ec) 
  )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e3095">Define auxiliary function for all-trees() 135</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">Here, <tt>$Ec</tt> is the completion item for
a nonterminal <tt>$n</tt>.
Its LHS tells us which nonterminal.
Its <i>from</i> and
<i>to</i> positions tell us the frontier
generated by <tt>$n</tt>.
</div>
<div class="Real-P">For each sequence <tt>$ln</tt> of adjacent nodes that
<ul><li>span the range <i>From</i> .. <i>To</i>, and</li>
<li>constitute a path through the RHS of <tt>$n</tt>,</li>
</ul>
return a raw parse-tree element for <tt>$n</tt> with content
<tt>$ln</tt>.
</div>
<div class="Real-P">
We want one parse tree for each possible sequence <tt>$ln</tt>,
but in order to iterate over them, we need to wrap them up in
something (since XDM sequences don't nest).  We will wrap them up in
elements (of type &lt;<em>nt</em>&gt;).  So in fact when we get the sequences
back, they will already be wrapped up in the element; all we need to
do is return them.
<div class="scrap"><span><a name="epi-all-trees-call-ans">&#x3008; 137 Get the sequences, or rather raw parse trees &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $parsetrees := epi:all-node-sequences(
    $Ec,
    $meiClosure,
    (),
    $Ec('from'), 
    $Ec('to'), 
    $I,
    ($Ec, $leiVStack),
    ()
  )</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e3095">Define auxiliary function for all-trees() 135</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">Once we get the trees, we just return them.
<div class="scrap"><span><a name="epi-all-trees-return-trees">&#x3008; 138 Return the raw parse trees &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  for $parsetree in $parsetrees
  let $dummy := eri:notrace($parsetree,
    'all-trees got this parsetree back from item Ec = ' || eri:sXei($Ec))
  return $parsetree 
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e3095">Define auxiliary function for all-trees() 135</a> &#x3009; <br></span>
</div>
</div>
</div>

<div class="div">

<h5><a name="epi-trf-anytree" id="epi-trf-anytree">6.2.2.2. </a>The <i>any-tree()</i> function</h5>
<div class="Real-P">If the user wants an arbitrary tree -- well, for now they are 
out of luck. 
<div class="scrap"><span><a name="epi-any-tree">&#x3008; 139 Define any-tree() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:any-tree(
  $leiCompletions as map(*)*,
  $leiClosure as map(*)*,
  $I as xs:string
) as element()* {
  &lt;any-tree-not-implemented-yet/&gt;
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e341">[File Earley-parser-internals.xqm] 4</a> &#x3009; <br></span>
</div>
</div>
</div>

<div class="div">

<h5><a name="epi-trf-cursor" id="epi-trf-cursor">6.2.2.3. </a>The <i>tree-cursor()</i> function</h5>
<div class="Real-P">We want (eventually) to provide an interface for a kind of
&#x2018;tree cursor&#x2019;, which will allow the user to
iterate over the set of parse trees in the same way as a cursor
in SQL allows the application to read a sequence of results.
In XQuery, the basic idea is to return not a tree but a pair
consisting of (a) a tree and (b) a function to call to get
the next pair.  If there is a finite set of trees, then on
the last tree no function will be returned (or a special function
that raises a particular error when called?).</div>
<div class="Real-P">But for the moment, this is just a stub.
<div class="scrap"><span><a name="epi-tree-cursor">&#x3008; 140 Define tree-cursor() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:tree-cursor(
  $leiCompletions as map(*)*,
  $leiClosure as map(*)*,
  $I as xs:string
) as element()* {
  &lt;tree-cursor-not-implemented-yet/&gt;
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e341">[File Earley-parser-internals.xqm] 4</a> &#x3009; <br></span>
</div>
</div>
</div>

<div class="div">

<h5><a name="epi-trf-pfm" id="epi-trf-pfm">6.2.2.4. </a>The <i>parse-forest-map()</i> function</h5>
<div class="Real-P">Also a stub are functions to return results in the form
of parse forests.  One is a function which when completed
should return a parse-forest map, that is a data structure
with a directed graph containing all parse trees as sub-graphs.
<div class="scrap"><span><a name="epi-parse-forest-map">&#x3008; 141 Define parse-forest-map() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:parse-forest-map(
  $leiCompletions as map(*)*,
  $leiClosure as map(*)*,
  $I as xs:string
) as map(*) {
  map { 'Result' : &lt;parse-forest-map-not-implemented-yet/&gt; }
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e341">[File Earley-parser-internals.xqm] 4</a> &#x3009; <br></span>
</div>
</div>
</div>
</div>

<div class="div">

<h4><a name="epi-all-nodes" id="epi-all-nodes">6.2.3. </a>Finding a sequence of items for a single right-hand side</h4>
<div class="Real-P">One crucial step in finding a tree in the Earley set is
to identify a sequence of items that describe a path through
the right-hand side of a given rule.</div>
<div class="Real-P">The inspiration for the approach used here
is Maarten van Emden's solution to the Eight Queens problem at 
<a href="https://vanemden.wordpress.com/2008/04/27/programming-language-x/">https://vanemden.wordpress.com/2008/04/27/programming-language-x/</a>.
There is no code for stopping when you get a solution, no
overt backtracking,
just full speed ahead over all possibilities.</div>
<div class="Real-P">The result is a depth-first search which turns out in hindsight to
have some very unfortunate properties.  It's harder to understand than
I would like, and it has no form of memoization so given appropriate
input it may solve some subproblems many many times, with horrifying
effects on run time.</div>
<div class="Real-P">To perform this task, we define a function
<i>epi:all-node-sequences</i>(<tt>$item</tt>,
<tt>$closure</tt>, <tt>$acc</tt>, <tt>$from</tt>,
<tt>$to</tt>, <tt>$I</tt>), which iterates selectively (by
recursion) over elements in <tt>$closure</tt> to find items which
form a path through the RHS of a given rule in <i>G</i>.  The items have
the following properties.
<ul><li>All items in the path-sequence have locations in the same rule
for some non-terminal <tt>$n</tt>, namely
<tt>$item('rule')</tt>.  (If they didn't have that rule, they
could not describe a path through its RHS.)</li>
<li>All items in the path-sequence have the same
<i>from</i>-position (= <tt>$from</tt>).  (If they did
not, they would not describe a single instance of the rule's
nonterminal.)</li>
<li>The first item has <i>from</i>-position =
<i>to</i>-position = <tt>$from</tt>; that is, it is the
item produced by the predictor for an instance of the
nonterminal.</li>
<li>The last item has <i>from</i>-position =
<tt>$from</tt> and <i>to</i>-position =
<tt>$to</tt>; that is, it's the completion item for
one instance of the nonterminal.</li>
<li>Each item in the path-sequence advances the path by one symbol;
that is, for any two adjacent items
<i>EI</i>[<i>i</i>]
with <i>to</i> = <i>p1</i> 
and
<i>EI</i>[<i>i</i>+1]
with <i>to</i> = <i>p2</i>, either
<ul><li><i>EI</i>[<i>i</i>+1] will be the value of
<i>scan</i>(<i>E</i>[<i>i</i>],
<tt>$I</tt>) &#x2014; in this case,
<tt>$I</tt>[<i>p1</i> .. <i>p2</i>] matches the
terminal <i>EI</i>[<i>i</i>+1]('ri') &#x2014; or </li>
<li><i>EI</i>[<i>i</i>+1] will be the value of
<i>comp</i>(<i>EIc</i>,
<i>EI</i>[<i>i</i>]) for some <i>EIc</i> in
<tt>$closure</tt>.  In this case, <tt>$closure</tt> will
include some completion item <i>EIc</i> with
<i>from</i> = <i>p1</i>, <i>to</i> =
<i>p2</i>, <i>nonterminal</i> =
<i>EI</i>[<i>i</i>+1]('ri').</li>
</ul>
</li>
</ul>
</div>
<div class="Real-P">At each step (i.e. on each call to this function) we identify one
more item in the sequence.  There may be more than one (because there
may be multiple paths); if so, we iterate recursively on each of them
because we want all node sequences.
</div>
<div class="Real-P">The sequence we find is not represented explicitly, but implicitly
by the sequence of items passed as the current $item (in reverse
order, since we start with the completion).
</div>
<div class="Real-P">Along the way, we accumulate (in <tt>$acc</tt>) raw parse-tree
nodes corresponding to the path:
<ul><li><div class="Real-P">For normal <i>scan()</i> steps,

we create &lt;<em>lit</em>&gt;, &lt;<em>incl</em>&gt;, or &lt;<em>excl</em>&gt; elements
recording the matching string, with the <em>tmark</em> of the
terminal symbol </div></li>
<li><div class="Real-P">For <i>comp()</i> steps, we create &lt;<em>nt</em>&gt;
elements, with <em>name</em> and <em>mark</em> recording the
appropriate GI and annotation, and with content (found by a recursive
call) showing the raw parse tree for that nonterminal; if there is
more than one, we iterate over all of them.</div></li>
</ul>
</div>
<div class="Real-P">The function returns zero or more elements whose name is that on
the left-hand-side of <tt>$item</tt>, whose string value is the
input substring <tt>$from</tt> .. <tt>$to</tt>, and whose
children are the concatenation of (a) the children found by the
recursive call, with (b) those in the accumulator.
<div class="scrap"><span><a name="epi-all-node-sequences">&#x3008; 142 Define all-node-sequences() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   epi:all-node-sequences($item, $closure, 
                          $acc, 
                          $from, $to, $I)
:)
declare function epi:all-node-sequences(
  $Ecur as map(*),
  $meiClosure as map(xs:string, 
                     map(xs:integer, 
                         map(xs:string, 
                             item())*)),
  $lnAcc as item()*,
  $pFrom as xs:integer,
  $pTo as xs:integer,
  $I as xs:string,
  $leiVStack as map(*)*,
  $leiHStack as map(*)*
) as element()* {
  
  let $dummy := eri:notrace(eri:sXei($Ecur),
    'all-node-seqs (0) called with Ecur:')
  return 
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-loopcheck">Check for loops, which mean infinite ambiguity 143</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-basecase">Handle base case:  current item is initial 144</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-recursive">Handle recursive case 147</a></em> &#x3009;</span>  
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e341">[File Earley-parser-internals.xqm] 4</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Before we do any work, we should check to see whether we have
already dealt with this item, in this sequence of nodes.  If we have,
then we are looking at a sentence with an infinite number of parse
trees, and we need to snip the loop.
<div class="scrap"><span><a name="epi-ans-loopcheck">&#x3008; 143 Check for loops, which mean infinite ambiguity &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  (: 1. Before anything else, loop detection:  have we already 
     dealt with this item, in this sequence of nodes? :)
  if (some $eiH in $leiHStack satisfies deep-equal($Ecur, $eiH) )
  then let $dummy := eri:notrace(eri:sXei($Ecur),
           'all-node-seqs (case 1) returns empty sequence, '
           || 'current item has been seen before.')
       return ()
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-all-node-sequences">Define all-node-sequences() 142</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">The base case, on which we terminate because it means we have
completed the node sequence, is when the current Earley item is
initial.  The detection of this case is simplified by the fact that
all initial states are named q0, and only initial states are named q0.
So when we find such a state, we just wrap everything up and return it
to the caller.</div>
<div class="Real-P">N.B. we always return an element, regardless of how our
non-terminal is marked, but we pass the @mark attribute along
so the caller can convert the element to an attribute, or
replace it with its children, in a later pass which constructs
the AST from the raw parse tree.
<div class="scrap"><span><a name="epi-ans-basecase">&#x3008; 144 Handle base case:  current item is initial &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  (: 2. Base case:  $Ecur is initial. :)
  else if ($Ecur('ri') = 'q0'
      and $Ecur('from') eq $Ecur('to')
      and $Ecur('from') eq $pFrom)
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e3444">Construct an element holding the node sequence 145</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-all-node-sequences">Define all-node-sequences() 142</a> &#x3009; <br></span>
</div>

For a state named q0, from = to should always be true.
And for all q0, from = $pFrom should also always be true,
or should follow from the tests made by the caller. 
But we check anyway.  I don't trust this belt, and I don't trust 
these suspenders. </div>
<div class="Real-P">On the output element, we record the input span in
attributes named <em>_from</em> and <em>_to</em>,
and the mark.
<i>And for the moment, as a debugging measure, we also
see whether we can successfully identify the RHS nonterminal
that led to the prediction of this nonterminal.  We already
have a little context information in the form of 
the vertical stack <tt>$leiVStack</tt>,
the horizontal stack <tt>$leiHStack</tt>,
and the node list <tt>$lnAcc</tt>.
Let's examine the tops of those stacks.</i>
<div class="scrap"><span><a name="d3e3444">&#x3008; 145 Construct an element holding the node sequence [continues <a href="#epi-ans-basecase">144 Handle base case:  current item is initial</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  then 
    let $e := element nt {
                 $Ecur('rule')/@name,
                 attribute _from { $pFrom }, 
                 attribute _to { $pTo }, 
                 ( $Ecur('rule')/descendant::*
                                [@xml:id = $Ecur('ri')]
				/@mark
                   ,
                   $Ecur('rule')/@mark,
		   attribute mark { '^' }
                 )[1],
                 $lnAcc
               },
        $trace := eri:notrace(eri:sXei($Ecur),
                      'all-node-seqs (case 2) returns element ' 
		      || 'named ' || name($e) || ' for Ecur:')
    return $e
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">For safekeeping, here is the earlier version of this.
It used the nonterminal name as the GI for the element,
and it tried to handle attributes first.  Both of those
should now be handled by the AST constructor.
<div class="scrap"><span><a name="d3e3450">&#x3008; 146 Construct an element holding the node sequence [continues <a href="#epi-ans-basecase-2016"></a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  then 
    let $e := element {$Ecur('rule')/@name} {
                 attribute _from { $pFrom },
                 attribute _to { $pTo },
                 ( $Ecur('rule')/descendant::*
                                [@xml:id = $Ecur('ri')]
				/@mark
                   ,
                   $Ecur('rule')/@mark
                 )[1],
                 $lnAcc[self::attribute()],
                 $lnAcc[not(self::attribute())]                 
               },
        $trace := eri:notrace(eri:sXei($Ecur),
                      'all-node-seqs (case 2) returns element ' 
		      || 'named ' || name($e) || ' for Ecur:')
    return $e
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>

<div class="Real-P">In the recursive case, <tt>$Ecur</tt> shows, in its rule
location (= FSA state name or position), what symbol <tt>$sym</tt>
we must jump back past.  For example, if <tt>$Ecur</tt> is &#x201c;(0 8
Goal/ixml_0)&#x201d; (as it will be when we are constructing an XML
representation of an ixml grammar eight characters long), then we know
from the rule index <tt>ixml_0</tt> that we now need to find a
parse for <i>ixml</i> ending at position 8, and then
work out where that instance of <i>ixml</i> started.
</div>
<div class="Real-P">Find the item <tt>$eiPrev</tt> that was expecting that symbol
(there may be many); for each such item <tt>$eiPrev</tt>, the
Earley set documents a parse of <tt>$sym</tt> that dominates (or
generates) the input range from <tt>$eiPrev('to')</tt> to
<tt>$Ecur('to')</tt>.  In the example, we will first find
<tt>$sym</tt>, the nonterminal with an ID of <tt>ixml_0</tt>
in the rule for <i>Goal</i>.  How we look for
<tt>$eiPrev</tt> depends on what <tt>$sym</tt> is.
<div class="scrap"><span><a name="epi-ans-recursive">&#x3008; 147 Handle recursive case &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  (: 3. Recursive case. :)
  else (: 3. $Ecur('ri') is not a q0 / initial state :)
    (: 3.a some preparation common to T and N alike :)
    let $riCur := $Ecur('ri'),
        $sym := $Ecur('rule')/descendant::*[@xml:id = $riCur],
        $nParent := $Ecur('rule')/@name/string()
    return
      <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-rec-terminal">Handle recursion on terminal 148</a></em> &#x3009;</span>
      <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-rec-nonterminal">Handle recursion on nonterminal 150</a></em> &#x3009;</span>
      <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-rec-whazzat">Raise error if neither terminal nor nonterminal 155</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-all-node-sequences">Define all-node-sequences() 142</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">If <tt>$sym</tt> is terminal, then our clue for finding <tt>$eiPrev</tt>
is that the relation <tt>scan($eiPrev, $I) =
$Ecur</tt> holds. Find it, and then push
appropriate raw parse nodes 
onto the accumulator and recur.
Or rather, since there may be more than one,
find <em>them</em> (in <tt>$leiPrev</tt>) and then
recur on each of them, pushing the newly created parse node
<tt>$textnode</tt> onto the accumulator.
<div class="scrap"><span><a name="epi-ans-rec-terminal">&#x3008; 148 Handle recursion on terminal &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      (: 3.b current $sym is terminal :)
      if (eri:fTerminal($sym)) then
         let $trace := eri:notrace(eri:sXei($Ecur),
                       'all-node-seqs (case 3b) '
                       || 'unscanning terminal symbol '
		       || $riCur) 
         let $cSymlength := eri:match-length($sym),
             $pMedial := xs:integer($Ecur('to')) - $cSymlength,
             $leiPrev := $meiClosure('to')($pMedial)[ 
                eri:fScanrelEE(.,$Ecur)
                (: and xs:integer(.('to')) eq $pMedial :)
             ],
	     $sVal := substring($I,$pMedial+1,$cSymlength),
	     
             $textnode := element { 
                (: Rename the terminal to reduce confusion
                between grammar and parse tree :)
                if ($sym/self::inclusion) 
                then 'incl' 
                else if ($sym/self::exclusion) 
                then 'excl' 
                else if ($sym/self::literal)
                then 'lit' 
		else 'terminal---'
	     } {
	        $sym/@xml:id, 
		$sym/@tmark,
	        $sym/@regex, 
		attribute string { $sVal },
		attribute cps { string-to-codepoints($sVal) }
             }

         (: recur on each possible previous node :)
         for $eiPrev in $leiPrev
         let $trace := if (count($leiPrev) gt 1)
	               then eri:notrace(eri:sXei($Ecur),
                            'all-node-seqs (case 3b) finds '
			    || count($leiPrev)
                            || ' predecessors, now recurring on eiPrev='
			    || eri:sXei($eiPrev))
		       else eri:notrace(eri:sXei($Ecur),
                            'all-node-seqs (case 3b) finds '
		            || count($leiPrev)
                            || ' predecessors, now recurring on eiPrev='
			    || eri:sXei($eiPrev))

         return epi:all-node-sequences($eiPrev,
                                       $meiClosure,
                                       ($textnode, $lnAcc),
                                       $pFrom,
                                       $pTo,
                                       $I,
                                       $leiVStack,
                                       ($Ecur, $leiHStack)
                                      )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ans-recursive">Handle recursive case 147</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">The initial version rendered terminals as text nodes and not as
elements.  So it had no place to put a <em>tmark</em>.
<div class="scrap"><span><a name="epi-ans-rec-terminal-2016">&#x3008; 149 Handle recursion on terminal &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      (: 3.b current $sym is terminal :)
      if (eri:fTerminal($sym)) then
         let $trace := eri:notrace(eri:sXei($Ecur),
                       'all-node-seqs (case 3b) '
                       || 'unscanning terminal symbol '
		       || $riCur) 
         let $cSymlength := eri:match-length($sym),
             $pMedial := xs:integer($Ecur('to')) - $cSymlength,
             $leiPrev := $meiClosure('to')($pMedial)[ 
                eri:fScanrelEE(.,$Ecur)
                (: and xs:integer(.('to')) eq $pMedial :)
              ],
             $textnode := text { substring($I,$pMedial+1,$cSymlength) }
             (: let $trace := eri:notrace($textnode,
	                      'Adding a text node: ') :)
         (: recur on each possible previous node :)
         for $eiPrev in $leiPrev
         let $trace := if (count($leiPrev) gt 1)
	               then eri:notrace(eri:sXei($Ecur),
                            'all-node-seqs (case 3b) finds '
			    || count($leiPrev)
                            || ' predecessors, now recurring on eiPrev='
			    || eri:sXei($eiPrev))
		       else eri:notrace(eri:sXei($Ecur),
                            'all-node-seqs (case 3b) finds '
		            || count($leiPrev)
                            || ' predecessors, now recurring on eiPrev='
			    || eri:sXei($eiPrev))

         return epi:all-node-sequences($eiPrev,
                                       $meiClosure,
                                       ($textnode, $lnAcc),
                                       $pFrom,
                                       $pTo,
                                       $I,
                                       $leiVStack,
                                       ($Ecur, $leiHStack)
                                      )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>

</div>
<div class="Real-P">If <tt>$sym</tt> is nonterminal, we can find
<tt>$eiPrev</tt> by exploiting the fact that the relation
<tt>comp($EComp, $eiPrev, $G) = $Ecur</tt> holds.  The closure
should include at least one completion item of the form
(<tt>$eiPrev('to')</tt>, <tt>$Ecur('to')</tt>,
<tt>$sym</tt>, <tt>$ri</tt>), where <tt>$ri</tt> is a
final state of a rule for <tt>$sym</tt>.
</div>
<div class="Real-P">We're going to break this down into steps.
First, just identify this case (and possibly issue
a trace message).
<div class="scrap"><span><a name="epi-ans-rec-nonterminal">&#x3008; 150 Handle recursion on nonterminal &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      (: 3.c current $sym is nonterminal :)
      else if ($sym/self::nonterminal) then 
         let $trace := eri:notrace(eri:sXei($Ecur), 
                       'all-node-seqs (case 3c) '
		       || 'trying to unparse nonterminal '
		       || $riCur) 
         <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-recnt-leiprev">Find the child completions for $sym 151</a></em> &#x3009;</span>
         <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-recnt-lnodechild">Find parse trees for the child completions 152</a></em> &#x3009;</span>
         <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-recnt-recur">Recur on each predictor 153</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ans-recursive">Handle recursive case 147</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">Then find all completion items (<tt>$leiPrev</tt>) for
nonterminal <tt>$sym</tt> finishing at this position.  That is, if
<tt>$sym</tt> is a RHS reference to <i>ixml</i>, the
completion items will have the form (<i>start</i>,
<i>to</i>, <i>ixml</i>/<i>q_f</i>).  What we
want is every item in the closure which (a) has the right
<i>to</i>-position and (b) is final for the right nonterminal.
<div class="scrap"><span><a name="epi-ans-recnt-leiprev">&#x3008; 151 Find the child completions for $sym &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">         let $leiPrev := $meiClosure('to')($Ecur('to'))[
           eri:fFinalEiPN(.,$Ecur('to'),$sym)
         ]
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ans-rec-nonterminal">Handle recursion on nonterminal 150</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Now, for each child completion, find all possible parse trees, and
then find all possible predictor items for <tt>$sym</tt> at the
start position of the completion item.  That is, all items ending
at that position, for which <tt>$sym</tt> is in the follow set.
<div class="scrap"><span><a name="epi-ans-recnt-lnodechild">&#x3008; 152 Find parse trees for the child completions &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">         for $eiCC at $nEiCC in $leiPrev
         let $trace := eri:notrace(eri:sXei($Ecur),
	       'all-node-seqs (case 3c) finds completion item '
               || '(' || $nEiCC || ' of '
	       || count($leiPrev) || ')'
               || ' for ' || $sym/@name
	       || ', namely ' || eri:sXei($eiCC)
	       || ' and calls all-trees for it.')
         let $lnodeChild := epi:all-trees($eiCC,
                                          $meiClosure,
	                                  $I,
					  $leiVStack), 
             $leiPredictors := $meiClosure('to')($eiCC('from'))
	                       [eri:fAdvanceNrelEE(.,$Ecur)
                                (: and .('to') eq $eiCC('from') :)]

	 (:
         let $trace := for $nCh in $lnodeChild
                       return eri:notrace($nCh,
                              'all-node-seqs got this back'
			      || ' from all-trees:') 
         :)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ans-rec-nonterminal">Handle recursion on nonterminal 150</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">For each pair of parse tree and predictor item,
we need to recur appropriately.
<div class="scrap"><span><a name="epi-ans-recnt-recur">&#x3008; 153 Recur on each predictor &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">         for $eiPred at $nEiP in $leiPredictors
         let $trace := eri:notrace(eri:sXei($Ecur),
	       'all-node-seqs (case 3c) finds predictor '
               || '(' || $nEiP || ' of '
	       || count($leiPredictors) || ')'
               || ' for ' || $sym/@name
	       || ', namely ' || eri:sXei($eiPred))
         
         for $nodeCh0 at $nNch in $lnodeChild
         <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-recnt-munge-mark">Adjust mark attribute on $nodeCh as needed 154</a></em> &#x3009;</span>
         let $trace := eri:notrace(eri:sXei($Ecur),
	       'all-node-seqs recurs on child'
               || '(' || $nNch
	       || ' of ' || count($lnodeChild) || '),'
               || ' (predictor' || $nEiP
	       || ' of ' || count($leiPredictors) || '),'
               || ' (Completion' || $nEiCC
	       || ' of ' || count($leiPrev) || '),'
			   )

         return epi:all-node-sequences($eiPred,
                                       $meiClosure,
                                       ($nodeCh, $lnAcc),
                                       $pFrom,
                                       $pTo,
                                       $I,
                                       $leiVStack,
                                       ($Ecur, $leiHStack)
                                      )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ans-rec-nonterminal">Handle recursion on nonterminal 150</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">There's one more complication.  The trees produced
by the call to <i>all-trees()</i> have <em>mark</em>
attributes reflecting the mark on the rule for the nonterminal.
If a mark is specified on the RHS reference to the nonterminal
(that would be the <tt>$sym</tt> element), it needs to
over-ride the mark on the rule.  So before we pop the
child nodes into the accumulator, we make sure their
<em>mark</em> attribute is correct.
<div class="scrap"><span><a name="epi-ans-recnt-munge-mark">&#x3008; 154 Adjust mark attribute on $nodeCh as needed &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">         let $nodeCh := 
             if (exists($sym/@mark)) 
             then element { name($nodeCh0) } {
	         $nodeCh0/(@* except @mark), 
	         $sym/@mark,
		 $nodeCh0/node()
	     }
             else $nodeCh0
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ans-recnt-recur">Recur on each predictor 153</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">If what we are looking at has not been recognized
as a terminal or a nonterminal, then we are out of luck
and can only report a problem.
<div class="scrap"><span><a name="epi-ans-rec-whazzat">&#x3008; 155 Raise error if neither terminal nor nonterminal &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      else (: not terminal, not nonterminal, we have a problem :)
        &lt;error-in-all-node-sequences
          from="{$pFrom}" to="{$pTo}"&gt;{
            eri:sXei($Ecur)
          }&lt;/error-in-all-node-sequences&gt;
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ans-recursive">Handle recursive case 147</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Here we appear to have some cruft that has been commented
out but not removed.
<div class="scrap"><span><a name="epi-lnDepXCleC">&#x3008; 156 Define lnDepXClEc() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: lnDepXClEc($Closure, $Ec):  from the Earley closure $Closure,
   extract the dependents of the node completed by $Ec.
:)
(: 
declare function epi:lnDepXClEc(
  $leiClosure as map(*)*, 
  $Ec as map(*)
) as item()* {
  &lt;lnDepXClEc-not-implemented/&gt;
};
  :)
(: eMakeEcLndepLaLa($Ec,$ln,$lA,$lC):  given a completion item $Ec,
   a (possibly partial) list of dependent nodes $ln, and 
   accumulated lists of attributes and children, construct an
   element.
 :)
 (:
declare function epi:eMakeEcLndepLaLc(
  $Ec as map(*),
  $lnDep as item()*
) as element() {
  let $gi := $Ec('rule')/@name,
      $lAtts := $lnDep[self::attribute()],
      $lChildren := $lnDep[self::element() 
                     or self::text() 
                     or self::comment() 
                     or self::processing-instruction()]
  return element {$gi} { $lAtts, $lChildren }
};

:)  
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>
</div>
</div>

<div class="div">

<h4><a name="epi-ast-from-raw" id="epi-ast-from-raw">6.2.4. </a>Extracting the abstract syntax tree from the raw parse tree</h4>
<div class="Real-P">The parse tree extraction routines defined elsewhere produce
the raw parse tree, but ixml requires that we return an abstract
syntax tree.  So we need a function to take a raw parse tree
and return the corresponding AST.</div>
<div class="Real-P">There are several different functions, depending on which
situation we are in.
<ul><li><div class="Real-P">The initial call expects to find the 'Goal' nonterminal at
the root of the raw parse tree; it then passes its child element to a
function that seeks to make the document element.</div>
<div class="Real-P">If that function returns multiple children, the function
provides an &lt;<em>ixml:multiple-roots</em>&gt; wrapper.</div></li>
<li><div class="Real-P">The function to make a document element
&#x2018;knows&#x2019; that so far we don't have any parent
element, so in the normal case it just recurs looking for a
nonterminal marked as an element.  It deals differently with
different cases:
<ul><li>A nonterminal marked &#x201c;<tt>^</tt>&#x201d; is passed to
an element constructor.</li>
<li>A nonterminal marked &#x201c;<tt>-</tt>&#x201d; is skipped; the
function recurs on its children.  (It is this recursion which
makes it possible for the function to return multiple results.)</li>
<li>A nonterminal marked &#x201c;<tt>@</tt>&#x201d; is serialized as an
element (as required by the spec).</li>
<li>A terminal is wrapped in an &lt;<em>ixml:wrapper</em>&gt;
element.</li>
</ul>
</div></li>
<li><div class="Real-P">The element constructor should be called only on nonterminals
marked as elements.  It serializes the nonterminal as an element and
calls other functions to collect its attributes and its
content.</div></li>
<li><div class="Real-P">The function to collect attributes for a parent element
just constructed will recur through the relevant subtree of the raw
parse tree, looking for nonterminals marked as attributes.  It will
recur through hidden nonterminals, stop the recursion on
element nonterminals, raise an error on terminals, and call an
attribute-value constructor when it finds a nonterminal marked as an
attribute.</div></li>
<li><div class="Real-P">The attribute-value constructor function recurs, gathering
character data from terminals and ignoring the markings on all
intervening nodes.</div></li>
<li><div class="Real-P">The function to gather content for a parent element just
constructed will recur through the relevant subtree of the raw parse
tree, ignoring attributes, serializing terminals, recurring through
hidden nonterminals, and calling the element constructor on
serializable nonterminals.</div></li>
</ul>
</div>

<div class="div">

<h5><a name="epi-ast-init" id="epi-ast-init">6.2.4.1. </a>The initial call</h5>

<div class="Real-P">The top-level AST constructor function descends past the Goal
wrapper and passes its one descendant to the document-element
constructor.  It assigns the result to a variable, so it can check how
many nodes came back: if more than one, a special wrapper is needed.
It also rewrites the outer element if needed, adding an ambiguity
flag.</div>
<div class="Real-P">To handle the ambiguity flag, we accept a parameter showing how
many parse trees the caller got back from the
<i>recognizeX()</i> function; if it's greater than one, we
mark the result with <tt>ixml:state="ambiguous"</tt>, declaring
the namespace as <tt>xmlns:ixml="http://invisiblexml.org/NS"</tt>.
<div class="scrap"><span><a name="epi-astXparsetree">&#x3008; 157 Define astXparsetree() to make AST from raw parse &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:astXparsetree(
  $E as element(nt),
  $cpt as xs:integer
) as node()* {
  if (empty($E/nt)) 
  then
      element error {
          text {
              "Parse tree had wrapper",
              "but no content."
          }
      }
  else
      let $doc0 :=
              for $c in $E/*
              return epi:doc-elementXpt($c),
          $doc1 :=
	      if (count($doc0) eq 1) 
              then $doc0 
	      else if (count($doc0) eq 0) 
              then element ixml:no-roots {}
	      else element ixml:multiple-roots {
	          $doc0
	      }
      return
          if ($cpt eq 1) 
          then $doc1
	  else element { name($doc1) } {
	       attribute ixml:state { 'ambiguous' },
	       $doc1/@*, 
	       $doc1/node()
	  }
};
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-docelXpt">Define doc-elementXpt() to make AST for document element 158</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-elXpt">Define elementXpt() to make AST for one element 160</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-attsXpt">Define attributesXpt() to collect attributes 161</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-avXpt">Define avXpt() to collect attribute value 162</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-contentXpt">Define contentXpt() 163</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e341">[File Earley-parser-internals.xqm] 4</a> &#x3009; <br></span>
</div>
</div>
</div>

<div class="div">

<h5><a name="epi-ast-outer" id="epi-ast-outer">6.2.4.2. </a>The document-element constructor</h5>
<div class="Real-P">The constructor for the document element is distinct from the
ordinary element constructor because in the special case that the
top-most node of the result is an attribute or a terminal symbol, we
want to coerce the result into an element.</div>
<div class="Real-P">
<div class="scrap"><span><a name="epi-docelXpt">&#x3008; 158 Define doc-elementXpt() to make AST for document element &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:doc-elementXpt(
  $E as element()*
) as node()* {
  (: Normal case :)
  if ($E/self::nt[@mark = '^' or not(@mark)]) 
  then epi:elementXpt($E)
  
  (: Hidden wrapper, recur :) 
  else if ($E/self::nt[@mark = '-']) 
  then for $c in $E/*
      return epi:doc-elementXpt($c) 

  (: Attribute (sic) :) 
  else if ($E/self::nt[@mark = '@']) 
  then element { $E/@name } {
      attribute ixml:warning {
          'Attribute found as root of AST'
      }
  }

  (: Terminal (sic) :) 
  else if ($E/self::*[name() = ('lit', 'incl', 'excl')])  
  then element ixml:terminal {
      attribute warning { 
          'Terminal found as root of AST'
      }, 
      text { <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-sXpt">Make string from raw parse tree terminal $E 159</a></em> &#x3009;</span> } 
  }
  
  (: Unexpected input: what? :)
  else &lt;oops&gt;{$E}&lt;/oops&gt;
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-astXparsetree">Define astXparsetree() to make AST from raw parse 157</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">There are a couple of places where we will need to
make a string from a raw parse tree terminal. This
involves checking that the terminal is not marked
hidden and then serializing from the list of code points.
(An approximation of the string value will be in the

<div class="scrap"><span><a name="epi-sXpt">&#x3008; 159 Make string from raw parse tree terminal $E &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/@tmark = '-')  
       then ()  
       else codepoints-to-string(
               for $t in tokenize(
                   normalize-space($E/@cps),
	           '\s')  
               return xs:integer($t)
       )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-docelXpt">Define doc-elementXpt() to make AST for document element 158</a> &#x3009; &#x3008; <a href="#epi-avXpt">Define avXpt() to collect attribute value 162</a> &#x3009; &#x3008; <a href="#epi-contentXpt">Define contentXpt() 163</a> &#x3009; <br></span>
</div>

</div>
</div>

<div class="div">

<h5><a name="epi-ast-element" id="epi-ast-element">6.2.4.3. </a>The element constructor</h5>
<div class="Real-P">The ordinary element constructor creates an element with the
appropriate name, then calls two functions to traverse the current
part of the raw parse tree and collect attributes and content,
respectively.  The argument is required to be an &lt;<em>nt</em>&gt;
element and expected to be marked &#x201c;<tt>^</tt>&#x201d;.</div>
<div class="Real-P">
<div class="scrap"><span><a name="epi-elXpt">&#x3008; 160 Define elementXpt() to make AST for one element &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:elementXpt(
  $E as element()
) as node()* {
  element { $E/@name } {
      if ($E/@mark = ('-', '@'))
      then attribute ixml:warning {
          'Wrong mark (' || $E/@mark 
          || ') on nonterminal'
      }
      else (),
      for $c in $E/*
      return epi:attributesXpt($c), 
      for $c in $E/*
      let $dummy := eri:notrace(
          concat(name($c), '/', $c/@name, '/', $c/@xml:id),
          'constructing content from:') 
      let $n := epi:contentXpt($c)
      let $dummy := for $chunk in $n return
          if ($chunk instance of text())
          then eri:notrace(concat('/',
	       string-join(string-to-codepoints($chunk),' '), 
               '/'), 
               'eXpt got text node') 
          else if ($chunk instance of element())
	  then eri:notrace($chunk/name(), 'eXpt gets element:') 
	  else eri:notrace($chunk, 'eXpt gets unknown item:') 
      return $n
  }
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-astXparsetree">Define astXparsetree() to make AST from raw parse 157</a> &#x3009; <br></span>
</div>
</div>
</div>

<div class="div">

<h5><a name="epi-ast-attcoll" id="epi-ast-attcoll">6.2.4.4. </a>The attribute collector</h5>
<div class="Real-P">The attribute collector traverses the subtree looking for things to
serialize as attributes on the current element.  For
each such nonterminal, it constructs the attribute and
called the attribute value constructor to construct
the value.
<div class="scrap"><span><a name="epi-attsXpt">&#x3008; 161 Define attributesXpt() to collect attributes &#x3009;  &#x2261;</a></span>
<pre class="scrapbody"> 
declare function epi:attributesXpt(
  $E as element()
) as attribute()* {
  (: Main case: make an attribute :)
  if ($E/self::nt[@mark = '@']) 
  then attribute { $E/@name } {
      string-join(
          (for $c in $E/*
          return epi:avXpt($c)),
	  '')
  }

  (: skip terminals and elements :)
  else if ($E/name() = ('lit', 'incl', 'excl')) 
  then () 
  else if ($E/self::nt[@mark = '^' or not(@mark)])
  then ()

  (: recur through hidden nt :)
  else if ($E/self::nt[@mark = '-']) 
      then for $c in $E/*
      return epi:attributesXpt($c)

  else eri:trace((),
      '! unexpected argument to attributesXpt()') 
     
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-astXparsetree">Define astXparsetree() to make AST from raw parse 157</a> &#x3009; <br></span>
</div>
</div>
</div>

<div class="div">

<h5><a name="epi-ast-attvalue" id="epi-ast-attvalue">6.2.4.5. </a>The attribute value constructor</h5>
<div class="Real-P">The attribute value constructor traverses a subtree constructing
the string value of an attribute.  The spec says we serialize &#x201c;all
non-hidden terminal descendants of the node (regardless of marking of
intermediate nonterminals)&#x201d;. So we ignore the &#x201c;<tt>^</tt>&#x201d;
marking and treats it the same as &#x201c;<tt>-</tt>&#x201d;, recurring
through it. For an example of this treatment, see the handling of
<i>dchar</i> and <i>schar</i> in the current ixml
grammar.
<div class="scrap"><span><a name="epi-avXpt">&#x3008; 162 Define avXpt() to collect attribute value &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:avXpt(
  $E as element()
) as xs:string* {
  if ($E/(self::incl or self::excl or self::lit))
  then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-sXpt">Make string from raw parse tree terminal $E 159</a></em> &#x3009;</span> 
  else for $c in $E/*
       return epi:avXpt($c)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-astXparsetree">Define astXparsetree() to make AST from raw parse 157</a> &#x3009; <br></span>
</div>

</div>
</div>

<div class="div">

<h5><a name="epi-ast-content" id="epi-ast-content">6.2.4.6. </a>The content collector</h5>
<div class="Real-P">The content collector traverses the subtree looking for things to
serialize as content of the current element and either
serializing them itself (if terminals) or passing them to the
element constructor.
<div class="scrap"><span><a name="epi-contentXpt">&#x3008; 163 Define contentXpt() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:contentXpt(
  $E as element()
) as item()* {
  if ($E/self::nt[@mark = '^' or not(@mark)])
  then epi:elementXpt($E)
  else if ($E/self::nt[@mark = '-'])
  then for $c in $E/*
       return epi:contentXpt($c)
  else if ($E/self::nt[@mark = '@'])
  then ()
  else if ($E[self::incl or self::excl or self::lit])
  then text { <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-sXpt">Make string from raw parse tree terminal $E 159</a></em> &#x3009;</span> }
  else element ixml:unexpected {
       attribute f { "epi:contentXpt" }, 
       $E
  }
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-astXparsetree">Define astXparsetree() to make AST from raw parse 157</a> &#x3009; <br></span>
</div>

</div>
</div>
</div>
</div>


<div class="div">

<h3><a name="legacy-Gluschkov.xqm" id="legacy-Gluschkov.xqm">6.3. </a>Construction of the Gluschkov automaton</h3>
<div class="Real-P">The file Gluschkov.xqm has routines for annotating
a grammar with attributes that allow the right-hand
sides to be interpreted as Gluschkov automata:  that is,
finite state automata whose states are the basic symbols
of the regular expression.
<div class="scrap"><span><a name="d3e3814">&#x3008; 164  [File Gluschkov.xqm]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">module namespace gl =
"http://blackmesatech.com/2019/iXML/Gluschkov";

(: Constructs a Gluschkov automaton for ixml :)

(: GPL ...:) 

<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-prolog">Prolog for Gluschkov module 165</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME">Define function gl:ME() 166</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-merge">Define gl:merge() 184</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-read-one-ixml-char">Define gl:read-one-char-spec() 168</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-trace">Define trace() function for debugging 104</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>
</div>
<div class="Real-P">This module is one place affected by the syntax changes
between 2013 and 2021.  Most scraps are defined twice,
once in the initial version following the 2013 syntax,
and again for today's syntax. 
(Steven's original paper said something about bootstrapping
and supporting multiple syntaxes, but I got confused and am
not going to try to do that.  Too clever for me.)
</div>

<div class="div">

<h4><a name="leggl-prolog" id="leggl-prolog">6.3.1. </a>Module prolog</h4>
<div class="Real-P">The module prolog defines a namespace for follow sets, and a
variable with the namespace name.  We also import the
<i>d2x</i> library so we can use its hex-to-decimal
conversion.
<div class="scrap"><span><a name="gl-prolog">&#x3008; 165 Prolog for Gluschkov module &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare namespace follow =
"http://blackmesatech.com/2016/nss/ixml-gluschkov-automata-followset";

import module namespace d2x =
'http://blackmesatech.com/2019/iXML/d2x'
at "d2x.xqm";

declare variable $gl:follow-ns :=
"http://blackmesatech.com/2016/nss/ixml-gluschkov-automata-followset";
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e3814">[File Gluschkov.xqm] 164</a> &#x3009; <br></span>
</div>

</div>
</div>

<div class="div">

<h4><a name="leggl-ME" id="leggl-ME">6.3.2. </a>Calculating the Gluschkov automaton <i>M</i> <sub><i>E</i></sub></h4>


<div class="Real-P">For a regular expression <i>E</i>, the Gluschkov automaton
(conventionally referred to as <i>M</i> <sub><i>E</i></sub>) is a finite state automaton
derived from (and in some sense constructed on top of) <i>E</i>.  The
states of <i>M</i> <sub><i>E</i></sub> are the basic symbols of <i>E</i>, with the fairly
straightforward interpretation that we are in a given state <i>q</i> if and
only if we have just read an input character (or, in the general case,
character sequence) that matches the atomic symbol <i>q</i>.  We calculate
the Gluschkov automaton by following the algorithm laid out in
Br&#xfc;ggemann-Klein 1993, adapted for the XML form of ixml grammars.</div>
<div class="Real-P">Each node <i>$E</i> in the expression gets:
<ul><li><em>id</em> to identify the expression; in the case of positions (i.e. 
       occurrences of symbols in the alphabet, as opposed to
       parenthesized expressions etc.), this also
       serves as an identifier for the FSA state.</li>
<li><em>first</em> = set of positions which match the first symbol of some word
       in <i>L($E)</i></li>
<li><em>last</em> = set of positions which match the last symbol in some word
       in <i>L($E)</i></li>
<li><em>nullable</em> = true iff <i>L($E)</i> contains the empty
word</li>
</ul>
</div>
<div class="Real-P">We also have attributes to represent the
<i>follow</i>(<i>exp</i>, <i>sym</i>) function
for <i>exp</i>=<i>$E</i>.  For each position $p in $E
we have an attribute in the follow namespace whose local name is the
ID of $p; the value of the attribute is the set of positions which can
follow $p in a path through $E.
</div>
<div class="Real-P">By representing follow($E,$p) as an attribute on $E we avoid having
to traverse the tree multiple times.
</div>

<div class="Real-P">The
construction of the Gluschkov automaton consists largely of
calculating, from the structure of <i>E</i>, which symbols can follow which
other symbols, and defining an appropriate transition function.
Along the way, various auxiliary functions are computed for each
subexpression of <i>E</i>.</div>
<div class="Real-P">For the right-hand side of a rule in an ixml grammar, the basic
symbols of the expression are terminal and nonterminal symbols, and
the subexpressions include both the basic symbols and the other
elements in the XML representation of the right-hand side.  For each
subexpression, we add attributes to record various values:
<ul><li>an ID (for use in referring to the state)</li>
<li><em>nullable</em> (is the empty string in the language
defined by this sub-expression?)</li>
<li><em>first</em> (what are the initial states in the
sub-automaton for this sub-expression?)</li>
<li><em>last</em> (what are the final states in the
sub-automaton for this sub-expression?)</li>
<li>for each state <i>q</i> within (the sub-automaton for) this
sub-expression, what are the follow states of <i>q</i>?  Here, we need one
attribute for every state within the sub-expression; we make them by
creating, for each such state, an attribute with a local name matching
the ID of the state, in a namespace designed to hold such follow-state
attributes.  So if the states in a given expression are named
<i>q0</i>, <i>q1</i>, and <i>q2</i>, we would
have attributes named <i>follow:q0</i>,
<i>follow:q1</i>, and <i>follow:q2</i>.</li>
<li>For later use in recognition, it will also be helpful to
calculate an XPath 3 regular expression that matches the
terminal.</li>
</ul>
These attributes are for the most part of only transient interest:
they are essential for calculating information for the next higher
level of sub-expression, but the information we care about when
running the Earley parser is just the information on the top-level
element of the right-hand side.</div>
<div class="Real-P">Since the values of these attributes are in general calculated
inductively, the first step in handling any element <i>e</i> is to recur
to handle the element's children, and then to construct the values
for <i>e</i> itself.
<div class="scrap"><span><a name="gl-ME">&#x3008; 166 Define function gl:ME() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function gl:ME (
  $E as element()
) as element() {
  let $children := for $c in $E/node() 
                   return if ($c/self::element())
                          then gl:ME($c)
                          else $c,
      $ch := $children[self::element()]
  return <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-identity">Handle leaf nodes 169</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-terminals">Handle terminal nodes 172</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-nonterminal">Handle nonterminal symbols 173</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-option">Handle options 174</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-repeats">Handle repetitions 176</a></em> &#x3009;</span>   
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-sep">Handle separator expressions 185</a></em> &#x3009;</span>     
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-alt">Handle alt elements 187</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-def">Handle alts elements (= def) 189</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-rule">Handle rule elements 193</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-comment">Handle comment elements 195</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-ixml">Handle ixml elements (grammars) 196</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-whahhh">Handle unexpected elements 197</a></em> &#x3009;</span>
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e3814">[File Gluschkov.xqm] 164</a> &#x3009; <br></span>
</div>
</div>

<div class="Real-P">In the 2013 grammar supported by Aparecium 0.1, the elements
&lt;<em>quoted</em>&gt;, &lt;<em>charset</em>&gt;, and several others were always
assumed wrapped in a &lt;<em>terminal</em>&gt; element.  They thus occur below
the level of the basic symbol and need no decorations.  We need to
handle them, since when the function is called on their parent
element, it will recursively be called on them, too.  But they can and
should be returned without change. 
<div class="scrap"><span><a name="gl-ME-identity-2013">&#x3008; 167 Handle leaf nodes (v0.1) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/(self::quoted
      or self::charset or self::exclude
      or self::range
      or self::schar or self::dchar))
then 
      $E</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>

</div>
<div class="Real-P">In the 2021 grammar, the &lt;<em>range</em>&gt; and
&lt;<em>class</em>&gt; elements fall into this category (always
children of &lt;<em>inclusion</em>&gt; or &lt;<em>exclusion</em>&gt;.
The &lt;<em>literal</em>&gt; element falls into this category
when it is a child of &lt;<em>inclusion</em>&gt; or &lt;<em>exclusion</em>&gt;,
but it does no harm to handle it separately.</div>
<div class="Real-P">For ranges, the calculation of the correct regular
is straightforward in the simple case:  put a hyphen
between the values of the <em>from</em> and
<em>to</em> attributes, and wrap the entire thing
in square brackets.  But while those attributes
will usually contain single characters, they can
contain doubled quotation marks or hexadecimal strings
preceded by '#'.  It would be tempting to inline this,
but it's just complicated enough that I am going to write
a utility function to do it.
<div class="scrap"><span><a name="gl-read-one-ixml-char">&#x3008; 168 Define gl:read-one-char-spec() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function gl:read-one-char-spec(
  $s as xs:string
) as xs:string {
  if (string-length($s) eq 1)
  then string($s)
  else if ($s eq '""') 
  then '"' 
  else if ($s eq "''") 
  then "'"
  else if (starts-with($s,'#'))
  then codepoints-to-string(d2x:x2d(substring($s, 2)))
  else ""
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e3814">[File Gluschkov.xqm] 164</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Armed with that little function, we can easily
specify the regex for a range.
<div class="scrap"><span><a name="gl-ME-identity">&#x3008; 169 Handle leaf nodes &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/self::range)
then 
   element { name($E) } {
      $E/@*, 
      attribute regex {
         '['
         || gl:read-one-char-spec(string($E/@from))
	 || '-'
         || gl:read-one-char-spec(string($E/@to))
	 || ']'	 
      },
      $E/child::node()
   }
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e4043">Handle character-class expressions 170</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 166</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">For character-class expressions, the regular expression we need is
also very simple: just the class code wrapped in &#x201c;<tt>\p{
... }</tt>&#x201d;.
<div class="scrap"><span><a name="d3e4043">&#x3008; 170 Handle character-class expressions [continues <a href="#gl-ME-identity">169 Handle leaf nodes</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">else if ($E/self::class)
then 
   element { name($E) } {
      $E/@*, 
      attribute regex { '\p{' || $E/@code || '}'}
   }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">For terminal symbols, all attribute values are straightforward.
They are non-nullable, they are their own first and last
states, and they have no follow states.  In 2013, all terminals
were &lt;<em>terminal</em>&gt; elements. 
<div class="scrap"><span><a name="gl-ME-terminals-2013">&#x3008; 171 Handle terminal nodes (v0.1) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/self::terminal)
then let $id := '_t_' || (1 + count($E/preceding::terminal))
     return element terminal {
       $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @follow:*)),
       attribute xml:id { $id },
       attribute nullable { false() },
       attribute first { $id },
       attribute last { $id },
       attribute {QName($gl:follow-ns, "follow:" || $id)} { },
       $children
     }</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>
</div>
<div class="Real-P">In 2021, we distinguish several different terminals.
<div class="scrap"><span><a name="gl-ME-terminals">&#x3008; 172 Handle terminal nodes &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/self::inclusion or $E/self::exclusion
    or $E/self::literal)
then
      let $id := '_t_' 
                 || (1 + count(($E/preceding::* | $E/ancestor::*)
                    [self::inclusion 
                    or self::exclusion
		    or self::literal])), 
          $re := 'dummy' (:if ($E/self::inclusion) 
                 then gl:inclusion-regex($E) 
                 else if ($E/self::exclusion)
                 then gl:exclusion-regex($E) 
                 else if ($E/self::literal)
		 then gl:literal-regex($E)
		 else '[! error in gl:ME !]'
		 :)
      return element {name($E)} {
         $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @regex,
                     @follow:*)),
         attribute xml:id { $id },
         attribute nullable { false() },
         attribute first { $id },
         attribute last { $id },
         attribute {QName($gl:follow-ns, "follow:" || $id)} { },
	 attribute regex { $re },
         $children
      }</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 166</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">We have now committed to writing functions to create
regular expressions for inclusions, exclusions, and literals.
(But it's not the most pressing need, so for the moment
I'm commenting it out.)
</div>
<div class="Real-P">Nonterminals are similarly straightforward:  from the
point of view of the Gluschkov automaton, they are
indistinguishable from terminals.
<div class="scrap"><span><a name="gl-ME-nonterminal">&#x3008; 173 Handle nonterminal symbols &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/self::nonterminal)
then
     let $id := $E/@name || '_'
                || (1 + count($E/preceding::nonterminal
                              [@name = $E/@name]))
     return element nonterminal {
       $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @follow:*)),
       attribute xml:id { $id },
       attribute nullable { false() },
       attribute first { $id },
       attribute last { $id },
       attribute {QName($gl:follow-ns, "follow:" || $id)} { },
       $children
     }</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 166</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Syntactically, an option is an expression to which a question mark
has been added.  So any option <i>E</i> has the form (<i>F</i>?).  <i>E</i> is
nullable regardless of whether <i>F</i> is or not, and <i>E</i> has the same
first, final, and follow sets as <i>F</i>.
Note than an &lt;<em>option</em>&gt; should only ever have one child element:
a terminal symbol (inclusion, exclusion, literal), a nonterminal
symbol, or a set of alternatives (&lt;<em>alts</em>&gt;).  If we ever see
anything else, this case will not process it and it will fall through
to the error case.
<div class="scrap"><span><a name="gl-ME-option">&#x3008; 174 Handle options &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/self::option
    [count(*) eq 1]
    [child::*[self::inclusion
              or self::exclusion
              or self::literal 
              or self::nonterminal 
	      or self::alts]])
then
     let $id := 'exp_option_' || (1 + count($E/preceding::option))
     return element option {
       $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @follow:*)),
       attribute xml:id { $id },
       attribute nullable { true() },
       attribute first { $children/@first },
       attribute last { $children/@last },
       for $follow-att in $children/@follow:* 
       return $follow-att,
       $children
     }</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 166</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Repeats will have either one child element or two.  The
first will be a terminal, a nonterminal, or a set of alternatives;
the optional second child is a separator.  If anything else is
encountered, we are not ready for it and we'll fall through to
the error case.</div>
<div class="Real-P">In the 2013 grammar, a set of alternatives was a
&lt;<em>def</em>&gt; element: 
<div class="scrap"><span><a name="gl-ME-repeats-2013">&#x3008; 175 Handle repetitions (v0.1) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E[self::repeat0 or self::repeat1]
      [*[1][self::terminal or self::nonterminal or self::def]]
      [count(*) eq 1 or child::*[2][self::sep]]
         ) 
then
     let $gi := name($E)
     let $id := 'exp_' || $gi || '_' 
                || (1 + count($E/preceding::*[name() = $gi])),
         $F := gl:notrace($ch[1], "repetition factor F: "),
         $G := gl:notrace($ch[2], "repetition sep G: ")
     return element {$gi} {
       $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @follow:*)),
       attribute xml:id { $id },
       attribute nullable { 
         if ($gi = 'repeat0') 
         then true() 
         else $F/@nullable
       },
       attribute first { 
         if (xs:boolean($F/@nullable) = true())
         then concat($F/@first, ' ', $G/@first)
         else $F/@first
       },
       attribute last { 
         if (xs:boolean($F/@nullable) = true())
         then concat($F/@last, ' ', $G/@last)
         else $F/@last
       },
       <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-rep-follow">Calculate follow:* attributes for repetitions 177</a></em> &#x3009;</span>
       ,
       $children
     }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>
</div>

<div class="Real-P">In 2021, the functionality is the same, but the
choice element is named &lt;<em>alts</em>&gt;:
<div class="scrap"><span><a name="gl-ME-repeats">&#x3008; 176 Handle repetitions &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E[self::repeat0 or self::repeat1]
      [*[1]
        [self::inclusion or self::exclusion
        or self::literal
        or self::nonterminal
	or self::alts]]
      [count(*) eq 1 
      or child::*[2][self::sep]]) 
then let $gi := name($E)
     let $id := 'exp_' || $gi || '_' 
                || (1 + count($E/preceding::*[name() = $gi])),
         $F := gl:notrace($ch[1], "F: "),
         $G := gl:notrace($ch[2], "G: ")
     return element {$gi} {
       $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @follow:*)),
       attribute xml:id { $id },
       attribute nullable { 
         if ($gi = 'repeat0') 
         then true() 
         else $F/@nullable
       },
       attribute first { 
         if (xs:boolean($F/@nullable) = true())
         then concat($F/@first, ' ', $G/@first)
         else $F/@first
       },
       attribute last { 
         if (xs:boolean($F/@nullable) = true())
         then concat($F/@last, ' ', $G/@last)
         else $F/@last
       },
       <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-rep-follow">Calculate follow:* attributes for repetitions 177</a></em> &#x3009;</span>
       ,         
       $children
     }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 166</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The calculation of the follow set here has several
cases.  Watch carefully.  First case:  no separator.
So for all positions <i>p</i> in the expression <i>E</i>,
<ul><li>if <i>p</i> is in last(<i>E</i>)
then follow(<i>E</i>*, <i>p</i>) is 
the union of follow(<i>E</i>, <i>p</i>) with first(<i>E</i>)</li>
<li>otherwise
follow(<i>E</i>*, <i>p</i>) is  
just follow(<i>E</i>, <i>p</i>)
with no additions.</li>
</ul>
<div class="scrap"><span><a name="gl-ME-rep-follow">&#x3008; 177 Calculate follow:* attributes for repetitions &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">       if (count($ch) eq 1)
       then
         let $lastF := tokenize($F/@last,'\s+'),
             $firstF := tokenize($F/@first,'\s+')
         for $a in $F/@follow:*
         return if (local-name($a) = $lastF)
           then attribute { 
               QName($gl:follow-ns, "follow:"||local-name($a) ) 
             } { 
               gl:merge((tokenize($a,'\s+'), $firstF))    
             }
           else $a
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e4213">Calculate follow-set for repetition with separator 178</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME-repeats-2013">Handle repetitions (v0.1) 175</a> &#x3009; &#x3008; <a href="#gl-ME-repeats">Handle repetitions 176</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">If there is a separator, then the same principle
applies, but things are complicated by the presence
of the separator in the way.
For all <i>p</i>
in <i>F</i>*<i>G</i> or <i>F</i>+<i>G</i>, its follow-set depends
on <ul><li>whether <i>p</i> is in <i>F</i> or in <i>G</i>,</li>
<li>whether it's in last(<i>F</i>) or last(<i>G</i>),
and </li>
<li>whether <i>F</i> and <i>G</i> are nullable.</li>
</ul>
So we break out the detailed calculations.
The overall pattern is as follows.  We pre-calculate
<ul><li>the two <i>last()</i> sets,</li>
<li>the two <i>first()</i> sets,</li>
<li>whether <i>F</i> and <i>G</i> are nullable, and</li>
<li>for each position in <i>F</i> or <i>G</i>, its local
name and its follow-set within <i>F</i> or <i>G</i>.</li>
</ul>
<div class="scrap"><span><a name="d3e4213">&#x3008; 178 Calculate follow-set for repetition with separator [continues <a href="#gl-ME-rep-follow">177 Calculate follow:* attributes for repetitions</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">       else (: count($children) eq 2 :)
         let $lastF := tokenize($F/@last,'\s+'),
             $lastG := tokenize($G/@last,'\s+'),
             $firstF := tokenize($F/@first,'\s+'),
             $firstG := tokenize($G/@first,'\s+'),
             $nullableF := (xs:boolean($F/@nullable) = true()), 
             $nullableG := (xs:boolean($G/@nullable) = true())
         return 
           for $a in $children/@follow:* 
           let $p := local-name($a),
               $follow0 := tokenize($a,'\s+')
           let $followset :=  
             <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-rep-follow-sep-1">Follow set when p in last(F), G nullable 179</a></em> &#x3009;</span>
             <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-rep-follow-sep-2">Follow set when p in last(F), G not nullable 180</a></em> &#x3009;</span>
             <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-rep-follow-sep-3">Follow set when p in last(G), F nullable 181</a></em> &#x3009;</span>
             <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-rep-follow-sep-4">Follow set when p in last(G), F not nullable 182</a></em> &#x3009;</span>
             <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-rep-follow-sep-5">Follow set when p non-final in F or G 183</a></em> &#x3009;</span>
           return attribute { 
                    QName($gl:follow-ns, 
                          "follow:"||local-name($a) ) 
                } { 
                    $followset    
                    }</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">If <i>p</i> is final in <i>F</i> and <i>G</i> is nullable, then it's final
in <i>F</i>*<i>G</i> or <i>F</i>+<i>G</i> and can thus be followed by any first
state of <i>G</i> and any first state of <i>F</i>, as well as (naturally)
its follow-set within <i>F</i>:
<div class="scrap"><span><a name="gl-ME-rep-follow-sep-1">&#x3008; 179 Follow set when p in last(F), G nullable &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">             if ($p = $lastF and $nullableG) 
             then gl:merge(($follow0, $firstG, $firstF))
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e4213">Calculate follow-set for repetition with separator 178</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">If <i>p</i> is final in <i>F</i> and <i>G</i> is <em>not</em> nullable, 
then its follow-set omits the first sets of <i>F</i>. 
<div class="scrap"><span><a name="gl-ME-rep-follow-sep-2">&#x3008; 180 Follow set when p in last(F), G not nullable &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">             else if ($p = $lastF and not($nullableG))
             then gl:merge(($follow0, $firstG))
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e4213">Calculate follow-set for repetition with separator 178</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">If <i>p</i> is final in <i>G</i> and <i>F</i> is nullable, 
then we again have a three-way merge for its follow-set:
its follow-set within <i>G</i>, the first-set of <i>F</i>, and
(skipping <i>F</i> entirely, since it's nullable)
the first-set of <i>G</i>. 
<div class="scrap"><span><a name="gl-ME-rep-follow-sep-3">&#x3008; 181 Follow set when p in last(G), F nullable &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">             else if ($p = $lastG and $nullableF)
             then gl:merge(($follow0, $firstG, $firstF))
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e4213">Calculate follow-set for repetition with separator 178</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">If <i>p</i> is final in <i>G</i> and <i>F</i> is <em>not</em> nullable, 
then the first-set of <i>G</i> is not included in the follow-set
of <i>p</i>.
<div class="scrap"><span><a name="gl-ME-rep-follow-sep-4">&#x3008; 182 Follow set when p in last(G), F not nullable &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">             else if ($p = $lastG and not($nullableF))
             then gl:merge(($follow0, $firstF))
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e4213">Calculate follow-set for repetition with separator 178</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">Finally, if none of the above are true, then <i>p</i>
is non-final in either <i>F</i> or <i>G</i> and its follow-set is
unaffected by the repetition operator, so we just copy it
out again.
<div class="scrap"><span><a name="gl-ME-rep-follow-sep-5">&#x3008; 183 Follow set when p non-final in F or G &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">             else string($a)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e4213">Calculate follow-set for repetition with separator 178</a> &#x3009; <br></span>
</div>
</div>

<div class="Real-P">We have appealed to a little utility function for merging
sets of IDs.  It's quite straightforward, really, thanks
to <i>distinct-values()</i>.
<div class="scrap"><span><a name="gl-merge">&#x3008; 184 Define gl:merge() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function gl:merge(
  $ids as xs:string*
) as xs:string {
  string-join(distinct-values($ids),' ')
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e3814">[File Gluschkov.xqm] 164</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">The &lt;<em>sep</em>&gt; element contains a single factor and
changes none of its properties.
<div class="scrap"><span><a name="gl-ME-sep">&#x3008; 185 Handle separator expressions &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/self::sep
           [count(*) eq 1]
           [child::*[self::inclusion
                     or self::exclusion 
                     or self::literal 
                     or self::nonterminal 
                     or self::alts]]
          ) then
     let $id := 'exp_sep_'
                || (1 + count($E/preceding::sep)) 
     return element sep {
       $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @follow:*)),
       attribute xml:id { $id },
       $ch/@nullable,
       $ch/@first,
       $ch/@last,
       $ch/@follow:*,
       $children
     }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 166</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">In 2013 the element names were different.  (Yawn.)
<div class="scrap"><span><a name="gl-ME-sep-2013">&#x3008; 186 Handle separator expressions (v0.1) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/self::sep
           [count(*) eq 1]
           [child::*[self::terminal 
                     or self::nonterminal
                     or self::def]]
          ) then
     let $id := 'exp_sep_'
                || (1 + count($E/preceding::sep)) 
     return element sep {
       $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @follow:*)),
       attribute xml:id { $id },
       attribute nullable { $ch/@nullable },
       attribute first { $ch/@first },
       attribute last { $ch/@last },
       for $follow-att in $ch/@follow:* 
       return $follow-att,
       $children
     }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>

</div>
<div class="Real-P">An &lt;<em>alt</em>&gt; is one choice among (sometimes) several; it
contains a sequence of terms (i.e. terminal, nonterminal, repetition,
option, nested set of alternatives).  Since it's an arbitrary-length
sequence, not a binary operator, the calculation of first and last and
follow gets a bit tricky.  We may end up needing to normalize to
binary form just to keep things simple.
<div class="scrap"><span><a name="gl-ME-alt">&#x3008; 187 Handle alt elements &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/self::alt) then
     let $id := 'exp_alt_'
                || (1 + count($E/preceding::alt)) 
     return element alt {
       $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @follow:*)),
       attribute xml:id { $id },
       attribute nullable { 
         every $c in $ch
         satisfies (xs:boolean($c/@nullable) eq true())
       },
       attribute first { 
         string-join(
           for $c at $pos in $ch
           return if (every $lsib
	              in $ch[position() lt $pos]
                      satisfies
		      (xs:boolean($lsib/@nullable)
		      eq true() ))
                  then $c/@first
                  else (),
           ' '
         )
       },
       attribute last { 
         string-join(
           for $c at $pos in $ch
           return if (every $rsib
	              in $ch[position() gt $pos]
                      satisfies
		      (xs:boolean($rsib/@nullable)
		      eq true() ))
                  then $c/@last
                  else (),
           ' '
         )
       },
       <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-alt-follow">Calculate follow:* attributes for alt 188</a></em> &#x3009;</span>
       ,
       $children
     }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 166</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Again, calculating the follow-set is the most complicated
of the subcalculations for this type of expression.  So let's
take it slowly.
<ul><li>For every position <i>p</i> in each child <i>c</i>, the follow set 
follow(<i>E</i>,<i>p</i>) includes follow(<i>c</i>,<i>p</i>).</li>
<li>In addition, if <i>p</i> is in last(<i>c</i>) and <i>c</i> has a following sibling,
then follow(<i>E</i>,<i>p</i>) should include start(next-sibling(<i>c</i>)).</li>
<li>
In addition, if <i>p</i> is in last(<i>c</i>) and <i>c</i> has a following sibling,
and also next-sibling(<i>c</i>) is nullable, 
then follow(<i>E</i>,<i>p</i>) should include start(nextsib(nextsib(<i>c</i>))).
</li>
<li>
And so forth.</li>
</ul>

<div class="scrap"><span><a name="gl-ME-alt-follow">&#x3008; 188 Calculate follow:* attributes for alt &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">       for $c at $cpos in $ch 
       for $a in $c/@follow:*
       let $p := local-name($a),
           $lastC := tokenize($c/@last,'\s+'),
           $rightsibs := $ch[position() gt $cpos],
           $followset := if ($p = $lastC)
	   then string-join(
             (  $a,
                for $rsib at $rpos in $rightsibs
                let $inbetweens := $rightsibs
		                   [position() lt $rpos]
                return if (every $msib in $inbetweens
                           satisfies
                           (xs:boolean($msib/@nullable)
			   = true() ))
                       then $rsib/@first
                       else ()
             ),
             ' '
           )
           else
             $a
       return attribute { 
             QName($gl:follow-ns, "follow:"||$p )
         } { 
             $followset    
         }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME-alt">Handle alt elements 187</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">An &lt;<em>alts</em>&gt; element contains a set of alternatives,
each an &lt;<em>alt</em>&gt; element.
The 2013 alternative was the &lt;<em>def</em>&gt; element,
but note that &lt;<em>def</em>&gt; was required as the top-level
element of a right-hand side, which &lt;<em>alts</em>&gt; is not.
That doesn't affect the treatment of this element,
but it does affect
the treatment of rules, below. 
<div class="scrap"><span><a name="gl-ME-def">&#x3008; 189 Handle alts elements (= def) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E[self::<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-alts-gi">GI for alts element 191</a></em> &#x3009;</span>]) then
     let $id := 'exp_' || name($E) || '_' 
                || (1 + count(
                $E/preceding::<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-alts-gi">GI for alts element 191</a></em> &#x3009;</span>)
		) 
     <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-alternatives">Handle alternatives 190</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 166</a> &#x3009; <br></span>
</div>

We factor out the treatment of alternatives
so that we can re-use it for rules, below.
The properties should all be self-explanatory.
<div class="scrap"><span><a name="gl-ME-alternatives">&#x3008; 190 Handle alternatives &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">     return element {name($E)} {
       $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @follow:*)),
       attribute xml:id { $id },
       attribute nullable { 
         some $c in $ch
         satisfies
	 (xs:boolean($c/@nullable) eq true() )
       },
       attribute first { 
         string-join($ch/@first, ' ')
       },
       attribute last { 
         string-join($ch/@last, ' ')
       },
       
       (: follow-set is simple here. :) 
       for $a in $ch/@follow:*
       return $a,
       $children
     }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME-def">Handle alts elements (= def) 189</a> &#x3009; &#x3008; <a href="#gl-ME-rule">Handle rule elements 193</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">As an experiment, I am putting the generic identifier
for the element in a scrap.  If this works, much of the
duplication earlier in this section can be removed.
(Why do ideas come so late?)
<div class="scrap"><span><a name="gl-alts-gi">&#x3008; 191 GI for alts element &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">alts</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#eri-grammars-constructors">Functions that construct or return grammars 73</a> &#x3009; &#x3008; <a href="#gl-ME-def">Handle alts elements (= def) 189</a> &#x3009; <br></span>
</div>

In 2013, it was &lt;<em>def</em>&gt;:
<div class="scrap"><span><a name="gl-alts-gi-2013">&#x3008; 192 GI for alts element (v0.1) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">def</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>

</div>
<div class="Real-P">Since the alternatives inside a rule are not now wrapped
in a &lt;<em>def</em>&gt; or &lt;<em>alts</em>&gt; elements, we need to
put the properties for the rule as a whole on the &lt;<em>rule</em>&gt;
element.
<div class="scrap"><span><a name="gl-ME-rule">&#x3008; 193 Handle rule elements &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/self::rule) then
    let $id := $E/@name
    <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-alternatives">Handle alternatives 190</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 166</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">In 2013, it was simpler.
<div class="scrap"><span><a name="gl-ME-rule-2013">&#x3008; 194 Handle rule elements (v0.1) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/self::rule) then 
    element rule {
      $E/@*,
      $children
    }</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>

</div>
<div class="Real-P">Finally, a few miscellaneous elements.  Comments
require no annotation.
<div class="scrap"><span><a name="gl-ME-comment">&#x3008; 195 Handle comment elements &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/self::comment) then
    $E
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 166</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The &lt;<em>ixml</em>&gt; element also requires no
annotation.
<div class="scrap"><span><a name="gl-ME-ixml">&#x3008; 196 Handle ixml elements (grammars) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/self::ixml) then 
    element ixml {
      attribute follow:info { 
        "auxiliary namespace for FSA description"
      },
      $E/@*,
      $children
    }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 166</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">And finally, at the bottom of the if-then-else ladder,
we handle unexpected elements.
<div class="scrap"><span><a name="gl-ME-whahhh">&#x3008; 197 Handle unexpected elements &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/self::option or $E/self::sep)
then &lt;error&gt;Element {name($E)} with unexpected content: {$E}&lt;/error&gt;
else if ($E/(self::repeat1 or self::repeat0))
then &lt;error&gt;Element {name($E)} with unexpected content: {$E}&lt;/error&gt;
else &lt;error&gt;Unexpected element {$E}&lt;/error&gt;</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 166</a> &#x3009; <br></span>
</div>

</div>
</div>
</div>

</div>



<hr>

<div class="div">

<h2><a name="references" id="references">A. </a>References</h2>
<div class="Real-P"><i>Incomplete.</i></div>
<div class="bibliography">
<p class="bibl"><a name="Knuth-1984" id="Knuth-1984"></a>
Donald E. Knuth,
&#x201c;Literate Programming,&#x201d;
<em>The Computer Journal</em>
27 (1984):  97-111,
rpt. [rev.] in his
<em>Literate Programming</em>,
<em>CSLI Lecture Notes</em> Number 27
([Stanford, California]:  Center for the Study of Language and
Information, 1992), pp. 99-136, here p. 99.</p>

<p class="bibl"><a name="pemberton-2013" id="pemberton-2013"></a>
Pemberton, Steven.
2013.
&#x201c;Invisible XML&#x201d;.
Presented at Balisage: The Markup Conference 2013,
Montr&#xe9;al, Canada, August 6 - 9, 2013.
In
<em>Proceedings of Balisage: The Markup Conference 2013.</em>
Balisage Series on Markup Technologies, vol. 10 (2013).
DOI: 10.4242/BalisageVol10.Pemberton01.
On the web at
&lt;URL:<a href="http://www.balisage.net/Proceedings/vol10/html/Pemberton01/BalisageVol10-Pemberton01.html">http://www.balisage.net/Proceedings/vol10/html/Pemberton01/BalisageVol10-Pemberton01.html</a>&gt;.
Revised version (January 2014) at
&lt;URL:<a href="https://homepages.cwi.nl/~steven/Talks/2013/08-07-invisible-xml/invisible-xml-3.html">https://homepages.cwi.nl/~steven/Talks/2013/08-07-invisible-xml/invisible-xml-3.html</a>&gt;
</p>

<p class="bibl"><a name="pemberton-2021" id="pemberton-2021"></a>
Pemberton, Steven.
2021.
&#x201c;Invisible XML Specification
(Draft)&#x201d;.
On the web at
&lt;URL:<a href="https://invisiblexml.org/ixml-specification.html">https://invisiblexml.org/ixml-specification.html</a>&gt;
</p>

<p class="bibl"><a name="msm-1996" id="msm-1996"></a>
Sperberg-McQueen, C. M.
&#x201c;SWEB:
an SGML Tag Set for Literate Programming&#x201d;.
Unpublished technical report, 1993, rev. 1994, 1995, 1996.
On the web at
http://cmsmcq.com/1993/sweb.{<a href="http://cmsmcq.com/1993/sweb.xml">xml</a>,<a href="http://cmsmcq.com/1993/sweb.html">html</a>}.</p>

<p class="bibl"><a name="msm-2017" id="msm-2017"></a>
Sperberg-McQueen, C. M.
&#x201c;Translating imperative algorithms
into declarative, functional terms:
towards Earley parsing in XSLT and XQuery&#x201d;.
Presented at Balisage: The Markup Conference 2017,
Washington, DC, August 1 - 4, 2017.
In
<em>Proceedings of Balisage:
The Markup Conference 2017.</em>
<em>Balisage Series on Markup Technologies,
vol. 19 (2017)</em>.
&lt;URL:<a href="https://doi.org/10.4242/BalisageVol19.Sperberg-McQueen01">https://doi.org/10.4242/BalisageVol19.Sperberg-McQueen01</a>&gt;.
</p>

<p class="bibl"><a name="msm-2022" id="msm-2022"></a>
Sperberg-McQueen, C. M. &#x201c;Test harness
for Aparecium&#x201d;.  Unpublished technical report, 2022.</p>
</div>
</div>


<div class="div">

<h2><a name="notation" id="notation">B. </a>Literate programming notation</h2>
<div class="Real-P"><i>To be supplied:  a description of the notation used here.</i></div>
</div>


<div class="div">

<h2><a name="to-do" id="to-do">C. </a>To do</h2>
<div class="Real-P">As the reader will have noticed, in its current state this
program is not finished. Hence the following to-do lists.</div>


<div class="div">

<h3><a name="to-do-large" id="to-do-large"></a>Overall plans</h3>

<div class="Real-P">At the moment (23 February 2022), the primary concerns are to
improve performance and robustness.</div>
<ul><li><div class="Real-P">Improve tree constructor. Or, rather, replace
it. Concretely:</div>
<ul><li><div class="Real-P">Define a function to generate a parse-forest grammar
from the Earley set, rather than a parse tree.</div></li>
<li><div class="Real-P">Define a function to extract one or more parse trees
from a parse-forest grammar.</div>
</li>
</ul>
<div class="Real-P">The parse-tree constructor currently suffers from dismal
performance on some tests; see in particular the zeroes test catalog.
It performs its work without backtracking but also without memoization
or a work queue or any mechanism to avoid doing the same task multiple
times.  The result can be a combinatorial explosion, with the same
subtrees being constructed hundreds and thousands of times even for
input of only ten characters.</div>
<div class="Real-P">Since I want to write a parse-forest grammar constructor in any
case, I have not attempted to instrument the current tree constructor;
my plan is just to construct a parse-forest grammar and then extract
the tree from that, if the user wishes.</div>

<div class="Real-P">My current expectation is that in most cases this will result in a
modest improvement in performance.  Performance should improve because
useless work will be avoided and necessary work will be performed
only once.  But the improvement will be modest, because not all
grammars cause much unnecessary or repeated work.</div>
<div class="Real-P">To be concrete: at the moment tree construction normally takes
between 15% and 50% of the running time, except in a few pathological
cases.  (Some timing data are in the A subdirectory of this project.)
A ten to twenty per cent improvement in the performance of tree
construction will thus provide a one to ten per cent overall
improvement.  In the pathological cases, the improvement should be
greater.
</div>
</li>
<li><div class="Real-P">Quick and dirty ad-hoc tokenization change for
ixml grammar for ixml grammars.  (Hand-modify and
hand-annotate the grammar, add support for the
annotations.)</div></li>
<li><div class="Real-P">Revise the document thoroughly, reorganizing as
appropriate.  There are two audiences: those interested
in understanding how the implementation works, and those
maintaining the code.</div>
<div class="Real-P">Begin by introducing scraps to represent the abstract
data types <i>Earley item</i>, <i>Earley
set</i>, etc., so that the high-level algorithm can
be followed independently of the chosen
representation.  Explain the high-level algorithm,
then the internals.</div>
</li>
<li><div class="Real-P">Allow invoker to specify options, so they can choose whether
to get back one parse tree, several, a parse-forest grammar, a raw
parse tree, or the entire Earley set.</div>
<div class="Real-P">The current organization based on higher-level functions should be
scrapped, in order that Aparecium can run under Saxon.</div>
<div class="Real-P">Eventually the current direct-construction code may be
retired completely.</div>
</li>
<li><div class="Real-P">Improve tokenization.</div>
<div class="Real-P">Since ixml grammars don't have a distinct token level, either
analysis by the processor or manual annotation, or both, may be
required.  The goal is to identify nonterminals which can be
recognized with a single greedy regular-expression match, and
recognize them in that way.  I believe a nonterminal <i>N</i>
qualifies for this treatment if and only if:
<ul><li><i>N</i> defines a regular language.  (Sufficient but not necessary
condition: no center embedding for them or any descendant.  A stronger
and easier condition: no self-embedding at all.)</li>
<li>Every nonterminal descendant of <i>N</i> is marked hidden.</li>
<li>Every terminal descendant of <i>N</i> is marked visible.</li>
<li><i>N</i> is what we might call <em>end-stopped</em>, by analogy
with the metrical phenomenon in which syntactic and verse boundaries
fall together, thus clearly marking the boundary.  Concretely, <i>N</i> is
end-stopped if it is clear without lookahead where the end of an
occurrence of <i>N</i> falls: any legal character is either a continuation
of the <i>N</i> or the beginning of the next symbol, and no symbol can be
read in both ways.[<a name="ref-to-d3e4676" href="#d3e4676" title="&#xA;&#xA;Operationally, I think end-stopping can be detected as follows.&#xA;Construct the FSA for the O0 regular superset approximation of&#xA;L(G), in the usual way.  For ea">14</a>]</li>
<li></li>
</ul></div>
</li>
<li><div class="Real-P">Improve diagnostics in case of failure.</div></li>
<li><div class="Real-P">Improve robustness.</div></li>
<li><div class="Real-P">Upgrade the SWeb infrastructure to support
XSLT.</div></li>
<li><div class="Real-P">Create XSLT version of Aparecium.</div></li>
<li><div class="Real-P">Consider shifting to using BNF rather than EBNF
internally. (This will make it simpler to handle various forms of
infinite ambiguity satisfactorily, but will have little effect in
ordinary grammars.)</div></li>
</ul>
</div>


<div class="div">

<h3><a name="to-do-code" id="to-do-code"></a>Code changes</h3>
<div class="Real-P">Fixes / shorter-term changes to be made:</div>
<ul><li>16 Feb 22:  make compilation place a <em>follow:info</em> attribute
or something on the &lt;<em>ixml</em>&gt; element, to de-clutter the
compiled grammar.</li>
<li>16 Feb 22: Weed these to-do lists!</li>
<li>Make a common-utilities module for global project-level
variables (e.g. version number, tracing level) and tracing / debugging
routines.</li>
<li>Insert GPL notices in all modules.</li>
</ul>

<div class="Real-P">Enhancements longer-term changes to be made:</div>
<ul><li>Make marks work correctly.  Why is S appearing in output when
ixml is parsed?</li>
<li>Allow options to turn _from and _to attributes on and off?</li>
</ul>
</div>


<div class="div">

<h3><a name="to-do-sweb" id="to-do-sweb"></a>SWeb upgrades</h3>
<div class="Real-P">To do asap:</div>
<ul><li>make RNC schema for p3 + SWeb + XSLT</li>
<li>ensure new schema allows any well formed XML in
scraps, but enforces parent/child relations on XSLT</li>
<li>add module to SWeb stylesheet, to handle
XSLT and other XML elements within scraps</li>
<li>when this document is a bit further along (and has
decent display / translation into XHTML), move to github.</li>
</ul>
<div class="Real-P">To do eventually:</div>
<ul><li>make RNC schema for TEI P5 + SWeb + XSLT</li>
<li>upgrade this document, SWeb weave processor, SWeb
tangle processor</li>
</ul>
</div>

<div class="div">

<h3><a name="d3e4800" id="d3e4800"></a>To-do list from Earley recognizer internals module</h3>
<div class="Real-P">This module has a complicated enough to-do list of its own that
I'll give it here for the moment instead of inserting these into the
general to-do lists just given.</div>
<ul><li><div class="Real-P">establish coherent Hungarian type policy to distinguish 
     element and string representations of symbols.  We need
     shorthands for both.</div></li>
<li><div class="Real-P">fix symbol/position issue in leiAdvanceEiSymP()</div></li>
<li><div class="Real-P">finish minimal version</div></li>
<li><div class="Real-P">add support for #xxxx characters</div></li>
<li><div class="Real-P">clarify XML representation of terminals and other questions
with SP:
<ul><li>grammar says -quoted, I say quoted </li>
<li>grammar says quoted/@dstring, quoted/@sstring, 
       I think I prefer quoted with PCDATA (code
       currently handles all three)</li>
<li>grammar defines -character, I want character element
       as child of terminal (-character is fine for 
       @dstring and @sstring)</li>
<li>grammar and papers don't say what ^ means</li>
<li>how is start symbol determined?  For now I
       take LHS of first rule, like yacc.</li>
<li>if a rule reads "-foo: @bar, baz.", what happens?
       does @bar percolate up to parent element? (Do you
       know how to do this?)</li>
<li>Is a grammar specifying an @ mark on a repeatable 
       non-terminal ill-formed?  Or is the @ just ignored
       in that case?  (Tentative answer: both.)</li>
<li>True or false? 
       On a nonterminal, the mark "-" means "do not tag as element",
       but do promote the children.  On a terminal, it means
       "omit the entire thing".
</li>
</ul></div>
</li>
<li><div class="Real-P">do some sanity checking in reXTerminal to avoid having
     matches() blow up.</div></li>
<li><div class="Real-P">fix confusion over two senses of nullable:
<ul><li>locally nullable = nullable within the RHS (decorated 
       with ? or *, inside optional group, etc.)</li>
<li>generates null string in sentence</li>
</ul>
</div>
<div class="Real-P">N.B. a required non-terminal, not nullable in first
sense, can generate empty string and thus make its
parent nullable in the second sense.</div>
<div class="Real-P">Use fNullable for the first sense (already established)
and fGES (to be renamed for the second.</div>
</li>
<li><div class="Real-P">For testing purposes, provide a recognize function that
specifies a start symbol (analogous to phrase/2 in Prolog).</div></li>
</ul>
</div>
</div>


<div class="div">

<h2><a name="known-bugs" id="known-bugs">D. </a>Known bugs and test failures</h2>
<div class="Real-P">Known bugs and shortcomings:
<ul><li>On inputs over a few tens of characters, Aparecium is
currently unreasonably slow.</li>
<li></li>
</ul>
</div>

<div class="Real-P">Test-case failures (as of 17 Feb 22):
<ul><li>In test catalog test2:
<ul><li>test set ambiguity-1, test amb-1</li>
</ul>
</li>
<li>In test catalog zeroes:<ul><li>zeroes-gone-bad / t-4x0 (test-catalog error, I guess:
should expect an ambiguity label)</li>
</ul></li>
<li>In test set syntax-cagt (catalog as grammar tests):
<ul><li>elem1 (duplicate attributes)</li>
<li>illegal-class.ixml</li>
<li>rule2 (more than one rule for a nonterminal)</li>
<li>unused-rule (unreachable and undefined nonterminals)</li>
<li>unused-rules (ditto)</li>
</ul></li>
<li>In test set ixml-corr:
<ul><li>expr1:  exception in parsing XQDY0025</li>
<li>hex3:  grammar compilation failed</li>
<li>json:  grammar compilation failed</li>
<li>range:  grammar compilation failed</li>
<li>unicode-range1:  grammar compilation failed</li>
<li>element-content</li>
<li>range-comments</li>
<li>ranges1</li>
</ul></li>
<li>In test set ixml-ambi:
<ul><li>date</li>
</ul></li>
<li>In test set wisps:
<ul><li>grammar tests on grammars 02b, 02c, 02d (non-structural
nonconformance of grammars)</li>
</ul></li>
</ul>
</div>
<div class="Real-P">And to make myself feel better, here is a list of test sets
with no failures:
<ul><li>test0</li>
<li>test1</li>
<li>misc (as of 17 Feb 22)</li>
<li>syntax-caii (catalog as instances in ixml)</li>
<li>syntax-caix (catalog as instances in XML)</li>
</ul></div>
<div class="Real-P">The test harness used is described in a separate document
(<a href="#test-harness"></a>).</div>
</div>


<div class="div">

<h2><a name="change-logs" id="change-logs">E. </a>Change logs</h2>

<div class="div">

<h3><a name="logs-v0.2" id="logs-v0.2"></a>Change log for version 0.2</h3>
<ul><li>2021-08-03 : CMSMcQ : put all (well, almost all) code into
Aparecium.xml, an SWeb document.</li>
</ul>
</div>

<div class="div">

<h3><a name="logs-v0.1" id="logs-v0.1"></a>Change log for version 0.1</h3>
<div class="Real-P">The lists below are extracted from the revision histories
at the beginnings of the individual modules.</div>
<div class="Real-P">Aparecium.xqm:
<ul><li>2021-10-03 : CMSMcQ : conversion to SWeb form.</li>
<li>2019-06-03 : CMSMcQ : rename parse-string-with-compiledgrammar as
                         parse-string-with-compiled-grammar.</li>
<li>2019-04-19 : CMSMcQ : force myself to write first version</li>
</ul>
</div>
<div class="Real-P">Earley-parser.xqm:
<ul><li>2021-10-03 : CMSMcQ : into sweb</li>
<li>2019-04-16 : CMSMcQ : copy to new location, use new namespace names</li>
<li>2018-04-05 : CMSMcQ : start file, hesitate a bit</li>
</ul>
</div>
<div class="Real-P">Earley-parser-internals.xqm:
<ul><li>2019-06-30 : CMSMcQ : remove profiling code again (done for now).</li>
<li>2019-06-29 : CMSMcQ : make item-as-map branch, change all type-aware
                         references to items.  Add profiling code.</li>
<li>2019-06-03 : CMSMcQ : first cut at trimming parse tree as specified in G</li>
<li>2019-04-22 : CMSMcQ : On error, give input in full</li>
<li>2019-04-16 : CMSMcQ : move to new location, assign new namespace name</li>
<li>2018-04-08 : CMSMcQ : when ixml.xml is corrected and smart quotes
                         corrected, parses all sample ixml grammars in
                         teststrings.xml</li>
<li>2018-04-08 : CMSMcQ : passes tests for grammars 1-4, parses most 
                         but not all sample ixml grammars.</li>
<li>2018-04-07 : CMSMcQ : made stubs of earley-parser and various
                         functions for returning parse information</li>
</ul>
</div>
<div class="Real-P">Earley-recognizer.xqm:
<ul><li>2019-06-30 : CMSMcQ : Remove profiling code again (done for now)</li>
<li>2019-06-29 : CMSMcQ : Add profiling code to try to find speed issues</li>
<li>2019-04-15 : CMSMcQ : Move to repo, adopt new namespace names.
                      Adjust spelling of some function calls.</li>
<li>2018-04-04 : CMSMcQ : Seem to have been interrupted in this; there is
                      almost nothing here.  Starting again, from sketch
                      made this morning away from desk.  (There are
                      earlier sketches which I am not now consulting.)
                      I'm transcribing the sketch, not trying to test.
                      item() used as type for Earley items.</li>
<li>2018-03-29 : CMSMcQ : made file.  Trying to do in XQuery what I did in
                      Prolog:  small top level ignorant of data
                      representation, lower level that knows.</li>
</ul>
</div>
<div class="Real-P">Earley-rec-internals.xqm:
<ul><li>2019-06-30 : CMSMcQ : remove profiling code (done for now)</li>
<li>2019-06-30 : CMSMcQ : restructure accumulator in earley-closure as
                      map indexed by both start and end points:
                      $acc($n)('from') provides all items with from=$n,
                      $acc($n)('to') all items with to=$n.
                      For now, no indexing by fFinal, fPredictive,
                      or non-terminal.</li>
<li>2019-06-29 : CMSMcQ : rewrite all Earley item constructors, extractors,
                      and functions to use maps and not elements</li>
<li>2019-06-29 : CMSMcQ : make item-as-map branch in git</li>
<li>2019-06-03 : CMSMcQ : make reXTerminal deal properly with hex characters</li>
<li>2019-05-27 : CMSMcQ : resuming work.</li>
<li>2019-04-21 : CMSMcQ : tracing and other changes</li>
<li>2019-04-17 : CMSMcQ : import d2x; add charXHex(); make fNullableNG 
                      take string, not element(nonterminal); make 
                      reXTerminal() handle quote.</li>
<li>2019-04-16 : CMSMcQ : moved to repo; adopted new namespace names.
                      Improved navigation comments.
                      Improved (or supplied) function comments.</li>
<li>2018-04-05 : CMSMcQ : fixed handling of 'quoted' to use attributes;
                      worked on supplying missing functions;
                      fixed symbol/position and initial-state 
                        confusions in functions for rules and items.</li>
<li>2018-04-04 : CMSMcQ : beginning filling out the details, guided
                      by "Unknown function" messages in earley0.xq
		      and here.</li>
<li>2018-03-29 : CMSMcQ : made file.
                      Trying to do in XQuery what I did in Prolog:
                      small top level ignorant of data representation,
                      lower level that knows.  This is the lower
                      level.  To-do list in ~/2018/Earley/status...asc</li>
</ul>
</div>
<div class="Real-P">Gluschkov.xqm:
<ul><li>2019-04-19 : CMSMcQ : Move to repo for easier imports.</li>
<li>2016-04-05 : CMSMcQ : Completed Gluschkov constructor for use in 
                         an Earley parser.</li>
</ul>
</div>
</div>
</div>

<div class="div">

<h2><a name="obsolete" id="obsolete">F. </a>Older versions of some code</h2>
<div class="Real-P">Some portions of v0.2 have been made obsolete.
In some cases, changes have been made directly in
the code; in others, scraps have been replaced but
the old scraps have been retained here for
some kind of completeness, which may or may not
make sense.</div>


<div class="div">

<h3><a name="obs-hlf" id="obs-hlf"></a>Code using higher-level functions</h3>
<div class="Real-P">The earlier versions of the high-level functions
<i>all-trees()</i>, <i>any-tree()</i>, etc. used
higher-level functions.  To work with engines that don't support
higher-level functions, they have been rewritten.
The code should be self-explanatory. </div>
<div class="Real-P">At least, I hope it is, since I don't want to
spend any time explaining it.
<div class="scrap"><span><a name="d3e5019">&#x3008; 198 Declare ep:alltrees() function &#x3009; (for version <em>v0.2</em>) &#x2261;</a></span>
<pre class="scrapbody">(: ep:alltrees($I,$G):  return all loopless parse trees :)
declare function ep:all-trees(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as element()+ {
  (: trace((), 'ep:all-trees calling epi:earley-parse'), :)

  epi:earley-parse($I, $G, epi:all-trees#3)
  
  (: trace((), 'epi:earley-parse has returned '
        || 'and ep:all-trees is about to do so.') :)
};

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#ep-alltrees">Declare ep:all-trees() function 119</a> &#x3009; </span>
</div>
</div>
<div class="Real-P">
<div class="scrap"><span><a name="d3e5024">&#x3008; 199 Declare ep:anytree() function &#x3009; (for version <em>v0.2</em>) &#x2261;</a></span>
<pre class="scrapbody">(: ep:anytree($I,$G):  return one (loopless) parse tree, 
   whichever is found first 
:)
declare function ep:any-tree(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as element()? {
  epi:earley-parse($I, $G, epi:any-tree#3)
};

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#ep-anytree">Declare ep:any-tree() function 120</a> &#x3009; </span>
</div>

</div>
<div class="Real-P">
<div class="scrap"><span><a name="d3e5030">&#x3008; 200 Declare ep:tree-cursor() function &#x3009; (for version <em>v0.2</em>) &#x2261;</a></span>
<pre class="scrapbody">declare function ep:tree-cursor(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as item()* {
  epi:earley-parse($I, $G, epi:tree-cursor#3)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#ep-tree-cursor">Declare ep:tree-cursor() function 121</a> &#x3009; </span>
</div>

</div>
<div class="Real-P">
<div class="scrap"><span><a name="d3e5037">&#x3008; 201 Declare ep:parse-forest-map() function &#x3009; (for version <em>v0.2</em>) &#x2261;</a></span>
<pre class="scrapbody">(: ep:parseforestmap($I,$G):  return a map containing an and/or tree
   representing the set of all parses.
:)
declare function ep:parse-forest-map(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as element()* {
  epi:earley-parse($I, $G, epi:parse-forest-map#3)
};

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#ep-parse-forest-map">Declare ep:parse-forest-map() function 122</a> &#x3009; </span>
</div>

</div>
<div class="Real-P">
<div class="scrap"><span><a name="d3e5043">&#x3008; 202 Declare ep:alltrees() function &#x3009; (for version <em>v0.2</em>) &#x2261;</a></span>
<pre class="scrapbody">(: ep:parseforestgrammar($I,$G):  return a BNF (not EBNF[?]) grammar
   describing the set of all parses of $I against $G.
:)
declare function ep:parse-forest-grammar(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as element()* {
  epi:earley-parse($I, $G, epi:parse-forest-grammar#3)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#ep-parse-forest-grammar">Declare ep:parse-forest-grammar() function 123</a> &#x3009; </span>
</div>

</div>

<div class="Real-P">All of the code just given requires <i>earley-parse()</i>
to accept a higher-level function to do crucial parts of the work.
It still doesn't seem like a bad idea, but when version <i>pfg</i>
was being developed it turned out that the code embeds some false
assumptions about what that function does.  Rather than unsnarl those
assumptions, I rewrote things to use options, rather than higher-level
functions, to control what gets returned (and other things).
<div class="scrap"><span><a name="d3e5053">&#x3008; 203 Define earley-parse() &#x3009; (for version <em>v0.2</em>) &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   earley-parse($I, $G, $f);  run Earley recognizer on 
   input $I and grammar $G, return results using 
   $f($leiClosure, $Ec, $I, $G)
:)
declare function epi:earley-parse(
  $I as xs:string,
  $G as element(ixml),
  $f as function(
    map(*)*  (: Ec :),
    map(*)* (: Closure :),
    xs:string (: Input :)
    (: , element(ixml) (: Grammar :) :)
  ) as item()* 
) as item()* {
  let $dummy := eri:notrace((), 'epi:earley-parse() ...') 
  let $mapResult := prof:time(
                    er:recognizeX($I, $G), 
                    '0a recognize(): '),

      $meiClosure := $mapResult('Closure'),
      $leiCompletions := $mapResult('Completions')
  return if ($mapResult('Result'))
    then (: if we have a result, return each parse tree :)
        let $dummy := eri:notrace((), 
                      'epi:earley-parse() has result') 
        let $lpt := prof:time(
                    $f($leiCompletions, $meiClosure, $I (: , $G :) )
                    , '0b making trees: ')
        for $pt at $npt in $lpt
        let $dummy := eri:notrace((), 
                      'epi:earley-parse() returning a result') 
        (: return if (('raw','ast')[2] eq 'raw') 
	       then $pt  
               else epi:astXparsetree($pt, count($lpt)) :)
        (: What an ugly hack!  Clean this up! :)
        (: let $logfn := '/Users/cmsmcq/'
                      || '2021/Aparecium/tests/output/raw.'
	              || translate(
                           string(
                             adjust-dateTime-to-timezone(
                               current-dateTime(), 
                               ())),
                           ' :',
                           '__')
                      || $npt
                      || '.xml'   
        return (file:write($logfn, $pt), 
                epi:astXparsetree($pt, count($lpt))) :)
        return epi:astXparsetree($pt, count($lpt)) 
        
   else (: otherwise, send an apology and explanation :)
   &lt;no-parse&gt;
   &lt;p&gt;Sorry, no parse for this string and grammar.&lt;/p&gt;
   &lt;p&gt;The completions are:&lt;/p&gt;
   &lt;completions&gt;{$leiCompletions}&lt;/completions&gt;
   &lt;p&gt;The map is:&lt;/p&gt;
   
   &lt;Initial-Item&gt;{eri:eXei($mapResult('Initial-Item'))}&lt;/Initial-Item&gt;
   &lt;Input&gt;{$mapResult('Input')}&lt;/Input&gt;
   &lt;Input-Length&gt;{$mapResult('Input-Length')}&lt;/Input-Length&gt;
   &lt;Completions&gt;{
     for $ei in $mapResult('Completions')
     return eri:eXei($ei)
   }&lt;/Completions&gt;
   &lt;Closure&gt;{
     let $mei := $mapResult('Closure')
     for $n in map:keys($mei('to'))
     order by $n descending
     for $ei in $mei('to')($n)
     return eri:eXei($ei)
   }&lt;/Closure&gt;
   &lt;Result&gt;{$mapResult('Result')}&lt;/Result&gt;
   &lt;grammar&gt;{(: 'Omitted.' :) $mapResult('Grammar') }&lt;/grammar&gt;
   &lt;/no-parse&gt;
   (: we have to think about how to return that no-parse signal.
   :)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#epi-earley-parse">Define earley-parse() 124</a> &#x3009; </span>
</div>

</div>
</div>
</div>



<div class="div">

<h2><a name="indices" id="indices">G. </a>Indices</h2>
<div><h2>Index of file names</h2><ul><li>Aparecium.xqm: defined in &#x3008; <a href="#d3e295">1 [File Aparecium.xqm]</a> &#x3009; </li><li>Earley-parser-internals.xqm: defined in &#x3008; <a href="#d3e341">4 [File Earley-parser-internals.xqm]</a> &#x3009; </li><li>Earley-parser.xqm: defined in &#x3008; <a href="#d3e327">3 [File Earley-parser.xqm]</a> &#x3009; , &#x3008; <a href="#d3e2810">118 [File Earley-parser.xqm]</a> &#x3009; </li><li>Earley-rec-internals.xqm: defined in &#x3008; <a href="#d3e411">7 [File Earley-rec-internals.xqm]</a> &#x3009; </li><li>Earley-recognizer.xqm: defined in &#x3008; <a href="#Earley-rec">5 [File Earley-recognizer.xqm]</a> &#x3009; </li><li>Gluschkov.xqm: defined in &#x3008; <a href="#d3e3814">164 [File Gluschkov.xqm]</a> &#x3009; </li></ul></div>
<div><h2>Index of scrap names</h2><ul><li><a href="#d3e295">[File Aparecium.xqm] 1</a></li><li><a href="#d3e327">[File Earley-parser.xqm] 3</a></li><li><a href="#d3e341">[File Earley-parser-internals.xqm] 4</a></li><li><a href="#Earley-rec">[File Earley-recognizer.xqm] 5</a></li><li><a href="#d3e411">[File Earley-rec-internals.xqm] 7</a></li><li><a href="#eri-sym-reXT-range"> 82</a></li><li><a href="#d3e2810">[File Earley-parser.xqm] 118</a></li><li><a href="#d3e3814">[File Gluschkov.xqm] 164</a></li><li><a href="#pfg-fw-set-new-acc">Add satisfactory walks to the accumulator 31</a></li><li><a href="#epi-ans-recnt-munge-mark">Adjust mark attribute on $nodeCh as needed 154</a></li><li><a href="#d3e4213">Calculate follow-set for repetition with separator 178</a></li><li><a href="#gl-ME-alt-follow">Calculate follow:* attributes for alt 188</a></li><li><a href="#gl-ME-rep-follow">Calculate follow:* attributes for repetitions 177</a></li><li><a href="#eri-items-closure">Calculating the closure of an Earley set 65</a></li><li><a href="#epi-ans-loopcheck">Check for loops, which mean infinite ambiguity 143</a></li><li><a href="#d3e3444">Construct an element holding the node sequence 145</a></li><li><a href="#d3e3450">Construct an element holding the node sequence 146</a></li><li><a href="#epi-ep-any-direct">Construct one tree directly 129</a></li><li><a href="#epi-ep-any-via-pfg">Construct one tree via parse-forest-grammar 130</a></li><li><a href="#ep-alltrees">Declare ep:all-trees() function 119</a></li><li><a href="#d3e5019">Declare ep:alltrees() function  (v. v0.2) 198</a></li><li><a href="#d3e5043">Declare ep:alltrees() function  (v. v0.2) 202</a></li><li><a href="#ep-anytree">Declare ep:any-tree() function 120</a></li><li><a href="#d3e5024">Declare ep:anytree() function  (v. v0.2) 199</a></li><li><a href="#ep-parse-forest-grammar">Declare ep:parse-forest-grammar() function 123</a></li><li><a href="#ep-parse-forest-map">Declare ep:parse-forest-map() function 122</a></li><li><a href="#d3e5037">Declare ep:parse-forest-map() function  (v. v0.2) 201</a></li><li><a href="#ep-tree-cursor">Declare ep:tree-cursor() function 121</a></li><li><a href="#d3e5030">Declare ep:tree-cursor() function  (v. v0.2) 200</a></li><li><a href="#epi-all-node-sequences">Define all-node-sequences() 142</a></li><li><a href="#epi-all-trees">Define all-trees() 134</a></li><li><a href="#epi-any-tree">Define any-tree() 139</a></li><li><a href="#epi-astXparsetree">Define astXparsetree() to make AST from raw parse 157</a></li><li><a href="#epi-attsXpt">Define attributesXpt() to collect attributes 161</a></li><li><a href="#d3e3095">Define auxiliary function for all-trees() 135</a></li><li><a href="#epi-avXpt">Define avXpt() to collect attribute value 162</a></li><li><a href="#d3e2421">Define catescXS() to build category escape 93</a></li><li><a href="#d3e2427">Define charXhex() to get character given hex expression 94</a></li><li><a href="#er-comp">Define comp() 12</a></li><li><a href="#ap2-cgfs">Define compile-grammar-from-string() 112</a></li><li><a href="#ap2-cgfu">Define compile-grammar-from-uri() 111</a></li><li><a href="#ap2-cgfx">Define compile-grammar-from-xml() 113</a></li><li><a href="#epi-contentXpt">Define contentXpt() 163</a></li><li><a href="#epi-docelXpt">Define doc-elementXpt() to make AST for document element 158</a></li><li><a href="#d3e2459">Define eXei() to build 'item' element for Earley item 98</a></li><li><a href="#d3e2049">Define earley-closure($lei, $I, $G) 66</a></li><li><a href="#d3e2068">Define earley-closure($pending, $accumulator, $I, $G) 67</a></li><li><a href="#d3e2179">Define earley-closure($pending, $accumulator, $I, $G) 71</a></li><li><a href="#epi-earley-parse">Define earley-parse() 124</a></li><li><a href="#d3e5053">Define earley-parse()  (v. v0.2) 203</a></li><li><a href="#eri-make-p-p-r-ri">Define eiMakePPRRi() 56</a></li><li><a href="#d3e1924">Define eiMakePPT() 57</a></li><li><a href="#epi-elXpt">Define elementXpt() to make AST for one element 160</a></li><li><a href="#d3e2030">Define fAdvanceNrelEE() 64</a></li><li><a href="#d3e2005">Define fExpectsN-Ei() 62</a></li><li><a href="#eri-sym-fNonterminal">Define fNonterminal() 84</a></li><li><a href="#d3e2023">Define fScanrelEE() 63</a></li><li><a href="#eri-sym-fSymbolmatchRRiSym">Define fSymbolmatchRRiSym() 85</a></li><li><a href="#eri-sym-fTerminal">Define fTerminal() 83</a></li><li><a href="#epi-make-pfg-rules">Define function epi:make-pfg-rules() 18</a></li><li><a href="#gl-ME">Define function gl:ME() 166</a></li><li><a href="#gl-merge">Define gl:merge() 184</a></li><li><a href="#gl-read-one-ixml-char">Define gl:read-one-char-spec() 168</a></li><li><a href="#eri-lei-advance-ei-sym-p">Define leiAdvanceEiSymP() 58</a></li><li><a href="#epi-lnDepXCleC">Define lnDepXClEc() 156</a></li><li><a href="#eri-sym-match-length">Define match-length() 80</a></li><li><a href="#eri-notrace-function">Define notrace() function for debugging 102</a></li><li><a href="#epi-parse-forest-grammar">Define parse-forest-grammar() 15</a></li><li><a href="#epi-parse-forest-map">Define parse-forest-map() 141</a></li><li><a href="#ap2-pgfs">Define parse-grammar-from-string() 110</a></li><li><a href="#ap2-pgfu">Define parse-grammar-from-uri() 109</a></li><li><a href="#ap-pr">Define parse-resource() 8</a></li><li><a href="#ap-ps">Define parse-string() 106</a></li><li><a href="#ap-pswcg">Define parse-string-with-compiled-grammar() 107</a></li><li><a href="#er-pred">Define pred() 11</a></li><li><a href="#eri-sym-reXTerminal">Define reXTerminal(), regex from terminal 81</a></li><li><a href="#er-recognize">Define recognize() 13</a></li><li><a href="#d3e548">Define recognizeX() 14</a></li><li><a href="#d3e2453">Define s X ei() to build string form of Earley item 97</a></li><li><a href="#er-scan">Define scan() 9</a></li><li><a href="#er-scan-pfg">Define scan()  (v. pfg) 10</a></li><li><a href="#d3e2415">Define sceXS() to read range ends 92</a></li><li><a href="#d3e2433">Define string-length() 95</a></li><li><a href="#d3e2440">Define string-value() 96</a></li><li><a href="#eri-trace-function">Define trace() function 100</a></li><li><a href="#d3e2465">Define trace() function for debugging 99</a></li><li><a href="#eri-trace-dummy">Define trace() function for debugging 103</a></li><li><a href="#gl-trace">Define trace() function for debugging 104</a></li><li><a href="#epi-tree-cursor">Define tree-cursor() 140</a></li><li><a href="#eri-items">Earley items (constructors, extractors, etc.) 55</a></li><li><a href="#d3e1409">Extend the walk 30</a></li><li><a href="#epi-tfg-literal">Extract character data from literal element 50</a></li><li><a href="#epi-tfg-alt">Extract sequence of nodes from alt element 48</a></li><li><a href="#epi-tfg-nonterminal">Extract subtree from nonterminal element 49</a></li><li><a href="#epi-tfg-rule">Extract subtree from rule element 41</a></li><li><a href="#epi-tfg-ixml">Extract tree from ixml parse-forest grammar 40</a></li><li><a href="#d3e1947">Extractors for Earley items 59</a></li><li><a href="#d3e1953">Extractors for Earley items 60</a></li><li><a href="#eri-input-ext">Extractors for input 87</a></li><li><a href="#d3e1406">Find follow-on completion items 29</a></li><li><a href="#epi-ans-recnt-lnodechild">Find parse trees for the child completions 152</a></li><li><a href="#epi-ans-recnt-leiprev">Find the child completions for $sym 151</a></li><li><a href="#gl-ME-rep-follow-sep-2">Follow set when p in last(F), G not nullable 180</a></li><li><a href="#gl-ME-rep-follow-sep-1">Follow set when p in last(F), G nullable 179</a></li><li><a href="#gl-ME-rep-follow-sep-4">Follow set when p in last(G), F not nullable 182</a></li><li><a href="#gl-ME-rep-follow-sep-3">Follow set when p in last(G), F nullable 181</a></li><li><a href="#gl-ME-rep-follow-sep-5">Follow set when p non-final in F or G 183</a></li><li><a href="#eri-grammars-predicates">Functions that check grammar properties 77</a></li><li><a href="#eri-grammars-constructors">Functions that construct or return grammars 73</a></li><li><a href="#eri-grammars-extractors">Functions that extract information from grammars 76</a></li><li><a href="#gl-alts-gi">GI for alts element 191</a></li><li><a href="#gl-alts-gi-2013">GI for alts element (v0.1) 192</a></li><li><a href="#epi-all-trees-call-ans">Get the sequences, or rather raw parse trees 137</a></li><li><a href="#d3e2216">Goal-symbol construction 74</a></li><li><a href="#d3e2223">Goal-symbol construction 75</a></li><li><a href="#eri-grammars">Grammars (constructors, extractors, etc.) 72</a></li><li><a href="#gl-ME-alt">Handle alt elements 187</a></li><li><a href="#gl-ME-alternatives">Handle alternatives 190</a></li><li><a href="#gl-ME-def">Handle alts elements (= def) 189</a></li><li><a href="#epi-ans-basecase">Handle base case:  current item is initial 144</a></li><li><a href="#d3e4043">Handle character-class expressions 170</a></li><li><a href="#gl-ME-comment">Handle comment elements 195</a></li><li><a href="#gl-ME-ixml">Handle ixml elements (grammars) 196</a></li><li><a href="#gl-ME-identity">Handle leaf nodes 169</a></li><li><a href="#gl-ME-identity-2013">Handle leaf nodes (v0.1) 167</a></li><li><a href="#gl-ME-nonterminal">Handle nonterminal symbols 173</a></li><li><a href="#gl-ME-option">Handle options 174</a></li><li><a href="#epi-ans-rec-nonterminal">Handle recursion on nonterminal 150</a></li><li><a href="#epi-ans-rec-terminal">Handle recursion on terminal 148</a></li><li><a href="#epi-ans-rec-terminal-2016">Handle recursion on terminal 149</a></li><li><a href="#epi-ans-recursive">Handle recursive case 147</a></li><li><a href="#gl-ME-repeats">Handle repetitions 176</a></li><li><a href="#gl-ME-repeats-2013">Handle repetitions (v0.1) 175</a></li><li><a href="#gl-ME-rule">Handle rule elements 193</a></li><li><a href="#gl-ME-rule-2013">Handle rule elements (v0.1) 194</a></li><li><a href="#gl-ME-sep">Handle separator expressions 185</a></li><li><a href="#gl-ME-sep-2013">Handle separator expressions (v0.1) 186</a></li><li><a href="#gl-ME-terminals">Handle terminal nodes 172</a></li><li><a href="#gl-ME-terminals-2013">Handle terminal nodes (v0.1) 171</a></li><li><a href="#gl-ME-whahhh">Handle unexpected elements 197</a></li><li><a href="#epi-mpr-stop">If PFG queue is empty, return accumulator 19</a></li><li><a href="#epi-pfg-error-return">If there is an error, return an error element 17</a></li><li><a href="#epi-rfw-nonterminal">If this step is a nonterminal, return a nonterminal 35</a></li><li><a href="#epi-rfw-terminal">If this step is a terminal, return a literal 34</a></li><li><a href="#epi-ep-success">If we have a parse result, return it 125</a></li><li><a href="#pfg-fw-if-done">If we have all our walks, return 27</a></li><li><a href="#epi-rfw-stop">If we're done, return 33</a></li><li><a href="#eri-imports">Imports for recognizer internals 6</a></li><li><a href="#eri-input">Input (constructors, extractors, etc.) 86</a></li><li><a href="#eri-itcl-traces">Issue trace messages for earley-closure() 70</a></li><li><a href="#epi-all-trees-for">Iterate over the list of completion items 136</a></li><li><a href="#d3e2737">Location of ixml grammar 117</a></li><li><a href="#d3e2724">Location of library 116</a></li><li><a href="#aparecium-main">Main interfaces for Aparecium 105</a></li><li><a href="#epi-sXpt">Make string from raw parse tree terminal $E 159</a></li><li><a href="#aparecium-imports">Module imports for Aparecium top-level 2</a></li><li><a href="#eri-items-closure-normal">Normal case for Earley closure 69</a></li><li><a href="#d3e1480">Otherwise, something has gone very wrong 36</a></li><li><a href="#d3e2000">Predicates for Earley items 61</a></li><li><a href="#eri-inpred-pfg">Predicates for input: cMatchIPT()  (v. pfg) 89</a></li><li><a href="#eri-input-pred">Predicates for input: fMatchesIPT() 88</a></li><li><a href="#gl-prolog">Prolog for Gluschkov module 165</a></li><li><a href="#epi-ans-rec-whazzat">Raise error if neither terminal nor nonterminal 155</a></li><li><a href="#epi-ans-recnt-recur">Recur on each predictor 153</a></li><li><a href="#epi-mpr-recur">Recursive call with new queue and accumulator 25</a></li><li><a href="#epi-ep-all-trees">Return (approximately) all trees 127</a></li><li><a href="#epi-ep-parse-forest-map">Return a parse-forest map 133</a></li><li><a href="#epi-ep-parse-forest-grammar">Return a tree cursor 131</a></li><li><a href="#epi-ep-tree-cursor">Return a tree cursor 132</a></li><li><a href="#epi-tfg-rule-wha">Return an error element 47</a></li><li><a href="#epi-ep-any-tree">Return any tree 128</a></li><li><a href="#epi-ep-failure">Return parse-failure result 126</a></li><li><a href="#epi-pfg-return">Return parse-forest grammar containing $rules 16</a></li><li><a href="#epi-all-trees-return-trees">Return the raw parse trees 138</a></li><li><a href="#eri-rules">Rules (constructors, extractors, etc.) 78</a></li><li><a href="#aparecium-secondary">Secondary interfaces (a bit specialized) 108</a></li><li><a href="#epi-tfg-rule-zero">Serialize nothing, stop recursion 46</a></li><li><a href="#epi-tfg-rule-attr">Serialize rule as attribute 43</a></li><li><a href="#epi-tfg-rule-av">Serialize rule as attribute value 45</a></li><li><a href="#epi-tfg-rule-content">Serialize rule as content 44</a></li><li><a href="#epi-tfg-rule-elem">Serialize rule as element 42</a></li><li><a href="#epi-mpr-update-queue">Set $new-queue to include new completions 24</a></li><li><a href="#epi-mpr-make-rule">Set $rule to production rule for $ei 23</a></li><li><a href="#epi-mpr-find-walk">Set $walks to possible child sequences for $ei 22</a></li><li><a href="#pfg-fw-set-new-queue">Set new queue by extending all walks in the queue 28</a></li><li><a href="#d3e2480">Starry trace() function 101</a></li><li><a href="#eri-symbols">Symbols (constructors, extractors, etc.) 79</a></li><li><a href="#eri-items-closure-termination">Terminating case for Earley closure 68</a></li><li><a href="#aparecium-tertiary">Tertiary interfaces (of interest only for maintainer) 114</a></li><li><a href="#epi-find-dups-in-walk">The dups-from-walk() function 38</a></li><li><a href="#epi-tree-from-pfg">The epi:tree-from-pfg() function 39</a></li><li><a href="#epi-find-walks">The find-walks() function 26</a></li><li><a href="#epi-lei-from-walk">The lei-from-walk() function 37</a></li><li><a href="#epi-rhs-from-walk">The rhs-from-walk() function 32</a></li><li><a href="#adt-eiclosure">Type:  Earley closure 53</a></li><li><a href="#adt-ei">Type: Earley item 51</a></li><li><a href="#pfg-adt-walks">Type: collection of walks 21</a></li><li><a href="#adt-input">Type: input string 54</a></li><li><a href="#adt-list-ei">Type: list of Earley items 52</a></li><li><a href="#pfg-adt-walk">Type: walk in a RHS 20</a></li><li><a href="#eri-utils-and-misc">Utilities for recognizer internals module 91</a></li><li><a href="#aparecium-variables">Variables (of interest only for maintainer) 115</a></li><li><a href="#eri-input-pred-matchlength">match-length(I,p,t) 90</a></li></ul></div>
</div>



</div><div class="notes"><hr><h3>Notes</h3><div class="note">[<a name="d3e200" id="d3e200" href="#ref-to-d3e200">1</a>] 
A simple example is the grammar <tt>S:  'a';
S.</tt>,
for which the single sentence (&#x201c;<tt>a</tt>&#x201d;)
has an infinite number of parses (one <i>S</i>
node, two <i>S</i> nodes, three, ...).
<div class="Real-P">Another is the grammar <tt>S: S*; {nil}.</tt>,
which provides an infinite number of parses for the
empty string, which vary both in depth and in width.</div>
</div><div class="note">[<a name="d3e725" id="d3e725" href="#ref-to-d3e725">2</a>] 
Since those rules would be a potentially
informative description of the garden paths followed by the parser
before they reached a dead end, they might be useful as a
grammar-debugging measure.  But for now we are interested only in
completions that actually play a role in a successful derivation of
the input.</div><div class="note">[<a name="d3e741" id="d3e741" href="#ref-to-d3e741">3</a>] Here <i>q</i><sub><i>f</i></sub> is any final state in the
definition of <i>N</i>.</div><div class="note">[<a name="d3e776" id="d3e776" href="#ref-to-d3e776">4</a>]  I call it a
<i>satisfactory</i> walk because (a) the sequence of
nonterminals satisfies the constraints of the right-hand side, and
(b) the walk is acceptable to the needs of further processing.  And
I need a short way to refer to the class of walks I'm looking
for.
<div class="Real-P">I often slip and refer to these as <em>paths</em> through
the right-hand side, but in graph theory a <em>path</em>
denotes a walk in which no vertex appears more than once.  If
the input grammar is BNF, any walk through any right-hand side
will be a path.  But we are working with EBNF.</div>
</div><div class="note">[<a name="d3e816" id="d3e816" href="#ref-to-d3e816">5</a>] At the moment, there are some infinitely ambiguous
sentences for which we will not in fact get all of the walks
(informally, those involving infinite
&#x2018;horizontal&#x2019; ambiguity, as in &#x201c;<tt>S = A*,
'a'. A = .</tt>&#x201d;).  Our inability to capture horizontal
ambiguities completely appears to be a disadvantage of working
directly with EBNF instead of rewriting the grammar to BNF.  (An
equivalent BNF like &#x201c;<tt>S = _star_A, 'a'. _star_A = {}; A,
_star_A.  A = {}.</tt>&#x201d; does not present the
problem.)<div class="Real-P">The key appears to be that in an EBNF grammar there
may be an infinite number of walks through a right-hand side,
whereas in a BNF grammar that can never be so, because BNF lacks
repetition operators.</div> <div class="Real-P">Note also that the user does
<em>not</em> in fact always want all the walks.  Sometimes any
one will do, with or without the knowledge that the sentence is
ambiguous.</div></div><div class="note">[<a name="d3e1123" id="d3e1123" href="#ref-to-d3e1123">6</a>] 
By <i>iterative function</i> I mean a recursive
function where recursion serves only to provide a looping
construct.
</div><div class="note">[<a name="d3e1131" id="d3e1131" href="#ref-to-d3e1131">7</a>] 
If we are not trying to return all walks but only a finite number
of walks, a depth-first search might be better.  But at the moment I
am reacting, and possibly over-reacting, against the problems in the
depth-first implementation of the
<i>all-node-sequences()</i> function.
</div><div class="note">[<a name="d3e1141" id="d3e1141" href="#ref-to-d3e1141">8</a>] 

In principle, a walk can be extended if the last state reached by
the walk has follow states.  But since right-hand sides in an EBNF can
have cycles, we cut off any walk if its last state has already been
visited more than <i>n</i> times.

<div class="Real-P">If we set <i>n</i> to 0, then we eliminate all loops; that's sufficient
for all normal grammars.  If we set <i>n</i> higher, then we traverse each
loop at most <i>n</i> times; this may be interesting for people fascinated
by ambiguity.</div>

</div><div class="note">[<a name="d3e1348" id="d3e1348" href="#ref-to-d3e1348">9</a>] 
If this is the only source of ambiguity in the parse, returning
<i>n</i> walks will give us <i>n</i> trees.  If there are multiple sources of
ambiguity, the parse-forest grammar will generate more than <i>n</i>
trees, but the cost of returning a richer parse-forest grammar than
needed is lower than the cost of keeping track of how many trees we
could generate from the walks we have so far.  It's worth
remembering that ambiguities are not necessarily independent: having
two two-way ambiguities does not guarantee four trees.
</div><div class="note">[<a name="d3e1368" id="d3e1368" href="#ref-to-d3e1368">10</a>] Note that the current position is the
&#x201c;<tt>from</tt>&#x201d; value for the starter step (a completion for
the parent) but the &#x201c;<tt>to</tt>&#x201d; value for any other
step.</div><div class="note">[<a name="d3e1383" id="d3e1383" href="#ref-to-d3e1383">11</a>] Note that <i>N</i> and <i>T</i> are uniquely
determined by <i>qNext</i> and thus redundant, but including
them as grouping keys allows them to be referred to without
subscripts.</div><div class="note">[<a name="d3e1497" id="d3e1497" href="#ref-to-d3e1497">12</a>] 
Might it be faster to do this at the same time we
generate the right-hand side from the walk?</div><div class="note">[<a name="d3e1604" id="d3e1604" href="#ref-to-d3e1604">13</a>]  Actually, <i>Goal</i> should carry
&#x201c;<tt>mark="-"</tt>&#x201d; in any case.</div><div class="note">[<a name="d3e4676" id="d3e4676" href="#ref-to-d3e4676">14</a>] 

Operationally, I think end-stopping can be detected as follows.
<ul><li>Construct the FSA for the <i>O</i><sub>0</sub> regular superset approximation of
<i>L(G)</i>, in the usual way.  For each nonterminal, keep track of the set
of states that recognize that nonterminal.  (Including states in
descendant nonterminals, if they have been retained; in practice, I
expect it will make sense to rewrite the rules for <i>N</i> as a regular
expression over characters.)</li>
<li>For every nonterminal <i>N</i> and every state which can reach the
final state of <i>N</i> via epsilon transitions, mark that state as a
member of <i>last</i>(<i>N</i>).  The terminal subset of this set
we can call <i>last</i><sub><i>T</i></sub>(<i>N</i>).</li>
<li>Remove epsilon transitions.</li>
<li>For each state <i>q</i> in <i>last</i><sub><i>T</i></sub>(<i>N</i>), classify the outgoing arcs: either they lead
to a state in the recognizer for <i>N</i>, or they lead to one of the
initial states in a recognizer for some nonterminal in
<i>follow(N)</i>.  We can call these <em>endotelic</em>
and <em>exotelic</em> arcs: they have goals inside, or outside,
the recognizer for <i>N</i>.</li>
<li>If no symbol occurs on both an endotelic and an exotelic arc,
then <i>N</i> is end-stopped: if an occurrence of <i>N</i> can be extended by
including the next character in the input, then in any correct parse
that character is included in the <i>N</i>.  If any symbol occurs on both
kinds of arc, then it is not clear without further information
whether it belongs in the <i>N</i> or outside it.</li>
</ul>


</div></div></body></html>

