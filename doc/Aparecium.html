<html>
<!--Need to find a way to insert the current date-->
<head><meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<title>Aparecium:  an ixml parser for XSLT and XQuery</title>

<style type="text/css">
      p {
      margin-top: 0.6em;      
      margin-bottom: 0.6em;
    }
    p.bibl {
      margin-top: 0.6em;      
      margin-bottom: 0.6em;
      margin-left: 2em;
      text-indent: -2em;
    }
    .Real-P {
      margin-top: 0.6em;      
      margin-bottom: 0.6em;
    }
    div.sp {
      margin-top: 0.6em;      
      margin-bottom: 0.6em;
    }
    div.address {
      margin-top: 0.6em;      
      margin-bottom: 0.6em;
      margin-left: 2em;
    }
    div.note {
      margin-top: 1em;      
      margin-left: 2em;
      
    }
    pre {  
      font-family: monospace;
      margin-left: 2em 
    }  
    a:hover { 
      background: #CCF 
    }
    td.no { 
      background: #CCF 
    }
    .author { 
      font-size: x-large
    }
    .bio { 
      font-size: small;
      font-style: italic
    }
    span.decision { 
    }
    span.result { 
      font-weight: bold
    }
    span.aye { 
      display: block;
      margin-left: 2em;
    }
    span.nay { 
      display: block;
      margin-left: 2em;
    }
    span.abstain { 
      display: block;
      margin-left: 2em;
    }
    span.result { 
      display: block;
      margin-left: 2em;
      font-weight: bold
    }
    span.speaker { 
      display: inline;
    }
    span.typename { 
      display: inline;
      font-family: monospace;
    }
   
  div.scrap {
    margin-top: 0.5em; 
    background-color: #CFEFCF; 
    background-color: #E7F7E7; 
    padding: 0.6em;
    margin-bottom: 0.5em;
  }
  pre.scrapbody {
    margin-left: 0.5em; 
    margin-bottom: 0.5em;
  }
  span.scrapcontinuations {
    font-size:smaller; 
  }
  span.scrapinbound {
    font-size:smaller;
  }
  span.scrapref {
    font-family: New Times Roman, serif, Lucida Sans Unicode;
  }
  em.scrapptr {
    font-family: New Times Roman, serif, Lucida Sans Unicode;
  }
  dl.desclist {
    list-style-type: none;
  }
  dl.desclist > dt {
    display: run-in;
    padding-right: 0.5em;
/*
*/
  }
  dl.desclist > dd {
    text-indent: -1em;
    margin-left: 1em; 
  }
  ul.desclist { 
    list-style-type: none;
  }
  ul.desclist > li {
    margin-left: 2em;
    text-indent: -2em;
  }
  div.epigraph .Real-P {margin-top: 0em; margin-bottom: 0em;} 
  </style></head><body><div class="doc">







<h1>Aparecium</h1>
<h1>An ixml parser for XSLT and XQuery</h1>

<h3>C. M. Sperberg-McQueen</h3>
<h3>Begun 16 August 2021
<br>Last rev. 3 October 2021</h3>

<hr><a name="toc"></a>
<ul><!-- and a 1! -->
<li>1. <a href="#intro">Introduction</a></li><li>2. <a href="#overall">Overall structure</a></li><li>3. <a href="#highlevel">High-level functions</a><ul>
<!-- and a 2! -->
<li>3.1. <a href="#hi-code-org">Organization of the code</a><ul><!-- and a 3! -->
<li>3.1.1. <a href="#files-ap">Aparecium module:  <i>Aparecium.xqm</i></a></li><li>3.1.2. <a href="#files-parser">Parser:  <i>Earley-parser.xqm</i></a></li><li>3.1.3. <a href="#files-epi">Parser internals:  <i>Earley-parser-internals.xqm</i></a></li><li>3.1.4. <a href="#files-rec">Recognizer: <i>Earley-recognizer.xqm</i></a></li><li>3.1.5. <a href="#files-eri">Recognizer internals: <i>Earley-rec-internals.xqm</i></a></li></ul></li>
<li>3.2. <a href="#hi-calling">Calling the parser</a></li>
<li>3.3. <a href="#hi-prep-input">Preparing the input</a></li>
<li>3.4. <a href="#hi-prep-grammar">Preparing the grammar</a></li>
<li>3.5. <a href="#hi-earley-set">Generating the Earley set</a><ul><!-- and a 3! -->
<li>3.5.1. <a href="#hies-scan">The scanner</a></li><li>3.5.2. <a href="#hies-pred">The predictor</a></li><li>3.5.3. <a href="#hies-comp">The completer</a></li><li>3.5.4. <a href="#hies-recognizer">The recognizer</a></li></ul></li>
<li>3.6. <a href="#hi-ptc">Direct generation of parse tree</a><ul><!-- and a 3! -->
<li>3.6.1. <a href="#hi-ptc-raw">Raw parse trees</a></li><li>3.6.2. <a href="#hi-ptc-ast">Abstract syntax trees</a></li></ul></li>
<li>3.7. <a href="#hi-pfg">Generating the parse-forest grammar</a></li>
<li>3.8. <a href="#hi-rpt-ex-pfg">Extracting a raw parse tree from the parse-forest grammar</a></li>
<li>3.9. <a href="#hi-ast-ex-rpt">Extracting an abstract syntax tree from the raw parse tree</a></li>
</ul></li><li>4. <a href="#lowlevel">Low-level utility routines</a><ul>
<!-- and a 2! -->
<li>4.1. <a href="#ll-items">Working with Earley items</a><ul><!-- and a 3! -->
<li>4.1.1. <a href="#ll-items-con">Earley items - constructors</a></li><li>4.1.2. <a href="#ll-items-extr">Earley items - extractors</a></li><li>4.1.3. <a href="#ll-items-predicates">Earley items - predicates</a></li><li>4.1.4. <a href="#ll-items-closure">Earley set closure</a></li></ul></li>
<li>4.2. <a href="#ll-grammars">Working with grammars</a></li>
<li>4.3. <a href="#ll-rules">Working with rules</a></li>
<li>4.4. <a href="#ll-symbols">Working with symbols</a></li>
<li>4.5. <a href="#ll-input">Dealing with the input</a></li>
<li>4.6. <a href="#ll-utils">Utilities and miscellaneous</a><ul><!-- and a 3! -->
<li>4.6.1. <a href="#ll-utils-strings">Routines for strings and characters</a></li><li>4.6.2. <a href="#ll-utils-tracing">Trace routines</a></li></ul></li>
</ul></li><li>5. <a href="#alt-calls">Alternative interfaces</a><ul>
<!-- and a 2! -->
<li>5.1. <a href="#alt-calls-main">Main user-facing calls</a></li>
<li>5.2. <a href="#alt-calls-secondary">Secondary user-facing calls</a></li>
<li>5.3. <a href="#alt-calls-other">Non-user-facing functions</a></li>
</ul></li><li>6. <a href="#quarry">Unsorted bits of legacy code</a><ul>
<!-- and a 2! -->
<li>6.1. <a href="#legacy-Earley-parser.xqm">Earley parser</a></li>
<li>6.2. <a href="#legacy-Earley-parser-internals.xqm">Parser internals</a><ul><!-- and a 3! -->
<li>6.2.1. <a href="#epi-earley-parse-function">The <i>earley-parse()</i> function</a></li><li>6.2.2. <a href="#epi-tree-returns">Functions to return one or more trees</a></li><li>6.2.3. <a href="#epi-all-nodes">Finding a sequence of items for a single right-hand side</a></li><li>6.2.4. <a href="#epi-ast-from-raw">Extracting the abstract syntax tree from the raw parse tree</a></li></ul></li>
<li>6.3. <a href="#legacy-Gluschkov.xqm">Construction of the Gluschkov automaton</a><ul><!-- and a 3! -->
<li>6.3.1. <a href="#leggl-prolog">Module prolog</a></li><li>6.3.2. <a href="#leggl-ME">Calculating the Gluschkov automaton <i>M</i> <i><i>E</i></i></a></li></ul></li>
</ul></li><li>A. <a href="#references">References</a></li>
<li>B. <a href="#notation">Literate programming notation</a></li>
<li>C. <a href="#to-do">To do</a></li>
<li>D. <a href="#change-logs">Change logs</a></li>
</ul>

<hr>
<div class="epigraph" style="margin-top: 12 pt; text-align:left; margin-left: 30%">
<blockquote>
<div class="Real-P">... Hermione was pulling her wand out of her bag.</div>
<div class="Real-P">&#x2018;It might be invisible ink!&#x2019; she whispered.</div>
<div class="Real-P">She tapped the diary three times and said,
&#x2018;Aparecium!&#x2019;</div>
</blockquote>
<div style="margin-top: 12 pt; text-align:right; margin-left: 10%; margin-right: 10%; font-size: 80%;">
J. K. Rowling, <em>Harry Potter 
and the Chamber of Secrets</em>
</div>
</div>

<div class="Real-P">This document is the source code for Aparecium, an
invisible-XML processor written in XSLT and XQuery, as a library
for use in those languages.  Aparecium is a &#x2018;literate
program&#x2019;, in the sense defined by Donald Knuth: this
document contains descriptions of the program in English prose
and in XQuery and XSLT source code.  Processed in one way, the
document produces XQuery and XSLT programs; processed another
way, it produces a (rather dry) technical exposition of their
structure and coding.  Readers in search of user-level
introductions to invisible XML or the use of Aparecium to build
applications will not find here what they seek.</div>

<div class="Real-P">The specific literate programming system used here is SWeb; a
description of its notation is given 
in <a href="#msm-1996" title="&#xA;Sperberg-McQueen, C. M.&#xA;SWEB:&#xA;an SGML Tag Set for Literate Programming.&#xA;Unpublished technical report, 1993, rev. 1994, 1995, 1996.&#xA;On the web at&#xA;http://cmsmcq.com/1993/sweb.{xml,html}.">[Sperberg-McQueen 1996]</a>.

</div>

<div class="Real-P">In its current form, the program is incomplete.  A running
version of Aparecium exists, implemented in XQuery; this
document is my attempt to update and upgrade it.  The work plan
is:
<ul><li><div class="Real-P">Draft overview of program, top-level structure, in
XQuery.</div></li>
<li><div class="Real-P">Create three simple cases to use in initial
development, showing input and output for each stage of
processing.</div></li>
<li><div class="Real-P">Write XSLT stylesheet to translate from test suite
catalog (as in ixml-texts repo) to XSpec.</div></li>
<li><div class="Real-P">Implement grammar normalization (EBNF to
BNF).</div></li>
<li><div class="Real-P">Implement generation of Earley set.</div></li>
<li><div class="Real-P">Implement creation of parse forest grammar from
Earley set.</div></li>
<li><div class="Real-P">Implement extraction of parse tree(s) from parse
forest grammar.</div></li>
<li><div class="Real-P">When XQuery version is running on the three toy
cases, run on larger ixml test suite.</div></li>
<li><div class="Real-P">Upgrade the SWeb infrastructure to support
XSLT.</div></li>
<li><div class="Real-P">Create XSLT version of Aparecium.</div></li>
</ul>
</div>


<div class="div">

<h2><a name="intro" id="intro">1. </a>Introduction</h2>
<div class="Real-P">Aparecium is an XQuery implementation of Invisible XML (or:
ixml).  In the usual case, it accepts a context-free grammar
and input, and it returns an XML representation of the parse
tree.  Any grammar in the grammar notation defined by the
specification for Invisible XML (<a href="#pemberton-2021" title="&#xA;Pemberton, Steven.&#xA;2021.&#xA;Invisible XML Specification&#xA;(Draft).&#xA;On the web at&#xA;https://invisiblexml.org/ixml-specification.html&#xA;">[Pemberton 2021]</a>) is accepted, and the XML
representation returned will be not the raw parse tree but the
tree as modified by annotations in the grammar.
</div>

<div class="Real-P">This paper assumes that the reader is familiar with the
ideas of Invisible XML and those of Earley parsing.  Several
accessible introductions to Invisible XML can be found at
&lt;URL:<a href="http://invisiblexml.org">http://invisiblexml.org</a>&gt;, as can the formal
specification itself (<a href="#pemberton-2021" title="&#xA;Pemberton, Steven.&#xA;2021.&#xA;Invisible XML Specification&#xA;(Draft).&#xA;On the web at&#xA;https://invisiblexml.org/ixml-specification.html&#xA;">[Pemberton 2021]</a>).
A 
discussion of the particular challenges of implementing
an Earley parser in a declarative functional language,
and a re-formulation of the Earley algorithm in declarative
terms to simplify that task, may be found in
<a href="#msm-2017" title="&#xA;Sperberg-McQueen, C. M.&#xA;Translating imperative algorithms&#xA;into declarative, functional terms:&#xA;towards Earley parsing in XSLT and XQuery.&#xA;Presented at Balisage: The Markup Conference 2017,&#xA;Washington, DC, August 1 - 4, 2017.&#xA;In&#xA;Proceedings of Balisage:&#xA;The Markup Conference 2017.&#xA;Balisage Series on Markup Technologies,&#xA;vol. 19 (2017).&#xA;https://doi.org/10.4242/BalisageVol19.Sperberg-McQueen01.&#xA;">[Sperberg-McQueen 2017]</a>.</div>
</div>


<div class="div">

<h2><a name="overall" id="overall">2. </a>Overall structure</h2>
<div class="Real-P">Aparecium divides its task into several steps:
<ul><li>
<div class="Real-P">Depending on the top-level function called, we may
start work with a string containing the input to be
parsed, or with a URI which should be dereferenced in
order to obtain the string to be parsed.  The grammar may
be provided as a string, as a URI, as an XML document
containing the standard XML representation of the ixml
grammar, or as a &#x2018;compiled&#x2019; or prepared
grammar.</div>	    
<div class="Real-P">The first step is thus to collect what is needed and
put it into the form required for further processing: a
prepared grammar <i>G</i> and a string <i>I</i> (for
&#x2018;<span>input</span>&#x2019;) to be parsed.</div>
</li>
<li>
<div class="Real-P">The second step is to calculate the Earley set, a set
of Earley items sufficient to indicate whether <i>I</i> is a
sentence in <i>L(G)</i> (the language defined by <i>G</i>).</div>
<div class="Real-P">This suffices for an Earley recognizer, which
recognizes <i>L(G)</i>, but not for a parser, which identifies
the parse trees of sentences in <i>L(G)</i>.
</div>
</li>
<li>
<div class="Real-P">The next step is to use the Earley set to construct a
parse tree for the sentence.</div>
<div class="Real-P">When the sentence has only one parse tree, this is
relatively straightforward, but there are some cases of
interest in which we can expect sentences to be ambiguous,
and in which the user may wish to inspect more than one
possible parse tree.  For example, in a programming
language, keywords might have the same lexical form as
variable or function names, and this can easily give rise
to ambiguity.  Or the grammar writer may be trying to
detect possible ambiguities in a language specification
and need to examine in detail the possible parses for
ambiguous sentences.</div>
<div class="Real-P">In some cases, the number of possible parse trees
may be unbounded.[<a name="ref-to-d3e199" href="#d3e199" title="&#xA;A simple example is the grammar S:  'a';&#xA;S.,&#xA;for which the single sentence (a)&#xA;has an infinite number of parses (one S&#xA;node, two S nodes, three, ...).&#xA;Another ">1</a>]</div>
<div class="Real-P">For this reason, Aparecium divides this step further.	   
<ul><li>
<div class="Real-P">Instead of extracting a single parse tree from the
Earley set, Aparecium extracts a parse-forest grammar
representing all parse trees for the sentence. [Or rather,
it will do so real soon now.  The current version
does extract a tree.]</div>
<div class="Real-P">Parse-forest grammars have the convenient property
that they can concisely describe more than one parse
tree over the given input, even infinite trees.  It is
relatively straightforward to tell by examing the
parse-forest grammar whether it describes a single
parse tree or multiple parse trees, and whether the
number of parse trees is finite or infinite.</div>
</li>
<li>
<div class="Real-P">A separate function extracts [er, will extract] a single parse tree
from the parse-forest grammar and returns a pair
consisting of (a) the tree extracted and (b) a
function which can be called to extract another parse
tree, if there is another.</div>
</li>
</ul>
</div>
</li>
<li>
<div class="Real-P">The final step is to simplify the raw parse tree as
specified in the annotation of the ixml grammar.</div>
</li>
</ul>
</div>
<div class="Real-P">Functions performing these high-level tasks are described
below in section <a href="#highlevel" title="High-level functions">3</a>.</div>
<div class="Real-P">Lower-level functions called upon by the higher-level
routines are described in section <a href="#lowlevel" title="Low-level utility routines">4</a>.</div>
</div>


<div class="div">

<h2><a name="highlevel" id="highlevel">3. </a>High-level functions</h2>
<div class="Real-P">The following sections describe the high-level
functionality described above.</div>


<div class="div">

<h3><a name="hi-code-org" id="hi-code-org">3.1. </a>Organization of the code</h3>
<div class="Real-P">The code is organized into different modules
(and files) in an attempt to keep things organized.
<ul><li><i>Aparecium.xqm</i> declares the top-level user-facing
functions for parsing (and also some cruft most users can and should
ignore).</li>
<li><i>Earley-recognizer.xqm</i> declares the high-level
functions of an Earley recognizer.  These functions prepare the
grammar, build the initial Earley item, and construct the Earley set.
The functions here are relatively abstract and are intended to be
independent of many of the lower-level implementation details, which
are factored out into an internals module.  As a recognizer, all the
main function here does is to decide whether the input given is or is
not a sentence in the language defined by the grammar.</li>
<li><i>Earley-rec-internals.xqm</i> declares low-level
functions called by the Earley recognizer.  These routines reflect
specific implementation choices from which the recognizer itself
should ideally be insulated.</li>
<li><i>Earley-parser.xqm</i> declares the high-level
functions of the Earley parser.  The main function calls the
recognizer and constructs a parse tree from the Earley set generated
by the recognizer.</li>
<li><i>Earley-parser-internals.xqm</i> contains low-level
routines for the Earley parser.</li>
<li><i>Gluschkov.xqm</i> decorates the right-hand sides of
rules in a grammar with attributes allowing the rule to be interpreted
as a finite state automaton instead of as a regular expression.</li>
</ul>
These files are described in the following paragraphs.
</div>

<div class="div">

<h4><a name="files-ap" id="files-ap">3.1.1. </a>Aparecium module:  <i>Aparecium.xqm</i></h4>
<div class="Real-P">The file <i>Aparecium.xqm</i>
contains the module the typical user will
want to import and use.
<div class="scrap"><span><a name="d3e294">&#x3008; 1  [File Aparecium.xqm]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
module namespace aparecium =
"http://blackmesatech.com/2019/iXML/Aparecium";

(: Aparecium:  a library to make invisible XML visible.

    ... Hermione was pulling her wand out of her bag.
    "It might be invisible ink!" she whispered.
    She tapped the diary three times and said, "Aparecium!"
      
                           - J. K. Rowling, Harry Potter 
                           and the Chamber of Secrets

:)

<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#aparecium-imports">Module imports for Aparecium top-level 2</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#aparecium-main">Main interfaces for Aparecium 55</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#aparecium-secondary">Secondary interfaces (a bit specialized) 58</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#aparecium-tertiary">Tertiary interfaces (of interest only for maintainer) 59</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#aparecium-variables">Variables (of interest only for maintainer) 60</a></em> &#x3009;</span>
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>
</div>

<div class="Real-P">The file needs to import the Earley parser and the constructor
for Gluschkov automata.
<div class="scrap"><span><a name="aparecium-imports">&#x3008; 2 Module imports for Aparecium top-level &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
import module namespace earley
   = "http://blackmesatech.com/2019/iXML/Earley-parser"
  at "Earley-parser.xqm";
import module namespace gluschkov
   = "http://blackmesatech.com/2019/iXML/Gluschkov"
  at "Gluschkov.xqm";
  
(: Quick hack for testing ... :)
import module namespace ws
   = "http://blackmesatech.com/2019/iXML/wstrimtree"
   at "wstrimtree.xqm";
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e294">[File Aparecium.xqm] 1</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<h4><a name="files-parser" id="files-parser">3.1.2. </a>Parser:  <i>Earley-parser.xqm</i></h4>
<div class="Real-P"><i>Earley-parser.xqm</i> has the functions called
by the Aparecium module to parse the input and construct the
parse tree.</div>
<div class="Real-P">As far as I have been able, the functions defined here are ignorant
of details of how the data are represented; they call functions
defined in other modules to take care of the details.
<div class="scrap"><span><a name="d3e326">&#x3008; 3  [File Earley-parser.xqm]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
module namespace ep =
"http://blackmesatech.com/2019/iXML/Earley-parser";

(: The top-level definition of an Earley parser. :)

import module namespace epi =
"http://blackmesatech.com/2019/iXML/Earley-parser-internals"
at "Earley-parser-internals.xqm";
  
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>
</div>
</div>


<div class="div">

<h4><a name="files-epi" id="files-epi">3.1.3. </a>Parser internals:  <i>Earley-parser-internals.xqm</i></h4>
<div class="Real-P">Some lower-level functions are separated out into
<i>Earley-parser-internals.xqm</i>.  These functions are not
intended to be used by users of the Earley parsers; if I knew how to
hide their names, I would.  The functions defined here are intended to
be called by the parser proper; the internal details (in particular
the representation of data structures) are subject to change.
<div class="scrap"><span><a name="d3e340">&#x3008; 4  [File Earley-parser-internals.xqm]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
module namespace epi =
"http://blackmesatech.com/2019/iXML/Earley-parser-internals";

(: Internals of Earley parser. :)
(: Not intended for user exposure. :) 

import module namespace er =
"http://blackmesatech.com/2019/iXML/Earley-recognizer"
at "Earley-recognizer.xqm";

import module namespace eri =
"http://blackmesatech.com/2019/iXML/Earley-rec-internals"
at "Earley-rec-internals.xqm";
  
declare namespace follow = 
"http://blackmesatech.com/2016/nss/ixml-gluschkov-automata-followset"; 

declare namespace ixml = 
"http://invisiblexml.org/NS";

(: We rely on the EXPath file module, and we use maps. :)
declare namespace file =
"http://expath.org/ns/file";

declare namespace map =
"http://www.w3.org/2005/xpath-functions/map";



<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-earley-parse">Define earley-parse() 64</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-all-trees">Define all-trees() 65</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-any-tree">Define any-tree() 70</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tree-cursor">Define tree-cursor() 71</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-parse-forest-map">Define parse-forest-map() 72</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-parse-forest-grammar">Define parse-forest-grammar() 73</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-all-node-sequences">Define all-node-sequences() 74</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-astXparsetree">Define astXparsetree() to make AST from raw parse 89</a></em> &#x3009;</span>
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>
</div>
</div>


<div class="div">

<h4><a name="files-rec" id="files-rec">3.1.4. </a>Recognizer: <i>Earley-recognizer.xqm</i></h4>

<div class="Real-P">Most of the actual work done is performed by the code in
<i>Earley-recognizer.xqm</i>: 

<div class="scrap"><span><a name="Earley-rec">&#x3008; 5  [File Earley-recognizer.xqm]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
module namespace ix =
"http://blackmesatech.com/2019/iXML/Earley-recognizer";

(: Earley parser, v0 :)

import module namespace ixi =
"http://blackmesatech.com/2019/iXML/Earley-rec-internals"
at "Earley-rec-internals.xqm";

<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#er-scan">Define scan() 9</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#er-pred">Define pred() 10</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#er-comp">Define comp() 11</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#er-recognize">Define recognize() 12</a></em> &#x3009;</span>
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>
</div>
</div>

<div class="div">

<h4><a name="files-eri" id="files-eri">3.1.5. </a>Recognizer internals: <i>Earley-rec-internals.xqm</i></h4>
<div class="Real-P">The low-level functions of the recognizer are in
<i>Earley-rec-internals.xqm</i>.  The
&#x2018;public&#x2019; interface (the functions intended for use
by consumers) is in Earley-recognizer.xqm; this module contains
details that are subject to change and intended to be
&#x2018;private&#x2019;.</div>
<div class="Real-P">It is in this module that I first experienced a
pressing need to clarify some naming conventions.
Naming is sort of Hungarian, at least some of the time.
<ul><li><em>ei</em>: Earley item (aka ITEM, map(xs:string, item())</li>
<li><em>e</em>:  Earley item</li>
<li><em>f</em>:  Boolean (flag)</li>
<li><em>G</em>:  the grammar</li>
<li><em>I</em>:  the input</li>
<li><em>mei</em>:  map of Earley items (= map(xs:integer, map(xs:string, ITEM*))
       = map(xs:integer, map(xs:string, map(xs:string, item())*))</li>
<li><em>n</em>:  non-terminal symbol (may sometimes be nt)</li>
<li><em>p</em>:  position in input (to, from)</li>
<li><em>pt</em>:  raw parse tree (or subtree)</li>
<li><em>r</em>:  rule in grammar</li>
<li><em>ri</em>:  rule index (position in rule)  </li>
<li><em>s</em>:  string</li>
<li><em>sym</em>:  symbol from grammar</li>
<li><em>t</em>:  terminal symbol   </li>
</ul>
</div>
<div class="Real-P">Functions:
<ul><li><em>aXb</em>: return thing A from thing B</li>
</ul>
<div class="scrap"><span><a name="d3e455">&#x3008; 6  [File Earley-rec-internals.xqm]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
module namespace ixi =
"http://blackmesatech.com/2019/iXML/Earley-rec-internals";

(: Earley recognizer internals :)

declare namespace map =
"http://www.w3.org/2005/xpath-functions/map";

<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-imports">Imports for recognizer internals 7</a></em> &#x3009;</span>   
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-items">Earley items (constructors, extractors, etc.) 14</a></em> &#x3009;</span>   
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-grammars">Grammars (constructors, extractors, etc.) 27</a></em> &#x3009;</span>   
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-rules">Rules (constructors, extractors, etc.) 33</a></em> &#x3009;</span>   
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-symbols">Symbols (constructors, extractors, etc.) 34</a></em> &#x3009;</span>   
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-input">Input (constructors, extractors, etc.) 40</a></em> &#x3009;</span>   
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-utils-and-misc">Utilities for recognizer internals module 41</a></em> &#x3009;</span>   
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>
</div>
<div class="Real-P">This module has a complicated enough to-do list of its own that
I'll give it here for the moment instead of inserting these into the
general to-do list at the bottom of this document.</div>
<ul><li><div class="Real-P">establish coherent Hungarian type policy to distinguish 
     element and string representations of symbols.  We need
     shorthands for both.</div></li>
<li><div class="Real-P">fix symbol/position issue in leiAdvanceEiSymP()</div></li>
<li><div class="Real-P">finish minimal version</div></li>
<li><div class="Real-P">add support for #xxxx characters</div></li>
<li><div class="Real-P">clarify XML representation of terminals and other questions
with SP:
<ul><li>grammar says -quoted, I say quoted </li>
<li>grammar says quoted/@dstring, quoted/@sstring, 
       I think I prefer quoted with PCDATA (code
       currently handles all three)</li>
<li>grammar defines -character, I want character element
       as child of terminal (-character is fine for 
       @dstring and @sstring)</li>
<li>grammar and papers don't say what ^ means</li>
<li>how is start symbol determined?  For now I
       take LHS of first rule, like yacc.</li>
<li>if a rule reads "-foo: @bar, baz.", what happens?
       does @bar percolate up to parent element? (Do you
       know how to do this?)</li>
<li>Is a grammar specifying an @ mark on a repeatable 
       non-terminal ill-formed?  Or is the @ just ignored
       in that case?  (Tentative answer: both.)</li>
<li>True or false? 
       On a nonterminal, the mark "-" means "do not tag as element",
       but do promote the children.  On a terminal, it means
       "omit the entire thing".
</li>
</ul></div>
</li>
<li><div class="Real-P">do some sanity checking in reXTerminal to avoid having
     matches() blow up.</div></li>
<li><div class="Real-P">fix confusion over two senses of nullable:
<ul><li>locally nullable = nullable within the RHS (decorated 
       with ? or *, inside optional group, etc.)</li>
<li>generates null string in sentence</li>
</ul>
</div>
<div class="Real-P">N.B. a required non-terminal, not nullable in first
sense, can generate empty string and thus make its
parent nullable in the second sense.</div>
<div class="Real-P">Use fNullable for the first sense (already establisted)
and fGES (to be renamed for the second.</div>
</li>
<li><div class="Real-P">For testing purposes, provide a recognize function that
specifies a start symbol (analogous to phrase/2 in Prolog).</div></li>
</ul>

<div class="Real-P">The Earley-rec-internals module has a (cyclic) import
for the recognizer itself (why?), and also some low-level
things.
<div class="scrap"><span><a name="eri-imports">&#x3008; 7 Imports for recognizer internals &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: **************************************************************** 
   * Imports and setup
   **************************************************************** :)

import module namespace ix =
"http://blackmesatech.com/2019/iXML/Earley-recognizer"
at "Earley-recognizer.xqm";
  
import module namespace d2x =
'http://blackmesatech.com/2019/iXML/d2x'
at "d2x.xqm";
  
declare namespace follow = 
"http://blackmesatech.com/2016/nss/ixml-gluschkov-automata-followset";

(: $ixi:combinedups:  convenience variable for calls to map:merge. :)
declare variable $ixi:combinedups as map(*)
   := map:entry('duplicates','combine');
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e455">[File Earley-rec-internals.xqm] 6</a> &#x3009; <br></span>
</div>

</div>
</div>
</div>

<div class="div">

<h3><a name="hi-calling" id="hi-calling">3.2. </a>Calling the parser</h3>
<div class="Real-P">In the simple case, Aparecium is designed to be callable
in much the same way as the <tt>doc()</tt> function.
If the file at <i>http://example.com/local.css</i>
were in XML, the expression
<tt>doc("http://example.com/local.css")</tt>
would have a document node as its value.  But a file
named <i>local.css</i> is probably not in XML.
With Aparecium, the idea is to open it with a call like
<tt>aparecium:parse-resource( "http://example.com/local.css",
"http://example.com/grammars/css.ixml")</tt>, which will
fetch the CSS file and a grammar for CSS, use the grammar
to parse the CSS, and return the document node of an XML
document representing the resulting parse tree.</div>

<div class="Real-P">
<div class="scrap"><span><a name="d3e542">&#x3008; 8 Define parse-resource() [continues <a href="#aparecium-main">55 Main interfaces for Aparecium</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ................................................................
   parse-resource($Input, $Grammar)
   ................................................................
   Given URIs for the input and an ixml grammar describing it,
   returns the XML representation of the resource.
:)

declare function aparecium:parse-resource(
  $uriI as xs:string,
  $uriG as xs:string
) as element() {
  let $sI := unparsed-text($uriI),
      $sG := unparsed-text($uriG)
  return aparecium:parse-string($sI, $sG)
};
   
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P"><i>Move other primary functions here.</i></div>
</div>


<div class="div">

<h3><a name="hi-prep-input" id="hi-prep-input">3.3. </a>Preparing the input</h3>
<div class="Real-P">Watch this space.</div>
</div>


<div class="div">

<h3><a name="hi-prep-grammar" id="hi-prep-grammar">3.4. </a>Preparing the grammar</h3>
<div class="Real-P">Watch this space.</div>
</div>


<div class="div">

<h3><a name="hi-earley-set" id="hi-earley-set">3.5. </a>Generating the Earley set</h3>
<div class="Real-P">Watch this space.</div>

<div class="div">

<h4><a name="hies-scan" id="hies-scan">3.5.1. </a>The scanner</h4>
<div class="Real-P">
<div class="scrap"><span><a name="er-scan">&#x3008; 9 Define scan() &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: **************************************************************** 
   * ix:scan($E, $I)
   **************************************************************** :)
(: If $E expects any terminals which occur as expected, return
   the advance of E over that terminal. :)
   
declare function ix:scan(
  $E as item() (: ITEM :),
  $I as item() (: INPUT :)
) as item()? (: ITEM? :) {
  let $p := ixi:pToXEi($E),
      $lt := ixi:lsymExpectedXEi($E)[ixi:fTerminal(.)],
      $dummy := ixi:notrace(ixi:sXei($E), 'ix:scan() on item:') 
  for $t in $lt
  let $dummy := ixi:notrace($t, 'ix:scan() expects terminal:'),
      $dummy := ixi:notrace(ixi:fMatchesIPT($I, $p, $t), 
                          'ix:scan() matches? ') 
  return
    if (ixi:fMatchesIPT($I, $p, $t))
    then ixi:leiAdvanceEiSymP($E,$t,$p + ixi:match-length($I,$p,$t))
    else ()
};

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#Earley-rec">[File Earley-recognizer.xqm] 5</a> &#x3009; <br></span>
</div>

</div>
</div>

<div class="div">

<h4><a name="hies-pred" id="hies-pred">3.5.2. </a>The predictor</h4>

<div class="Real-P">
<div class="scrap"><span><a name="er-pred">&#x3008; 10 Define pred() &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: **************************************************************** 
   * ix:pred($E, $G)
   **************************************************************** :)
(: If $E predicts any non-terminals, return items which expect
   those non-terminals at the appropriate location. :)
   
declare function ix:pred(
  $E as item() (: ITEM :),
  $G as item() (: GRAMMAR :)
) as item()* (: ITEM :) {
  (: iterate over
       $ln nonterminals expected by $E,
       $lr rules in $G for $n,
       $lri initial positions in $r
     also return advance of $E for nullable $n
   :)
   let $p := ixi:pToXEi($E),
       $ln := ixi:lsymExpectedXEi($E)[ixi:fNonterminal(.)]
   for $n in $ln
   let $fNullable := ixi:fNullableNG($n/@name, $G),
       $lr := ixi:lrulesXNG($n,$G)
   return (
     (: first, return advance of $E if $n nullable :)
     if ($fNullable)
     then ixi:leiAdvanceEiSymP($E,$n,$p)
     else (),
       
     (: then iterate over rules and initial locations for $n :)
     for $r in $lr
     let $lri := ixi:lriStartstatesXR($r)
     for $ri in $lri
     return ixi:eiMakePPRRi($p, $p, $r, $ri)
   )
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#Earley-rec">[File Earley-recognizer.xqm] 5</a> &#x3009; <br></span>
</div>
</div>
</div>


<div class="div">

<h4><a name="hies-comp" id="hies-comp">3.5.3. </a>The completer</h4>

<div class="Real-P">
<div class="scrap"><span><a name="er-comp">&#x3008; 11 Define comp() &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: **************************************************************** 
   * ix:comp($Ec, $Ep)
   **************************************************************** :)
(: If $Ec and $Ep are a prediction/completion pair, return the
   advance of $Ep over the non-terminal predicted by $Ec. :)
   
(: comp($Ec, $Ep): if $Ec is a completion item, 
   and $Ep a prediction item,
   and $Ep predicts a nonterminal $n at position $pPTo,
   and $Ec completes nonterminal $n starting at $pCFrom=$pPTo,
   then advance $Ep over $n and place the new to-position
   at the to-position of $Ec.
   
   The test for whether $Ep expects $n is handled
   by leiAdvanceEiSymP, so we need not make it here.
:)
declare function ix:comp(
  $Ec as item() (: ITEM :),
  $Ep as item() (: ITEM :)
) as item()* (: ITEM :) {
  let $pCFrom := ixi:pFromXEi($Ec),
      $pCTo   := ixi:pToXEi($Ec),
      (: $pPFrom := ixi:pFromXEi($Ep), :)
      $pPTo   := ixi:pToXEi($Ep),
      $n      := ixi:nLhsXEi($Ec),
      $RESULT := if (ixi:fFinalEi($Ec)
                    and $pPTo eq $pCFrom)
                 then ixi:leiAdvanceEiSymP($Ep, $n, $pCTo)
                 else (),
      $trace1 := ixi:notrace($RESULT,
      concat('&amp;#xA;****** comp(',
             '&amp;#xA;            ',
             '$Ec=',ixi:sXei($Ec),
             '&amp;#xA;            ',
             '$Ep=',ixi:sXei($Ep),
             ') ==&gt; '
            )
      ),
      $r      := ixi:rXEi($Ep),	    
      $trace2 := ixi:notrace('sanity check',
      concat('&amp;#xA;****** comp(',
             '&amp;#xA;            ',
             '$Ec=(',$pCFrom,' ',$pCTo, ' ',
                     $n/@name, '/', $Ec/@ri,'),',
             '&amp;#xA;            ',
             '$Ep=(', ixi:pFromXEi($Ep),' ',$pPTo, ' ',
                     $r/@name, '/', $Ep/@ri, ')',
             ')&amp;#xA;'
            )
      )
  return $RESULT
};

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#Earley-rec">[File Earley-recognizer.xqm] 5</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<h4><a name="hies-recognizer" id="hies-recognizer">3.5.4. </a>The recognizer</h4>
<div class="Real-P">The <i>ix:recognize()</i> function accepts an input string
and a grammar, and returns a boolean: true if the input is a sentence
in the language defined by the grammar, false otherwise.  On the way
to reaching that result, of course, a lot of intermediate results will
be calculated, some of them of interest for other purposes (e.g. for
the parser as a whole).  So there are two recognition functions: one
to calculate and expose all the intermediate results, and one to
expose only the boolean result, which calls the other function to do
the preliminary work.  The <i>ix:recognize()</i> function
works as a kind of wrapper around the other function:
<div class="scrap"><span><a name="er-recognize">&#x3008; 12 Define recognize() &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
declare function ix:recognize(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as xs:boolean {
  let $m := ix:recognizeX($I, $G)
  return $m('Result')
};

</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e622">Define recognizeX() 13</a>&#x3009;<br></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#Earley-rec">[File Earley-recognizer.xqm] 5</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The <i>ix:recognizeX()</i> function (an extended
recognizer, if you will)
<div class="scrap"><span><a name="d3e622">&#x3008; 13 Define recognizeX() [continues <a href="#er-recognize">12 Define recognize()</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
declare function ix:recognizeX(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as map(*) {
  let $G2 := ixi:augment-grammar($G),
      $symStart0 := ixi:symStartG($G),
      $symStart2 := ixi:symStartG($G2),
      $rInitial := ixi:lrulesXNG(
        &lt;nonterminal name="{$symStart2}"/&gt;, 
        $G2)[1],
      $riInitial := ixi:lriStartstatesXR($rInitial)[1],
      $eiInitial := ixi:eiMakePPRRi(0, 0, $rInitial, $riInitial),
      $len := ixi:inputlength($I),
      
      $meiClosure := ixi:earley-closure($eiInitial, $I, $G2),
      (: $leiCompletions := $meiClosure
         [ixi:fFinalEiPPN(.,0,$len,$symStart2)], :)
      $leiCompletions := $meiClosure('from')(0)
                         [ixi:fFinalEiPPN(.,0,$len,$symStart2)],
      $result := exists($leiCompletions)
      (:
      ,
      $dummy := for $eiTmp in $meiClosure
                return ixi:notrace($eiTmp,
              '&amp;#xA;&amp;#xA; (*** closure ***) &amp;#xA;')
      :)
  return map {
    'Grammar' : $G2,
    'Initial-Item' : $eiInitial,
    'Input' : $I,
    'Input-Length' : $len,
    'Closure' : $meiClosure,
    'Completions' : $leiCompletions,
    'Result' : $result
  }
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

</div>
</div>
</div>


<div class="div">

<h3><a name="hi-ptc" id="hi-ptc">3.6. </a>Direct generation of parse tree</h3>
<div class="Real-P">In version 0.2 of Aparecium, we generate one
or more parse trees directly from the Earley set.
(In future versions, it is expected that we will
generate a parse-forest grammar from the Earley
set, and generate trees from that grammar, or
return the grammar to the user.  But at the moment
that's just pie in the sky.)</div>
<div class="Real-P">We generate the parse trees in two steps.
From the Earley set, we generate a raw parse tree
which records every nonterminal used (we may
regret this, eventually).  From the raw parse tree,
we create the abstract syntax tree by attending to
the marks on the nonterminals.
</div>

<div class="div">

<h4><a name="hi-ptc-raw" id="hi-ptc-raw">3.6.1. </a>Raw parse trees</h4>
<div class="Real-P">For raw parse trees, we use a generic XML
representation with two element types:
<ul><li>&lt;<em>nt</em>&gt; elements record that a given nonterminal was parsed
at a given location, with attributes providing details:
<ul><li><em>name</em> gives the nonterminal symbol.</li>
<li><em>_from</em> and <em>_to</em> give the
range in the input.</li>
<li><em>mark</em> records the mark effective for this instance of
the nonterminal.  If a nonterminal in a right-hand side carries a
mark, we record it here; if not, we fetch the default value; if no
default value is specified, we supply the value
&#x201c;<tt>^</tt>&#x201d;.</li>
</ul>
</li>
<li>&lt;<em>lit</em>&gt;, &lt;<em>inc</em>&gt;, and &lt;<em>exc</em>&gt; elements record
that a given terminal was found at a given location, with attributes
providing details:
<ul><li><em>name</em> gives the nonterminal symbol.</li>
<li><em>_from</em> and <em>_to</em> give the
range in the input.  For &lt;<em>inc</em>&gt; and &lt;<em>exc</em>&gt;
the two values will be the same, but not necessarily so
for literals.</li>
<li><em>tmark</em> records the terminal mark effective for this
the nonterminal.  This is what makes it possible to suppress
terminals marked &#x201c;<tt>-</tt>&#x201d; (or inject
terminals marked &#x201c;<tt>+</tt>&#x201d;, which doesn't seem
to have made it into the spec yet).</li>
</ul>
</li>
</ul>
Representing nonterminal nodes as &lt;<em>nt</em>&gt; elements
instead of elements with the nonterminal itself as a name
allows terminals marked for suppression to be distinguished
reliably from nonterminals marked &#x201c;<tt>-</tt>&#x201d;.
(It also allows the raw parse tree to be produced even if
the nonterminal is not a legal XML name.)
</div>
<div class="Real-P">N.B. The initial implementation of raw parse trees
used nonterminals as element names; there may be traces
of that state of affairs in this document.</div>
<div class="Real-P"><i>all-node-sequences() should be described here.</i>
For the moment, see <a href="#epi-all-nodes">Finding a sequence of items for a single right-hand side</a>.</div>
</div>

<div class="div">

<h4><a name="hi-ptc-ast" id="hi-ptc-ast">3.6.2. </a>Abstract syntax trees</h4>
<div class="Real-P"><i>The epi:astXparsetree() function should
go here.  For now, see <a href="#epi-ast-from-raw">Extracting the abstract syntax tree from the raw parse tree</a>.</i></div>
</div>

</div>

<div class="div">

<h3><a name="hi-pfg" id="hi-pfg">3.7. </a>Generating the parse-forest grammar</h3>
<div class="Real-P">Watch this space.</div>
<div class="Real-P">Note that each non-terminal in the parse-forest grammar
carries an explicit annotation, to simplify later construction
of the abstract syntax tree.</div>
</div>


<div class="div">

<h3><a name="hi-rpt-ex-pfg" id="hi-rpt-ex-pfg">3.8. </a>Extracting a raw parse tree from the parse-forest grammar</h3>
<div class="Real-P">Watch this space.</div>
</div>


<div class="div">

<h3><a name="hi-ast-ex-rpt" id="hi-ast-ex-rpt">3.9. </a>Extracting an abstract syntax tree from the raw parse tree</h3>
<div class="Real-P">Watch this space.</div>
</div>
</div>


<div class="div">

<h2><a name="lowlevel" id="lowlevel">4. </a>Low-level utility routines</h2>


<div class="div">

<h3><a name="ll-items" id="ll-items">4.1. </a>Working with Earley items</h3>

<div class="div">

<h4><a name="ll-items-con" id="ll-items-con">4.1.1. </a>Earley items - constructors</h4>
<div class="Real-P">
<div class="scrap"><span><a name="eri-items">&#x3008; 14 Earley items (constructors, extractors, etc.) &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: **************************************************************** 
   * Earley items
   **************************************************************** :)
(: We represent an Earley item as a map with keys 'from', 'to',
   'rule', and 'ri' (rule index).  For any item $ei, $ei('from') 
   and $ei('to') are integers, $ei('rule') is element(rule), and
   $ei('ri') is a string (an NCName, in fact, but typed only as 
   a string).
:)

(: ****************************************************************
   * Earley items:  constructors
  :)

<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-make-p-p-r-ri">Define eiMakePPRRi() 15</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-lei-advance-ei-sym-p">Define leiAdvanceEiSymP() 16</a></em> &#x3009;</span>
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e793">Extractors for Earley items 17</a>&#x3009;, &#x3008;<a href="#d3e799">Extractors for Earley items 18</a>&#x3009;, &#x3008;<a href="#d3e846">Predicates for Earley items 19</a>&#x3009;, &#x3008;<a href="#d3e851">Define fExpectsN-Ei() 20</a>&#x3009;, &#x3008;<a href="#d3e869">Define fScanrelEE() 21</a>&#x3009;, &#x3008;<a href="#d3e876">Define fAdvanceNrelEE() 22</a>&#x3009;, &#x3008;<a href="#eri-items-closure">Calculating the closure of an Earley set 23</a>&#x3009;<br></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e455">[File Earley-rec-internals.xqm] 6</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">To construct an Earley function from known values, we call
<i>eiMakePPRRi</i>:
<div class="scrap"><span><a name="eri-make-p-p-r-ri">&#x3008; 15 Define eiMakePPRRi() &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ................................................................
   ei Make P P R Ri: make an Earley item from two positions, a rule,
   and a rule index
  :)
declare function ixi:eiMakePPRRi(
  $From as xs:integer,
  $To as xs:integer,
  $r as element(rule),
  $ri as xs:string
) as map(xs:string, item()) {  
  map {
    'from' : $From,
    'to' : $To,
    'rule' : $r,
    'ri' : $ri
  }
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#eri-items">Earley items (constructors, extractors, etc.) 14</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The function <i>leiAdvanceEiSymP()</i>
takes (as its name signals) an Earley item, a symbol,
and a position, and returns the list of Earley items
which are advances from that position on that symbol.
<div class="scrap"><span><a name="eri-lei-advance-ei-sym-p">&#x3008; 16 Define leiAdvanceEiSymP() &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ................................................................
   ixi:lei Advance Ei Sym P($E, $sym, $p): return the set of Earley
   items (lei) that arise if you advance $E over $sym, or over any
   equivalent symbol, to reach position $p.
:)
declare function ixi:leiAdvanceEiSymP(
  $E as map(xs:string, item()),
  $sym as element(),
  $pNew as xs:integer
) as map(xs:string, item())* {
  let $pFr := $E('from'),
      $pTo := $E('to')
  return if ($pNew lt xs:integer($pTo))
      then () (: $E cannot advance backwards :)
      else 
  let $r := $E('rule'),
      $ri0 := $E('ri'),
      $lriFollow := if ($ri0 eq 'q0')
                    then $r/@first
                    else $r/@follow:*[local-name() = $ri0],
      $lri := tokenize($lriFollow,'\s+')[normalize-space()]
  for $ri in $lri
  where ixi:fSymbolmatchRRiSym($r,$ri,$sym)
    (: and $pNew ge xs:integer($pTo) :)
  return ixi:eiMakePPRRi($pFr, $pNew, $r, $ri) 
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#eri-items">Earley items (constructors, extractors, etc.) 14</a> &#x3009; <br></span>
</div>

</div>
</div>

<div class="div">

<h4><a name="ll-items-extr" id="ll-items-extr">4.1.2. </a>Earley items - extractors</h4>
<div class="Real-P">For the <em>to</em> and <em>from</em> pointers,
the rule, and the rule's nonterminal, the extractor
functions are very straightforward.
<div class="scrap"><span><a name="d3e793">&#x3008; 17 Extractors for Earley items [continues <a href="#eri-items">14 Earley items (constructors, extractors, etc.)</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ****************************************************************
   * Earley items:  extractors
   :)

(: See also sXei() below under Utilities :)

(: ................................................................
   pTo X Ei($E): extract 'to' position from item
   :)
declare function ixi:pToXEi(
  $E as map(xs:string, item())
) as xs:integer {
  $E('to')
};

(: ................................................................
   pFrom X Ei($E): extract 'from' position from item
   :)
declare function ixi:pFromXEi(
  $E as map(xs:string, item())
) as xs:integer {
  $E('from')
};

(: ................................................................
   r X Ei($E): extract rule from item
   :)
declare function ixi:rXEi(
  $E as map(xs:string, item())
) as element(rule) {
  $E('rule')
};

(: ................................................................
   nLhs X Ei($E): extract nonterminal on lhs of rule from item
   :)
declare function ixi:nLhsXEi(
  $E as map(xs:string, item())
) as element(nonterminal) {
  element nonterminal {
    attribute name { $E('rule')/@name }
  }
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">To get the list of expected symbols, more work is needed.
<div class="scrap"><span><a name="d3e799">&#x3008; 18 Extractors for Earley items [continues <a href="#eri-items">14 Earley items (constructors, extractors, etc.)</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
 (: ................................................................
   lsymExpected X Ei($E): extract list of expected symbols from item
   :)
declare function ixi:lsymExpectedXEi(
  $E as map(xs:string, item())
) as element()* {
  (: results will be element() or element(nonterminal). :)
  let $symCur := $E('ri'),
      $r := $E('rule'),
      $sFollowset := if ($symCur = 'q0') 
                     then $r/@first
                     else $r/@follow:*[local-name()=$symCur],
      $lsymFollow := tokenize($sFollowset,'\s+')[normalize-space(.)]
  for $sym in $lsymFollow
  let $e := $r//*[@xml:id = $sym]
  return $e
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">Q. would this be faster with the <tt>for</tt> loop replaced by
<tt>return $r/descendant::*[@xml:id =
tokenize($sFollowset,'\s+')]</tt> or <tt>return
$r/descendant::*[@xml:id = $lsymFollow]</tt>, maybe?
</div>
<div class="Real-P">A. Let's see.
<ul><li><b>Loop:</b>  1:13.6 user time (two runs, same time),
            1:09.8 / 1:10.8 real time (?)</li>
<li><b>XPath:</b>  <tt>$r/descendant::*
            [@xml:id = tokenize($sFollowset,'\s+')]</tt>:
            1:19.9, 1:21.8 user</li>
<li><b>XPath:</b>  <tt>$r/descendant::*
            [@xml:id = $lsymFollow]</tt>:
1:12.5, 1:12.4</li>
</ul>
So:  not, it would not be noticeably faster,
and might be slower.
</div>
</div>

<div class="div">

<h4><a name="ll-items-predicates" id="ll-items-predicates">4.1.3. </a>Earley items - predicates</h4>
<div class="Real-P">We use predicate functions to ask several questions
about Earley items:
<ul><li>Is it final?  Does it mark the completion of the rule?
Sometimes we specify the left-hand side of the rule,
sometimes also the position.</li>
<li>Does it expect any nonterminals?</li>
<li>Does the scan relation hold between two given Earley items?</li>
<li>Does the advance-over-symbol-S relation hold between two given
Earley items?</li>
</ul>
</div>
<div class="Real-P">There are several functions for asking whether an item is
a completion.
<div class="scrap"><span><a name="d3e846">&#x3008; 19 Predicates for Earley items [continues <a href="#eri-items">14 Earley items (constructors, extractors, etc.)</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ****************************************************************
   * Earley items:  predicates
   :)
(: ................................................................
   fFinal Ei P P N($E, $pFr, $pTo, $N): is $E a completion item
   for symbol N, running between the two positions?
   (Used just once, in recognizeX, to check for completions of
   the start symbol that cover the entire input string.)
   :)
declare function ixi:fFinalEiPPN(
  $E as map(xs:string, item()),
  $pFrom as xs:integer,
  $pTo as xs:integer,
  $sym as xs:string
) as xs:boolean {
  (xs:integer($E('from')) eq $pFrom)
  and (xs:integer($E('to')) eq $pTo)
  and ($E('rule')/@name eq $sym)
  and ($E('ri') = ixi:lriFinalstatesXR($E('rule')))
};

(: ................................................................
   ixi:fFinalEiPN($E, $pTo, $sym):  true iff $E is a completion 
   item ending at position $P for nonterminal $N 
   :)
declare function ixi:fFinalEiPN(
  $E as map(xs:string, item()),
  $pTo as xs:integer,
  $n as element(nonterminal)
) as xs:boolean {
  let $f := xs:integer($E('to')) eq $pTo
            and $E('rule')/@name eq $n/@name
            and $E('ri') = ixi:lriFinalstatesXR($E('rule'))
  (:
  let $trace := ixi:notrace($E,
        'Call to fFinalEiPN('
        || ixi:sXei($E) || ','
        || $pTo || ','
        || $n/@name || ') ==&gt; ' 
        || $f
      )
  :)    
  (:
  let $trace := if ($f) then ()
        else ixi:notrace($E,
             'fFinalEiPN returns false: &amp;#xA;'
                || ' to-values ' 
                  || (if (xs:integer($E('to')) eq $pTo)
		      then ''
		      else 'do not ' )
                  || 'match, &amp;#xA;' 
                || ' symbol names '
                  || (if ($E('rule')/@name eq $n/@name)
                      then ''
		      else 'do not ' )
                  || 'match, &amp;#xA;'
                || ' state ' || $E('ri')/string() || ' is ' 
                  || (if ($E('ri') = ixi:lriFinalstatesXR($E('rule'))) 
                        then '' else 'not ' )
                  || 'final. &amp;#xA;' 
               )
  :)    
  return $f
};

(: ................................................................
   fFinal Ei($E): is $E a completion item?  I.e. is its rule index
   in a final location?
   :)
declare function ixi:fFinalEi(
  $E as map(xs:string, item())
) as xs:boolean {
  $E('ri') = ixi:lriFinalstatesXR($E('rule'))
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P"><div class="scrap"><span><a name="d3e851">&#x3008; 20 Define fExpectsN-Ei() [continues <a href="#eri-items">14 Earley items (constructors, extractors, etc.)</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ................................................................
   fExpectsN - Ei($E):  does $E expect any nonterminals?
   :)
declare function ixi:fExpectsN-Ei(
  $E as map(xs:string, item())
) as xs:boolean {
  exists(ixi:lsymExpectedXEi($E)[ixi:fNonterminal(.)])
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">Abstractly, the scan relation scan(E1,E2) holds iff
<ul><li>E1 expects terminal T</li>
<li>and E1 wins</li>
<li>and E2 = advance(E1, T)</li>
</ul>
And E2 = advance(E1, T) iff
<ul><li>from(E1) = from(E2)</li>
<li>and rule(E1) = rule(E2)</li>
<li>and seen-so-far(E1) || T = seen-so-far(E2)</li>
<li>and E1 wins on T [redundant, why?]</li>
<li>else advance(E1, T) = empty set.</li>
</ul>
So:
<div class="scrap"><span><a name="d3e869">&#x3008; 21 Define fScanrelEE() [continues <a href="#eri-items">14 Earley items (constructors, extractors, etc.)</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ................................................................
   fScanrel E E($E1, $E2):  does the scan relation hold for E1, E2?
   (Used once, in Earley parser internals, to find related items.)
   :)
   (: N.B. does not test that the symbol in question is a terminal.
      Does it matter?
   :)   
declare function ixi:fScanrelEE(
  $E1 as map(xs:string, item()),
  $E2 as map(xs:string, item())
) as xs:boolean {
  let $fFrom := ($E1('from') eq $E2('from')),
        (: test 1 of advance() :)
      $lsymFollow := ixi:lsymExpectedXEi($E1), 
      $lSsymFollow := for $e in $lsymFollow return $e/@xml:id,
      $fStates1 := ($E2('ri') = $lSsymFollow),
        (: test 3, 4 of advance(), 1,2 of scan() :)
      $fRules := deep-equal($E1('rule'), $E2('rule')),
	(: test 2 of advance() :)
      $f := ($fFrom and $fStates1 and $fRules), 
      $trace := ($f,
                'fScanrelEE(' 
                || ixi:sXei($E1) || ',' 
                || ixi:sXei($E2) || ') ==&gt; '
                )
  return $f
      (: 
               .('from') = $Ecur('from')
               and .('to') = $pMedial
               and .('ri') = $lsPrevstates
               and deep-equal(./rule, $Ecur/rule)
      :)
};

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">
<div class="scrap"><span><a name="d3e876">&#x3008; 22 Define fAdvanceNrelEE() [continues <a href="#eri-items">14 Earley items (constructors, extractors, etc.)</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ................................................................
   fAdvanceNrel E E ($E1, $E2):  does the advance-over-symbol-N
   relation hold for E1, E2?
   (Used once, in Earley parser internals, to find related items.)

   By definition (see paper) E2 = advance(E1, T) iff
      * from(E1) = from(E2)
      * and rule(E1) = rule(E2)
      * and seen-so-far(E1) || T = seen-so-far(E2)
      * and E1 wins on T
      * else advance(E1, T) = empty set.

   Note that for the "E1 wins" clause we rely on the truth of
   all items in the closure.  E1 must be winning, because otherwise
   an E2 that satisfies the other tests would not be in the closure.
   :)
declare function ixi:fAdvanceNrelEE(
  $E1 as map(xs:string, item()),
  $E2 as map(xs:string, item())
) as xs:boolean {
  let $fFrom := ($E1('from') eq $E2('from')),
      $lsymFollow := ixi:lsymExpectedXEi($E1),
      $lSsymFollow := for $e in $lsymFollow return $e/@xml:id,
      $fStates1 := ($E2('ri') = $lSsymFollow),
      $fRules := deep-equal($E1('rule'), $E2('rule')),
      $f := ($fFrom and $fStates1 and $fRules),
      $trace := ($f,
                'fScanrelEE(' 
                || ixi:sXei($E1) || ',' 
                || ixi:sXei($E2) || ') ==&gt; '
                )
  return $f
      (: 
               .('from') = $Ecur('from')
               and .('to') = $eiCC('from')
               and .('ri') = $lsPrevstates 
               and deep-equal(./rule, $Ecur/rule)
      :)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

</div>
</div>

<div class="div">

<h4><a name="ll-items-closure" id="ll-items-closure">4.1.4. </a>Earley set closure</h4>
<div class="Real-P">The heart of the Earley algorithm is the calculating the
closure of the Earley set.
<div class="scrap"><span><a name="eri-items-closure">&#x3008; 23 Calculating the closure of an Earley set [continues <a href="#eri-items">14 Earley items (constructors, extractors, etc.)</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ****************************************************************
   * Earley items:  closure (the big kahuna)
   :)
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e895">Define earley-closure($lei, $I, $G) 24</a>&#x3009;, &#x3008;<a href="#d3e910">Define earley-closure($pending, $accumulator, $I, $G) 25</a>&#x3009;, &#x3008;<a href="#d3e918">Define earley-closure($pending, $accumulator, $I, $G) 26</a>&#x3009;<br></span>

<span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">We will want an accumulator to hold the set, so the
user's call to <i>earley-closure</i> merely
initializes an accumulator and calls another function to
do the work.
<div class="scrap"><span><a name="d3e895">&#x3008; 24 Define earley-closure($lei, $I, $G) [continues <a href="#eri-items-closure">23 Calculating the closure of an Earley set</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
 (: ................................................................
   ixi:earley-closure($lei, $I, $G2): 
   Calculate closure of $lei over the relations scan(), pred(),
   and comp().
:)
declare function ixi:earley-closure(
  $leiPending as map(xs:string, item())* (: ITEM* :), 
  $I as xs:string,
  $G as element(ixml)
) as map(xs:string,
         map(xs:integer,
             map(xs:string,
                 item())*)) (:MEI:) {
  let $meiAcc := map { 'from' : map:merge(
                         for $ei in $leiPending
			 return map:entry($ei('from'), $ei),
                         $ixi:combinedups
                       ),
                       'to' : map:merge(
                         for $ei in $leiPending
			 return map:entry($ei('to'), $ei),
                         $ixi:combinedups
		       ) }
		       
  return ixi:earley-closure($leiPending, $meiAcc, $I, $G)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">The larger function is this one.</div>
<div class="Real-P">We calculate the closure of the set of Earley items in $accumulator
over the relations scan(), pred(), and comp().
</div>
<div class="Real-P">Every item in $pending is also in $accumulator.  The items in
$pending have not yet been examined; the other items in $accumulator
have been dealt with and need not be dealt with again.
</div>
<div class="Real-P">N.B. To keep the control flow simple, this function does not
attempt to handle all of the items at position $p before moving to $p
+ 1, and it does not assume that all predictions of a nonterminal $n
beginning at position $p are present when a completion for $n at $p is
found.
</div>
<div class="Real-P">One immediate consequence of this is that every item making a
prediction must also check for completions of its predicted
non-terminals, which increases the number of times we must scan
through the accumulator and offers a low-hanging target for improving
speed.
<div class="scrap"><span><a name="d3e910">&#x3008; 25 Define earley-closure($pending, $accumulator, $I, $G) [continues <a href="#eri-items-closure">23 Calculating the closure of an Earley set</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">

(: ................................................................
   ixi:earley-closure($pending, $accumulator, $I, $G2):
:)
declare function ixi:earley-closure(
  $leiPending as map(xs:string, item())* (: pending items :),
  $meiAccum as map(xs:string, map(xs:integer, map(xs:string, item())*))
            (: accumulator of type MEI :),
  $I as xs:string,
  $G as element(ixml)
) as map(xs:string, map(xs:integer, map(xs:string, item())*)) (:MEI:) {
  (: if pending list is done, so are we; return the accumulator :)
  if (empty($leiPending))
  then $meiAccum
  else 
  (: normal case:  we have items to process :)
  (: Take head of pending list, run PCS function on it, dedup it, 
     remove items already in the accumulator, and recur,
     adding new items to the accumulator :)
  let $E := head($leiPending), 
      $dummy := ixi:notrace(count($leiPending), 'e-c() has pending items: '), 
      $dummy := ixi:notrace(
                    ixi:sXei($E),
                    'ixi:earley-closure running on pending item: '), 
      (: get everything from leiPCSrel :)
      $leiCs0 := ixi:leiPCSrel($E,$meiAccum,$I,$G),
      $dummy := ixi:notrace(count($leiCs0), 'e-c() initial closure has items: '), 
      (: dedup results from leiPCSrel :) 
      $leiCs := $leiCs0[
                   not(some $i in 1 to (position() - 1)
                       satisfies deep-equal(., $leiCs0[$i])
                   )],
      $dummy := ixi:notrace(count($leiCs), 'e-c() deduped closure has items: '), 
        	
      (: remove non-new results from leiPCSrel :)
      $leiNew := for $ei in $leiCs
	         let $from := $ei('from')
		 where not(some $e in $meiAccum('from')($from)
		           satisfies deep-equal($e, $ei))
		 return $ei,
      $dummy := ixi:notrace(count($leiNew), 'e-c() New items: '), 

		 
      $meiNewaccum := map {
	'from' : map:merge(
	  ( $meiAccum('from'),
	  for $ei in $leiNew return map:entry($ei('from'), $ei) ),
	  $ixi:combinedups),
        'to' : map:merge(
	  ( $meiAccum('to'),
	  for $ei in $leiNew return map:entry($ei('to'), $ei) ),
	  $ixi:combinedups) }
      
  return ixi:earley-closure(
    (tail($leiPending), $leiNew),
    $meiNewaccum,
    $I,
    $G)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">The function <i>leiPCSrel()</i> takes an Earley
item (and an accumulator, the input, and the grammar) and
returns all the items that stand in the scan, pred, or
comp relations to the given item.
<div class="scrap"><span><a name="d3e918">&#x3008; 26 Define earley-closure($pending, $accumulator, $I, $G) [continues <a href="#eri-items-closure">23 Calculating the closure of an Earley set</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">

(: ................................................................
   leiPCSrel($E, $leiA, $I, $G): return all items $E2 such 
   that $E2 = scan($E, $I)
   or $E2 = pred($E, $G)
   or comp($E1, $E3) for some $E3 in $leiA
   or comp($E3, $E1) for some $E3 in $leiA
:)
declare function ixi:leiPCSrel(
  $E as map(xs:string, item()),
  $meiAccum as map(xs:string, item())*,
  $I as xs:string,
  $G as element(ixml)
) as map(xs:string, item())* {
  (: If $E expects terminals, perform scan :)
  ix:scan($E,$I),
  
  (: If $E expects nonterminals, perform prediction :)
  ix:pred($E,$G), 
  
  (: If $E expects a nonterminal, look for a completion $Ec and 
     perform comp($Ec,$E) :)
  if (ixi:fExpectsN-Ei($E))
  then for $Ec in $meiAccum('from')($E('to'))
       where ixi:fFinalEi($Ec)
       return ix:comp($Ec,$E)
  else (), 
    
  (: If $E is a completion, look for a prediction $Ep and 
     perform comp($E,$Ep) :)
  if (ixi:fFinalEi($E)) 
  then for $Ep in $meiAccum('to')($E('from'))
       where ixi:fExpectsN-Ei($Ep)
       return ix:comp($E,$Ep)
  else ()
    
  (: N.B. In BNF, $E can only expect one symbol, so either scan
     or pred applies, but not both.  But we are expecting EBNF
     and $E can predict several things at the same time as being
     a completion. :)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

</div>
</div>
</div>


<div class="div">

<h3><a name="ll-grammars" id="ll-grammars">4.2. </a>Working with grammars</h3>

<div class="Real-P">
<div class="scrap"><span><a name="eri-grammars">&#x3008; 27 Grammars (constructors, extractors, etc.) &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: **************************************************************** 
   * Grammars
   **************************************************************** :)
(: A grammar is an ixml element with no namespace. :)

<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-grammars-constructors">Functions that construct or return grammars 28</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-grammars-extractors">Functions that extract information from grammars 31</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-grammars-predicates">Functions that check grammar properties 32</a></em> &#x3009;</span>
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e455">[File Earley-rec-internals.xqm] 6</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">We have just one routine that constructs grammars; it takes an
existing grammar and gives it a new start-symbol with a single rule.
This allows us to know without any further analysis that the start
symbol of the augmented grammar is non-recursive and has just one
rule. [<i>To do:</i> write a version of this that accepts a
start-symbol as a parameter.]</div>
<div class="Real-P">This is the same in v0.1 and v0.2 except that we use a different
element name to wrap the right-hand side of the rule.
<div class="scrap"><span><a name="eri-grammars-constructors">&#x3008; 28 Functions that construct or return grammars &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
 (: ****************************************************************
   * Grammars: constructors
   :)
   
(: ................................................................
   augment-grammar($G):  given grammar, augment it as Earley
   prescribes.
   :)
declare function ixi:augment-grammar(
  $G as element(ixml)
) as element(ixml) {
  let $symStart := ixi:symStartG($G),
      $symGoal := ixi:makeGoalsymbolG($G),
      $fNullable := ixi:fNullableNG($symStart, $G)
  return element ixml {
    element rule {
      attribute name {$symGoal}, 
      attribute xml:id {$symGoal || '_rule'},
      attribute nullable { false() },
      attribute first {$symStart || '_0'},
      attribute last {$symStart || '_0'},
      attribute { xs:QName('follow:'||$symStart||'_0') } {()},        
      element <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-alts-gi">GI for alts element 123</a></em> &#x3009;</span> {
        attribute xml:id {$symGoal || '_def_0'},
        attribute nullable { false() },
        attribute first {$symStart || '_0'},
        attribute last {$symStart || '_0'},
        attribute { xs:QName('follow:'||$symStart||'_0') } {()},        
        element alt {
          attribute xml:id {$symGoal || '_alt_0'},
          attribute nullable { false() },
          attribute first {$symStart || '_0'},
          attribute last {$symStart || '_0'},
          element nonterminal {
            attribute name { $symStart },
            attribute xml:id {$symStart || '_0'},
            attribute nullable { false() },
            attribute first {$symStart || '_0'},
            attribute last {$symStart || '_0'}
          } (: end nonterminal :)
        } (: end alt :)
      } (: end def :)
    }, (: end rule :)
    $G/rule
  } (: end ixml :)
};
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e955">Goal-symbol construction 29</a>&#x3009;, &#x3008;<a href="#d3e962">Goal-symbol construction 30</a>&#x3009;<br></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#eri-grammars">Grammars (constructors, extractors, etc.) 27</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">We have a small utility function for making a new
goal symbol that differs from all existing symbols.
<div class="scrap"><span><a name="d3e955">&#x3008; 29 Goal-symbol construction [continues <a href="#eri-grammars-constructors">28 Functions that construct or return grammars</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
 (: ................................................................
   makeGoalsymbolG($G):  make a new goal symbol for grammar G,
   ensuring that it's not the same as any existing symbol.
   :)
declare function ixi:makeGoalsymbolG(
  $G as element(ixml)
) as xs:string {
  let $ln := distinct-values($G/rule/@name),
      $n := ('Goal', '_Goal_', '_G_o_a_l_', '_G-o-a-l_')
            [not(. = $ln)][1]
  return if (exists($n)) 
    then $n 
    else ixi:mungesymbol(ixi:symStartG($G), $ln)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">And another utility for munging a given symbol.
<div class="scrap"><span><a name="d3e962">&#x3008; 30 Goal-symbol construction [continues <a href="#eri-grammars-constructors">28 Functions that construct or return grammars</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ................................................................
   mungesymbol:  given a symbol, munge it (by adding _ fore and aft)
   until it is no longer in the list of symbols $ln (which is the
   symbols already in the grammar).
   :)
declare function ixi:mungesymbol(
  $n as xs:string,
  $ln as xs:string*
) as xs:string {
  if ($n = $ln)
    then ixi:mungesymbol('_' || $n || '_', $ln)
    else $n
};

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">
<div class="scrap"><span><a name="eri-grammars-extractors">&#x3008; 31 Functions that extract information from grammars &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ****************************************************************
   * Grammars: extractors
   :)
   
(: ................................................................
   symStart G():  return start symbol(s) of G
   :)
declare function ixi:symStartG(
  $G as element(ixml)
) as xs:string+ {
  $G/rule[1]/@name/normalize-space()
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#eri-grammars">Grammars (constructors, extractors, etc.) 27</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">
<div class="scrap"><span><a name="eri-grammars-predicates">&#x3008; 32 Functions that check grammar properties &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ****************************************************************
   * Grammars:  predicates
   *
   * Note that predicates relating to symbols in context are
   * here, not under symbol.  (Test:  is $G a parameter?)
   :)
(: ixi:fNullableNG($n, $G):  is nonterminal n nullable in G? 

   For non-terminal N, fNullableNG(N,G) means an N element
   in the result tree may be empty.

   Here 'nullable' means it has a right-hand side whose
   regex matches the empty string, which means in turn
   that the parse tree may be empty, and non-terminal N
   may appear as an N element in the result.
   
   N.B. this is not the same as fGES.
  
:)
declare function  ixi:fNullableNG(
  $n as xs:string, (: element(nonterminal), :)
  $G as element(ixml)
) as xs:boolean {
  exists($G/rule[@name = $n][@nullable = ('true', '1')])
};


(: ixi:fGesNG($n, $G):  does nonterminal n generate the empty string 
   in G? 
   
   N.B. this is not the same as fNullable.
   
   Discussions of parsing often use 'nullable' for nonterminals
   that generate the empty string, but in the grammar 
     S: X. X: .
   X is nullable and GES, S is GES but not nullable.
   
   For non-terminal N, fGesNG(N,G) means an N element
   in the result tree may have string(N) = ''.
   
:)
(: this is a transitive closure algorithm and will 
   require more work (including an accumulator to 
   avoid looping).
   
   For now, suppress it and do without it.
:)
(:
declare function  ixi:fGesNG(
  $n as element(), 
  $G as element(ixml)
) as xs:boolean {
  ($n/self::nonterminal 
     and ixi:fNullable($n, $G)
         or 
         (some $d 
          in $G/rule[@name=$n]/alt
          satisfies ixi:fGesNG($d,$G)))
  or ($n/self::def
     and ($n/@nullable = ('true','1'))
  or 
  ()
 
};
:)

(: ixi:lrulesXNG($n,$G) :)
declare function ixi:lrulesXNG(
  $n as element(nonterminal),
  $G as element(ixml)
) as element(rule)* {
  $G/rule[@name = $n/@name]
};


(: ****************************************************************
   * Grammars: predicates
   :)

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#eri-grammars">Grammars (constructors, extractors, etc.) 27</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<h3><a name="ll-rules" id="ll-rules">4.3. </a>Working with rules</h3>

<div class="Real-P">
<div class="scrap"><span><a name="eri-rules">&#x3008; 33 Rules (constructors, extractors, etc.) &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: **************************************************************** 
   * Rules and rule indexes
   **************************************************************** :)
(: A rule is a rule element as defined in the ixml DTD, but 
   augmented with glushkov attributes.
   
   Note that functions relating to rules in context are not 
   here but under Grammars above.  (Test: is $G a parameter?)
   Functions here relate solely to the rule in isolation.
   That may be why there are so few of them.
:)

(: ****************************************************************
   * Rules and rule indexes: constructors
   :)
   
(: ****************************************************************
   * Rules and rule indexes: extractors
   :)

(: ixi:lriFinalstatesXR($r) :)
declare function ixi:lriFinalstatesXR(
  $r as element(rule)
) as xs:string* {
  (
    if ($r/@nullable = ('true', '1'))
    then 'q0' else (),
    tokenize($r/@last,'\s+')[normalize-space()]
  )

};

(: ixi:lriStartstatesXR($Rule):  return list of start-position
   identifiers.
 :)
declare function ixi:lriStartstatesXR(
  $r as element(rule)
) as xs:string* {
  'q0'
  (: NOT 
  tokenize($r/@first,'\s+')[normalize-space()]
  :)
};

(: duplicate, apparently :)
(:
declare function ixi:initial-stateR(
  $Rule as element(rule)
) as xs:string* {
  'q0'
  (: NOT
  tokenize($Rule/@first,'\s+')[. ne '']
  Those are the follow states of q0.  Whoops.
  :)
};
:)

(: ****************************************************************
   * Rules and rule indexes: predicates
   :)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e455">[File Earley-rec-internals.xqm] 6</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<h3><a name="ll-symbols" id="ll-symbols">4.4. </a>Working with symbols</h3>

<div class="Real-P">A symbol is (represented by) an element: one of nonterminal,
literal, inclusion, exclusion.
</div>
<div class="Real-P">(Any references to elements named 'terminal' is a relic from the
2016 grammar of ixml and now constitutes an error.)
</div>
<div class="Real-P">Note that functions relating to symbols in context are not here but
under Grammars above.  (Test: is $G a parameter?)  Functions here
relate solely to the symbol in isolation.  That may be why there
are so few of them.</div>
<div class="Real-P">Similarly any function that involves the input string is not here
but under Input, below.
<div class="scrap"><span><a name="eri-symbols">&#x3008; 34 Symbols (constructors, extractors, etc.) &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: **************************************************************** 
   * Symbols
   **************************************************************** :)

(: ****************************************************************
   * Symbols: constructors
   :)
   
(: ****************************************************************
   * Symbols: extractors
   :)
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-sym-match-length">Define match-length() 35</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-sym-reXTerminal">Define reXTerminal(), regex from terminal 36</a></em> &#x3009;</span>
 
(: ****************************************************************
   * Symbols: predicates
   :)
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-sym-fTerminal">Define fTerminal() 37</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-sym-fNonterminal">Define fNonterminal() 38</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-sym-fSymbolmatchRRiSym">Define fSymbolmatchRRiSym() 39</a></em> &#x3009;</span>
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e455">[File Earley-rec-internals.xqm] 6</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">In tree-builder, we want match-length info just from terminal; we
don't have access to $I.  If terminals ever become variable-length,
this will break.</div>
<div class="Real-P">See also match-length#3 below under Input.
<div class="scrap"><span><a name="eri-sym-match-length">&#x3008; 35 Define match-length() &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ................................................................
   match-length($t):  return length of any string that matches the
   specified terminal.  
   :)
declare function ixi:match-length(
  $t as element()
) as xs:integer {
  if ($t/self::literal) then ixi:string-length($t)
  else 1
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#eri-symbols">Symbols (constructors, extractors, etc.) 34</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The function <i>reXTerminal($t)</i> returns a regular
expression, given a terminal element.  Note that the regular
expression will match one character (or none) in the input; we don't
have terminal symbols with indeterminate length in the input.
</div>
<div class="Real-P">At the moment, this is only ever called with
character sets (&lt;<em>inclusion</em>&gt; and &lt;<em>exclusion</em>&gt;,
but I've added code to handle literals as well, just in case.
</div>
<div class="Real-P">To do:  make the code that compiles Gluschkov automata
also calculate regexes for terminals, so that we're not
doing it again and again.
<div class="scrap"><span><a name="eri-sym-reXTerminal">&#x3008; 36 Define reXTerminal(), regex from terminal &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ................................................................
   re X Terminal($t): return a regular expression, given a
   character-set terminal element.
   :)
declare function ixi:reXTerminal(
  $t as element() (: incl, excl, literal :)
) as xs:string {
  (: given a terminal element, produce a regex :)
  if ($t/self::literal) then
    ixi:sceXS( ixi:string-value($t) )
  else 
  let $le := $t/*,
      $lsRegexbits := for $e in $le
                      return if ($e/self::range)
                        then ixi:sceXS($e/@from)
		             || "-" || ixi:sceXS($e/@to)
                        else if ($e/self::literal) 
                        then ixi:sceXS($e/ixi:string-value($e)) 
                        else if ($e/self::class)
                        then ixi:catescXS($e/@code) 
                        else () (: error :)
  return if ($t/self::inclusion)
    then "[" || string-join($lsRegexbits,'') || "]"
    else if ($t/self::exclusion)
    then "[^" || string-join($lsRegexbits,'') || "]"
    else "--error in reXTerminal--"
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#eri-symbols">Symbols (constructors, extractors, etc.) 34</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The function <i>fTerminal()</i> returns true iff the
argument is a terminal symbol.  This version supports both my
interpretation of the 2016 syntax (with element type 'terminal') and
the 2019 syntax (literal, inclusion, exclusion).
<div class="scrap"><span><a name="eri-sym-fTerminal">&#x3008; 37 Define fTerminal() &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ................................................................
   f Terminal($sym):  is $sym a terminal symbol?
   :)
declare function ixi:fTerminal(
  $sym as item()
) as xs:boolean {
  exists($sym/self::element()[self::terminal
    or self::literal
    or self::inclusion
    or self::exclusion
  ])
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#eri-symbols">Symbols (constructors, extractors, etc.) 34</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The function <i>fNonterminal()</i> performs
a similar function for nonterminals.
<div class="scrap"><span><a name="eri-sym-fNonterminal">&#x3008; 38 Define fNonterminal() &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ................................................................
   f Nonterminal($sym):  is $sym a nonterminal symbol?
   :)
declare function ixi:fNonterminal(
  $sym as item()
) as xs:boolean {
  exists($sym/self::element()/self::nonterminal)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#eri-symbols">Symbols (constructors, extractors, etc.) 34</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The function <i>fSymbolmatchRRiSym($r, $ri, $sym)</i>
determines whether a symbol element $sym matches rule index $ri in
rule $r.  Equivalently: in the FSA for rule $r, does state $ri mean
"we have just read (a string generated by) $sym"?</div>
<div class="Real-P">N.B. $sym is an element, not a name or string, so simple comparison 
is not enough here; we need a bit more.
</div>
<div class="Real-P">Called once, from ixi:leiAdvanceEiSymP(), called in turn thrice
from Earley-recognizer:
<ul><li>in ix:scan() with terminal from rule (so 'terminal' element),</li>
<li>in ix:pred() with nullable nonterminal from rule,</li>
<li>in ix:comp() with constructed nonterminal element created
for the call.</li>
</ul>
So for nonterminals, we need to compare the @name attributes.
</div>
<div class="Real-P">For terminals, the likelihood is that $sym is the element we just
tested the input against, so we will use deep equality as a test.
</div>
<div class="Real-P">Note that this means that in a rule like 
<pre style="margin-left: 2em; background-color: #CCD; margin-right: 3em;">a: 'b', 'c'; 'b', 'd'.</pre>
we will not be advancing both paths on a 'b'.  The caller will
(or: must) call this once for each prediction, so with two different
'terminal' elements.  Since we may be dealing with a copy of the
terminal element, not the original, we must avoid reliance on
element identity.
</div>
<div class="Real-P">Note that this will not be called with a state of 'q0'; it's always
called with a state name corresponding to a symbol.  (We are,
as it were, always checking from the end of the arc, not the start.)</div>
<div class="Real-P">
To do: adjust to 2019 syntax, which no longer has a single 'terminal' 
element type but has 'quoted', 'inclusion', and 'exclusion'.
<div class="scrap"><span><a name="eri-sym-fSymbolmatchRRiSym">&#x3008; 39 Define fSymbolmatchRRiSym() &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ................................................................
   fSymbolmatch R Ri Sym($r, $ri, $sym): does symbol element $sym 
   match rule index $ri in rule $r?  
   
   :)
declare function ixi:fSymbolmatchRRiSym(
  $r as element(rule),
  $ri as xs:string,
  $sym as element() (: nonterminal or terminal :)
) as xs:boolean {  
  if ($sym/@xml:id = $ri)
  then true()
  else let $state := $r/descendant::*[@xml:id = $ri]
       return if (local-name($sym) ne local-name($state))
           (: we have a terminal trying to match a nonterminal,
              or vice versa, or different kinds of terminal;
              return false :)
         then false()
         
         else if (ixi:fTerminal($sym))
           (: we have terminals; they match if their children 
              are deep-equal.  NB we are relying on the fact
              that we have just extracted the terminal element
              from the rule we are working on, so it really
              ought to be deep-equal to itself.
              :)
         then deep-equal($state, $sym)
         (: was: 
         then deep-equal($state/*, $sym/*) 
         but when the terminal element is empty, that doesn't work.
         :)
         
         else if (ixi:fNonterminal($sym))
           (: we have non-terminals, they match on name :)
         then ($sym/@name eq $state/@name) 
         
         else (: something wrong :) false()
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#eri-symbols">Symbols (constructors, extractors, etc.) 34</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<h3><a name="ll-input" id="ll-input">4.5. </a>Dealing with the input</h3>

<div class="Real-P">
<div class="scrap"><span><a name="eri-input">&#x3008; 40 Input (constructors, extractors, etc.) &#x3009; &#x2261;</a></span>
<pre class="scrapbody">

(: **************************************************************** 
   * Input
   **************************************************************** :)
(: For now, the input is always a string. :)

(: ****************************************************************
   * Input: constructors
   :)

(: ****************************************************************
   * Input: extractors
   :)
(: ................................................................
   inputlength(): how long is the input?
   
   Used (once) for construction of an Earley item signaling
   completion
   :)
declare function ixi:inputlength(
  $I as xs:string
) as xs:integer {
  string-length($I)
};

(: ****************************************************************
   * Input: predicates
   :)

(: ................................................................
   fMatches I P T($I, $P, $T): does input $I match terminal $T
   at position $P?

   The terminals are elements in a rule's right-hand side (not
   strings).  Possible forms:
   In 2016 syntax:  terminal[quoted/@dstring], terminal[quoted/@sstring],
   terminal[quoted/text()], charset, exclude.
   In 2019 syntax:  literal[@dstring], literal[@sstring],
   literal[@hex], inclusion, exclusion.
   
   Note that position is 0-based, not 1-based, so we add 1 to it
   for XQuery substring calls.
   :)
declare function ixi:fMatchesIPT( 
  $I as xs:string, 
  $p as xs:integer,
  $t as element()
) as xs:boolean {
  if ($t/self::literal) then
     if (1 eq 0) then (: tracing code :)
     let $sProbe := ixi:string-value($t),
         $cPrLen := string-length($sProbe),
         $sInseg := substring($I,$p+1,$cPrLen),
         $fYesno := ($sProbe eq $sInseg)
     return $fYesno
     else (: normal code :)
     let $sProbe := ixi:string-value($t),
         $cPrLen := string-length($sProbe),
         $sInseg := substring($I,$p+1,$cPrLen),
         $fYesno := ($sProbe eq $sInseg)
     return $fYesno
  else if ($t/self::inclusion or $t/self::exclusion) then
     let $sProbe := ixi:notrace(ixi:reXTerminal($t), 
                              'regex for char set:'), 
         $sInseg := ixi:notrace(substring($I,$p+1,1), 
                              'substring (1 char):'),
         $fYesno := ixi:notrace(matches($sInseg,'^'||$sProbe||'$'),
	                      'matches?')
     return $fYesno
  else (: error :) false()
  (: :)
  (: 
  $cMatchlength := if ($t/self::literal)
  let $s := substring($I,$p + 1), (: Earley is 0-based, XPath 1-based :)
      $f := if ($t/self::literal) 
            then starts-with($s,ixi:string-value($t/quoted))
            else if ($t/self::inclusion or $t/self::exclusion)
            then let $re := ixi:reXTerminal($t)
                 return matches($s,$re)
            else (: error :) false(),
       $trace := ixi:notrace($f,
       concat(
         '&amp;#xA;### fMatchesIPT: &amp;#xA;',
         '  Input = ', $I, '&amp;#xA;',
         '  p =', $p, '&amp;#xA;',
         '  quoted = ', if ($t/self::literal) 
                      then ixi:string-value($t) 
                      else '(SEE RE)', '&amp;#xA;',
         '  re = ', if ($t/self::inclusion or $t/self::exclusion)
           then ixi:reXTermin
al($t)
           else '(SEE LITERAL)',
         '&amp;#xA;Result: '
       )
       )
  return $f
  :)
};

(: ................................................................
   match-length($I,$p,$t): return length of the match in input $I at
   position $p of terminal $t.

   In practice, this is called only when we know there is a match,
   but because of the name, and the theoretical possibility of 
   input-dependent answers (if we were to allow repetition operators
   inside terminals), we also support cases where there is no match
   and the answer is 0.

   If we later allow repetition operators inside terminals, this will
   become more complex, but for now, the value is always 1 if there is
   a match at all for charset and exclude non-terminals, and
   string-length of the literal for quoted strings.

   To do: adjust for 2019 syntax.
 :)
declare function ixi:match-length(
  $I as xs:string,
  $p as xs:integer,
  $t as element()
) as xs:integer {
  if (not(ixi:fMatchesIPT($I, $p, $t))) then 0
  else if ($t/self::literal) then ixi:string-length($t)
  else 1
};

(: See also match-length#1 above under Symbols. :)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e455">[File Earley-rec-internals.xqm] 6</a> &#x3009; <br></span>
</div>

</div></div>


<div class="div">

<h3><a name="ll-utils" id="ll-utils">4.6. </a>Utilities and miscellaneous</h3>

<div class="Real-P">
<div class="scrap"><span><a name="eri-utils-and-misc">&#x3008; 41 Utilities for recognizer internals module &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: **************************************************************** 
   * Utilities
   **************************************************************** :)
(: Things with no other obvious home. :)

(: ****************************************************************
   * Utilities: string to regex conversion, string-length, 
   * string-value, ...
   :)
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e1119">Define sceXS() to read range ends 42</a>&#x3009;, &#x3008;<a href="#d3e1125">Define catescXS() to build category escape 43</a>&#x3009;, &#x3008;<a href="#d3e1131">Define charXhex() to get character given hex expression 44</a>&#x3009;, &#x3008;<a href="#d3e1137">Define string-length() 45</a>&#x3009;, &#x3008;<a href="#d3e1144">Define string-value() 46</a>&#x3009;, &#x3008;<a href="#d3e1157">Define s X ei() to build string form of Earley item 47</a>&#x3009;, &#x3008;<a href="#d3e1163">Define eXei() to build 'item' element for Earley item 48</a>&#x3009;, &#x3008;<a href="#d3e1169">Define trace() function for debugging 49</a>&#x3009;<br></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e455">[File Earley-rec-internals.xqm] 6</a> &#x3009; <br></span>
</div>

</div>

<div class="div">

<h4><a name="ll-utils-strings" id="ll-utils-strings">4.6.1. </a>Routines for strings and characters</h4>
<div class="Real-P">
<div class="scrap"><span><a name="d3e1119">&#x3008; 42 Define sceXS() to read range ends [continues <a href="#eri-utils-and-misc">41 Utilities for recognizer internals module</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ................................................................
   sce X S($s) : given a one-character string or hex expression $s 
   (e.g. from a character terminal), check to see if it's a hex
   expression (in which case expand and recur) or a magic character 
   (in which case escape it) or is best represented for purposes of 
   regex mapping) with a single-character escape (in which case
   escape it).
   
   N.B. this is more than strictly necessary for character class
   escapes, but it seems better to be more general.

   To do:  adjust to new representation of terminals.
:)
declare function ixi:sceXS(
  $s as xs:string
) as xs:string {
  (: reEscapists:  regex matching characters 
     which must or may be escaped. :)  
  if (matches($s,'^#[0-9a-fA-F]+$'))
  then ixi:sceXS(ixi:charXhex(
    $s
    (: ixi:notrace($s,'sceXS calling charXhex on ' || $s)) :)
  ))
  else if (string-length($s) gt 1)
  then ixi:escapedstringXS($s) 
  else if (not(contains("&amp;#xA;&amp;#xD;&amp;#x9;\|.-^?$*+{}()[]",$s))) 
  then $s
  else if (contains("\|.-^?$*+{}()[]",$s)) 
  then concat("\" (:":), $s)   (: commented dq to help de-confuse emacs :) 
  else if ($s eq '&amp;#xA;')
  then "\n"
  else if ($s eq '&amp;#xD;')
  then "\r"
  else if ($s eq '&amp;#x9;')
  then "\t"
  else $s

};

declare function ixi:escapedstringXS(
  $s as xs:string
) as xs:string {
  let $reEscapists := concat('[',
                      '&amp;#xA;&amp;#xD;&amp;#x9;', 
                      '\\\|\.\-\^\?\$\*\+',
		      '\{\}\(\)\[\]',
                      ']') 
  return if (matches($s, $reEscapists))
  then string-join(
    for $i in 1 to string-length($s)
    return ixi:sceXS(substring($s, $i, 1)),
    '')
  else $s
};

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">
<div class="scrap"><span><a name="d3e1125">&#x3008; 43 Define catescXS() to build category escape [continues <a href="#eri-utils-and-misc">41 Utilities for recognizer internals module</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ................................................................
   catesc X S($s): given a two-character string from a class element,
   return the appropriate category escape in XSD/XPath notation.

   I should do some sanity checking here, but at the moment I'm
   impatient, so I just wrap it in braces with \p in front.

   The 2019 spec says "it is an error if there is no such class", so
   probably I should raise an error if the category given does not 
   match the list.  But for now, I'll just ignore it and return '.' 
   to match one character, on the theory of "carry on irregardless."   

   To do:  adjust as needed for 2019 syntax.
   To do:  figure out how Aparecium should handle errors.
:)
declare function ixi:catescXS(
  $s as xs:string
) as xs:string {
  if (matches($s,'^(L[ulmo]'
     || '|M[nce]'
     || '|N[dlo]'
     || '|P[cdseifo]'
     || '|Z[slp]'
     || '|S[mcko]'
     || '|C[cfon])$'))
  then '\p{' || $s || '}'
  else '.'
  (: Letters: u[pper] l[ower] t[itlecase] m[odifier] o[other]
     Marks: n[onspacing], [spacing ]c[ombining], e[nclosing]
     Numbers: d[ecimal digit] l[etter] o[ther]
     Punctuation: c[onnector] d[ash] s [= open]
         e [= close] i[nitial quote] f[inal quote] o[ther]
     Z separators: s[pace] l[ine] p[aragraph]
     Symbols: m[ath] c[urrency] k[=modifier] o[ther]
     C other: c[ontrol] f[ormat] o[=private  use] n[ot assigned]
  :)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">
<div class="scrap"><span><a name="d3e1131">&#x3008; 44 Define charXhex() to get character given hex expression [continues <a href="#eri-utils-and-misc">41 Utilities for recognizer internals module</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ................................................................
   char X hex ($s):  accept a hex expression, return the character.
:)
declare function ixi:charXhex(
  $s0 as xs:string
) as xs:string {
  (: let $tracing := ixi:notrace($s0,
     'charXhex called with |' || $s0 || '|') :)
  let $s := if (starts-with($s0,'#'))
            then substring($s0,2)
            else $s0
  return if (not(matches($s, '^[0-9a-fA-F]+$')))
         then '---error in charXhex---'
         else codepoints-to-string(d2x:x2d($s))
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">
<div class="scrap"><span><a name="d3e1137">&#x3008; 45 Define string-length() [continues <a href="#eri-utils-and-misc">41 Utilities for recognizer internals module</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ................................................................
   string-length:  calculate 'real' length of string.

   We use this to hide possible variation in the form of 'quoted' 
   strings.  (Q. Does that mean we are expecting quote doubling
   to show up in the XML form of the literal?  It shouldn't.)

   To do:  sanity check this, and delete if unnecessary.
   :)
declare function ixi:string-length(
  $q as element(literal)
) as xs:integer {
  string-length(ixi:string-value($q))
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">
<div class="scrap"><span><a name="d3e1144">&#x3008; 46 Define string-value() [continues <a href="#eri-utils-and-misc">41 Utilities for recognizer internals module</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ................................................................
   string-value:  calculate 'real' value of string.

   We use this to hide possible variation in the form of quoted 
   strings.  (Q. Does that mean we are expecting quote doubling
   to show up in the XML form of the literal?  It shouldn't.)

   To do:  handle 2019 syntax of literals.

   To do:  sanity check this, and delete if unnecessary.
   :)
declare function ixi:string-value(
  $q as element(literal)
) as xs:string {
  let $s := if ($q/@dstring)
            then replace($q/@dstring,'""','"') (:":)
            else if ($q/@sstring) 
            then replace($q/@sstring,"''", "'") 
            else if ($q/@hex) 
            then ixi:charXhex($q/@hex)
            else string($q)
  return if (matches($s,'^#[0-9a-fA-F]+$'))
         then ixi:charXhex(
               ixi:notrace($s,'string-value calls cXh on ' || $s) 
             )
         else $s
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

</div>
</div>

<div class="div">

<h4><a name="ll-utils-tracing" id="ll-utils-tracing">4.6.2. </a>Trace routines</h4>
<div class="Real-P">For debugging, it's helpful to make traces a little easier.</div>
<div class="Real-P">First, a function to display an Earley item as a string.
<div class="scrap"><span><a name="d3e1157">&#x3008; 47 Define s X ei() to build string form of Earley item [continues <a href="#eri-utils-and-misc">41 Utilities for recognizer internals module</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ................................................................
   s X ei($E):  a utility function to help make traces more legible.
   :)
declare function ixi:sXei($E as map(xs:string, item())) as xs:string {
  'item('
  || $E('from') || ' ' 
  || $E('to') || ' '
  || $E('rule')/@name || '/' || $E('ri')
  || ')'
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">Next, a function to build an XML element representing an Earley
item.  This is used less tracing than in returning verbose results.
<div class="scrap"><span><a name="d3e1163">&#x3008; 48 Define eXei() to build 'item' element for Earley item [continues <a href="#eri-utils-and-misc">41 Utilities for recognizer internals module</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ................................................................
   e X ei($E):  a utility function to help make traces and dumps
   more legible.
   :)
declare function ixi:eXei(
  $E as map(xs:string, item())
) as element(item) {
  element item {
    attribute from { $E('from') },
    attribute to { $E('to') },
    attribute rulemark { $E('rule')/@mark },
    attribute rulename { $E('rule')/@name },
    attribute ri { $E('ri') }
    }
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">The actual trace function has two forms:  one for when
we want debugging and tracing turned on, and one for when
we want to turn it off globally.  There probably should be
better ways of turning tracing on and off. 
<div class="scrap"><span><a name="d3e1169">&#x3008; 49 Define trace() function for debugging [continues <a href="#eri-utils-and-misc">41 Utilities for recognizer internals module</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-trace-function">Define trace() function 50</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-notrace-function">Define notrace() function for debugging 52</a></em> &#x3009;</span>
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>
</div>
<div class="Real-P">The <i>ixi:trace()</i> function is just a wrapper around
the built-in trace function which inserts newlines. 
<div class="scrap"><span><a name="eri-trace-function">&#x3008; 50 Define trace() function &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ................................................................
   trace($i, $s):  a utility function to help make code being
   traced stay more legible.
   :)
declare function ixi:trace(
  $x as item()?,
  $s as xs:string
) as item()? {
  trace($x, '&amp;#xA;' || $s || '&amp;#xA;')
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e1169">Define trace() function for debugging 49</a> &#x3009; <br></span>
</div>

An alternative form also inserts asterisks, but in general that proves
a little too busy.
<div class="scrap"><span><a name="d3e1184">&#x3008; 51 Starry trace() function &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
declare function ixi:trace($x as item()?, $s as xs:string) as item()? {
trace(($x,'')[1], '&amp;#xA;&amp;#xA;********&amp;#xA;' || $s || '&amp;#xA;')
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>

</div>
<div class="Real-P">It will be easier to turn tracing on and off at particular
locations if we also define a <i>notrace()</i> function, which
discards the string and returns the first argument. The dummy form
just throws away the string and returns the item in the first
argument.
<div class="scrap"><span><a name="eri-notrace-function">&#x3008; 52 Define notrace() function for debugging &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ................................................................
   notrace($i, $s):  a utility function to help make code being
   traced stay more legible.
   :)
declare function ixi:notrace(
  $x as item()?,
  $s as xs:string
) as item()? {
  $x 
}; 
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e1169">Define trace() function for debugging 49</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The dummy form of <i>trace()</i> does the same thing
as <i>notrace()</i>
<div class="scrap"><span><a name="eri-trace-dummy">&#x3008; 53 Define trace() function for debugging &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ................................................................
   trace($i, $s):  a utility function to help make code being
   traced stay more legible.
   :)
declare function ixi:trace(
  $x as item()?,
  $s as xs:string
) as item()? {
  $x 
}; 
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>

</div>
<div class="Real-P">We also want these available in other modules, like the
Gluschkov module.
<div class="scrap"><span><a name="gl-trace">&#x3008; 54 Define trace() function for debugging &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ................................................................
   trace($i, $s):  a utility function to help make code being
   traced stay more legible.
   :)
declare function gl:trace(
  $x as item()?,
  $s as xs:string
) as item() {
  trace($x, '&amp;#xA;' || $s || '&amp;#xA;')  
};  
declare function gl:notrace(
  $x as item()?,
  $s as xs:string
) as item()? {
  $x 
}; 
(:
declare function gl:trace($x as item()?, $s as xs:string) as item() {
  $x 
};
:)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e2229">[File Gluschkov.xqm] 96</a> &#x3009; <br></span>
</div>

</div>

</div>
</div>
</div>


<div class="div">

<h2><a name="alt-calls" id="alt-calls">5. </a>Alternative interfaces</h2>
<div class="Real-P">The file Aparecium.xqm offers several different calls
intended for users of the library.  They are defined here.</div>

<div class="div">

<h3><a name="alt-calls-main" id="alt-calls-main">5.1. </a>Main user-facing calls</h3>
<div class="Real-P">The file Aparecium.xqm has the user-facing
function definitions for the main interface
and the alternative interfaces.  Also some
maintenance routines.  <i>To do:</i> allow options
on these to control what is returned, and how:
<ul><li>parse tree(s) or parse-forest grammar?</li>
<li>AST (as in the spec) or raw parse tree (for debugging)?</li>
<li>with or without <em>_from</em> and <em>_to</em> attributes
giving character offsets of the construct?</li>
</ul>
</div>
<div class="Real-P">The <i>aparecium:doc()</i> function is intended to be as close
as possible to the <i>fn:doc()</i> function.  It is not yet
implemented, because it requires a bit more infrastructure.
<div class="scrap"><span><a name="aparecium-main">&#x3008; 55 Main interfaces for Aparecium &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ****************************************************************
   * Main interfaces (and the simplest) 
   ****************************************************************
   :)
  
(: ................................................................
   doc($InputURI)
   ................................................................
   Given the URI of the input, fetch the ixml grammar describing it
   and return the XML representation of the resource.
:)

(: TO BE IMPLEMENTED:  use html fetch to get both HTTP header
and payload.  If MIME type is ixml, fetch grammar and call
parse-string.  Otherwise, if XML and 200 return payload, 
otherwise return header and payload.

declare function aparecium:doc(
  $uriI as xs:string
) as element() {
  let $sI := unparsed-text($uriI),
      $sG := unparsed-text($uriG)
  return aparecium:parse-string($sI, $sG)
};
:)

</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e542">Define parse-resource() 8</a>&#x3009;, &#x3008;<a href="#d3e1315">Define parse-string() 56</a>&#x3009;, &#x3008;<a href="#d3e1327">Define parse-string-with-compiled-grammar() 57</a>&#x3009;<br></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e294">[File Aparecium.xqm] 1</a> &#x3009; <br></span>
</div>

Before it can parse the resource, the <i>doc()</i> function
will need to find a grammar for it.  There are two ways this
can happen (maybe more).
<ul><li><div class="Real-P">The web server hosting the resource can label it with an HTTP
header in which a reference to the grammar is given.  In <a href="#Pemberton-2013"></a>, the example given is a CSS stylesheet which
can be served either as <tt>text/css</tt> (which is usual)
<em>or</em> with the HTTP mediatype header
<tt>application/xml-invisible;
syntax=http://example.com/syntax/css</tt>.  The media type
<tt>application/xml-invisible</tt> (not currently standardized)
signals that the resource is an invisible XML document; the
<tt>syntax</tt> parameter gives the URI of an appropriate ixml
grammar.</div>
<div class="Real-P">This approach allows ixml to fit nicely into the architecture of
the Web.  It has the drawback that for the foreseeable future few
servers will provide such HTTP headers; of lesser importance in the
long run (but one important reason the <i>aparecium:doc()</i> function
has not yet been implemented) is that this approach requires
the implementor of an invisible-XML parser to understand
content negotiation and implement it correctly.</div>
</li>
<li><div class="Real-P">Even if the web server does not provide a pointer to an
invisible-XML grammar, an ixml parser can keep a cache or directory of
grammars for a set of known media types, and use the media type
returned by the server to find an appropriate grammar.</div>
<div class="Real-P">A parser's installation package might, for example, install
grammars for common media types (<tt>text/css</tt>,
<tt>text/csv</tt>, 
<tt>text/markdown</tt>,
<tt>application/sql</tt>,

etc.) and use them when <i>doc()</i> is called on a resource
with a known media type.  Since grammars for known media types will be
useful for all ixml users, there might be reason to make the
collection of grammars available on the web.</div>
<div class="Real-P">A parser might allow the user to add grammars to the
cache, to fill gaps in the collection.</div>
<div class="Real-P">Unfortunately, a number of notations that might be of interest to
ixml users have no MIME type registered with IANA, so this approach
does not help for TeX or LaTeX files (even ones that do not change the
default parsing rules), or for grammars in well known notations like
ABNF or Wirth's EBNF or ISO-standard EBNF.  Other notations of
possible interest for ixml users (such as SVG path expressions,
XPath expressions, XSLT match patterns, and others) do not have
registered media types because they are generally embedded in other
contexts rather than being served as stand-alone resources.</div>
</li>
<li><div class="Real-P">In an environment where a small number of grammars are very
often used, an ixml parser might emulate web browsers which sniff
content by examining the first portion of a resource and seeing
whether it &#x2018;looks&#x2019; like a known media type.  In the
same way, an ixml parser could attempt to identify the grammar of an
undocumented (or <tt>text/plain</tt>) resource by attempting to
parse the first 100 characters using several grammars.  This seems
unlikely to be generally useful, however: there are too many possible
grammars.</div>
</li>
</ul>
</div>
<div class="Real-P">Although its surface simplicity is attractive, the
<i>aparedium:doc()</i> function is not going to cover
all cases.  So we need interfaces that allow the user to specify
both a resource and a grammar.  And for cases where the notation
to be parsed is embedded in an XML document, the user needs to be
able to specify the input to be parsed, and the grammar, either
as a resource (using a URI) or as a string.
The <i>parse-string()</i> takes both as strings.
<div class="scrap"><span><a name="d3e1315">&#x3008; 56 Define parse-string() [continues <a href="#aparecium-main">55 Main interfaces for Aparecium</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ................................................................
   parse-string($Input, $Grammar)
   ................................................................
   Given strings with the input and an ixml grammar describing it,
   returns the XML representation of the resource.
:)

declare function aparecium:parse-string(
  $sI as xs:string,
  $sG as xs:string
) as element() {
  let $cG := aparecium:compile-grammar-from-string($sG)
  return aparecium:parse-string-with-compiled-grammar($sI, $cG)
};
   
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">Given a string with the input and the pre-processed form of an ixml
grammar describing it, the function
<i>parse-string-with-compiled-grammar()</i> returns the XML
representation of the string's parse tree.</div>
<div class="Real-P">This is the workhorse of the library, called by many other
functions.
<div class="scrap"><span><a name="d3e1327">&#x3008; 57 Define parse-string-with-compiled-grammar() [continues <a href="#aparecium-main">55 Main interfaces for Aparecium</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ................................................................
   parse-string-with-compiled-grammar($Input, $Grammar)
   ................................................................
:)
declare function aparecium:parse-string-with-compiled-grammar(
  $sI as xs:string,
  $cG as element(ixml)
) as element() {
  let $trace := trace((),'
parse-string-with-compiled-grammar()
') 
  let $result := earley:all-trees($sI, $cG) 
  return if (count($result) eq 1)
         then $result
         else &lt;forest 
              xmlns:ixml="http://invisiblexml.org/NS"
	      &gt;{$result}&lt;/forest&gt;
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

</div>
</div>

<div class="div">

<h3><a name="alt-calls-secondary" id="alt-calls-secondary">5.2. </a>Secondary user-facing calls</h3>
<div class="Real-P">Text here ...
<div class="scrap"><span><a name="aparecium-secondary">&#x3008; 58 Secondary interfaces (a bit specialized) &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ****************************************************************
   * Secondary interfaces (a bit more specialized) 
   ****************************************************************
   :)
   
(: ................................................................
   parse-grammar-from-uri($ixmlGrammar)
   ................................................................
   Given the URI of an ixml grammar, returns the XML 
   representation of the grammar.  
   
   Retrieves the grammar and parses it by calling
   parse-grammar-from-string().
:)
declare function aparecium:parse-grammar-from-uri(
  $uriG as xs:string
) as element() {
  let $sG := unparsed-text($uriG)
  return aparecium:parse-grammar-from-string($sG)
};
   
(: ................................................................
   parse-grammar-from-string($ixmlGrammar)
   ................................................................
   Given the string form of an ixml grammar, returns the XML 
   representation of the grammar.  
   
   Retrieves the grammar and parses it by calling
   parse-string-with-compiled-grammar with the ixml grammar
   for ixml grammars.
:)

declare function aparecium:parse-grammar-from-string(
  $G as xs:string
) as element(ixml) {
  (: CGIG:  compiled grammar for ixml grammars :)
  let $CGIG := doc($aparecium:ixml.gl.xml)/ixml,
      (: PG: parsed grammar :)
      $PG := aparecium:parse-string-with-compiled-grammar($G,$CGIG)
  return if ($PG/self::forest) 
      then trace($PG/ixml,
                 'Warning:  submitted grammar was ambiguous.') 
      else if ($PG/self::Goal) 
      then $PG/ixml 
      else if ($PG/self::ixml) 
      then $PG
      else &lt;ixml&gt;
        &lt;!--* Something is very wrong here *--&gt;
        { $PG }
      &lt;/ixml&gt;
};   
      
(: ................................................................
   compile-grammar-from-uri($ixmlGrammar)
   ................................................................
   Given the URI of an ixml grammar, returns the compiled XML 
   representation of the grammar. 
:)  

declare function aparecium:compile-grammar-from-uri(
  $uriG as xs:string
) as element() {
  let $xmlG := aparecium:parse-grammar-from-uri($uriG)
  return gluschkov:ME($xmlG)
};
      
(: ................................................................
   compile-grammar-from-string($ixmlGrammar)
   ................................................................
   Given the URI of an ixml grammar, returns the XML 
   representation of the grammar.  
:)  
 
declare function aparecium:compile-grammar-from-string(
  $sG as xs:string
) as element() {
  let $xmlG := aparecium:parse-grammar-from-string($sG)
  return gluschkov:ME($xmlG)
};

(: ................................................................
   compile-grammar-from-xml($ixmlGrammar)
   ................................................................
   Given the XML representation of an ixml grammar, returns an 
   annotated representation of the grammar that makes it usable
   by the Earley parser. 
:)   

declare function aparecium:compile-grammar-from-xml(
  $xmlG as element(ixml)
) as element(ixml) {
  gluschkov:ME($xmlG)
};

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e294">[File Aparecium.xqm] 1</a> &#x3009; <br></span>
</div>

</div>
</div>

<div class="div">

<h3><a name="alt-calls-other" id="alt-calls-other">5.3. </a>Non-user-facing functions</h3>
<div class="Real-P">Some things are in the Aparecium module because
they have to be, even though they are of no interest
to library users.</div>
<div class="Real-P">
<div class="scrap"><span><a name="aparecium-tertiary">&#x3008; 59 Tertiary interfaces (of interest only for maintainer) &#x3009; &#x2261;</a></span>
<pre class="scrapbody">

(: ****************************************************************
   * Tertiary interfaces (of interest only for maintainer) 
   ****************************************************************
   :)

(: This is bootstrapping code (for building the Gluschkov
   automaton of the ixml grammar for ixml grammars.  It 
   should be run once whenever the grammar changes -- that is,
   almost never.  But for now, it's here. 
   :)
  
(: Note that these don't save the result to disk; that's not
   automated yet.
   :)
(: reparse-ixml-grammar():  produce fresh XML version :)
(: The path starting from Goal on all these is a temporary hack. :)
declare function aparecium:reparse-ixml-grammar() as element(ixml) {
  aparecium:parse-grammar-from-uri($aparecium:ixml.ixml)/Goal/ixml
};
 
(: recompile-ixml-grammar():  produce fresh annotated XML :)
declare function aparecium:recompile-ixml-grammar() as element(ixml) {
  aparecium:compile-grammar-from-uri($aparecium:ixml.ixml)/Goal/ixml
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e294">[File Aparecium.xqm] 1</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Where are these things? They really should be in a collection, 
but collections are more complicated.  Maybe later.
<div class="scrap"><span><a name="aparecium-variables">&#x3008; 60 Variables (of interest only for maintainer) &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ****************************************************************
   * Variables (of interest only for maintainer) 
   ****************************************************************
   :)
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e1363">Location of library 61</a>&#x3009;, &#x3008;<a href="#d3e1376">Location of ixml grammar 62</a>&#x3009;<br></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e294">[File Aparecium.xqm] 1</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">It is embarrassing to move things around by changing these
strings, but ... that's what currently happens.
First, what directory are these things in?
<div class="scrap"><span><a name="d3e1363">&#x3008; 61 Location of library [continues <a href="#aparecium-variables">60 Variables (of interest only for maintainer)</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
declare variable $aparecium:libloc as xs:string
  := 'file://'
     || '/Users/cmsmcq/'
     || '2021/Aparecium/lib';
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

(Earlier values include 'http://blackmesatech.com/2018/demos/lib'
and 'http://localhost/~cmsmcq/blackmesatech.com/2019/demos/lib'.
The call <tt>Q{org.basex.util.Prop}HOMEDIR()</tt> is
helpful in BaseX.)
</div>
<div class="Real-P">Where is the master (local) copy of the ixml grammar 
for ixml grammars?  We have three forms:  the ixml grammar,
the &#x2018;visible XML&#x2019; representation of
the grammar, and the &#x2018;compiled&#x2019;
representation, with annotations describing each RHS as
an FSA.
<div class="scrap"><span><a name="d3e1376">&#x3008; 62 Location of ixml grammar [continues <a href="#aparecium-variables">60 Variables (of interest only for maintainer)</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
declare variable $aparecium:ixml.ixml as xs:string
  := $aparecium:libloc || '/ixml.2021-09-14.ixml';

declare variable $aparecium:ixml.xml as xs:string
  := $aparecium:libloc || '/ixml.2021-09-14.ixml.xml';
  
declare variable $aparecium:ixml.gl.xml as xs:string
  := $aparecium:libloc || '/ixml.2021-09-14.compiled.xml';  
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

</div>
</div>
</div>


<div class="div">

<h2><a name="quarry" id="quarry">6. </a>Unsorted bits of legacy code</h2>	
<div class="Real-P">The first version of this document is being made
by taking the existing code and embedding it in
this document.  This section and its subsections
contain portions of the code that have not yet
been broken out into pieces.</div>



<div class="div">

<h3><a name="legacy-Earley-parser.xqm" id="legacy-Earley-parser.xqm">6.1. </a>Earley parser</h3>
<div class="Real-P">The file Earley-parser.xqm has the top-level
function definitions for the parser.  These
functions call the recognizer and construct
a parse tree to return.</div>
<div class="Real-P">General remarks:
</div>
<div class="Real-P">We have a few problems, for which we might as well sketch our
solutions.
<ul><li><div class="Real-P">Some sentences are infinitely ambiguous; they have loops in their
derivation tree:  A is parent of sole child B is parent of sole child
A.</div>
<div class="Real-P">Solution;  cut out those loops, return only loopless trees.</div>
<div class="Real-P">Mechanism:  keep track of the set of ancestors in progress, don't
accept another node for the same nonterminal with the same frontier.</div>
<div class="Real-P">Alternative solution:  fix maximum height of a tree for a given frontier,
e.g. at 1 + number of non-terminals.  (Not an overall limit, just
a limit for a subtree with a fixed frontier.)</div>
</li>
<li><div class="Real-P">Some sentences are infinitely ambiguous: there may be zero or more
adjacent instances of nodes generating the empty string, e.g. in 
the RHS X*, Y, Z*.  (This is an EBNF-specific problem, not possible
for BNF.)</div>
<div class="Real-P">Solution:  cut out loops, return only loopless paths through a RHS.</div>
<div class="Real-P">Mechanism:  keep track of the states you have visited, don't accept
another node for the same state (RHS position, *not* nonterminal)
and the same frontier.</div>
<div class="Real-P">Alternative solution:  fix maximum width for sequence of zero-width
sibling nodes, e.t. at twice the number of positions in the RHS. </div>
</li>
<li><div class="Real-P">The user may want all trees, or one arbitrarily chosen tree, or one
tree with the option to fetch more.</div>
</li>
</ul>
</div>
<div class="Real-P">We will offer four functions (names subject to change):
<ul><li><div class="Real-P">ep:alltrees($I,$G) will return all loopless parse
trees</div></li>
<li><div class="Real-P">ep:anytree($I, $G) will return the first tree it finds and
stop</div></li>
<li><div class="Real-P">ep:treecursor($I, $G) will return two items: the first tree
it finds and a function to call for the next tree (and the next
function); this involves wrapping up continuations and passing them
around.  (It may be helpfl to do a five-finger exercise fetching the
items of a sequence one at a time.)</div></li>
<li><div class="Real-P">ep:parseforest($I, $G) will return a parse forest grammar for
the trees.  It can and should include the looped parse trees.  It may
have clean/dirty variants that do or don't bother to clean the grammar
up (tbd; dunno yet).</div></li>
</ul>
</div>
<div class="Real-P">These are all intended to be user-facing; there will be
corresponding functions internal to the module not intended to be
called by the user.
<div class="scrap"><span><a name="d3e1438">&#x3008; 63  [File Earley-parser.xqm]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">

(: Goal:  to return the set of parse trees recorded implicitly in the
   Earley closure.
   :)
(: ep:alltrees($I,$G):  return all loopless parse trees :)
declare function ep:all-trees(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as element()+ {
  trace((), 'ep:all-trees calling epi:earley-parse'),
  epi:earley-parse($I, $G, epi:all-trees#3),
  trace((), 'epi:earley-parse has returned '
        || 'and ep:all-trees is about to do so.') 
};

(: ep:anytree($I,$G):  return one (loopless) parse tree, 
   whichever is found first 
:)
declare function ep:any-tree(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as element()? {
  epi:earley-parse($I, $G, epi:any-tree#3)
};

(: ep:tree-cursor($I,$G):  return pair consisting of 
   1 a parse tree, and
   2 a function to return the next parsetree/function pair, or
     when trees are exhausted to return a 'no-more-trees' signal.
     
   The name is intended to recall the cursor notion of SQL results.
   
   If you keep track of the number of trees delivered, the
   no-more-trees signal can distinguish there-were-no-trees
   from all-done-now signals.
:)
declare function ep:tree-cursor(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as item()* {
  epi:earley-parse($I, $G, epi:tree-cursor#3)
};

(: ep:parseforestmap($I,$G):  return a map containing an and/or tree
   representing the set of all parses.
:)
declare function ep:parse-forest-map(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as element()* {
  epi:earley-parse($I, $G, epi:parse-forest-map#3)
};

(: ep:parseforestgrammar($I,$G):  return a BNF (not EBNF[?]) grammar
   describing the set of all parses of $I against $G.
:)
declare function ep:parse-forest-grammar(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as element()* {
  epi:earley-parse($I, $G, epi:parse-forest-grammar#3)
};

(:



:)
(: Given a final item, build a tree for it.
:)</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

</div>
</div>

<div class="div">

<h3><a name="legacy-Earley-parser-internals.xqm" id="legacy-Earley-parser-internals.xqm">6.2. </a>Parser internals</h3>
<div class="Real-P">The file Earley-parser-internals has low-level
function definitions for the parser,
which are intended to be subject to change
with minimal or no effect on the higher-level
functions.</div>

<div class="div">

<h4><a name="epi-earley-parse-function" id="epi-earley-parse-function">6.2.1. </a>The <i>earley-parse()</i> function</h4>
<div class="Real-P">The function <i>earley-parse()</i> runs the Earley
recognizer on the input and returns results as specified
by the user.  This version of earley-parse() requires
that the processor support higher-level functions.  Since
Saxon HE does not provide that support, it should be revised
so that the standard interfaces don't require higher-level
functions.
<div class="scrap"><span><a name="epi-earley-parse">&#x3008; 64 Define earley-parse() &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ****************************************************************
   earley-parse($I, $G, $f);  run Earley recognizer on 
   input $I and grammar $G, return results using 
   $f($leiClosure, $Ec, $I, $G)
:)
declare function epi:earley-parse(
  $I as xs:string,
  $G as element(ixml),
  $f as function(
    map(*)*  (: Ec :),
    map(*)* (: Closure :),
    xs:string (: Input :)
    (: , element(ixml) (: Grammar :) :)
  ) as item()* 
) as item()* {
  let $dummy := eri:trace((), 'epi:earley-parse() ...') 
  let $mapResult := er:recognizeX($I, $G), 
      $meiClosure := $mapResult('Closure'),
      $leiCompletions := $mapResult('Completions')
  return if ($mapResult('Result'))
    then (: if we have a result, return each parse tree :)
        let $dummy := eri:trace((), 'epi:earley-parse() has result') 
        let $lpt := $f($leiCompletions, $meiClosure, $I (: , $G :) )
        for $pt at $npt in $lpt
        let $dummy := eri:trace((), 'epi:earley-parse() returning a result') 
        (: return if (('raw','ast')[2] eq 'raw') 
	       then $pt  
               else epi:astXparsetree($pt, count($lpt)) :)
        (: What an ugly hack!  Clean this up! :)
        let $logfn := '/Users/cmsmcq/'
                      || '2021/Aparecium/tests/output/raw.'
	              || translate(
                           string(
                             adjust-dateTime-to-timezone(
                               current-dateTime(), 
                               ())),
                           ' :',
                           '__')
                      || $npt
                      || '.xml'   
        return (file:write($logfn, $pt), 
                epi:astXparsetree($pt, count($lpt)))
        
   else (: otherwise, send an apology and explanation :)
   &lt;no-parse&gt;
   &lt;p&gt;Sorry, no parse for this string and grammar.&lt;/p&gt;
   &lt;p&gt;The completions are:&lt;/p&gt;
   &lt;completions&gt;{$leiCompletions}&lt;/completions&gt;
   &lt;p&gt;The map is:&lt;/p&gt;
   
   &lt;Initial-Item&gt;{eri:eXei($mapResult('Initial-Item'))}&lt;/Initial-Item&gt;
   &lt;Input&gt;{$mapResult('Input')}&lt;/Input&gt;
   &lt;Input-Length&gt;{$mapResult('Input-Length')}&lt;/Input-Length&gt;
   &lt;Completions&gt;{
     for $ei in $mapResult('Completions')
     return eri:eXei($ei)
   }&lt;/Completions&gt;
   &lt;Closure&gt;{
     let $mei := $mapResult('Closure')
     for $n in map:keys($mei('to'))
     order by $n descending
     for $ei in $mei('to')($n)
     return eri:eXei($ei)
   }&lt;/Closure&gt;
   &lt;Result&gt;{$mapResult('Result')}&lt;/Result&gt;
   &lt;grammar&gt;{(: 'Omitted.' :) $mapResult('Grammar') }&lt;/grammar&gt;
   &lt;/no-parse&gt;
   (: we have to think about how to return that no-parse signal.
   :)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e340">[File Earley-parser-internals.xqm] 4</a> &#x3009; <br></span>
</div>

(Why do we produce parse trees in the recognizer?  We have
the completion item or we don't; we don't need parse trees here.
But since no one will ever actually want just a recognizer,
I don't suppose it matters.)
</div>
</div>

<div class="div">

<h4><a name="epi-tree-returns" id="epi-tree-returns">6.2.2. </a>Functions to return one or more trees</h4>


<div class="div">

<h5><a name="epi-trf-all-trees" id="epi-trf-all-trees">6.2.2.1. </a>The <i>all-trees()</i> function</h5>
<div class="Real-P">If the user wants all trees, we call the <i>all-trees()</i>
function.</div>
<div class="Real-P">For each completion item in $Ec, we return all parse trees for the
nonterminal $n in $Ec's left-hand side, as documented by $Closure
(a set of Earley items closed over scan(), pred(), and comp().</div>
<div class="Real-P">The result will be one or more elements for nonterminal <tt>$n</tt>.</div>
<div class="Real-P">The main function generates an empty vertical stack (to prevent
looping on infinite sets of trees with unbounded vertical depth)
and calls an auxiliary function to do the work.
<div class="scrap"><span><a name="epi-all-trees">&#x3008; 65 Define all-trees() &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ****************************************************************
   all-trees($Closure, $Ec, $I, $G):  
:)
declare function epi:all-trees(
  $leiCompletions as map(*)*,
  $meiClosure as map(xs:string,
                     map(xs:integer,
                         map(xs:string, item())*)) (:MEI:),
  $I as xs:string
  (: $G as element(ixml) :)
) as element()* {
  (: Call auxiliary routine with a vertical stack for
     loop prevention. :)
  epi:all-trees($leiCompletions, $meiClosure, $I, ())
};
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e1496">Define auxiliary function for all-trees() 66</a>&#x3009;<br></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e340">[File Earley-parser-internals.xqm] 4</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">The auxiliary function for generating all trees is initially called
for the item (0 $n Goal $q_final), but it's called again recursively,
once for every completion relevant to the tree(s) we are constructing.
<div class="scrap"><span><a name="d3e1496">&#x3008; 66 Define auxiliary function for all-trees() [continues <a href="#epi-all-trees">65 Define all-trees()</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ****************************************************************
   all-trees#5:  auxiliary function (more args, does the work) 
:)
   
declare function epi:all-trees(
  $leiCompletions as map(*)*,
  $meiClosure as map(xs:string,
                     map(xs:integer,
                         map(xs:string, item())*)) (:MEI:),
  $I as xs:string,
  $leiVStack as map(*)*
  (: $G as element(ixml) :)
) as element()* {
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-all-trees-for">Iterate over the list of completion items 67</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-all-trees-call-ans">Get the sequences, or rather raw parse trees 68</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-all-trees-return-trees">Return the raw parse trees 69</a></em> &#x3009;</span>
}; 
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">For every original completion item in <tt>$leiCompletions</tt>,
return parse trees for its nonterminal.
<div class="scrap"><span><a name="epi-all-trees-for">&#x3008; 67 Iterate over the list of completion items &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
  for $Ec at $nEc in $leiCompletions
             [not(
               some $eiV in $leiVStack
               satisfies deep-equal(.,$eiV)
             )]
  
  let $dummy := eri:notrace($Ec,
    'all-trees called with item '
    || $nEc || ' (of ' || count($leiCompletions)
    || ') = ' || eri:sXei($Ec) 
  )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e1496">Define auxiliary function for all-trees() 66</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">Here, <tt>$Ec</tt> is the completion item for
a nonterminal <tt>$n</tt>.
Its LHS tells us which nonterminal.
Its <i>from</i> and
<i>to</i> positions tell us the frontier
generated by <tt>$n</tt>.
</div>
<div class="Real-P">For each sequence <tt>$ln</tt> of adjacent nodes that
<ul><li>span the range <i>From</i> .. <i>To</i>, and</li>
<li>constitute a path through the RHS of <tt>$n</tt>,</li>
</ul>
return a raw parse-tree element for <tt>$n</tt> with content
<tt>$ln</tt>.
</div>
<div class="Real-P">
We want one parse tree for each possible sequence <tt>$ln</tt>,
but in order to iterate over them, we need to wrap them up in
something (since XDM sequences don't nest).  We will wrap them up in
elements (of type &lt;<em>nt</em>&gt;).  So in fact when we get the sequences
back, they will already be wrapped up in the element; all we need to
do is return them.
<div class="scrap"><span><a name="epi-all-trees-call-ans">&#x3008; 68 Get the sequences, or rather raw parse trees &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
  let $parsetrees := epi:all-node-sequences(
    $Ec,
    $meiClosure,
    (),
    $Ec('from'), 
    $Ec('to'), 
    $I,
    ($Ec, $leiVStack),
    ()
  )</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e1496">Define auxiliary function for all-trees() 66</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">Once we get the trees, we just return them.
<div class="scrap"><span><a name="epi-all-trees-return-trees">&#x3008; 69 Return the raw parse trees &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
  for $parsetree in $parsetrees
  let $dummy := eri:notrace($parsetree,
    'all-trees got this parsetree back from item Ec = ' || eri:sXei($Ec))
  return $parsetree 
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e1496">Define auxiliary function for all-trees() 66</a> &#x3009; <br></span>
</div>
</div>
</div>

<div class="div">

<h5><a name="epi-trf-anytree" id="epi-trf-anytree">6.2.2.2. </a>The <i>any-tree()</i> function</h5>
<div class="Real-P">If the user wants an arbitrary tree -- well, for now they are 
out of luck. 
<div class="scrap"><span><a name="epi-any-tree">&#x3008; 70 Define any-tree() &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
declare function epi:any-tree(
  $leiCompletions as map(*)*,
  $leiClosure as map(*)*,
  $I as xs:string
) as element()* {
  &lt;any-tree-not-implemented-yet/&gt;
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e340">[File Earley-parser-internals.xqm] 4</a> &#x3009; <br></span>
</div>
</div>
</div>

<div class="div">

<h5><a name="epi-trf-cursor" id="epi-trf-cursor">6.2.2.3. </a>The <i>tree-cursor()</i> function</h5>
<div class="Real-P">We want (eventually) to provide an interface for a kind of
&#x2018;tree cursor&#x2019;, which will allow the user to
iterate over the set of parse trees in the same way as a cursor
in SQL allows the application to read a sequence of results.
In XQuery, the basic idea is to return not a tree but a pair
consisting of (a) a tree and (b) a function to call to get
the next pair.  If there is a finite set of trees, then on
the last tree no function will be returned (or a special function
that raises a particular error when called?).</div>
<div class="Real-P">But for the moment, this is just a stub.
<div class="scrap"><span><a name="epi-tree-cursor">&#x3008; 71 Define tree-cursor() &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
declare function epi:tree-cursor(
  $leiCompletions as map(*)*,
  $leiClosure as map(*)*,
  $I as xs:string
) as element()* {
  &lt;tree-cursor-not-implemented-yet/&gt;
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e340">[File Earley-parser-internals.xqm] 4</a> &#x3009; <br></span>
</div>
</div>
</div>

<div class="div">

<h5><a name="epi-trf-pfm" id="epi-trf-pfm">6.2.2.4. </a>The <i>parse-forest-map()</i> function</h5>
<div class="Real-P">Also a stub are functions to return results in the form
of parse forests.  One is a function which when completed
should return a parse-forest map, that is a data structure
with a directed graph containing all parse trees as sub-graphs.
<div class="scrap"><span><a name="epi-parse-forest-map">&#x3008; 72 Define parse-forest-map() &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
declare function epi:parse-forest-map(
  $leiCompletions as map(*)*,
  $leiClosure as map(*)*,
  $I as xs:string
) as map(*) {
  map { 'Result' : &lt;parse-forest-map-not-implemented-yet/&gt; }
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e340">[File Earley-parser-internals.xqm] 4</a> &#x3009; <br></span>
</div>
</div>
</div>

<div class="div">

<h5><a name="epi-trf-pfg" id="epi-trf-pfg">6.2.2.5. </a>The <i>parse-forest-grammar()</i> function</h5>
<div class="Real-P">Another parse-forest interface will return a parse-forest
grammar.  (As this is written, I think this is the key:  from
the Earley set, generate a parse-forest grammar, and generate
all other forms of result from the parse-forest grammar.)
<div class="scrap"><span><a name="epi-parse-forest-grammar">&#x3008; 73 Define parse-forest-grammar() &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
declare function epi:parse-forest-grammar(
  $leiCompletions as map(*)*,
  $leiClosure as map(*)*,
  $I as xs:string
) as element() {
  &lt;parse-forest-grammar-not-implemented-yet/&gt;
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e340">[File Earley-parser-internals.xqm] 4</a> &#x3009; <br></span>
</div>
</div>
</div>
</div>

<div class="div">

<h4><a name="epi-all-nodes" id="epi-all-nodes">6.2.3. </a>Finding a sequence of items for a single right-hand side</h4>
<div class="Real-P">One crucial step in finding a tree in the Earley set is
to identify a sequence of items that describe a path through
the right-hand side of a given rule.</div>
<div class="Real-P">The inspiration for the approach used here
is Maarten van Emden's solution to the Eight Queens problem at 
<a href="https://vanemden.wordpress.com/2008/04/27/programming-language-x/">https://vanemden.wordpress.com/2008/04/27/programming-language-x/</a>.
There is no code for stopping when you get a solution, no
backtracking,
just full speed ahead over all possibilities.</div>
<div class="Real-P">To perform this task, we define a function
<i>epi:all-node-sequences</i>(<tt>$item</tt>,
<tt>$closure</tt>, <tt>$acc</tt>, <tt>$from</tt>,
<tt>$to</tt>, <tt>$I</tt>), which iterates selectively (by
recursion) over elements in <tt>$closure</tt> to find items which
form a path through the RHS of a given rule in <i>G</i>.  The items have
the following properties.
<ul><li>All items in the path-sequence have locations in the same rule
for some non-terminal <tt>$n</tt>, namely
<tt>$item('rule')</tt>.  (If they didn't have that rule, they
could not describe a path through its RHS.)</li>
<li>All items in the path-sequence have the same
<i>from</i>-position (= <tt>$from</tt>).  (If they did
not, they would not describe a single instance of the rule's
nonterminal.)</li>
<li>The first item has <i>from</i>-position =
<i>to</i>-position = <tt>$from</tt>; that is, it is the
item produced by the predictor for an instance of the
nonterminal.</li>
<li>The last item has <i>from</i>-position =
<tt>$from</tt> and <i>to</i>-position =
<tt>$to</tt>; that is, it's the completion item for
one instance of the nonterminal.</li>
<li>Each item in the path-sequence advances the path by one symbol;
that is, for any two adjacent items
<i>EI</i>[<i>i</i>]
with <i>to</i> = <i>p1</i> 
and
<i>EI</i>[<i>i</i>+1]
with <i>to</i> = <i>p2</i>, either
<ul><li><i>EI</i>[<i>i</i>+1] will be the value of
<i>scan</i>(<i>E</i>[<i>i</i>],
<tt>$I</tt>) &#x2014; in this case,
<tt>$I</tt>[<i>p1</i> .. <i>p2</i>] matches the
terminal <i>EI</i>[<i>i</i>+1]('ri') &#x2014; or </li>
<li><i>EI</i>[<i>i</i>+1] will be the value of
<i>comp</i>(<i>EIc</i>,
<i>EI</i>[<i>i</i>]) for some <i>EIc</i> in
<tt>$closure</tt>.  In this case, <tt>$closure</tt> will
include some completion item <i>EIc</i> with
<i>from</i> = <i>p1</i>, <i>to</i> =
<i>p2</i>, <i>nonterminal</i> =
<i>EI</i>[<i>i</i>+1]('ri').</li>
</ul>
</li>
</ul>
</div>
<div class="Real-P">At each step (i.e. on each call to this function) we identify one
more item in the sequence.  There may be more than one (because there
may be multiple paths); if so, we iterate recursively on each of them
because we want all node sequences.
</div>
<div class="Real-P">The sequence we find is not represented explicitly, but implicitly
by the sequence of items passed as the current $item (in reverse
order, since we start with the completion).
</div>
<div class="Real-P">Along the way, we accumulate (in <tt>$acc</tt>) raw parse-tree
nodes corresponding to the path:
<ul><li><div class="Real-P">For normal <i>scan()</i> steps,

we create &lt;<em>lit</em>&gt;, &lt;<em>incl</em>&gt;, or &lt;<em>excl</em>&gt; elements
recording the matching string, with the <em>tmark</em> of the
terminal symbol </div></li>
<li><div class="Real-P">For <i>comp()</i> steps, we create &lt;<em>nt</em>&gt;
elements, with <em>name</em> and <em>mark</em> recording the
appropriate GI and annotation, and with content (found by a recursive
call) showing the raw parse tree for that nonterminal; if there is
more than one, we iterate over all of them.</div></li>
</ul>
</div>
<div class="Real-P">The function returns zero or more elements whose name is that on
the left-hand-side of <tt>$item</tt>, whose string value is the
input substring <tt>$from</tt> .. <tt>$to</tt>, and whose
children are the concatenation of (a) the children found by the
recursive call, with (b) those in the accumulator.
<div class="scrap"><span><a name="epi-all-node-sequences">&#x3008; 74 Define all-node-sequences() &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: ****************************************************************
   epi:all-node-sequences($item, $closure, $acc, $from, $to, $I)
:)
declare function epi:all-node-sequences(
  $Ecur as map(*),
  $meiClosure as map(xs:string, map(xs:integer, map(xs:string, item())*)),
  $lnAcc as item()*,
  $pFrom as xs:integer,
  $pTo as xs:integer,
  $I as xs:string,
  $leiVStack as map(*)*,
  $leiHStack as map(*)*
) as element()* {
  
  let $dummy := eri:notrace(eri:sXei($Ecur),
    'all-node-seqs (0) called with Ecur:')
  return 
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-loopcheck">Check for loops, which mean infinite ambiguity 75</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-basecase">Handle base case:  current item is initial 76</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-recursive">Handle recursive case 79</a></em> &#x3009;</span>  
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e340">[File Earley-parser-internals.xqm] 4</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Before we do any work, we should check to see whether we have
already dealt with this item, in this sequence of nodes.  If we have,
then we are looking at a sentence with an infinite number of parse
trees, and we need to snip the loop.
<div class="scrap"><span><a name="epi-ans-loopcheck">&#x3008; 75 Check for loops, which mean infinite ambiguity &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
  (: 1. Before anything else, loop detection:  have we already 
     dealt with this item, in this sequence of nodes? :)
  if (some $eiH in $leiHStack satisfies deep-equal($Ecur, $eiH) )
  then let $dummy := eri:notrace(eri:sXei($Ecur),
           'all-node-seqs (case 1) returns empty sequence, '
           || 'current item has been seen before.')
       return ()
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#epi-all-node-sequences">Define all-node-sequences() 74</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">The base case, on which we terminate because it means we have
completed the node sequence, is when the current Earley item is
initial.  The detection of this case is simplified by the fact that
all initial states are named q0, and only initial states are named q0.
So when we find such a state, we just wrap everything up and return it
to the caller.</div>
<div class="Real-P">N.B. we always return an element, regardless of how our
non-terminal is marked, but we pass the @mark attribute along
so the caller can convert the element to an attribute, or
replace it with its children, in a later pass which constructs
the AST from the raw parse tree.
<div class="scrap"><span><a name="epi-ans-basecase">&#x3008; 76 Handle base case:  current item is initial &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
  (: 2. Base case:  $Ecur is initial. :)
  else if ($Ecur('ri') = 'q0'
      and $Ecur('from') eq $Ecur('to')
      and $Ecur('from') eq $pFrom)
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e1857">Construct an element holding the node sequence 77</a>&#x3009;<br></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#epi-all-node-sequences">Define all-node-sequences() 74</a> &#x3009; <br></span>
</div>

For a state named q0, from = to should always be true.
And for all q0, from = $pFrom should also always be true,
or should follow from the tests made by the caller. 
But we check anyway.  I don't trust this belt, and I don't trust 
these suspenders. </div>
<div class="Real-P">On the output element, we record the input span in
attributes named <em>_from</em> and <em>_to</em>,
and the mark.
<i>And for the moment, as a debugging measure, we also
see whether we can successfully identify the RHS nonterminal
that led to the prediction of this nonterminal.  We already
have a little context information in the form of 
the vertical stack <tt>$leiVStack</tt>,
the horizontal stack <tt>$leiHStack</tt>,
and the node list <tt>$lnAcc</tt>.
Let's examine the tops of those stacks.</i>
<div class="scrap"><span><a name="d3e1857">&#x3008; 77 Construct an element holding the node sequence [continues <a href="#epi-ans-basecase">76 Handle base case:  current item is initial</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
  then 
    let $e := element nt {
                 $Ecur('rule')/@name,
                 attribute _from { $pFrom }, 
                 attribute _to { $pTo }, 
                 ( $Ecur('rule')/descendant::*
                                [@xml:id = $Ecur('ri')]
				/@mark
                   ,
                   $Ecur('rule')/@mark,
		   attribute mark { '^' }
                 )[1],
                 $lnAcc
               },
        $trace := eri:notrace(eri:sXei($Ecur),
                      'all-node-seqs (case 2) returns element ' 
		      || 'named ' || name($e) || ' for Ecur:')
    return $e
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">For safekeeping, here is the earlier version of this.
It used the nonterminal name as the GI for the element,
and it tried to handle attributes first.  Both of those
should now be handled by the AST constructor.
<div class="scrap"><span><a name="d3e1863">&#x3008; 78 Construct an element holding the node sequence [continues <a href="#epi-ans-basecase-2016"></a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
  then 
    let $e := element {$Ecur('rule')/@name} {
                 attribute _from { $pFrom },
                 attribute _to { $pTo },
                 ( $Ecur('rule')/descendant::*
                                [@xml:id = $Ecur('ri')]
				/@mark
                   ,
                   $Ecur('rule')/@mark
                 )[1],
                 $lnAcc[self::attribute()],
                 $lnAcc[not(self::attribute())]                 
               },
        $trace := eri:notrace(eri:sXei($Ecur),
                      'all-node-seqs (case 2) returns element ' 
		      || 'named ' || name($e) || ' for Ecur:')
    return $e
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

</div>

<div class="Real-P">In the recursive case, <tt>$Ecur</tt> shows, in its rule
location (= FSA state name or position), what symbol <tt>$sym</tt>
we must jump back past.  For example, if <tt>$Ecur</tt> is &#x201c;(0 8
Goal/ixml_0)&#x201d; (as it will be when we are constructing an XML
representation of an ixml grammar eight characters long), then we know
from the rule index <tt>ixml_0</tt> that we now need to find a
parse for <i>ixml</i> ending at position 8, and then
work out where that instance of <i>ixml</i> started.
</div>
<div class="Real-P">Find the item <tt>$eiPrev</tt> that was expecting that symbol
(there may be many); for each such item <tt>$eiPrev</tt>, the
Earley set documents a parse of <tt>$sym</tt> that dominates (or
generates) the input range from <tt>$eiPrev('to')</tt> to
<tt>$Ecur('to')</tt>.  In the example, we will first find
<tt>$sym</tt>, the nonterminal with an ID of <tt>ixml_0</tt>
in the rule for <i>Goal</i>.  How we look for
<tt>$eiPrev</tt> depends on what <tt>$sym</tt> is.
<div class="scrap"><span><a name="epi-ans-recursive">&#x3008; 79 Handle recursive case &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
  (: 3. Recursive case. :)
  else (: 3. $Ecur('ri') is not a q0 / initial state :)
    (: 3.a some preparation common to T and N alike :)
    let $riCur := $Ecur('ri'),
        $sym := $Ecur('rule')/descendant::*[@xml:id = $riCur],
        $nParent := $Ecur('rule')/@name/string()
    return
      <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-rec-terminal">Handle recursion on terminal 80</a></em> &#x3009;</span>
      <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-rec-nonterminal">Handle recursion on nonterminal 82</a></em> &#x3009;</span>
      <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-rec-whazzat">Raise error if neither terminal nor nonterminal 87</a></em> &#x3009;</span>
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#epi-all-node-sequences">Define all-node-sequences() 74</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">If <tt>$sym</tt> is terminal, then our clue for finding <tt>$eiPrev</tt>
is that the relation <tt>scan($eiPrev, $I) =
$Ecur</tt> holds. Find it, and then push
appropriate raw parse nodes 
onto the accumulator and recur.
Or rather, since there may be more than one,
find <em>them</em> (in <tt>$leiPrev</tt>) and then
recur on each of them, pushing the newly created parse node
<tt>$textnode</tt> onto the accumulator.
<div class="scrap"><span><a name="epi-ans-rec-terminal">&#x3008; 80 Handle recursion on terminal &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
      (: 3.b current $sym is terminal :)
      if (eri:fTerminal($sym)) then
         let $trace := eri:notrace(eri:sXei($Ecur),
                       'all-node-seqs (case 3b) '
                       || 'unscanning terminal symbol '
		       || $riCur) 
         let $cSymlength := eri:match-length($sym),
             $pMedial := xs:integer($Ecur('to')) - $cSymlength,
             $leiPrev := $meiClosure('to')($pMedial)[ 
                eri:fScanrelEE(.,$Ecur)
                (: and xs:integer(.('to')) eq $pMedial :)
             ],
	     $sVal := substring($I,$pMedial+1,$cSymlength),
	     
             $textnode := element { 
                (: Rename the terminal to reduce confusion
                between grammar and parse tree :)
                if ($sym/self::inclusion) 
                then 'incl' 
                else if ($sym/self::exclusion) 
                then 'excl' 
                else if ($sym/self::literal)
                then 'lit' 
		else 'terminal---'
	     } {
	        $sym/@xml:id, 
		$sym/@tmark,
	        $sym/@regex, 
		attribute string { $sVal },
		attribute cps { string-to-codepoints($sVal) }
             }

         (: recur on each possible previous node :)
         for $eiPrev in $leiPrev
         let $trace := if (count($leiPrev) gt 1)
	               then eri:notrace(eri:sXei($Ecur),
                            'all-node-seqs (case 3b) finds '
			    || count($leiPrev)
                            || ' predecessors, now recurring on eiPrev='
			    || eri:sXei($eiPrev))
		       else eri:notrace(eri:sXei($Ecur),
                            'all-node-seqs (case 3b) finds '
		            || count($leiPrev)
                            || ' predecessors, now recurring on eiPrev='
			    || eri:sXei($eiPrev))

         return epi:all-node-sequences($eiPrev,
                                       $meiClosure,
                                       ($textnode, $lnAcc),
                                       $pFrom,
                                       $pTo,
                                       $I,
                                       $leiVStack,
                                       ($Ecur, $leiHStack)
                                      )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ans-recursive">Handle recursive case 79</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">The initial version rendered terminals as text nodes and not as
elements.  So it had no place to put a <em>tmark</em>.
<div class="scrap"><span><a name="epi-ans-rec-terminal-2016">&#x3008; 81 Handle recursion on terminal &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
      (: 3.b current $sym is terminal :)
      if (eri:fTerminal($sym)) then
         let $trace := eri:notrace(eri:sXei($Ecur),
                       'all-node-seqs (case 3b) '
                       || 'unscanning terminal symbol '
		       || $riCur) 
         let $cSymlength := eri:match-length($sym),
             $pMedial := xs:integer($Ecur('to')) - $cSymlength,
             $leiPrev := $meiClosure('to')($pMedial)[ 
                eri:fScanrelEE(.,$Ecur)
                (: and xs:integer(.('to')) eq $pMedial :)
              ],
             $textnode := text { substring($I,$pMedial+1,$cSymlength) }
             (: let $trace := eri:notrace($textnode,
	                      'Adding a text node: ') :)
         (: recur on each possible previous node :)
         for $eiPrev in $leiPrev
         let $trace := if (count($leiPrev) gt 1)
	               then eri:notrace(eri:sXei($Ecur),
                            'all-node-seqs (case 3b) finds '
			    || count($leiPrev)
                            || ' predecessors, now recurring on eiPrev='
			    || eri:sXei($eiPrev))
		       else eri:notrace(eri:sXei($Ecur),
                            'all-node-seqs (case 3b) finds '
		            || count($leiPrev)
                            || ' predecessors, now recurring on eiPrev='
			    || eri:sXei($eiPrev))

         return epi:all-node-sequences($eiPrev,
                                       $meiClosure,
                                       ($textnode, $lnAcc),
                                       $pFrom,
                                       $pTo,
                                       $I,
                                       $leiVStack,
                                       ($Ecur, $leiHStack)
                                      )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>

</div>
<div class="Real-P">If <tt>$sym</tt> is nonterminal, we can find
<tt>$eiPrev</tt> by exploiting the fact that the relation
<tt>comp($EComp, $eiPrev, $G) = $Ecur</tt> holds.  The closure
should include at least one completion item of the form
(<tt>$eiPrev('to')</tt>, <tt>$Ecur('to')</tt>,
<tt>$sym</tt>, <tt>$ri</tt>), where <tt>$ri</tt> is a
final state of a rule for <tt>$sym</tt>.
</div>
<div class="Real-P">We're going to break this down into steps.
First, just identify this case (and possibly issue
a trace messsage).
<div class="scrap"><span><a name="epi-ans-rec-nonterminal">&#x3008; 82 Handle recursion on nonterminal &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
      (: 3.c current $sym is nonterminal :)
      else if ($sym/self::nonterminal) then 
         let $trace := eri:notrace(eri:sXei($Ecur), 
                       'all-node-seqs (case 3c) '
		       || 'trying to unparse nonterminal '
		       || $riCur) 
         <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-recnt-leiprev">Find the child completions for $sym 83</a></em> &#x3009;</span>
         <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-recnt-lnodechild">Find parse trees for the child completions 84</a></em> &#x3009;</span>
         <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-recnt-recur">Recur on each predictor 85</a></em> &#x3009;</span>
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ans-recursive">Handle recursive case 79</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">Then find all completion items (<tt>$leiPrev</tt>) for
nonterminal <tt>$sym</tt> finishing at this position.  That is, if
<tt>$sym</tt> is a RHS reference to <i>ixml</i>, the
completion items will have the form (<i>start</i>,
<i>to</i>, <i>ixml</i>/<i>q_f</i>).  What we
want is every item in the closure which (a) has the right
<i>to</i>-position and (b) is final for the right nonterminal.
<div class="scrap"><span><a name="epi-ans-recnt-leiprev">&#x3008; 83 Find the child completions for $sym &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
         let $leiPrev := $meiClosure('to')($Ecur('to'))[
           eri:fFinalEiPN(.,$Ecur('to'),$sym)
         ]
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ans-rec-nonterminal">Handle recursion on nonterminal 82</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Now, for each child completion, find all possible parse trees, and
then find all possible predictor items for <tt>$sym</tt> at the
start position of the completion item.  That is, all items ending
at that position, for which <tt>$sym</tt> is in the follow set.
<div class="scrap"><span><a name="epi-ans-recnt-lnodechild">&#x3008; 84 Find parse trees for the child completions &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
         for $eiCC at $nEiCC in $leiPrev
         let $trace := eri:notrace(eri:sXei($Ecur),
	       'all-node-seqs (case 3c) finds completion item '
               || '(' || $nEiCC || ' of '
	       || count($leiPrev) || ')'
               || ' for ' || $sym/@name
	       || ', namely ' || eri:sXei($eiCC)
	       || ' and calls all-trees for it.')
         let $lnodeChild := epi:all-trees($eiCC,
                                          $meiClosure,
	                                  $I,
					  $leiVStack), 
             $leiPredictors := $meiClosure('to')($eiCC('from'))
	                       [eri:fAdvanceNrelEE(.,$Ecur)
                                (: and .('to') eq $eiCC('from') :)]

	 (:
         let $trace := for $nCh in $lnodeChild
                       return eri:notrace($nCh,
                              'all-node-seqs got this back'
			      || ' from all-trees:') 
         :)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ans-rec-nonterminal">Handle recursion on nonterminal 82</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">For each pair of parse tree and predictor item,
we need to recur appropriately.
<div class="scrap"><span><a name="epi-ans-recnt-recur">&#x3008; 85 Recur on each predictor &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
         for $eiPred at $nEiP in $leiPredictors
         let $trace := eri:notrace(eri:sXei($Ecur),
	       'all-node-seqs (case 3c) finds predictor '
               || '(' || $nEiP || ' of '
	       || count($leiPredictors) || ')'
               || ' for ' || $sym/@name
	       || ', namely ' || eri:sXei($eiPred))
         
         for $nodeCh0 at $nNch in $lnodeChild
         <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-recnt-munge-mark">Adjust mark attribute on $nodeCh as needed 86</a></em> &#x3009;</span>
         let $trace := eri:notrace(eri:sXei($Ecur),
	       'all-node-seqs recurs on child'
               || '(' || $nNch
	       || ' of ' || count($lnodeChild) || '),'
               || ' (predictor' || $nEiP
	       || ' of ' || count($leiPredictors) || '),'
               || ' (Completion' || $nEiCC
	       || ' of ' || count($leiPrev) || '),'
			   )

         return epi:all-node-sequences($eiPred,
                                       $meiClosure,
                                       ($nodeCh, $lnAcc),
                                       $pFrom,
                                       $pTo,
                                       $I,
                                       $leiVStack,
                                       ($Ecur, $leiHStack)
                                      )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ans-rec-nonterminal">Handle recursion on nonterminal 82</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">There's one more complication.  The trees produced
by the call to <i>all-trees()</i> have <em>mark</em>
attributes reflecting the mark on the rule for the nonterminal.
If a mark is specified on the RHS reference to the nonterminal
(that would be the <tt>$sym</tt> element), it needs to
over-ride the mark on the rule.  So before we pop the
child nodes into the accumulator, we make sure their
<em>mark</em> attribute is correct.
<div class="scrap"><span><a name="epi-ans-recnt-munge-mark">&#x3008; 86 Adjust mark attribute on $nodeCh as needed &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
         let $nodeCh := 
             if (exists($sym/@mark)) 
             then element { name($nodeCh0) } {
	         $nodeCh0/(@* except @mark), 
	         $sym/@mark,
		 $nodeCh0/node()
	     }
             else $nodeCh0
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ans-recnt-recur">Recur on each predictor 85</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">If what we are looking at has not been recognized
as a terminal or a nonterminal, then we are out of luck
and can only report a problem.
<div class="scrap"><span><a name="epi-ans-rec-whazzat">&#x3008; 87 Raise error if neither terminal nor nonterminal &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
      else (: not terminal, not nonterminal, we have a problem :)
        &lt;error-in-all-node-sequences
          from="{$pFrom}" to="{$pTo}"&gt;{
            eri:sXei($Ecur)
          }&lt;/error-in-all-node-sequences&gt;
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ans-recursive">Handle recursive case 79</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Here we appear to have some cruft that has been commented
out but not removed.
<div class="scrap"><span><a name="epi-lnDepXCleC">&#x3008; 88 Define lnDepXClEc() &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
(: lnDepXClEc($Closure, $Ec):  from the Earley closure $Closure,
   extract the dependents of the node completed by $Ec.
:)
(: 
declare function epi:lnDepXClEc(
  $leiClosure as map(*)*, 
  $Ec as map(*)
) as item()* {
  &lt;lnDepXClEc-not-implemented/&gt;
};
  :)
(: eMakeEcLndepLaLa($Ec,$ln,$lA,$lC):  given a completion item $Ec,
   a (possibly partial) list of dependent nodes $ln, and 
   accumulated lists of attributes and children, construct an
   element.
 :)
 (:
declare function epi:eMakeEcLndepLaLc(
  $Ec as map(*),
  $lnDep as item()*
) as element() {
  let $gi := $Ec('rule')/@name,
      $lAtts := $lnDep[self::attribute()],
      $lChildren := $lnDep[self::element() 
                     or self::text() 
                     or self::comment() 
                     or self::processing-instruction()]
  return element {$gi} { $lAtts, $lChildren }
};

:)  
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>
</div>
</div>

<div class="div">

<h4><a name="epi-ast-from-raw" id="epi-ast-from-raw">6.2.4. </a>Extracting the abstract syntax tree from the raw parse tree</h4>
<div class="Real-P">The parse tree extraction routines defined elsewhere produce
the raw parse tree, but ixml requires that we return an abstract
syntax tree.  So we need a function to take a raw parse tree
and return the corresponding AST.</div>
<div class="Real-P">There are several different functions, depending on which
situation we are in.
<ul><li><div class="Real-P">The initial call expects to find the 'Goal' nonterminal at
the root of the raw parse tree; it then passes its child element to a
function that seeks to make the document element.</div>
<div class="Real-P">If that function returns multiple children, the function
provides an &lt;<em>ixml:multiple-roots</em>&gt; wrapper.</div></li>
<li><div class="Real-P">The function to make a document element
&#x2018;knows&#x2019; that so far we don't have any parent
element, so in the normal case it just recurs looking for a
nonterminal marked as an element.  It deals differently with
different cases:
<ul><li>A nonterminal marked &#x201c;<tt>^</tt>&#x201d; is passed to
an element constructor.</li>
<li>A nonterminal marked &#x201c;<tt>-</tt>&#x201d; is skipped; the
function recurs on its children.  (It is this recursion which
makes it possible for the function to return multiple results.)</li>
<li>A nonterminal marked &#x201c;<tt>@</tt>&#x201d; is serialized as an
element (as required by the spec).</li>
<li>A terminal is wrapped in an &lt;<em>ixml:wrapper</em>&gt;
element.</li>
</ul>
</div></li>
<li><div class="Real-P">The element constructor should be called only on nonterminals
marked as elements.  It serializes the nonterminal as an element and
calls other functions to collect its attributes and its
content.</div></li>
<li><div class="Real-P">The function to collect attributes for a parent element
just constructed will recur through the relevant subtree of the raw
parse tree, looking for nonterminals marked as attributes.  It will
recur through hidden nonterminals, stop the recursion on
element nonterminals, raise an error on terminals, and call an
attribute-value constructor when it finds a nonterminal marked as an
attribute.</div></li>
<li><div class="Real-P">The attribute-value constructor function recurs, gathering
character data from terminals and ignoring the markings on all
intervening nodes.</div></li>
<li><div class="Real-P">The function to gather content for a parent element just
constructed will recur through the relevant subtree of the raw parse
tree, ignoring attributes, serializing terminals, recurring through
hidden nonterminals, and calling the element constructor on
serializable nonterminals.</div></li>
</ul>
</div>

<div class="div">

<h5><a name="epi-ast-init" id="epi-ast-init">6.2.4.1. </a>The initial call</h5>

<div class="Real-P">The top-level AST constructor function descends past the Goal
wrapper and passes its one descendant to the document-element
constructor.  It assigns the result to a variable, so it can check how
many nodes came back: if more than one, a special wrapper is needed.
It also rewrites the outer element if needed, adding an ambi</div>
<div class="Real-P">guity
flag.</div>
<div class="Real-P">To handle the ambiguity flag, we accept a parameter showing how
many parse trees the caller got back from the
<i>recognizeX()</i> function; if it's greater than one, we
mark the result with <tt>ixml:state="ambiguous"</tt>, declaring
the namespace as <tt>xmlns:ixml="http://invisiblexml.org/NS"</tt>.
<div class="scrap"><span><a name="epi-astXparsetree">&#x3008; 89 Define astXparsetree() to make AST from raw parse &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
declare function epi:astXparsetree(
  $E as element(nt),
  $cpt as xs:integer
) as node()* {
  if (empty($E/nt)) 
  then
      element error {
          text {
              "Parse tree had wrapper",
              "but no content."
          }
      }
  else
      let $doc0 :=
              for $c in $E/*
              return epi:doc-elementXpt($c),
          $doc1 :=
	      if (count($doc0) eq 1) 
              then $doc0 
	      else if (count($doc0) eq 0) 
              then element ixml:no-roots {}
	      else element ixml:multiple-roots {
	          $doc0
	      }
      return
          if ($cpt eq 1) 
          then $doc1
	  else element { name($doc1) } {
	       attribute ixml:state { 'ambiguous' },
	       $doc1/@*, 
	       $doc1/node()
	  }
};
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-docelXpt">Define doc-elementXpt() to make AST for document element 90</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-elXpt">Define elementXpt() to make AST for one element 92</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-attsXpt">Define attributesXpt() to collect attributes 93</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-avXpt">Define avXpt() to collect attribute value 94</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-contentXpt">Define contentXpt() 95</a></em> &#x3009;</span>
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e340">[File Earley-parser-internals.xqm] 4</a> &#x3009; <br></span>
</div>
</div>
</div>

<div class="div">

<h5><a name="epi-ast-outer" id="epi-ast-outer">6.2.4.2. </a>The document-element constructor</h5>
<div class="Real-P">The constructor for the document element is distinct from the
ordinary element constructor because in the special case that the
top-most node of the result is an attribute or a terminal symbol, we
want to coerce the result into an element.</div>
<div class="Real-P">
<div class="scrap"><span><a name="epi-docelXpt">&#x3008; 90 Define doc-elementXpt() to make AST for document element &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
declare function epi:doc-elementXpt(
  $E as element()*
) as node()* {
  (: Normal case :)
  if ($E/self::nt[@mark = '^' or not(@mark)]) 
  then epi:elementXpt($E)
  
  (: Hidden wrapper, recur :) 
  else if ($E/self::nt[@mark = '-']) 
  then for $c in $E/*
      return epi:doc-elementXpt($c) 

  (: Attribute (sic) :) 
  else if ($E/self::nt[@mark = '@']) 
  then element { $E/@name } {
      attribute ixml:warning {
          'Attribute found as root of AST'
      }
  }

  (: Terminal (sic) :) 
  else if ($E/self::*[name() = ('lit', 'incl', 'excl')])  
  then element ixml:terminal {
      attribute warning { 
          'Terminal found as root of AST'
      }, 
      text { <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-sXpt">Make string from raw parse tree terminal $E 91</a></em> &#x3009;</span> } 
  }
  
  (: Unexpected input: what? :)
  else &lt;oops&gt;{$E}&lt;/oops&gt;
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#epi-astXparsetree">Define astXparsetree() to make AST from raw parse 89</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">There are a couple of places where we will need to
make a string from a raw parse tree terminal. This
involves checking that the terminal is not marked
hidden and then serializing from the list of code points.
(An approximation of the string value will be in the

<div class="scrap"><span><a name="epi-sXpt">&#x3008; 91 Make string from raw parse tree terminal $E &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
if ($E/@tmark = '-')  
       then ()  
       else codepoints-to-string(
               for $t in tokenize(
                   normalize-space($E/@cps),
	           '\s')  
               return xs:integer($t)
       )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#epi-docelXpt">Define doc-elementXpt() to make AST for document element 90</a> &#x3009; &#x3008; <a href="#epi-avXpt">Define avXpt() to collect attribute value 94</a> &#x3009; &#x3008; <a href="#epi-contentXpt">Define contentXpt() 95</a> &#x3009; <br></span>
</div>

</div>
</div>

<div class="div">

<h5><a name="epi-ast-element" id="epi-ast-element">6.2.4.3. </a>The element constructor</h5>
<div class="Real-P">The ordinary element constructor creates an element with the
appropriate name, then calls two functions to traverse the current
part of the raw parse tree and collect attributes and content,
respectively.  The argument is required to be an &lt;<em>nt</em>&gt;
element and expected to be marked &#x201c;<tt>^</tt>&#x201d;.</div>
<div class="Real-P">
<div class="scrap"><span><a name="epi-elXpt">&#x3008; 92 Define elementXpt() to make AST for one element &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
declare function epi:elementXpt(
  $E as element()
) as node()* {
  element { $E/@name } {
      if ($E/@mark = ('-', '@'))
      then attribute ixml:warning {
          'Wrong mark (' || $E/@mark 
          || ') on nonterminal'
      }
      else (),
      for $c in $E/*
      return epi:attributesXpt($c), 
      for $c in $E/*
      let $dummy := eri:trace(
          concat(name($c), '/', $c/@name, '/', $c/@xml:id),
          'constructing content from:') 
      let $n := epi:contentXpt($c)
      let $dummy := for $chunk in $n return
          if ($chunk instance of text())
          then eri:trace(concat('/',
	  string-join(string-to-codepoints($chunk),' '), '/'), 'eXpt got text node') 
          else if ($chunk instance of element())
	  then eri:trace($chunk/name(), 'eXpt gets element:') 
	  else eri:trace($chunk, 'eXpt gets unknown item:') 
      return $n
  }
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#epi-astXparsetree">Define astXparsetree() to make AST from raw parse 89</a> &#x3009; <br></span>
</div>
</div>
</div>

<div class="div">

<h5><a name="epi-ast-attcoll" id="epi-ast-attcoll">6.2.4.4. </a>The attribute collector</h5>
<div class="Real-P">The attribute collector traverses the subtree looking for things to
serialize as attributes on the current element.  For
each such nonterminal, it constructs the attribute and
called the attribute value constructor to construct
the value.
<div class="scrap"><span><a name="epi-attsXpt">&#x3008; 93 Define attributesXpt() to collect attributes &#x3009; &#x2261;</a></span>
<pre class="scrapbody"> 
declare function epi:attributesXpt(
  $E as element()
) as attribute()* {
  (: Main case: make an attribute :)
  if ($E/self::nt[@mark = '@']) 
  then attribute { $E/@name } {
      string-join(
          (for $c in $E/*
          return epi:avXpt($c)),
	  '')
  }

  (: skip terminals and elements :)
  else if ($E/name() = ('lit', 'incl', 'excl')) 
  then () 
  else if ($E/self::nt[@mark = '^' or not(@mark)])
  then ()

  (: recur through hidden nt :)
  else if ($E/self::nt[@mark = '-']) 
      then for $c in $E/*
      return epi:attributesXpt($c)

  else eri:trace((),
      '! unexpected argument to attributesXpt()') 
     
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#epi-astXparsetree">Define astXparsetree() to make AST from raw parse 89</a> &#x3009; <br></span>
</div>
</div>
</div>

<div class="div">

<h5><a name="epi-ast-attvalue" id="epi-ast-attvalue">6.2.4.5. </a>The attribute value constructor</h5>
<div class="Real-P">The attribute value constructor traverses a subtree constructing
the string value of an attribute.  The spec says we serialize &#x201c;all
non-hidden terminal descendants of the node (regardless of marking of
intermediate nonterminals)&#x201d;. So we ignore the &#x201c;<tt>^</tt>&#x201d;
marking and treats it the same as &#x201c;<tt>-</tt>&#x201d;, recurring
through it. For an example of this treatment, see the handling of
<i>dchar</i> and <i>schar</i> in the current ixml
grammar.
<div class="scrap"><span><a name="epi-avXpt">&#x3008; 94 Define avXpt() to collect attribute value &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
declare function epi:avXpt(
  $E as element()
) as xs:string* {
  if ($E/(self::incl or self::excl or self::lit))
  then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-sXpt">Make string from raw parse tree terminal $E 91</a></em> &#x3009;</span> 
  else for $c in $E/*
       return epi:avXpt($c)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#epi-astXparsetree">Define astXparsetree() to make AST from raw parse 89</a> &#x3009; <br></span>
</div>

</div>
</div>

<div class="div">

<h5><a name="epi-ast-content" id="epi-ast-content">6.2.4.6. </a>The content collector</h5>
<div class="Real-P">The content collector traverses the subtree looking for things to
serialize as content of the current element and either
serializing them itself (if terminals) or passing them to the
element constructor.
<div class="scrap"><span><a name="epi-contentXpt">&#x3008; 95 Define contentXpt() &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
declare function epi:contentXpt(
  $E as element()
) as item()* {
  if ($E/self::nt[@mark = '^' or not(@mark)])
  then epi:elementXpt($E)
  else if ($E/self::nt[@mark = '-'])
  then for $c in $E/*
       return epi:contentXpt($c)
  else if ($E/self::nt[@mark = '@'])
  then ()
  else if ($E[self::incl or self::excl or self::lit])
  then text { <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-sXpt">Make string from raw parse tree terminal $E 91</a></em> &#x3009;</span> }
  else element ixml:unexpected {
       attribute f { "epi:contentXpt" }, 
       $E
  }
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#epi-astXparsetree">Define astXparsetree() to make AST from raw parse 89</a> &#x3009; <br></span>
</div>

</div>
</div>
</div>
</div>


<div class="div">

<h3><a name="legacy-Gluschkov.xqm" id="legacy-Gluschkov.xqm">6.3. </a>Construction of the Gluschkov automaton</h3>
<div class="Real-P">The file Gluschkov.xqm has routines for annotating
a grammar with attributes that allow the right-hand
sides to be interpreted as Gluschkov automata:  that is,
finite state automata whose states are the basic symbols
of the regular expression.
<div class="scrap"><span><a name="d3e2229">&#x3008; 96  [File Gluschkov.xqm]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
module namespace gl =
"http://blackmesatech.com/2019/iXML/Gluschkov";

(: Constructs a Gluschkov automaton for ixml :)

(: GPL ...:) 

<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-prolog">Prolog for Gluschkov module 97</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME">Define function gl:ME() 98</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-merge">Define gl:merge() 116</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-read-one-ixml-char">Define gl:read-one-char-spec() 100</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-trace">Define trace() function for debugging 54</a></em> &#x3009;</span>
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>
</div>
<div class="Real-P">This module is one place affected by the syntax changes
between 2013 and 2021.  Most scraps are defined twice,
once in the initial version following the 2013 syntax,
and again for today's syntax. 
(Steven's original paper said something about bootstrapping
and supporting multiple syntaxes, but I got confused and am
not going to try to do that.  Too clever for me.)
</div>

<div class="div">

<h4><a name="leggl-prolog" id="leggl-prolog">6.3.1. </a>Module prolog</h4>
<div class="Real-P">The module prolog defines a namespace for follow sets, and a
variable with the namespace name.  We also import the
<i>d2x</i> library so we can use its hex-to-decimal
conversion.
<div class="scrap"><span><a name="gl-prolog">&#x3008; 97 Prolog for Gluschkov module &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
declare namespace follow =
"http://blackmesatech.com/2016/nss/ixml-gluschkov-automata-followset";

import module namespace d2x =
'http://blackmesatech.com/2019/iXML/d2x'
at "d2x.xqm";

declare variable $gl:follow-ns :=
"http://blackmesatech.com/2016/nss/ixml-gluschkov-automata-followset";
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e2229">[File Gluschkov.xqm] 96</a> &#x3009; <br></span>
</div>

</div>
</div>

<div class="div">

<h4><a name="leggl-ME" id="leggl-ME">6.3.2. </a>Calculating the Gluschkov automaton <i>M</i> <i><i>E</i></i></h4>


<div class="Real-P">For a regular expression <i>E</i>, the Gluschkov automaton
(conventionally referred to as <i>M</i> <i><i>E</i></i>) is a finite state automaton
derived from (and in some sense constructed on top of) <i>E</i>.  The
states of <i>M</i> <i><i>E</i></i> are the basic symbols of <i>E</i>, with the fairly
straightforward interpretation that we are in a given state <i>q</i> if and
only if we have just read an input character (or, in the general case,
character sequence) that matches the atomic symbol <i>q</i>.  We calculate
the Gluschkov automaton by following the algorithm laid out in
Br&#xfc;ggemann-Klein 1993, adapted for the XML form of ixml grammars.</div>
<div class="Real-P">Each node <i>$E</i> in the expression gets:
<ul><li><em>id</em> to identify the expression; in the case of positions (i.e. 
       occurrences of symbols in the alphabet, as opposed to
       parenthesized expressions etc.), this also
       serves as an identifier for the FSA state.</li>
<li><em>first</em> = set of positions which match the first symbol of some word
       in <i>L($E)</i></li>
<li><em>last</em> = set of positions which match the last symbol in some word
       in <i>L($E)</i></li>
<li><em>nullable</em> = true iff <i>L($E)</i> contains the empty
word</li>
</ul>
</div>
<div class="Real-P">We also have attributes to represent the
<i>follow</i>(<i>exp</i>, <i>sym</i>) function
for <i>exp</i>=<i>$E</i>.  For each position $p in $E
we have an attribute in the follow namespace whose local name is the
ID of $p; the value of the attribute is the set of positions which can
follow $p in a path through $E.
</div>
<div class="Real-P">By representing follow($E,$p) as an attribute on $E we avoid having
to traverse the tree multiple times.
</div>

<div class="Real-P">The
construction of the Gluschkov automaton consists largely of
calculating, from the structure of <i>E</i>, which symbols can follow which
other symbols, and defining an appropriate transition function.
Along the way, various auxiliary functions are computed for each
subexpression of <i>E</i>.</div>
<div class="Real-P">For the right-hand side of a rule in an ixml grammar, the basic
symbols of the expression are terminal and nonterminal symbols, and
the subexpressions include both the basic symbols and the other
elements in the XML representation of the right-hand side.  For each
subexpression, we add attributes to record various values:
<ul><li>an ID (for use in referring to the state)</li>
<li><em>nullable</em> (is the empty string in the language
defined by this sub-expression?)</li>
<li><em>first</em> (what are the initial states in the
sub-automaton for this sub-expression?)</li>
<li><em>last</em> (what are the final states in the
sub-automaton for this sub-expression?)</li>
<li>for each state <i>q</i> within (the sub-automaton for) this
sub-expression, what are the follow states of <i>q</i>?  Here, we need one
attribute for every state within the sub-expression; we make them by
creating, for each such state, an attribute with a local name matching
the ID of the state, in a namespace designed to hold such follow-state
attributes.  So if the states in a given expression are named
<i>q0</i>, <i>q1</i>, and <i>q2</i>, we would
have attributes named <i>follow:q0</i>,
<i>follow:q1</i>, and <i>follow:q2</i>.</li>
<li>For later use in recognition, it will also be helpful to
calculate an XPath 3 regular expression that matches the
terminal.</li>
</ul>
These attributes are for the most part of only transient interest:
they are essential for calculating information for the next higher
level of sub-expression, but the information we care about when
running the Earley parser is just the information on the top-level
element of the right-hand side.</div>
<div class="Real-P">Since the values of these attributes are in general calculated
inductively, the first step in handling any element <i>e</i> is to recur
to handle the element's children, and then to construct the values
for <i>e</i> itself.
<div class="scrap"><span><a name="gl-ME">&#x3008; 98 Define function gl:ME() &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
declare function gl:ME (
  $E as element()
) as element() {
  let $children := for $c in $E/node() 
                   return if ($c/self::element())
                          then gl:ME($c)
                          else $c,
      $ch := $children[self::element()]
  return <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-identity">Handle leaf nodes 101</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-terminals">Handle terminal nodes 104</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-nonterminal">Handle nonterminal symbols 105</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-option">Handle options 106</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-repeats">Handle repetitions 108</a></em> &#x3009;</span>   
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-sep">Handle separator expressions 117</a></em> &#x3009;</span>     
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-alt">Handle alt elements 119</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-def">Handle alts elements (= def) 121</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-rule">Handle rule elements 125</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-comment">Handle comment elements 127</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-ixml">Handle ixml elements (grammars) 128</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-whahhh">Handle unexpected elements 129</a></em> &#x3009;</span>
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e2229">[File Gluschkov.xqm] 96</a> &#x3009; <br></span>
</div>
</div>

<div class="Real-P">In the 2013 grammar supported by Aparecium 0.1, the elements
&lt;<em>quoted</em>&gt;, &lt;<em>charset</em>&gt;, and several others were always
assumed wrapped in a &lt;<em>terminal</em>&gt; element.  They thus occur below
the level of the basic symbol and need no decorations.  We need to
handle them, since when the function is called on their parent
element, it will recursively be called on them, too.  But they can and
should be returned without change. 
<div class="scrap"><span><a name="gl-ME-identity-2013">&#x3008; 99 Handle leaf nodes (v0.1) &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
if ($E/(self::quoted
      or self::charset or self::exclude
      or self::range
      or self::schar or self::dchar))
then 
      $E</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>

</div>
<div class="Real-P">In the 2021 grammar, the &lt;<em>range</em>&gt; and
&lt;<em>class</em>&gt; elements fall into this category (always
children of &lt;<em>inclusion</em>&gt; or &lt;<em>exclusion</em>&gt;.
The &lt;<em>literal</em>&gt; element falls into this category
when it is a child of &lt;<em>inclusion</em>&gt; or &lt;<em>exclusion</em>&gt;,
but it does no harm to handle it separately.</div>
<div class="Real-P">For ranges, the calculation of the correct regular
is straightforward in the simple case:  put a hyphen
between the values of the <em>from</em> and
<em>to</em> attributes, and wrap the entire thing
in square brackets.  But while those attributes
will usually contain single characters, they can
contain doubled quotation marks or hexadecimal strings
preceded by '#'.  It would be tempting to inline this,
but it's just complicated enough that I am going to write
a utility function to do it.
<div class="scrap"><span><a name="gl-read-one-ixml-char">&#x3008; 100 Define gl:read-one-char-spec() &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
declare function gl:read-one-char-spec(
  $s as xs:string
) as xs:string {
  if (string-length($s) eq 1)
  then string($s)
  else if ($s eq '""') 
  then '"' 
  else if ($s eq "''") 
  then "'"
  else if (starts-with($s,'#'))
  then codepoints-to-string(d2x:x2d(substring($s, 2)))
  else ""
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e2229">[File Gluschkov.xqm] 96</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Armed with that little function, we can easily
specify the regex for a range.
<div class="scrap"><span><a name="gl-ME-identity">&#x3008; 101 Handle leaf nodes &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
if ($E/self::range)
then 
   element { name($E) } {
      $E/@*, 
      attribute regex {
         '['
         || gl:read-one-char-spec(string($E/@from))
	 || '-'
         || gl:read-one-char-spec(string($E/@to))
	 || ']'	 
      },
      $E/child::node()
   }
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e2458">Handle character-class expressions 102</a>&#x3009;<br></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 98</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">For character-class expressions, the regular expression we need is
also very simple: just the class code wrapped in &#x201c;<tt>\p{
... }</tt>&#x201d;.
<div class="scrap"><span><a name="d3e2458">&#x3008; 102 Handle character-class expressions [continues <a href="#gl-ME-identity">101 Handle leaf nodes</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
else if ($E/self::class)
then 
   element { name($E) } {
      $E/@*, 
      attribute regex { '\p{' || $E/@code || '}'}
   }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">For terminal symbols, all attribute values are straightforward.
They are non-nullable, they are their own first and last
states, and they have no follow states.  In 2013, all terminals
were &lt;<em>terminal</em>&gt; elements. 
<div class="scrap"><span><a name="gl-ME-terminals-2013">&#x3008; 103 Handle terminal nodes (v0.1) &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
if ($E/self::terminal)
then let $id := '_t_' || (1 + count($E/preceding::terminal))
     return element terminal {
       $E/@*,
       attribute xml:id { $id },
       attribute nullable { false() },
       attribute first { $id },
       attribute last { $id },
       attribute {QName($gl:follow-ns, "follow:" || $id)} { },
       $children
     }</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>
</div>
<div class="Real-P">In 2021, we distinguish several different terminals.
<div class="scrap"><span><a name="gl-ME-terminals">&#x3008; 104 Handle terminal nodes &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
if ($E/self::inclusion or $E/self::exclusion
    or $E/self::literal)
then
      let $id := '_t_' 
                 || (1 + count(($E/preceding::* | $E/ancestor::*)
                    [self::inclusion 
                    or self::exclusion
		    or self::literal])), 
          $re := 'dummy' (:if ($E/self::inclusion) 
                 then gl:inclusion-regex($E) 
                 else if ($E/self::exclusion)
                 then gl:exclusion-regex($E) 
                 else if ($E/self::literal)
		 then gl:literal-regex($E)
		 else '[! error in gl:ME !]'
		 :)
      return element {name($E)} {
         $E/@*,
         attribute xml:id { $id },
         attribute nullable { false() },
         attribute first { $id },
         attribute last { $id },
         attribute {QName($gl:follow-ns, "follow:" || $id)} { },
	 attribute regex { $re },
         $children
      }</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 98</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">We have now committed to writing functions to create
regular expressions for inclusions, exclusions, and literals.
(But it's not the most pressing need, so for the moment
I'm commenting it out.)
</div>
<div class="Real-P">Nonterminals are similarly straightforward:  from the
point of view of the Gluschkov automaton, they are
indistinguishable from terminals.
<div class="scrap"><span><a name="gl-ME-nonterminal">&#x3008; 105 Handle nonterminal symbols &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
if ($E/self::nonterminal)
then
     let $id := $E/@name || '_'
                || (1 + count($E/preceding::nonterminal
                              [@name = $E/@name]))
     return element nonterminal {
       $E/@*,
       attribute xml:id { $id },
       attribute nullable { false() },
       attribute first { $id },
       attribute last { $id },
       attribute {QName($gl:follow-ns, "follow:" || $id)} { },
       $children
     }</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 98</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Syntactically, an option is an expression to which a question mark
has been added.  So any option <i>E</i> has the form (<i>F</i>?).  <i>E</i> is
nullable regardless of whether <i>F</i> is or not, and <i>E</i> has the same
first, final, and follow sets as <i>F</i>.
Note than an &lt;<em>option</em>&gt; should only ever have one child element:
a terminal symbol (inclusion, exclusion, literal), a nonterminal
symbol, or a set of alternatives (&lt;<em>alts</em>&gt;).  If we ever see
anything else, this case will not process it and it will fall through
to the error case.
<div class="scrap"><span><a name="gl-ME-option">&#x3008; 106 Handle options &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
if ($E/self::option
    [count(*) eq 1]
    [child::*[self::inclusion
              or self::exclusion
              or self::literal 
              or self::nonterminal 
	      or self::alts]])
then
     let $id := 'exp_option_' || (1 + count($E/preceding::option))
     return element option {
       $E/@*,
       attribute xml:id { $id },
       attribute nullable { true() },
       attribute first { $children/@first },
       attribute last { $children/@last },
       for $follow-att in $children/@follow:* 
       return $follow-att,
       $children
     }</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 98</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Repeats will have either one child element or two.  The
first will be a terminal, a nonterminal, or a set of alternatives;
the optional second child is a separator.  If anything else is
encountered, we are not ready for it and we'll fall through to
the error case.</div>
<div class="Real-P">In the 2013 grammar, a set of alternatives was a
&lt;<em>def</em>&gt; element: 
<div class="scrap"><span><a name="gl-ME-repeats-2013">&#x3008; 107 Handle repetitions (v0.1) &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
if ($E[self::repeat0 or self::repeat1]
      [*[1][self::terminal or self::nonterminal or self::def]]
      [count(*) eq 1 or child::*[2][self::sep]]
         ) 
then
     let $gi := name($E)
     let $id := 'exp_' || $gi || '_' 
                || (1 + count($E/preceding::*[name() = $gi])),
         $F := gl:notrace($ch[1], "repetition factor F: "),
         $G := gl:notrace($ch[2], "repetition sep G: ")
     return element {$gi} {
       $E/@*,
       attribute xml:id { $id },
       attribute nullable { 
         if ($gi = 'repeat0') 
         then true() 
         else $F/@nullable
       },
       attribute first { 
         if (xs:boolean($F/@nullable) = true())
         then concat($F/@first, ' ', $G/@first)
         else $F/@first
       },
       attribute last { 
         if (xs:boolean($F/@nullable) = true())
         then concat($F/@last, ' ', $G/@last)
         else $F/@last
       },
       <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-rep-follow">Calculate follow:* attributes for repetitions 109</a></em> &#x3009;</span>
       ,
       $children
     }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>
</div>

<div class="Real-P">In 2021, the functionality is the same, but the
choice element is named &lt;<em>alts</em>&gt;:
<div class="scrap"><span><a name="gl-ME-repeats">&#x3008; 108 Handle repetitions &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
if ($E[self::repeat0 or self::repeat1]
      [*[1]
        [self::inclusion or self::exclusion
        or self::literal
        or self::nonterminal
	or self::alts]]
      [count(*) eq 1 
      or child::*[2][self::sep]]) 
then let $gi := name($E)
     let $id := 'exp_' || $gi || '_' 
                || (1 + count($E/preceding::*[name() = $gi])),
         $F := gl:notrace($ch[1], "F: "),
         $G := gl:notrace($ch[2], "G: ")
     return element {$gi} {
       $E/@*,
       attribute xml:id { $id },
       attribute nullable { 
         if ($gi = 'repeat0') 
         then true() 
         else $F/@nullable
       },
       attribute first { 
         if (xs:boolean($F/@nullable) = true())
         then concat($F/@first, ' ', $G/@first)
         else $F/@first
       },
       attribute last { 
         if (xs:boolean($F/@nullable) = true())
         then concat($F/@last, ' ', $G/@last)
         else $F/@last
       },
       <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-rep-follow">Calculate follow:* attributes for repetitions 109</a></em> &#x3009;</span>
       ,         
       $children
     }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 98</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The calculation of the follow set here has several
cases.  Watch carefully.  First case:  no separator.
So for all positions <i>p</i> in the expression <i>E</i>,
<ul><li>if <i>p</i> is in last(<i>E</i>)
then follow(<i>E</i>*, <i>p</i>) is 
the union of follow(<i>E</i>, <i>p</i>) with first(<i>E</i>)</li>
<li>otherwise
follow(<i>E</i>*, <i>p</i>) is  
just follow(<i>E</i>, <i>p</i>)
with no additions.</li>
</ul>
<div class="scrap"><span><a name="gl-ME-rep-follow">&#x3008; 109 Calculate follow:* attributes for repetitions &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
       if (count($ch) eq 1)
       then
         let $lastF := tokenize($F/@last,'\s+'),
             $firstF := tokenize($F/@first,'\s+')
         for $a in $F/@follow:*
         return if (local-name($a) = $lastF)
           then attribute { 
               QName($gl:follow-ns, "follow:"||local-name($a) ) 
             } { 
               gl:merge((tokenize($a,'\s+'), $firstF))    
             }
           else $a
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e2628">Calculate follow-set for repetition with separator 110</a>&#x3009;<br></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME-repeats-2013">Handle repetitions (v0.1) 107</a> &#x3009; &#x3008; <a href="#gl-ME-repeats">Handle repetitions 108</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">If there is a separator, then the same principle
applies, but things are complicated by the presence
of the separator in the way.
For all <i>p</i>
in <i>F</i>*<i>G</i> or <i>F</i>+<i>G</i>, its follow-set depends
on <ul><li>whether <i>p</i> is in <i>F</i> or in <i>G</i>,</li>
<li>whether it's in last(<i>F</i>) or last(<i>G</i>),
and </li>
<li>whether <i>F</i> and <i>G</i> are nullable.</li>
</ul>
So we break out the detailed calculations.
The overall pattern is as follows.  We pre-calculate
<ul><li>the two <i>last()</i> sets,</li>
<li>the two <i>first()</i> sets,</li>
<li>whether <i>F</i> and <i>G</i> are nullable, and</li>
<li>for each position in <i>F</i> or <i>G</i>, its local
name and its follow-set within <i>F</i> or <i>G</i>.</li>
</ul>
<div class="scrap"><span><a name="d3e2628">&#x3008; 110 Calculate follow-set for repetition with separator [continues <a href="#gl-ME-rep-follow">109 Calculate follow:* attributes for repetitions</a>]  &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
       else (: count($children) eq 2 :)
         let $lastF := tokenize($F/@last,'\s+'),
             $lastG := tokenize($G/@last,'\s+'),
             $firstF := tokenize($F/@first,'\s+'),
             $firstG := tokenize($G/@first,'\s+'),
             $nullableF := (xs:boolean($F/@nullable) = true()), 
             $nullableG := (xs:boolean($G/@nullable) = true())
         return 
           for $a in $children/@follow:* 
           let $p := local-name($a),
               $follow0 := tokenize($a,'\s+')
           let $followset :=  
             <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-rep-follow-sep-1">Follow set when p in last(F), G nullable 111</a></em> &#x3009;</span>
             <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-rep-follow-sep-2">Follow set when p in last(F), G not nullable 112</a></em> &#x3009;</span>
             <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-rep-follow-sep-3">Follow set when p in last(G), F nullable 113</a></em> &#x3009;</span>
             <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-rep-follow-sep-4">Follow set when p in last(G), F not nullable 114</a></em> &#x3009;</span>
             <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-rep-follow-sep-5">Follow set when p non-final in F or G 115</a></em> &#x3009;</span>
           return attribute { 
                    QName($gl:follow-ns, 
                          "follow:"||local-name($a) ) 
                } { 
                    $followset    
                    }</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">If <i>p</i> is final in <i>F</i> and <i>G</i> is nullable, then it's final
in <i>F</i>*<i>G</i> or <i>F</i>+<i>G</i> and can thus be followed by any first
state of <i>G</i> and any first state of <i>F</i>, as well as (naturally)
its follow-set within <i>F</i>:
<div class="scrap"><span><a name="gl-ME-rep-follow-sep-1">&#x3008; 111 Follow set when p in last(F), G nullable &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
             if ($p = $lastF and $nullableG) 
             then gl:merge(($follow0, $firstG, $firstF))
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e2628">Calculate follow-set for repetition with separator 110</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">If <i>p</i> is final in <i>F</i> and <i>G</i> is <em>not</em> nullable, 
then its follow-set omits the first sets of <i>F</i>. 
<div class="scrap"><span><a name="gl-ME-rep-follow-sep-2">&#x3008; 112 Follow set when p in last(F), G not nullable &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
             else if ($p = $lastF and not($nullableG))
             then gl:merge(($follow0, $firstG))
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e2628">Calculate follow-set for repetition with separator 110</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">If <i>p</i> is final in <i>G</i> and <i>F</i> is nullable, 
then we again have a three-way merge for its follow-set:
its follow-set within <i>G</i>, the first-set of <i>F</i>, and
(skipping <i>F</i> entirely, since it's nullable)
the first-set of <i>G</i>. 
<div class="scrap"><span><a name="gl-ME-rep-follow-sep-3">&#x3008; 113 Follow set when p in last(G), F nullable &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
             else if ($p = $lastG and $nullableF)
             then gl:merge(($follow0, $firstG, $firstF))
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e2628">Calculate follow-set for repetition with separator 110</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">If <i>p</i> is final in <i>G</i> and <i>F</i> is <em>not</em> nullable, 
then the first-set of <i>G</i> is not included in the follow-set
of <i>p</i>.
<div class="scrap"><span><a name="gl-ME-rep-follow-sep-4">&#x3008; 114 Follow set when p in last(G), F not nullable &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
             else if ($p = $lastG and not($nullableF))
             then gl:merge(($follow0, $firstF))
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e2628">Calculate follow-set for repetition with separator 110</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">Finally, if none of the above are true, then <i>p</i>
is non-final in either <i>F</i> or <i>G</i> and its follow-set is
unaffected by the repetition operator, so we just copy it
out again.
<div class="scrap"><span><a name="gl-ME-rep-follow-sep-5">&#x3008; 115 Follow set when p non-final in F or G &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
             else string($a)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e2628">Calculate follow-set for repetition with separator 110</a> &#x3009; <br></span>
</div>
</div>

<div class="Real-P">We have appealed to a little utility function for merging
sets of IDs.  It's quite straightforward, really, thanks
to <i>distinct-values()</i>.
<div class="scrap"><span><a name="gl-merge">&#x3008; 116 Define gl:merge() &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
declare function gl:merge(
  $ids as xs:string*
) as xs:string {
  string-join(distinct-values($ids),' ')
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#d3e2229">[File Gluschkov.xqm] 96</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">The &lt;<em>sep</em>&gt; element contains a single factor and
changes none of its properties.
<div class="scrap"><span><a name="gl-ME-sep">&#x3008; 117 Handle separator expressions &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
if ($E/self::sep
           [count(*) eq 1]
           [child::*[self::inclusion
                     or self::exclusion 
                     or self::literal 
                     or self::nonterminal 
                     or self::alts]]
          ) then
     let $id := 'exp_sep_'
                || (1 + count($E/preceding::sep)) 
     return element sep {
       $E/@*,
       attribute xml:id { $id },
       $ch/@nullable,
       $ch/@first,
       $ch/@last,
       $ch/@follow:*,
       $children
     }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 98</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">In 2013 the element names were different.  (Yawn.)
<div class="scrap"><span><a name="gl-ME-sep-2013">&#x3008; 118 Handle separator expressions (v0.1) &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
if ($E/self::sep
           [count(*) eq 1]
           [child::*[self::terminal 
                     or self::nonterminal
                     or self::def]]
          ) then
     let $id := 'exp_sep_'
                || (1 + count($E/preceding::sep)) 
     return element sep {
       $E/@*,
       attribute xml:id { $id },
       attribute nullable { $ch/@nullable },
       attribute first { $ch/@first },
       attribute last { $ch/@last },
       for $follow-att in $ch/@follow:* 
       return $follow-att,
       $children
     }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>

</div>
<div class="Real-P">An &lt;<em>alt</em>&gt; is one choice among (sometimes) several; it
contains a sequence of terms (i.e. terminal, nonterminal, repetition,
option, nested set of alternatives).  Since it's an arbitrary-length
sequence, not a binary operator, the calculation of first and last and
follow gets a bit tricky.  We may end up needing to normalize to
binary form just to keep things simple.
<div class="scrap"><span><a name="gl-ME-alt">&#x3008; 119 Handle alt elements &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
if ($E/self::alt) then
     let $id := 'exp_alt_'
                || (1 + count($E/preceding::alt)) 
     return element alt {
       $E/@*,
       attribute xml:id { $id },
       attribute nullable { 
         every $c in $ch
         satisfies (xs:boolean($c/@nullable) eq true())
       },
       attribute first { 
         string-join(
           for $c at $pos in $ch
           return if (every $lsib
	              in $ch[position() lt $pos]
                      satisfies
		      (xs:boolean($lsib/@nullable)
		      eq true() ))
                  then $c/@first
                  else (),
           ' '
         )
       },
       attribute last { 
         string-join(
           for $c at $pos in $ch
           return if (every $rsib
	              in $ch[position() gt $pos]
                      satisfies
		      (xs:boolean($rsib/@nullable)
		      eq true() ))
                  then $c/@last
                  else (),
           ' '
         )
       },
       <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-alt-follow">Calculate follow:* attributes for alt 120</a></em> &#x3009;</span>
       ,
       $children
     }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 98</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Again, calculating the follow-set is the most complicated
of the subcalculations for this type of expression.  So let's
take it slowly.
<ul><li>For every position <i>p</i> in each child <i>c</i>, the follow set 
follow(<i>E</i>,<i>p</i>) includes follow(<i>c</i>,<i>p</i>).</li>
<li>In addition, if <i>p</i> is in last(<i>c</i>) and <i>c</i> has a following sibling,
then follow(<i>E</i>,<i>p</i>) should include start(next-sibling(<i>c</i>)).</li>
<li>
In addition, if <i>p</i> is in last(<i>c</i>) and <i>c</i> has a following sibling,
and also next-sibling(<i>c</i>) is nullable, 
then follow(<i>E</i>,<i>p</i>) should include start(nextsib(nextsib(<i>c</i>))).
</li>
<li>
And so forth.</li>
</ul>

<div class="scrap"><span><a name="gl-ME-alt-follow">&#x3008; 120 Calculate follow:* attributes for alt &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
       for $c at $cpos in $ch 
       for $a in $c/@follow:*
       let $p := local-name($a),
           $lastC := tokenize($c/@last,'\s+'),
           $rightsibs := $ch[position() gt $cpos],
           $followset := if ($p = $lastC)
	   then string-join(
             (  $a,
                for $rsib at $rpos in $rightsibs
                let $inbetweens := $rightsibs
		                   [position() lt $rpos]
                return if (every $msib in $inbetweens
                           satisfies
                           (xs:boolean($msib/@nullable)
			   = true() ))
                       then $rsib/@first
                       else ()
             ),
             ' '
           )
           else
             $a
       return attribute { 
             QName($gl:follow-ns, "follow:"||$p )
         } { 
             $followset    
         }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME-alt">Handle alt elements 119</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">An &lt;<em>alts</em>&gt; element contains a set of alternatives,
each an &lt;<em>alt</em>&gt; element.
The 2013 alternative was the &lt;<em>def</em>&gt; element,
but note that &lt;<em>def</em>&gt; was required as the top-level
element of a right-hand side, which &lt;<em>alts</em>&gt; is not.
That doesn't affect the treatment of this element,
but it does affect
the treatment of rules, below. 
<div class="scrap"><span><a name="gl-ME-def">&#x3008; 121 Handle alts elements (= def) &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
if ($E[self::<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-alts-gi">GI for alts element 123</a></em> &#x3009;</span>]) then
     let $id := 'exp_' || name($E) || '_' 
                || (1 + count(
                $E/preceding::<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-alts-gi">GI for alts element 123</a></em> &#x3009;</span>)
		) 
     <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-alternatives">Handle alternatives 122</a></em> &#x3009;</span>
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 98</a> &#x3009; <br></span>
</div>

We factor out the treatment of alternatives
so that we can re-use it for rules, below.
The properties should all be self-explanatory.
<div class="scrap"><span><a name="gl-ME-alternatives">&#x3008; 122 Handle alternatives &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
     return element {name($E)} {
       $E/@*,
       attribute xml:id { $id },
       attribute nullable { 
         some $c in $ch
         satisfies
	 (xs:boolean($c/@nullable) eq true() )
       },
       attribute first { 
         string-join($ch/@first, ' ')
       },
       attribute last { 
         string-join($ch/@last, ' ')
       },
       
       (: follow-set is simple here. :) 
       for $a in $ch/@follow:*
       return $a,
       $children
     }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME-def">Handle alts elements (= def) 121</a> &#x3009; &#x3008; <a href="#gl-ME-rule">Handle rule elements 125</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">As an experiment, I am putting the generic identifier
for the element in a scrap.  If this works, much of the
duplication earlier in this section can be removed.
(Why do ideas come so late?)
<div class="scrap"><span><a name="gl-alts-gi">&#x3008; 123 GI for alts element &#x3009; &#x2261;</a></span>
<pre class="scrapbody">alts</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#eri-grammars-constructors">Functions that construct or return grammars 28</a> &#x3009; &#x3008; <a href="#gl-ME-def">Handle alts elements (= def) 121</a> &#x3009; <br></span>
</div>

In 2013, it was &lt;<em>def</em>&gt;:
<div class="scrap"><span><a name="gl-alts-gi-2013">&#x3008; 124 GI for alts element (v0.1) &#x3009; &#x2261;</a></span>
<pre class="scrapbody">def</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>

</div>
<div class="Real-P">Since the alternatives inside a rule are not now wrapped
in a &lt;<em>def</em>&gt; or &lt;<em>alts</em>&gt; elements, we need to
put the properties for the rule as a whole on the &lt;<em>rule</em>&gt;
element.
<div class="scrap"><span><a name="gl-ME-rule">&#x3008; 125 Handle rule elements &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
if ($E/self::rule) then
    let $id := $E/@name
    <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-alternatives">Handle alternatives 122</a></em> &#x3009;</span>
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 98</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">In 2013, it was simpler.
<div class="scrap"><span><a name="gl-ME-rule-2013">&#x3008; 126 Handle rule elements (v0.1) &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
if ($E/self::rule) then 
    element rule {
      $E/@*,
      $children
    }</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>

</div>
<div class="Real-P">Finally, a few miscellaneous elements.  Comments
require no annotation.
<div class="scrap"><span><a name="gl-ME-comment">&#x3008; 127 Handle comment elements &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
if ($E/self::comment) then
    $E
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 98</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The &lt;<em>ixml</em>&gt; element also requires no
annotation.
<div class="scrap"><span><a name="gl-ME-ixml">&#x3008; 128 Handle ixml elements (grammars) &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
if ($E/self::ixml) then 
    element ixml {
      $E/@*,
      $children
    }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 98</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">And finally, at the bottom of the if-then-else ladder,
we handle unexpected elements.
<div class="scrap"><span><a name="gl-ME-whahhh">&#x3008; 129 Handle unexpected elements &#x3009; &#x2261;</a></span>
<pre class="scrapbody">
if ($E/self::option or $E/self::sep)
then &lt;error&gt;Element {name($E)} with unexpected content: {$E}&lt;/error&gt;
else if ($E/(self::repeat1 or self::repeat0))
then &lt;error&gt;Element {name($E)} with unexpected content: {$E}&lt;/error&gt;
else &lt;error&gt;Unexpected element {$E}&lt;/error&gt;</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 98</a> &#x3009; <br></span>
</div>

</div>
</div>
</div>

</div>



<hr>

<div class="div">

<h2><a name="references" id="references">A. </a>References</h2>
<div class="Real-P"><i>Incomplete.</i></div>
<div class="bibliography">
<p class="bibl"><a name="Knuth-1984" id="Knuth-1984"></a>
Donald E. Knuth,
&#x201c;Literate Programming,&#x201d;
<em>The Computer Journal</em>
27 (1984):  97-111,
rpt. [rev.] in his
<em>Literate Programming</em>,
<em>CSLI Lecture Notes</em> Number 27
([Stanford, California]:  Center for the Study of Language and
Information, 1992), pp. 99-136, here p. 99.</p>

<p class="bibl"><a name="pemberton-2013" id="pemberton-2013"></a>
Pemberton, Steven.
2013.
&#x201c;Invisible XML&#x201d;.
Presented at Balisage: The Markup Conference 2013,
Montr&#xe9;al, Canada, August 6 - 9, 2013.
In
<em>Proceedings of Balisage: The Markup Conference 2013.</em>
Balisage Series on Markup Technologies, vol. 10 (2013).
DOI: 10.4242/BalisageVol10.Pemberton01.
On the web at
&lt;URL:<a href="http://www.balisage.net/Proceedings/vol10/html/Pemberton01/BalisageVol10-Pemberton01.html">http://www.balisage.net/Proceedings/vol10/html/Pemberton01/BalisageVol10-Pemberton01.html</a>&gt;.
Revised version (January 2014) at
&lt;URL:<a href="https://homepages.cwi.nl/~steven/Talks/2013/08-07-invisible-xml/invisible-xml-3.html">https://homepages.cwi.nl/~steven/Talks/2013/08-07-invisible-xml/invisible-xml-3.html</a>&gt;
</p>

<p class="bibl"><a name="pemberton-2021" id="pemberton-2021"></a>
Pemberton, Steven.
2021.
&#x201c;Invisible XML Specification
(Draft)&#x201d;.
On the web at
&lt;URL:<a href="https://invisiblexml.org/ixml-specification.html">https://invisiblexml.org/ixml-specification.html</a>&gt;
</p>

<p class="bibl"><a name="msm-1996" id="msm-1996"></a>
Sperberg-McQueen, C. M.
&#x201c;SWEB:
an SGML Tag Set for Literate Programming&#x201d;.
Unpublished technical report, 1993, rev. 1994, 1995, 1996.
On the web at
http://cmsmcq.com/1993/sweb.{<a href="http://cmsmcq.com/1993/sweb.xml">xml</a>,<a href="http://cmsmcq.com/1993/sweb.html">html</a>}.</p>

<p class="bibl"><a name="msm-2017" id="msm-2017"></a>
Sperberg-McQueen, C. M.
&#x201c;Translating imperative algorithms
into declarative, functional terms:
towards Earley parsing in XSLT and XQuery&#x201d;.
Presented at Balisage: The Markup Conference 2017,
Washington, DC, August 1 - 4, 2017.
In
<em>Proceedings of Balisage:
The Markup Conference 2017.</em>
<em>Balisage Series on Markup Technologies,
vol. 19 (2017)</em>.
&lt;URL:<a href="https://doi.org/10.4242/BalisageVol19.Sperberg-McQueen01">https://doi.org/10.4242/BalisageVol19.Sperberg-McQueen01</a>&gt;.
</p>
</div>
</div>


<div class="div">

<h2><a name="notation" id="notation">B. </a>Literate programming notation</h2>
<div class="Real-P"><i>To be supplied:  a description of the notation used here.</i></div>
</div>


<div class="div">

<h2><a name="to-do" id="to-do">C. </a>To do</h2>
<div class="Real-P">As the reader will have noticed, in its current state this
program is not finished. Hence the following to-do lists.</div>

<div class="div">

<h3><a name="to-do-code" id="to-do-code"></a>Code changes</h3>
<div class="Real-P">Fixes / shorter-term changes to be made:</div>
<ul><li>Make a common-utilities module for global project-level
variables (e.g. version number, tracing level) and tracing / debugging
routines.</li>
<li>Insert GPL notices in all modules.</li>
</ul>

<div class="Real-P">Enhancements longer-term changes to be made:</div>
<ul><li>Make marks work correctly.  Why is S appearing in output when
ixml is parsed?</li>
<li>Allow options to turn _from and _to attributes on and off?</li>
</ul>
</div>


<div class="div">

<h3><a name="to-do-sweb" id="to-do-sweb"></a>SWeb upgrades</h3>
<div class="Real-P">To do asap:</div>
<ul><li>make RNC schema for p3 + SWeb + XSLT</li>
<li>ensure new schema allows any well formed XML in
scraps, but enforces parent/child relations on XSLT</li>
<li>add module to SWeb stylesheet, to handle
XSLT and other XML elements within scraps</li>
<li>when this document is a bit further along (and has
decent display / translation into XHTML), move to github.</li>
</ul>
<div class="Real-P">To do eventually:</div>
<ul><li>make RNC schema for TEI P5 + SWeb + XSLT</li>
<li>upgrade this document, SWeb weave processor, SWeb
tangle processor</li>
</ul>
</div>
</div>


<div class="div">

<h2><a name="change-logs" id="change-logs">D. </a>Change logs</h2>

<div class="div">

<h3><a name="logs-v0.2" id="logs-v0.2"></a>Change log for version 0.2</h3>
<ul><li>2021-08-03 : CMSMcQ : put all (well, almost all) code into
Aparecium.xml, an SWeb document.</li>
</ul>
</div>

<div class="div">

<h3><a name="logs-v0.1" id="logs-v0.1"></a>Change log for version 0.1</h3>
<div class="Real-P">The lists below are extracted from the revision histories
at the beginnings of the individual modules.</div>
<div class="Real-P">Aparecium.xqm:
<ul><li>2021-10-03 : CMSMcQ : conversion to SWeb form.</li>
<li>2019-06-03 : CMSMcQ : rename parse-string-with-compiledgrammar as
                         parse-string-with-compiled-grammar.</li>
<li>2019-04-19 : CMSMcQ : force myself to write first version</li>
</ul>
</div>
<div class="Real-P">Earley-parser.xqm:
<ul><li>2021-10-03 : CMSMcQ : into sweb</li>
<li>2019-04-16 : CMSMcQ : copy to new location, use new namespace names</li>
<li>2018-04-05 : CMSMcQ : start file, hesitate a bit</li>
</ul>
</div>
<div class="Real-P">Earley-parser-internals.xqm:
<ul><li>2019-06-30 : CMSMcQ : remove profiling code again (done for now).</li>
<li>2019-06-29 : CMSMcQ : make item-as-map branch, change all type-aware
                         references to items.  Add profiling code.</li>
<li>2019-06-03 : CMSMcQ : first cut at trimming parse tree as specified in G</li>
<li>2019-04-22 : CMSMcQ : On error, give input in full</li>
<li>2019-04-16 : CMSMcQ : move to new location, assign new namespace name</li>
<li>2018-04-08 : CMSMcQ : when ixml.xml is corrected and smart quotes
                         corrected, parses all sample ixml grammars in
                         teststrings.xml</li>
<li>2018-04-08 : CMSMcQ : passes tests for grammars 1-4, parses most 
                         but not all sample ixml grammars.</li>
<li>2018-04-07 : CMSMcQ : made stubs of earley-parser and various
                         functions for returning parse information</li>
</ul>
</div>
<div class="Real-P">Earley-recognizer.xqm:
<ul><li>2019-06-30 : CMSMcQ : Remove profiling code again (done for now)</li>
<li>2019-06-29 : CMSMcQ : Add profiling code to try to find speed issues</li>
<li>2019-04-15 : CMSMcQ : Move to repo, adopt new namespace names.
                      Adjust spelling of some function calls.</li>
<li>2018-04-04 : CMSMcQ : Seem to have been interrupted in this; there is
                      almost nothing here.  Starting again, from sketch
                      made this morning away from desk.  (There are
                      earlier sketches which I am not now consulting.)
                      I'm transcribing the sketch, not trying to test.
                      item() used as type for Earley items.</li>
<li>2018-03-29 : CMSMcQ : made file.  Trying to do in XQuery what I did in
                      Prolog:  small top level ignorant of data
                      representation, lower level that knows.</li>
</ul>
</div>
<div class="Real-P">Earley-rec-internals.xqm:
<ul><li>2019-06-30 : CMSMcQ : remove profiling code (done for now)</li>
<li>2019-06-30 : CMSMcQ : restructure accumulator in earley-closure as
                      map indexed by both start and end points:
                      $acc($n)('from') provides all items with from=$n,
                      $acc($n)('to') all items with to=$n.
                      For now, no indexing by fFinal, fPredictive,
                      or non-terminal.</li>
<li>2019-06-29 : CMSMcQ : rewrite all Earley item constructors, extractors,
                      and functions to use maps and not elements</li>
<li>2019-06-29 : CMSMcQ : make item-as-map branch in git</li>
<li>2019-06-03 : CMSMcQ : make reXTerminal deal properly with hex characters</li>
<li>2019-05-27 : CMSMcQ : resuming work.</li>
<li>2019-04-21 : CMSMcQ : tracing and other changes</li>
<li>2019-04-17 : CMSMcQ : import d2x; add charXHex(); make fNullableNG 
                      take string, not element(nonterminal); make 
                      reXTerminal() handle quote.</li>
<li>2019-04-16 : CMSMcQ : moved to repo; adopted new namespace names.
                      Improved navigation comments.
                      Improved (or supplied) function comments.</li>
<li>2018-04-05 : CMSMcQ : fixed handling of 'quoted' to use attributes;
                      worked on supplying missing functions;
                      fixed symbol/position and initial-state 
                        confusions in functions for rules and items.</li>
<li>2018-04-04 : CMSMcQ : beginning filling out the details, guided
                      by "Unknown function" messages in earley0.xq
		      and here.</li>
<li>2018-03-29 : CMSMcQ : made file.
                      Trying to do in XQuery what I did in Prolog:
                      small top level ignorant of data representation,
                      lower level that knows.  This is the lower
                      level.  To-do list in ~/2018/Earley/status...asc</li>
</ul>
</div>
<div class="Real-P">Gluschkov.xqm:
<ul><li>2019-04-19 : CMSMcQ : Move to repo for easier imports.</li>
<li>2016-04-05 : CMSMcQ : Completed Gluschkov constructor for use in 
                         an Earley parser.</li>
</ul>
</div>
</div>
</div>


</div><div class="notes"><hr><h3>Notes</h3><div class="note">[<a name="d3e199" id="d3e199" href="#ref-to-d3e199">1</a>] 
A simple example is the grammar <tt>S:  'a';
S.</tt>,
for which the single sentence (&#x201c;<tt>a</tt>&#x201d;)
has an infinite number of parses (one <i>S</i>
node, two <i>S</i> nodes, three, ...).
<div class="Real-P">Another is the grammar <tt>S: S*; {nil}.</tt>,
which provides an infinite number of parses for the
empty string, which vary both in depth and in width.</div>
</div></div></body></html>

