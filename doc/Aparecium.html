<!DOCTYPE HTML><html>
<!--Need to find a way to insert the current date-->
<head><meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<title>Aparecium:  an ixml parser for XSLT and XQuery</title>

<style type="text/css">
      p {
      margin-top: 0.6em;      
      margin-bottom: 0.6em;
    }
    p.bibl {
      margin-top: 0.6em;      
      margin-bottom: 0.6em;
      margin-left: 2em;
      text-indent: -2em;
    }
    .Real-P {
      margin-top: 0.6em;      
      margin-bottom: 0.6em;
    }
    div.sp {
      margin-top: 0.6em;      
      margin-bottom: 0.6em;
    }
    div.address {
      margin-top: 0.6em;      
      margin-bottom: 0.6em;
      margin-left: 2em;
    }
    div.note {
      margin-top: 1em;      
      margin-left: 2em;
      
    }
    pre {  
      font-family: monospace;
      margin-left: 2em 
    }  
    a:hover { 
      background: #CCF 
    }
    td.no { 
      background: #CCF 
    }
    .author { 
      font-size: x-large
    }
    .bio { 
      font-size: small;
      font-style: italic
    }
    span.decision { 
    }
    span.result { 
      font-weight: bold
    }
    span.aye { 
      display: block;
      margin-left: 2em;
    }
    span.nay { 
      display: block;
      margin-left: 2em;
    }
    span.abstain { 
      display: block;
      margin-left: 2em;
    }
    span.result { 
      display: block;
      margin-left: 2em;
      font-weight: bold
    }
    span.speaker { 
      display: inline;
    }
    span.typename { 
      display: inline;
      font-family: monospace;
    }
    a.selflink {
      text-decoration: none; 
      color: initial;
    }
   
  div.scrap {
    margin-top: 0.5em; 
    background-color: #CFEFCF; 
    background-color: #E7F7E7; 
    padding: 0.6em;
    margin-bottom: 0.5em;
  }
  pre.scrapbody {
    margin-left: 0.5em; 
    margin-bottom: 0.5em;
  }
  span.scrapcontinuations {
    font-size:smaller; 
  }
  span.scrapinbound {
    font-size:smaller;
  }
  span.scrapref {
    display: inline-block;
    text-indent: -0.3em;
    font-family: New Times Roman, serif, Lucida Sans Unicode;
  }
  em.scrapptr {
    font-family: New Times Roman, serif, Lucida Sans Unicode;
  }
  dl.desclist {
    list-style-type: none;
  }
  dl.desclist > dt {
    display: run-in;
    padding-right: 0.5em;
/*
*/
  }
  dl.desclist > dd {
    text-indent: -1em;
    margin-left: 1em; 
  }
  ul.desclist { 
    list-style-type: none;
  }
  ul.desclist > li {
    margin-left: 2em;
    text-indent: -2em;
  }
  div.epigraph .Real-P {margin-top: 0em; margin-bottom: 0em;} 
  </style><link xmlns="http://www.w3.org/1999/xhtml" rel="stylesheet" href="../lib/local.css"></head><body><div class="doc">







<h1>Aparecium</h1>
<h1>An ixml parser for XSLT and XQuery</h1>

<h3>C. M. Sperberg-McQueen</h3>
<h3>Begun 16 August 2021
<br>Last rev. 30 July 2022</h3>

<div class="versionList"><p>Versions defined:</p><ul>
<li id="v0.2" class="versionentry"><em>v0.2:</em>&nbsp;Version presented at Balisage in 2020
and at Declarative Amsterdam in 2021</li>
<li id="pfg" class="versionentry"><em>pfg:</em>&nbsp;Modifications to support
production of parse-forest grammars</li>
<li id="tok0" class="versionentry"><em>tok0:</em>&nbsp;Modifications to support
faster tokenization in user-annotated grammars (falls back to v0.2)</li>
</ul></div>
<hr><a name="toc"></a>
<ul><!-- and a 1! -->
<li>1. <a href="#intro">Introduction</a></li><li>2. <a href="#overall">Overall structure</a></li><li>3. <a href="#highlevel">High-level functions</a><ul>
<!-- and a 2! -->
<li>3.1. <a href="#hi-code-org">Organization of the code</a><ul><!-- and a 3! -->
<li>3.1.1. <a href="#files-ap">Aparecium module:  <i>Aparecium.xqm</i></a></li><li>3.1.2. <a href="#files-cli">Command-line interface</a></li><li>3.1.3. <a href="#files-parser">Parser:  <i>Earley-parser.xqm</i></a></li><li>3.1.4. <a href="#files-epi">Parser internals:  <i>Earley-parser-internals.xqm</i></a></li><li>3.1.5. <a href="#files-rec">Recognizer: <i>Earley-recognizer.xqm</i></a></li><li>3.1.6. <a href="#files-eri">Recognizer internals: <i>Earley-rec-internals.xqm</i></a></li></ul></li>
<li>3.2. <a href="#hi-calling">Calling the parser</a><ul><!-- and a 3! -->
<li>3.2.1. <a href="#hi-call-options">User options</a></li><li>3.2.2. <a href="#hi-call-pr">The <i>parse-resource()</i> function</a></li><li>3.2.3. <a href="#hi-call-ps">The <i>aparecium:parse-string()</i> function</a></li><li>3.2.4. <a href="#hi-call-pscg">The <i>aparecium:parse-string-with-compiled-grammar()</i> function</a></li><li>3.2.5. <a href="#hi-call-doc">The <i>aparecium:doc()</i> function</a></li></ul></li>
<li>3.3. <a href="#hi-prep-input">Preparing the input</a></li>
<li>3.4. <a href="#hi-prep-grammar">Preparing the grammar</a><ul><!-- and a 3! -->
<li>3.4.1. <a href="#hi-compile-grammar">Compiling the grammar</a></li><li>3.4.2. <a href="#hi-check-compiled-grammar">Checking the compiled grammar</a></li></ul></li>
<li>3.5. <a href="#hi-earley-parse">Managing the parsing process</a></li>
<li>3.6. <a href="#hi-earley-set">Generating the Earley set</a><ul><!-- and a 3! -->
<li>3.6.1. <a href="#hies-scan">The scanner</a></li><li>3.6.2. <a href="#hies-pred">The predictor</a></li><li>3.6.3. <a href="#hies-comp">The completer</a></li><li>3.6.4. <a href="#hies-recognizer">The recognizer</a></li></ul></li>
<li>3.7. <a href="#hi-ptc">Direct generation of parse tree</a><ul><!-- and a 3! -->
<li>3.7.1. <a href="#hi-ptc-raw">Raw parse trees</a></li><li>3.7.2. <a href="#hi-ptc-ast">Abstract syntax trees</a></li></ul></li>
<li>3.8. <a href="#hi-pfg">Generating the parse-forest grammar</a><ul><!-- and a 3! -->
<li>3.8.1. <a href="#hi-pfg-intro">Short description of parse-forest grammars</a></li><li>3.8.2. <a href="#hi-pfg-const">Constructing a parse-forest grammar</a></li><li>3.8.3. <a href="#hi-pfgc-top">The parse-forest-grammar() function</a></li><li>3.8.4. <a href="#hi-pfgc-make-rules">The <i>make-pfg-rules()</i> function</a></li><li>3.8.5. <a href="#hi-pfgc-walks">Finding walks through a rule's right-hand-side</a></li><li>3.8.6. <a href="#hi-pfgc-makerule">Making a production rule for a given walk</a></li><li>3.8.7. <a href="#hi-pfgc-recur">Preparing for the next iteration</a></li><li>3.8.8. <a href="#hi-pfgc-find-walks">The <i>find-walks()</i> function</a></li><li>3.8.9. <a href="#hi-pfgc-make-rhs">The <i>rhs-from-walk()</i> function</a></li><li>3.8.10. <a href="#hi-pfgc-make-lei">The <i>lei-from-walk()</i> function</a></li><li>3.8.11. <a href="#hi-pfgc-find-dups">The <i>dups-from-walk()</i> function</a></li></ul></li>
<li>3.9. <a href="#hi-rpt-ex-pfg">Extracting a parse tree from the parse-forest grammar</a></li>
<li>3.10. <a href="#hi-ast-ex-rpt">Extracting an abstract syntax tree from a raw parse tree</a></li>
</ul></li><li>4. <a href="#lowlevel">Low-level utility routines</a><ul>
<!-- and a 2! -->
<li>4.1. <a href="#ll-types">Abstract types</a></li>
<li>4.2. <a href="#ll-items">Working with Earley items</a><ul><!-- and a 3! -->
<li>4.2.1. <a href="#ll-items-con">Earley items - constructors</a></li><li>4.2.2. <a href="#ll-items-extr">Earley items - extractors</a></li><li>4.2.3. <a href="#ll-items-predicates">Earley items - predicates</a></li><li>4.2.4. <a href="#ll-items-closure">Earley set closure</a></li></ul></li>
<li>4.3. <a href="#ll-grammars">Working with grammars</a></li>
<li>4.4. <a href="#ll-rules">Working with rules</a></li>
<li>4.5. <a href="#ll-symbols">Working with symbols</a><ul><!-- and a 3! -->
<li>4.5.1. <a href="#ll-sym-match-length">The <i>match-length()</i> function</a></li><li>4.5.2. <a href="#d3e4498">Making regular expressions from terminal symbols</a></li><li>4.5.3. <a href="#d3e4626">Testing for symbol type</a></li><li>4.5.4. <a href="#d3e4649">Matching symbols against rule indices</a></li></ul></li>
<li>4.6. <a href="#ll-input">Dealing with the input</a></li>
<li>4.7. <a href="#ll-utils">Utilities and miscellaneous</a><ul><!-- and a 3! -->
<li>4.7.1. <a href="#ll-utils-strings">Routines for strings and characters</a></li><li>4.7.2. <a href="#ll-utils-tracing">Trace routines</a></li></ul></li>
</ul></li><li>5. <a href="#alt-calls">Alternative interfaces</a><ul>
<!-- and a 2! -->
<li>5.1. <a href="#alt-calls-secondary">Secondary user-facing calls</a></li>
<li>5.2. <a href="#alt-calls-other">Non-user-facing functions</a></li>
</ul></li><li>6. <a href="#quarry">Unsorted bits of legacy code</a><ul>
<!-- and a 2! -->
<li>6.1. <a href="#legacy-Earley-parser.xqm">Earley parser</a></li>
<li>6.2. <a href="#legacy-Earley-parser-internals.xqm">Parser internals</a><ul><!-- and a 3! -->
<li>6.2.1. <a href="#epi-earley-parse-function">The <i>earley-parse()</i> function</a></li><li>6.2.2. <a href="#epi-tree-returns">Functions to return one or more trees</a></li><li>6.2.3. <a href="#epi-all-nodes">Finding a sequence of items for a single right-hand side</a></li><li>6.2.4. <a href="#epi-ast-from-raw">Extracting the abstract syntax tree from the raw parse tree</a></li></ul></li>
</ul></li><li>A. <a href="#references">References</a></li>
<li>B. <a href="#to-do">To do</a></li>
<li>C. <a href="#known-limits">Known limitations</a></li>
<li>D. <a href="#known-bugs">Known bugs and test failures</a></li>
<li>E. <a href="#change-logs">Change logs</a></li>
<li>F. <a href="#obsolete">Older versions of some code</a></li>
<li>G. <a href="#indices">Indices</a></li>
</ul>

<hr>
<div class="epigraph" style="margin-top: 12 pt; text-align:left; margin-left: 30%">
<blockquote>
<div class="Real-P">... Hermione was pulling her wand out of her bag.</div>
<div class="Real-P">&#x2018;It might be invisible ink!&#x2019; she whispered.</div>
<div class="Real-P">She tapped the diary three times and said,
&#x2018;Aparecium!&#x2019;</div>
</blockquote>
<div style="margin-top: 12 pt; text-align:right; margin-left: 10%; margin-right: 10%; font-size: 80%;">
J. K. Rowling, <em>Harry Potter 
and the Chamber of Secrets</em>
</div>
</div>

<div class="Real-P">This document is the source code for Aparecium, an invisible-XML
processor written in XSLT and XQuery, as a library for use in those
languages.  Aparecium is a &#x2018;literate program&#x2019;, in
the sense defined by Donald Knuth: this document contains descriptions
of the program in English prose and in XQuery and XSLT source code.
Processed in one way, the document produces XQuery and XSLT programs;
processed another way, it produces a (rather dry) technical exposition
of their structure and coding.  Readers in search of user-level
introductions to invisible XML or the use of Aparecium to build
applications will not find here what they seek.</div>

<div class="Real-P">The specific literate programming system used here is SWeb; a
description of its notation is given in <a href="#msm-1996" title="&#xA;Sperberg-McQueen, C. M.&#xA;SWEB:&#xA;an SGML Tag Set for Literate Programming.&#xA;Unpublished technical report, 1993, rev. 1994, 1995, 1996.&#xA;On the web at&#xA;http://cmsmcq.com/1993/sweb.{xml,html}.">[Sperberg-McQueen 1996]</a>.
The locus classicus for literate programming in general is
<a href="#Knuth-1984" title="&#xA;Donald E. Knuth,&#xA;Literate Programming,&#xA;The Computer Journal&#xA;27 (1984):  97-111,&#xA;rpt. [rev.] in his&#xA;Literate Programming,&#xA;CSLI Lecture Notes Number 27&#xA;([Stanford, California]:  Center for the Study of Language and&#xA;Information, 1992), pp. 99-136, here p. 99.">[Knuth 1984]</a>.[<a name="ref-to-d3e125" href="#d3e125" title="&#xA;In most crucial ways, SWeb resembles Knuth's WEB system, as do&#xA;most other literate programming systems: code is presented in a&#xA;sequence determined by rhetorica">1</a>]

</div>

<div class="Real-P">In its current form, the document is incomplete and not well
organized.  It was created by making a skeletal overview of the
document as it should be and then breaking the source code of a
running version of Aparecium up into chunks and inserting them into
that skeleton.  Not everything landed where it ought in principle to
have landed; the organization of the document suffered somewhat from
that.  As time permits, I hope to revise the document to make it
easier to read and better organized.</div>
<div class="Real-P">At this revision (30 July 2022), Aparecium works and passes
the large majority of the tests available.  (A list of test-case
failures as of today is given <a href="#known-bugs">in an
appendix</a>.)  The current plans for further work are 
given <a href="#to-do">in a different appendix</a>.</div>


<div class="div">

<div class="quicknav"><span class="arrow">&nbsp;</span><span class="arrow"><a href="#toc">&#x23f6;</a></span><span class="arrow"><a href="#overall">&#x23f5;</a></span></div><h2><a class="selflink" name="intro" id="intro" href="#intro">1. </a>Introduction</h2>
<div class="Real-P">Aparecium is an XQuery implementation of Invisible XML (or:
ixml).  In the usual case, it accepts a context-free grammar
and input, and it returns an XML representation of the parse
tree.  Any grammar in the grammar notation defined by the
specification for Invisible XML (<a href="#pemberton-2021" title="&#xA;Pemberton, Steven.&#xA;2021.&#xA;Invisible XML Specification&#xA;(Draft).&#xA;On the web at&#xA;https://invisiblexml.org/ixml-specification.html&#xA;">[Pemberton 2021]</a>) is accepted, and the XML
representation returned will be not the raw parse tree but the
tree as modified by annotations in the grammar.
</div>

<div class="Real-P">This paper assumes that the reader is familiar with the ideas of
Invisible XML and those of Earley parsing.  Several accessible
introductions to Invisible XML can be found at
&lt;URL:<a href="http://invisiblexml.org">http://invisiblexml.org</a>&gt;, as can the formal
specification itself (<a href="#pemberton-2021" title="&#xA;Pemberton, Steven.&#xA;2021.&#xA;Invisible XML Specification&#xA;(Draft).&#xA;On the web at&#xA;https://invisiblexml.org/ixml-specification.html&#xA;">[Pemberton 2021]</a>).  A discussion
of the particular challenges of implementing an Earley parser in a
declarative functional language, and a re-formulation of the Earley
algorithm in declarative terms to simplify that task, may be found
in <a href="#msm-2017" title="&#xA;Sperberg-McQueen, C. M.&#xA;Translating imperative algorithms&#xA;into declarative, functional terms:&#xA;towards Earley parsing in XSLT and XQuery.&#xA;Presented at Balisage: The Markup Conference 2017,&#xA;Washington, DC, August 1 - 4, 2017.&#xA;In&#xA;Proceedings of Balisage:&#xA;The Markup Conference 2017.&#xA;Balisage Series on Markup Technologies,&#xA;vol. 19 (2017).&#xA;https://doi.org/10.4242/BalisageVol19.Sperberg-McQueen01.&#xA;">[Sperberg-McQueen 2017]</a>.</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#intro">&#x23f4;</a></span><span class="arrow"><a href="#toc">&#x23f6;</a></span><span class="arrow"><a href="#highlevel">&#x23f5;</a></span></div><h2><a class="selflink" name="overall" id="overall" href="#overall">2. </a>Overall structure</h2>
<div class="Real-P">Aparecium divides its task into several steps:
<ul><li>
<div class="Real-P">Depending on the top-level function called, we may
start work with a string containing the input to be
parsed, or with a URI which should be dereferenced in
order to obtain the string to be parsed.  The grammar may
be provided as a string, as a URI, as an XML document
containing the standard XML representation of the ixml
grammar, or as a &#x2018;compiled&#x2019; or prepared
grammar.</div>	    
<div class="Real-P">The first step is thus to collect what is needed and
put it into the form required for further processing: a
prepared grammar <i>G</i> and a string <i>I</i> (for
&#x2018;<span>input</span>&#x2019;) to be parsed.</div>
</li>
<li>
<div class="Real-P">The second step is to calculate the Earley set, a set
of Earley items sufficient to indicate whether <i>I</i> is a
sentence in <i>L(G)</i> (the language defined by <i>G</i>).</div>
<div class="Real-P">This suffices for an Earley recognizer, which
recognizes <i>L(G)</i>, but not for a parser, which identifies
the parse trees of sentences in <i>L(G)</i>.
</div>
</li>
<li>
<div class="Real-P">The next step is to use the Earley set to construct a
parse tree for the sentence.</div>
<div class="Real-P">When the sentence has only one parse tree, this is
relatively straightforward, but there are some cases of
interest in which we can expect sentences to be ambiguous,
and in which the user may wish to inspect more than one
possible parse tree.  For example, in a programming
language, keywords might have the same lexical form as
variable or function names, and this can easily give rise
to ambiguity.  Or the grammar writer may be trying to
detect possible ambiguities in a language specification
and need to examine in detail the possible parses for
ambiguous sentences.</div>
<div class="Real-P">In some cases, the number of possible parse trees
may be unbounded.[<a name="ref-to-d3e220" href="#d3e220" title="&#xA;A simple example is the grammar S:  'a';&#xA;S.,&#xA;for which the single sentence (a)&#xA;has an infinite number of parses (one S&#xA;node, two S nodes, three, ...).&#xA;Another ">2</a>]</div>
<div class="Real-P">For this reason, Aparecium typically divides this step further.
For historical reasons, there are two work flows.
<ul><li>
<div class="Real-P">In the original flow, Aparecium extracts &#x2018;raw&#x2019;
parse trees direct from the Earley set.  It attempts to identify and
return <em>all</em> the parse trees for the sentence, except that
it uses simple forms of loop detection to avoid attempting to produce
an infinite number of trees.</div>
</li>
<li>
<div class="Real-P">A second function then simplifies the &#x2018;raw&#x2019;
parse trees as specified in the annotation of the ixml grammar, in
order to produce the XML output (sometimes referred to here as an
abtract syntax tree or AST).</div>
</li>
</ul>
A second flow works differently.
<ul><li>
<div class="Real-P">From the Earley set, the second flow extracts a parse-forest
grammar representing all parse trees for the sentence.  (Well, almost
all.  Here, too, loop detection is used to keep the task finite.)</div>
<div class="Real-P">Parse-forest grammars have the convenient property that they can
concisely describe more than one parse tree over the given input,
even infinite trees.  It is relatively straightforward to tell by
examining the parse-forest grammar whether it describes a single
parse tree or multiple parse trees, and whether the number of parse
trees is finite or infinite.</div>
</li>
<li>
<div class="Real-P">A separate function extracts a single parse tree from the
parse-forest grammar.</div>
</li>
</ul>
</div>
</li>
<li>
<div class="Real-P">Again depending on the top-level function called, we may return
to the user a single tree, a collection of trees, or a parse-forest
grammar.</div>
<div class="Real-P">The design also foresees the user being able to specify a maximum
number of parse trees to return in case of ambiguity, or the
processor being able to deliver a &#x2018;tree cursor&#x2019;
pair consisting of a parse tree and a function which, when called,
returns the next parse tree and a function to call for the one after
that.  At this time, these additional variations are not
available.</div>
</li>
</ul>
</div>
<div class="Real-P">Functions performing these high-level tasks are described
below in section <a href="#highlevel" title="High-level functions">3</a>.</div>
<div class="Real-P">Lower-level functions called upon by the higher-level
routines are described in section <a href="#lowlevel" title="Low-level utility routines">4</a>.</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#overall">&#x23f4;</a></span><span class="arrow"><a href="#toc">&#x23f6;</a></span><span class="arrow"><a href="#lowlevel">&#x23f5;</a></span></div><h2><a class="selflink" name="highlevel" id="highlevel" href="#highlevel">3. </a>High-level functions</h2><ul><li>3.1. <a href="#hi-code-org">Organization of the code</a><ul><li>3.1.1. <a href="#files-ap">Aparecium module:  <i>Aparecium.xqm</i></a></li><li>3.1.2. <a href="#files-cli">Command-line interface</a></li><li>3.1.3. <a href="#files-parser">Parser:  <i>Earley-parser.xqm</i></a></li><li>3.1.4. <a href="#files-epi">Parser internals:  <i>Earley-parser-internals.xqm</i></a></li><li>3.1.5. <a href="#files-rec">Recognizer: <i>Earley-recognizer.xqm</i></a></li><li>3.1.6. <a href="#files-eri">Recognizer internals: <i>Earley-rec-internals.xqm</i></a></li></ul></li><li>3.2. <a href="#hi-calling">Calling the parser</a><ul><li>3.2.1. <a href="#hi-call-options">User options</a><ul><li>3.2.1.1. <a href="#hi-call-opt-returns">How to return results</a></li><li>3.2.1.2. <a href="#hi-call-opt-how">Processing choices and behavior</a></li><li>3.2.1.3. <a href="#hi-call-opt-dfts">Default values for options</a></li></ul></li><li>3.2.2. <a href="#hi-call-pr">The <i>parse-resource()</i> function</a></li><li>3.2.3. <a href="#hi-call-ps">The <i>aparecium:parse-string()</i> function</a></li><li>3.2.4. <a href="#hi-call-pscg">The <i>aparecium:parse-string-with-compiled-grammar()</i> function</a></li><li>3.2.5. <a href="#hi-call-doc">The <i>aparecium:doc()</i> function</a></li></ul></li><li>3.3. <a href="#hi-prep-input">Preparing the input</a></li><li>3.4. <a href="#hi-prep-grammar">Preparing the grammar</a><ul><li>3.4.1. <a href="#hi-compile-grammar">Compiling the grammar</a><ul><li>3.4.1.1. <a href="#higl-prolog">Module prolog</a></li><li>3.4.1.2. <a href="#higl-ME">Calculating the Gluschkov automaton <i>M</i><sub><i>E</i></sub></a></li><li>3.4.1.3. <a href="#higl-ME-terminals">Gluschkov automata for terminal symbols</a></li><li>3.4.1.4. <a href="#higl-ME-nonterminals">Gluschkov automata for nonterminal symbols</a></li><li>3.4.1.5. <a href="#higl-ME-opt-rep">Gluschkov automata for repetitions and options</a></li><li>3.4.1.6. <a href="#higl-ME-sequences">Gluschkov automata for sequences (&lt;<em>alt</em>&gt;)</a></li><li>3.4.1.7. <a href="#higl-ME-choice">Gluschkov automata for choice (&lt;<em>alts</em>&gt;)</a></li><li>3.4.1.8. <a href="#higl-ME-choice">Gluschkov automata for other elements</a></li></ul></li><li>3.4.2. <a href="#hi-check-compiled-grammar">Checking the compiled grammar</a><ul><li>3.4.2.1. <a href="#hi-ccg-what">What is checked</a></li><li>3.4.2.2. <a href="#hi-ccg-gok">The <i>grammar-ok()</i> function</a><ul><li>3.4.2.2.1. <a href="#hi-ccg-gok-str">Structural checks</a></li><li>3.4.2.2.2. <a href="#hi-ccg-gok-nonxml">Checking for non-XML names</a></li><li>3.4.2.2.3. <a href="#hi-ccg-gok-duprules">Checking for multiple definitions</a></li><li>3.4.2.2.4. <a href="#hi-ccg-gok-classes">Checking character classes</a></li><li>3.4.2.2.5. <a href="#hi-ccg-gok-hex">Checking hex literals</a></li><li>3.4.2.2.6. <a href="#hi-ccg-gok-range">Checking ranges</a></li><li>3.4.2.2.7. <a href="#hi-ccg-gok-undef">Checking for undefined nonterminals</a></li><li>3.4.2.2.8. <a href="#hi-ccg-gok-unreachable">Checking for unreachable rules</a></li><li>3.4.2.2.9. <a href="#hi-ccg-gok-unprod">Checking for unproductive nonterminals</a></li></ul></li></ul></li></ul></li><li>3.5. <a href="#hi-earley-parse">Managing the parsing process</a></li><li>3.6. <a href="#hi-earley-set">Generating the Earley set</a><ul><li>3.6.1. <a href="#hies-scan">The scanner</a></li><li>3.6.2. <a href="#hies-pred">The predictor</a></li><li>3.6.3. <a href="#hies-comp">The completer</a></li><li>3.6.4. <a href="#hies-recognizer">The recognizer</a></li></ul></li><li>3.7. <a href="#hi-ptc">Direct generation of parse tree</a><ul><li>3.7.1. <a href="#hi-ptc-raw">Raw parse trees</a></li><li>3.7.2. <a href="#hi-ptc-ast">Abstract syntax trees</a></li></ul></li><li>3.8. <a href="#hi-pfg">Generating the parse-forest grammar</a><ul><li>3.8.1. <a href="#hi-pfg-intro">Short description of parse-forest grammars</a></li><li>3.8.2. <a href="#hi-pfg-const">Constructing a parse-forest grammar</a></li><li>3.8.3. <a href="#hi-pfgc-top">The parse-forest-grammar() function</a></li><li>3.8.4. <a href="#hi-pfgc-make-rules">The <i>make-pfg-rules()</i> function</a></li><li>3.8.5. <a href="#hi-pfgc-walks">Finding walks through a rule's right-hand-side</a></li><li>3.8.6. <a href="#hi-pfgc-makerule">Making a production rule for a given walk</a></li><li>3.8.7. <a href="#hi-pfgc-recur">Preparing for the next iteration</a></li><li>3.8.8. <a href="#hi-pfgc-find-walks">The <i>find-walks()</i> function</a></li><li>3.8.9. <a href="#hi-pfgc-make-rhs">The <i>rhs-from-walk()</i> function</a></li><li>3.8.10. <a href="#hi-pfgc-make-lei">The <i>lei-from-walk()</i> function</a></li><li>3.8.11. <a href="#hi-pfgc-find-dups">The <i>dups-from-walk()</i> function</a></li></ul></li><li>3.9. <a href="#hi-rpt-ex-pfg">Extracting a parse tree from the parse-forest grammar</a></li><li>3.10. <a href="#hi-ast-ex-rpt">Extracting an abstract syntax tree from a raw parse tree</a></li></ul>
<div class="Real-P">The following sections describe the high-level
functionality described above.</div>


<div class="div">

<div class="quicknav"><span class="arrow">&nbsp;</span><span class="arrow"><a href="#highlevel">&#x23f6;</a></span><span class="arrow"><a href="#hi-calling">&#x23f5;</a></span></div><h3><a class="selflink" name="hi-code-org" id="hi-code-org" href="#hi-code-org">3.1. </a>Organization of the code</h3><ul><li>3.1.1. <a href="#files-ap">Aparecium module:  <i>Aparecium.xqm</i></a></li><li>3.1.2. <a href="#files-cli">Command-line interface</a></li><li>3.1.3. <a href="#files-parser">Parser:  <i>Earley-parser.xqm</i></a></li><li>3.1.4. <a href="#files-epi">Parser internals:  <i>Earley-parser-internals.xqm</i></a></li><li>3.1.5. <a href="#files-rec">Recognizer: <i>Earley-recognizer.xqm</i></a></li><li>3.1.6. <a href="#files-eri">Recognizer internals: <i>Earley-rec-internals.xqm</i></a></li></ul>
<div class="Real-P">The code is organized into different modules
(and files) in an attempt to keep things organized.
<ul><li><i>Aparecium.xqm</i> declares the top-level user-facing
functions for parsing (and also some cruft most users can and should
ignore).</li>
<li>A set of stand-alone XQuery modules and a shell script provide a
command-line interface to selected top-level user-facing
functions.</li>
<li><i>Earley-recognizer.xqm</i> declares the high-level
functions of an Earley recognizer.  These functions prepare the
grammar, build the initial Earley item, and construct the Earley set.
The functions here are relatively abstract and are intended to be
independent of many of the lower-level implementation details, which
are factored out into an internals module.  As a recognizer, all the
main function here does is to decide whether the input given is or is
not a sentence in the language defined by the grammar.</li>
<li><i>Earley-rec-internals.xqm</i> declares low-level
functions called by the Earley recognizer.  These routines reflect
specific implementation choices from which the recognizer itself
should ideally be insulated.</li>
<li><i>Earley-parser.xqm</i> declares the high-level
functions of the Earley parser.  The main function calls the
recognizer and constructs a parse tree from the Earley set generated
by the recognizer.</li>
<li><i>Earley-parser-internals.xqm</i> contains low-level
routines for the Earley parser.</li>
<li><i>Gluschkov.xqm</i> decorates the right-hand sides of
rules in a grammar with attributes allowing the rule to be interpreted
as a finite state automaton instead of as a regular expression.</li>
</ul>
These files are described in the following subsections.
</div>

<div class="div">

<div class="quicknav"><span class="arrow">&nbsp;</span><span class="arrow"><a href="#hi-code-org">&#x23f6;</a></span><span class="arrow"><a href="#files-cli">&#x23f5;</a></span></div><h4><a class="selflink" name="files-ap" id="files-ap" href="#files-ap">3.1.1. </a>Aparecium module:  <i>Aparecium.xqm</i></h4>
<div class="Real-P">The file <i>Aparecium.xqm</i>
contains the module the typical user will
want to import and use.
<div class="scrap"><span><a name="d3e339">&#x3008; 1  [File Aparecium.xqm]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">module namespace aparecium =
"http://blackmesatech.com/2019/iXML/Aparecium";

(: Aparecium:  a library to make invisible XML visible.

    ... Hermione was pulling her wand out of her bag.
    "It might be invisible ink!" she whispered.
    She tapped the diary three times and said, "Aparecium!"
      
                           - J. K. Rowling, Harry Potter 
                           and the Chamber of Secrets

:)

<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#aparecium-imports">Module imports for Aparecium top-level 2</a></em> &#x3009;</span>

<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#aparecium-main">Main interfaces for Aparecium 12</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#aparecium-secondary">Secondary interfaces (a bit specialized) 182</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#aparecium-tertiary">Tertiary interfaces (of interest only for maintainer) 189</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#aparecium-variables">Variables (of interest only for maintainer) 13</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>
</div>

<div class="Real-P">The file needs to import the Earley parser and the constructor
for Gluschkov automata.
<div class="scrap"><span><a name="aparecium-imports">&#x3008; 2 Module imports for Aparecium top-level &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">import module namespace earley
   = "http://blackmesatech.com/2019/iXML/Earley-parser"
  at "Earley-parser.xqm";
import module namespace gluschkov
   = "http://blackmesatech.com/2019/iXML/Gluschkov"
  at "Gluschkov.xqm";
import module namespace d2x 
   = 'http://blackmesatech.com/2019/iXML/d2x'
  at "d2x.xqm";

declare namespace map = 
"http://www.w3.org/2005/xpath-functions/map";
  
(: Quick hack for testing ... :)
import module namespace ws
   = "http://blackmesatech.com/2019/iXML/wstrimtree"
   at "wstrimtree.xqm";
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e339">[File Aparecium.xqm] 1</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The user-facing functions of this module are described in
sections <a href="#hi-calling" title="Calling the parser">3.2</a> and <a href="#alt-calls" title="Alternative interfaces">5</a>.</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#files-ap">&#x23f4;</a></span><span class="arrow"><a href="#hi-code-org">&#x23f6;</a></span><span class="arrow"><a href="#files-parser">&#x23f5;</a></span></div><h4><a class="selflink" name="files-cli" id="files-cli" href="#files-cli">3.1.2. </a>Command-line interface</h4>
<div class="Real-P">The modules for calling from the command line will
be described here.
</div>
<div class="Real-P">The <i>parse-resource</i> XQuery module is a top-level
XQuery module which calls <tt>parse-resource()</tt> on
user-specified URIs for input and grammar.
<div class="scrap"><span><a name="d3e378">&#x3008; 3  [File parse-resource.xqy]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: watch this space :)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>
</div>
<div class="Real-P">The <i>parse-resource</i> XQuery module is a top-level
XQuery module which calls <tt>parse-resource()</tt> on
user-specified URIs for input and grammar.
<div class="scrap"><span><a name="d3e387">&#x3008; 4  [File parse-resource.xqy]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">import module namespace aparecium 
= "http://blackmesatech.com/2019/iXML/Aparecium"
at "../build/Aparecium.xqm";

declare variable $input as xs:string external;
declare variable $grammar as xs:string external;

return aparecium:parse-resource(
           $input, 
           $grammar)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">The <i>parse-resource-with-compiled-grammar</i> module is
intended to be called from the command line; as the name suggests, it
accepts URIs for the input and a compiled grammar and uses the grammar
to parse the input.
<div class="scrap"><span><a name="d3e395">&#x3008; 5  [File parse-resource-with-compiled-grammar.xq]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">import module namespace aparecium 
= "http://blackmesatech.com/2019/iXML/Aparecium"
at "../build/Aparecium.xqm";

declare variable $input as xs:string external;
declare variable $grammar as xs:string external;

let $input-string := try {
        doc($input)
    } catch * {
        trace(element aparecium:error {
           'Failure loading input string from',
           '
' || $input
        }, 
        'Failure loading input string, sorry.')
    },
    $compiled-grammar := try {
        doc($grammar/ixml)
    } catch * {
        trace(element aparecium:error {
           'Failure loading compiled grammar from',
           '
' || $grammar
        }, 
        'Failure loading compiled grammar, sorry.')        
    },

return aparecium:parse-string-with-compiled-grammar(
           $input-string, 
           $grammar)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>
</div>
<div class="Real-P">The <i>compile-grammar</i> module is intended to be
called from the command line; as the name suggests, it compiles a
grammar and returns it.
<div class="scrap"><span><a name="d3e403">&#x3008; 6  [File compile-grammar.xq]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">import module namespace aparecium 
= "http://blackmesatech.com/2019/iXML/Aparecium"
at "../build/Aparecium.xqm";

declare variable $file as xs:string external;

let $xml-grammar := doc($file),
    $compiled-grammar := aparecium:compile-grammar-from-xml($xml-grammar/ixml)
return $compiled-grammar
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>
</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#files-cli">&#x23f4;</a></span><span class="arrow"><a href="#hi-code-org">&#x23f6;</a></span><span class="arrow"><a href="#files-epi">&#x23f5;</a></span></div><h4><a class="selflink" name="files-parser" id="files-parser" href="#files-parser">3.1.3. </a>Parser:  <i>Earley-parser.xqm</i></h4>
<div class="Real-P"><i>Earley-parser.xqm</i> has the functions called
by the Aparecium module to parse the input and construct the
parse tree.</div>
<div class="Real-P">As far as I have been able to make it so, the functions defined
here are ignorant of details of how the data are represented; they
call functions defined in other modules to take care of the details.
<div class="scrap"><span><a name="d3e419">&#x3008; 7  [File Earley-parser.xqm]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">module namespace ep =
"http://blackmesatech.com/2019/iXML/Earley-parser";

(: The top-level definition of an Earley parser. :)

import module namespace epi =
"http://blackmesatech.com/2019/iXML/Earley-parser-internals"
at "Earley-parser-internals.xqm";

import module namespace er =
"http://blackmesatech.com/2019/iXML/Earley-recognizer"
at "Earley-recognizer.xqm";

import module namespace eri =
"http://blackmesatech.com/2019/iXML/Earley-rec-internals"
at "Earley-rec-internals.xqm";

declare namespace ap = 
"http://blackmesatech.com/2019/iXML/Aparecium";

declare namespace ixml = 
"http://invisiblexml.org/NS";

declare namespace map = 
"http://www.w3.org/2005/xpath-functions/map";
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>
</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#files-parser">&#x23f4;</a></span><span class="arrow"><a href="#hi-code-org">&#x23f6;</a></span><span class="arrow"><a href="#files-rec">&#x23f5;</a></span></div><h4><a class="selflink" name="files-epi" id="files-epi" href="#files-epi">3.1.4. </a>Parser internals:  <i>Earley-parser-internals.xqm</i></h4>
<div class="Real-P">Some lower-level functions are separated out into
<i>Earley-parser-internals.xqm</i>.  These functions are not
intended to be used by users of the Earley parsers; if I knew how to
hide their names, I would.  The functions defined here are intended to
be called by the parser proper; the internal details (in particular
the representation of data structures) are subject to change.
<div class="scrap"><span><a name="d3e434">&#x3008; 8  [File Earley-parser-internals.xqm]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">module namespace epi =
"http://blackmesatech.com/2019/iXML/Earley-parser-internals";

(: Internals of Earley parser. :)
(: Not intended for user exposure. :) 

import module namespace er =
"http://blackmesatech.com/2019/iXML/Earley-recognizer"
at "Earley-recognizer.xqm";

import module namespace eri =
"http://blackmesatech.com/2019/iXML/Earley-rec-internals"
at "Earley-rec-internals.xqm";

import module namespace d2x = 
'http://blackmesatech.com/2019/iXML/d2x'
at "d2x.xqm";

declare namespace follow = 
"http://blackmesatech.com/2016/nss/ixml-gluschkov-automata-followset"; 

declare namespace ixml = 
"http://invisiblexml.org/NS";

declare namespace ap = 
"http://blackmesatech.com/2019/iXML/Aparecium";

(: We rely on the EXPath file module, and we use maps. :)
declare namespace file =
"http://expath.org/ns/file";

declare namespace map =
"http://www.w3.org/2005/xpath-functions/map";



<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-earley-parse">Define earley-parse() 192</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-all-trees">Define all-trees() 204</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-any-tree">Define any-tree() 209</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tree-cursor">Define tree-cursor() 210</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-parse-forest-map">Define parse-forest-map() 211</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-parse-forest-grammar">Define parse-forest-grammar() 81</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tree-from-pfg">The epi:tree-from-pfg() function 106</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-all-node-sequences">Define all-node-sequences() 212</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-astXparsetree">Define astXparsetree() to make AST from raw parse 227</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>
</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#files-epi">&#x23f4;</a></span><span class="arrow"><a href="#hi-code-org">&#x23f6;</a></span><span class="arrow"><a href="#files-eri">&#x23f5;</a></span></div><h4><a class="selflink" name="files-rec" id="files-rec" href="#files-rec">3.1.5. </a>Recognizer: <i>Earley-recognizer.xqm</i></h4>

<div class="Real-P">Most of the actual work done is performed by the code in
<i>Earley-recognizer.xqm</i>: 

<div class="scrap"><span><a name="Earley-rec">&#x3008; 9  [File Earley-recognizer.xqm]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">module namespace ix =
"http://blackmesatech.com/2019/iXML/Earley-recognizer";

(: Earley parser, v0 :)

import module namespace ixi =
"http://blackmesatech.com/2019/iXML/Earley-rec-internals"
at "Earley-rec-internals.xqm";

<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#er-scan">Define scan() 75</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#er-pred">Define pred() 77</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#er-comp">Define comp() 78</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#er-recognize">Define recognize() 79</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>
</div>
</div>

<div class="div">

<div class="quicknav"><span class="arrow"><a href="#files-rec">&#x23f4;</a></span><span class="arrow"><a href="#hi-code-org">&#x23f6;</a></span><span class="arrow">&nbsp;</span></div><h4><a class="selflink" name="files-eri" id="files-eri" href="#files-eri">3.1.6. </a>Recognizer internals: <i>Earley-rec-internals.xqm</i></h4>
<div class="Real-P">The low-level functions of the recognizer are in
<i>Earley-rec-internals.xqm</i>.  The
&#x2018;public&#x2019; interface (the functions intended for use
by consumers) is in Earley-recognizer.xqm; this module contains
details that are subject to change and intended to be
&#x2018;private&#x2019;.</div>

<div class="Real-P">The Earley-rec-internals module has a (cyclic) import
for the recognizer itself (why?), and also some low-level
things.
<div class="scrap"><span><a name="eri-imports">&#x3008; 10 Imports for recognizer internals &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ****************************************************** 
   * Imports and setup
   ****************************************************** :)

import module namespace ix =
"http://blackmesatech.com/2019/iXML/Earley-recognizer"
at "Earley-recognizer.xqm";
  
import module namespace d2x =
'http://blackmesatech.com/2019/iXML/d2x'
at "d2x.xqm";
  
declare namespace follow = 
"http://blackmesatech.com/2016/nss/ixml-gluschkov-automata-followset";

(: $ixi:combinedups:  convenience variable for calls to 
   map:merge. :)
declare variable $ixi:combinedups as map(*)
   := map:entry('duplicates','combine');
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e503">[File Earley-rec-internals.xqm] 11</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">
The overall structure of the internals file:
<div class="scrap"><span><a name="d3e503">&#x3008; 11  [File Earley-rec-internals.xqm]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">module namespace ixi =
"http://blackmesatech.com/2019/iXML/Earley-rec-internals";

(: Earley recognizer internals :)

declare namespace map =
"http://www.w3.org/2005/xpath-functions/map";

<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-imports">Imports for recognizer internals 10</a></em> &#x3009;</span>   
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-items">Earley items (constructors, extractors, etc.) 127</a></em> &#x3009;</span>   
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-grammars">Grammars (constructors, extractors, etc.) 144</a></em> &#x3009;</span>   
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-rules">Rules (constructors, extractors, etc.) 150</a></em> &#x3009;</span>   
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-symbols">Symbols (constructors, extractors, etc.) 151</a></em> &#x3009;</span>   
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-input">Input (constructors, extractors, etc.) 163</a></em> &#x3009;</span>   
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-utils-and-misc">Utilities for recognizer internals module 168</a></em> &#x3009;</span>   
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
</div>
</div>

<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-code-org">&#x23f4;</a></span><span class="arrow"><a href="#highlevel">&#x23f6;</a></span><span class="arrow"><a href="#hi-prep-input">&#x23f5;</a></span></div><h3><a class="selflink" name="hi-calling" id="hi-calling" href="#hi-calling">3.2. </a>Calling the parser</h3><ul><li>3.2.1. <a href="#hi-call-options">User options</a><ul><li>3.2.1.1. <a href="#hi-call-opt-returns">How to return results</a></li><li>3.2.1.2. <a href="#hi-call-opt-how">Processing choices and behavior</a></li><li>3.2.1.3. <a href="#hi-call-opt-dfts">Default values for options</a></li></ul></li><li>3.2.2. <a href="#hi-call-pr">The <i>parse-resource()</i> function</a></li><li>3.2.3. <a href="#hi-call-ps">The <i>aparecium:parse-string()</i> function</a></li><li>3.2.4. <a href="#hi-call-pscg">The <i>aparecium:parse-string-with-compiled-grammar()</i> function</a></li><li>3.2.5. <a href="#hi-call-doc">The <i>aparecium:doc()</i> function</a></li></ul>

<div class="Real-P">Aparecium is designed to make loading non-XML resources as easy
as loading XML documents.  When loading XML, the user of the XPath 3
function library merely needs to call the <tt>doc()</tt>
function, with a URI naming the resource, and the processor takes
care of the rest.</div>
<div class="Real-P">Aparecium provides several main functions to do analogous work for
non-XML data described by a gramar:<ul><li><div class="Real-P">The <i>parse-resource()</i> function takes URIs for
the input string and the input grammar to be used to parse the
string.</div></li>
<li><div class="Real-P">The <i>parse-string()</i> function is intended for
use when the input string and the input grammar are already
available, as character strings.</div></li>
<li><div class="Real-P">The <i>parse-string-with-compiled-grammar()</i>
function caters for the case in which multiple strings are to be
parsed with the same grammar; functions to compile the grammar for
reuse are listed in section <a href="#alt-calls-secondary" title="Secondary user-facing calls">5.1</a>.</div></li>
<li><div class="Real-P">The <i>doc()</i> function (not yet implemented) is
an attempt to let the function library handle the task of
identifying a suitable grammar for a given input.</div></li>
</ul>

<div class="scrap"><span><a name="aparecium-main">&#x3008; 12 Main interfaces for Aparecium &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   * Main interfaces (and the simplest) 
   ******************************************************
   :)  
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ap-pr">Define parse-resource() 14</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ap-ps">Define parse-string() 16</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ap-pswcg">Define parse-string-with-compiled-grammar() 17</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ap-doc">The doc() function 18</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e339">[File Aparecium.xqm] 1</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">All of the user-facing functions should come in two forms, with and
without an <i>$options</i> argument.  The current set of
options are described <a href="#hi-call-options">below</a>.</div>


<div class="div">

<div class="quicknav"><span class="arrow">&nbsp;</span><span class="arrow"><a href="#hi-calling">&#x23f6;</a></span><span class="arrow"><a href="#hi-call-pr">&#x23f5;</a></span></div><h4><a class="selflink" name="hi-call-options" id="hi-call-options" href="#hi-call-options">3.2.1. </a>User options</h4><ul><li>3.2.1.1. <a href="#hi-call-opt-returns">How to return results</a></li><li>3.2.1.2. <a href="#hi-call-opt-how">Processing choices and behavior</a></li><li>3.2.1.3. <a href="#hi-call-opt-dfts">Default values for options</a></li></ul>

<div class="Real-P">All the functions in this group have an optional
<i>$options</i> argument, which takes the form of a map with
string keys and atomic values.  For the moment, the options we care
about are these (not all implemented -- I am trying to plan ahead for
once).</div>


<div class="div">

<div class="quicknav"><span class="arrow">&nbsp;</span><span class="arrow"><a href="#hi-call-options">&#x23f6;</a></span><span class="arrow"><a href="#hi-call-opt-how">&#x23f5;</a></span></div><h5><a class="selflink" name="hi-call-opt-returns" id="hi-call-opt-returns" href="#hi-call-opt-returns">3.2.1.1. </a>How to return results</h5>
<div class="Real-P">First, options describing <b>what to return to the user</b>.
These are a set of Boolean values, with the indicated default values.
<ul><li><div class="Real-P"><tt>return-tree</tt> (<tt>true</tt>): return a parse
tree, if there is any.  If there is none, an
&lt;<em>aparecium:no-parse</em>&gt; element is returned.

</div></li>
<li><div class="Real-P"><tt>return-pfg</tt> (<tt>false</tt>): return a
parse-forest grammar, if there is one.</div></li>
<li><div class="Real-P"><tt>return-items</tt> (<tt>false</tt>): return an
XML representation of the Earley set constructed during parsing.
Unlikely to be of interest except for debugging.</div></li>
<li><div class="Real-P"><tt>return-grammar</tt> (<tt>false</tt>): return the
XML representation of the compiled grammar.</div></li>
</ul>
</div>
<div class="Real-P">If trees are requested, then <tt>tree-type</tt> is relevant:
<ul><li><tt>tree-type</tt>: <tt>ast</tt> (the abstract syntax tree
described by the marks in the grammar) or <tt>raw</tt> (the raw parse
tree, ignoring the marks in the grammar).
Default value: <tt>ast</tt>.</li>
</ul>
</div>



<div class="Real-P">If more than one of these is set, then the results will be wrapped
in an enclosing &lt;<em>aparecium:result</em>&gt; element.</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-call-opt-returns">&#x23f4;</a></span><span class="arrow"><a href="#hi-call-options">&#x23f6;</a></span><span class="arrow"><a href="#hi-call-opt-dfts">&#x23f5;</a></span></div><h5><a class="selflink" name="hi-call-opt-how" id="hi-call-opt-how" href="#hi-call-opt-how">3.2.1.2. </a>Processing choices and behavior</h5>
<div class="Real-P">Some options describe <b>processing choices</b>.  Some of
these affect conformance.</div>
<div class="Real-P">First, there are four options that control behavior regarding
individual points of grammar &#x2018;hygiene&#x2019;:
<ul><li><div class="Real-P"><tt>multiple-definitions</tt>: how should multiple definition
of a nonterminal symbol be treated?  As an <tt>error</tt>, as a <tt>warning</tt>,
or passed over in <tt>silence</tt>?</div>
<div class="Real-P"><i>Currently only <tt>error</tt> is implemented.</i></div></li>
<li><div class="Real-P"><tt>undefined-symbols</tt>: how should undefined nonterminal symbols
be treated? (Same values.)</div>
<div class="Real-P"><i>Currently only <tt>error</tt> is implemented.</i></div></li>
<li><div class="Real-P"><tt>unreachable-symbols</tt>: how should unreachable nonterminal symbols
be treated? (Same values.)</div>
<div class="Real-P"><i>Currently only <tt>silence</tt> is implemented.</i></div></li>
<li><div class="Real-P"><tt>unproductive-symbols</tt>: how should unproductive nonterminal symbols
be treated? (Same values.)</div>
<div class="Real-P"><i>Currently only <tt>silence</tt> is implemented.</i></div></li>
</ul>
</div>
<div class="Real-P">Then there are some options which serve as short-hand for those
just mentioned.
</div>
<div class="Real-P">The <tt>hygiene</tt> option provides a sort of gang-switch for the
individual hygiene options:
<ul><li><div class="Real-P"><tt>hygiene</tt>: what should the processor do about checking
grammar hygiene issues?  
<ul><li><tt>error</tt>: treat any hygiene issue as a fatal error.
Unless they are specified individually, sets all four hygiene options
to <tt>error</tt>.</li>
<li><tt>tolerant</tt> or <tt>warning</tt>: sets hygiene options to
<tt>warning</tt>.</li>
<li><tt>silence</tt>:  sets hygiene options to <tt>silence</tt>.</li>
<li><tt>conformant</tt> or <tt>easy</tt>: sets <tt>multiple-definitions</tt> and
<tt>undefined-symbols</tt> to <tt>warning</tt> because they are easy
to check, sets <tt>unreachable-symbols</tt> and
<tt>unproductive-symbols</tt> to <tt>silence</tt> because they are
harder.</li>
</ul></div></li>
<li><div class="Real-P"><tt>conformance</tt>: how strict should conformance checking be?
<ul><li><tt>strict</tt> (default): enforce all conformance rules; sets
<tt>hygiene</tt> to <tt>conformant</tt> unless it is set
separately.</li>
<li><tt>pedantic</tt>:  currently a synonym for <tt>strict</tt>.</li>
<li><tt>tolerant</tt>: enforce most conformance rules, but ignore
those that seem unhelpful; sets <tt>hygiene</tt> to <tt>tolerant</tt>.
(<i>When the underlying options are all implemented, this will become
the default.</i>)</li>
</ul></div></li>
</ul>
<i>Currently only <tt>easy</tt> is implemented.</i>
</div>
<div class="Real-P">Other options may be described later.</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-call-opt-how">&#x23f4;</a></span><span class="arrow"><a href="#hi-call-options">&#x23f6;</a></span><span class="arrow">&nbsp;</span></div><h5><a class="selflink" name="hi-call-opt-dfts" id="hi-call-opt-dfts" href="#hi-call-opt-dfts">3.2.1.3. </a>Default values for options</h5>

<div class="Real-P">The default options are specified as a global variable:
<div class="scrap"><span><a name="aparecium-variables">&#x3008; 13 Variables (of interest only for maintainer) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   * Variables (of interest only for maintainer) 
   ******************************************************
   :)
declare variable $aparecium:options 
   as map(xs:string, item()*)
   := map {
        'return-tree': true(),
        'return-pfg': false(),
        'return-items': false(),
        'return-grammar': false(),

        'tree-type': 'ast',
        <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#aparecium-other-default-options">Other default options 50</a></em> &#x3009;</span>
      };
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e4937">Location of library 190</a>&#x3009;, &#x3008;<a href="#d3e4950">Location of ixml grammar 191</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e339">[File Aparecium.xqm] 1</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">
<i>N.B. Not all of these options are implemented yet.</i></div>
<div class="Real-P"><i>To do: figure out how to pass in options from the command line.</i></div>
<div class="Real-P">
<i>To do:</i> allow options
on these to control what is returned, and how:
<ul><li>parse tree(s) or parse-forest grammar?</li>
<li>AST (as in the spec) or raw parse tree (for debugging)?</li>
<li>with or without <em>_from</em> and <em>_to</em> attributes
giving character offsets of the construct?</li>
</ul>
</div>
</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-call-options">&#x23f4;</a></span><span class="arrow"><a href="#hi-calling">&#x23f6;</a></span><span class="arrow"><a href="#hi-call-ps">&#x23f5;</a></span></div><h4><a class="selflink" name="hi-call-pr" id="hi-call-pr" href="#hi-call-pr">3.2.2. </a>The <i>parse-resource()</i> function</h4>
<div class="Real-P">Given URIs for the input and an ixml grammar describing it, the
<i>parse-resource()</i> function returns (if all goes well)
the XML representation of the resource. If not all goes well, XML
representations of other situations are returned:
<ul><li><div class="Real-P">An &lt;<em>aparecium:no-parse</em>&gt; element indicates that the
grammar does not actually describe the input &#x2014; the input is
not a sentence in the language described by the grammar.  The
element may contain some diagnostic information intended to help the
human user understand where the parsing attempt failed.</div></li>
<li><div class="Real-P">An &lt;<em>aparecium:error</em>&gt; element indicates that
something went wrong.  It should have both an error code (tbd) and
some prose explanation of the error.</div>
<div class="Real-P"><i>At present, the error detection and error reporting of
Aparecium offer many opportunities for improvement.</i></div></li>
</ul>
Let's try (experimentally) a slightly more systematic description.
<ul><li><div class="Real-P"><b>Pre-requisites:</b></div>
<ul><li><div class="Real-P"><i>$uriI</i> is an untrusted string value to be
interpreted as a URI for the input string to be parsed.</div></li>
<li><div class="Real-P"><i>$uriG</i> is an untrusted string value to be
interpreted as a URI for the grammar to be used in parsing the input
string.</div></li>
<li><div class="Real-P"><i>$options</i>, if specified, is an untrusted map to
be interpreted as options for processing.</div></li>
</ul>
</li>
<li><div class="Real-P"><b>Post-conditions / assurances:</b></div>
<ul><li><div class="Real-P">If a resource denoted by <i>$uriI</i> is available,
then the string value of the resource is the input stream to be
parsed; otherwise, an <i>aparecium:error</i> is
returned.</div></li>
<li><div class="Real-P">If a resource denoted by <i>$uriG</i> is available,
the string value of that resource is an untrusted input grammar to be
used in parsing; otherwise, an <i>aparecium:error</i> is
returned.</div></li>
<li><div class="Real-P">If <i>$options</i> is supplied, its values are
checked and default values are supplied for options not specified.
Undocumented options are not removed.  Warnings are issued if options
are unknown or incorrect.</div></li>
<li><div class="Real-P">If parsing (or other processing) is successful, the results
of parsing requested in <i>$options</i> are returned; if
processing is unsuccessful, an <i>aparecium:error</i> element
is returned. If multiple results are requested and processing is
partly successful, the results may include some normal results and
some error elements.</div>
<div class="Real-P">Details as for
<i>parse-string-with-compiled-grammar()</i>.</div>
</li>
</ul>
</li>
</ul>


<div class="scrap"><span><a name="ap-pr">&#x3008; 14 Define parse-resource() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   parse-resource($Input, $Grammar)
   ......................................................
:)
declare function aparecium:parse-resource(
  $uriI as xs:string,
  $uriG as xs:string
) as element() {
  aparecium:parse-resource($uriI, $uriG, $aparecium:options)
};

declare function aparecium:parse-resource(
  $uriI as xs:string,
  $uriG as xs:string,
  $options as map(*)
) as element() {
  let $sI := if (unparsed-text-available($uriI))
             then unparsed-text($uriI)
             else (),
      $sG := if (unparsed-text-available($uriG))
             then unparsed-text($uriG)
             else ()
  return if (exists($sI) and exists($sG))
         then aparecium:parse-string($sI, $sG, $options)
         else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#appr-errors">If input or grammar are not found, say so 15</a></em> &#x3009;</span>
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#aparecium-main">Main interfaces for Aparecium 12</a> &#x3009; <br></span>
</div>

We wrap the attempts to dereference the URIs in conditionals so as
to detect the case where they are not in fact available.  If both
the input and the grammar are available, we call the
<i>parse-string()</i> function and return its result.  (Note
that we assume that if <i>unparsed-text-available()</i>
succeeds, then <i>unparsed-text()</i> will also succeed.
<i>The Functions and Operators spec should be checked to make sure
this is the guarantee.</i>) If either, or both, are missing, we
return an error element.
<div class="scrap"><span><a name="appr-errors">&#x3008; 15 If input or grammar are not found, say so &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">         if (exists($sI))
         then element aparecium:error {
              attribute id { "ap:tbd01" },
              "Grammar (" || $uriG || ") not found."
         }
         else if (exists($sG))
         then element aparecium:error {
              attribute id { "ap:tbd02" },
              "Input string (" || $uriI || ") not found."
         }
         else element aparecium:error {
              attribute id { "ap:tbd03" },
              "Input string (" || $uriI || ") not found.",
              "Grammar (" || $uriG || ") not found.",
              "You're breaking my heart here."
         }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#ap-pr">Define parse-resource() 14</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-call-pr">&#x23f4;</a></span><span class="arrow"><a href="#hi-calling">&#x23f6;</a></span><span class="arrow"><a href="#hi-call-pscg">&#x23f5;</a></span></div><h4><a class="selflink" name="hi-call-ps" id="hi-call-ps" href="#hi-call-ps">3.2.3. </a>The <i>aparecium:parse-string()</i> function</h4>

<div class="Real-P">Given strings with the input and an ixml grammar describing it,
the <i>parse-string()</i> function returns the XML
representation of the resource, or an &lt;<em>aparecium:no-parse</em>&gt;
element, or an &lt;<em>aparecium:error</em>&gt; element.</div>

<div class="Real-P">Description:
<ul><li><div class="Real-P"><b>Pre-requisites:</b></div>
<ul><li><div class="Real-P"><i>$sI</i> is the input string to be parsed.  We may
assume it consists of XML characters.</div></li>
<li><div class="Real-P"><i>$sG</i> is an untrusted string value to be
interpreted as a grammar to be used in parsing the input
string.</div></li>
<li><div class="Real-P"><i>$options</i>, if specified, is an untrusted map to
be interpreted as options for processing.</div></li>
</ul>
</li>
<li><div class="Real-P"><b>Post-conditions / assurances:</b></div>
<ul><li>
<div class="Real-P">If <i>$sG</i> is a usable grammar, then <i>$sI</i>
is parsed against it and results returned in accordance with the
specified <i>$options</i>; details as for
<i>parse-string-with-compiled-grammar()</i>.</div>
</li>
<li>
<div class="Real-P">If <i>$sG</i> is not a usable grammar, an &lt;<em>aparecium:error</em>&gt;
element is returned.</div>
</li>
</ul>
</li>
</ul>
<div class="scrap"><span><a name="ap-ps">&#x3008; 16 Define parse-string() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   parse-string($Input, $Grammar)
   ......................................................
:)

declare function aparecium:parse-string(
  $sI as xs:string,
  $sG as xs:string
) as element() {
  aparecium:parse-string($sI, $sG, $aparecium:options)
};

declare function aparecium:parse-string(
  $sI as xs:string,
  $sG as xs:string,
  $options as map(*)
) as element() {
  let $cG := (:stat ...prof:time( ... tats:)
             aparecium:compile-grammar-from-string($sG, $options)
             (:stat ..., 
             'parse-string: compiling grammar from string:') 
             ... tats:)
             
  return 
    if ($cG/self::aparecium:error)
    then element aparecium:error {
      attribute id { "ap:tbd04" },
      "parse-string():  Error compiling grammar.",
      $cG      
    }
    else (:stat ...prof:time( ... tats:)
         aparecium:parse-string-with-compiled-grammar(
             $sI, $cG, $options
         )
         (:stat ..., 'parse-string:  parsing input string:') ... tats:)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#aparecium-main">Main interfaces for Aparecium 12</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-call-ps">&#x23f4;</a></span><span class="arrow"><a href="#hi-calling">&#x23f6;</a></span><span class="arrow"><a href="#hi-call-doc">&#x23f5;</a></span></div><h4><a class="selflink" name="hi-call-pscg" id="hi-call-pscg" href="#hi-call-pscg">3.2.4. </a>The <i>aparecium:parse-string-with-compiled-grammar()</i> function</h4>

<div class="Real-P">Given a string with the input and the pre-processed 
form of an ixml grammar describing it, the function
<i>parse-string-with-compiled-grammar()</i> returns the XML
representation of the string's parse tree.</div>
<div class="Real-P">This is the workhorse of the library, called by many other
functions.  Because it can be called directly with an untrusted
grammar, by default it checks the grammar before using it.[<a name="ref-to-d3e1036" href="#d3e1036" title="&#xA;Since in many cases, the grammar in question will just&#xA;have been checked, this may lead to unnecessary slowdowns&#xA;in some cases.  If it becomes an issue, we can">3</a>]
Description:
<ul><li><div class="Real-P"><b>Pre-requisites:</b></div>
<ul><li><div class="Real-P"><i>$sI</i> is the input string to be
parsed.</div></li>
<li><div class="Real-P"><i>$cG</i> is a(n untrusted) compiled grammar.</div>
<div class="Real-P"><i>At the moment, it is treated as untrusted, even though in some
cases it is known to be OK and does not need to be checked.  To do:
make a separate function for parsing with a trusted compiled
grammar.</i></div></li>
<li><div class="Real-P"><i>$options</i>, if specified, is an untrusted map to
be interpreted as options for processing.</div></li>
</ul>
</li>
<li><div class="Real-P"><b>Post-conditions / assurances:</b></div>
<ul><li><div class="Real-P">If <i>$options</i> is supplied, its values are
checked and default values are supplied for options not specified.
Undocumented options are not removed.  Warnings are issued if options
are unknown or incorrect.</div></li>
<li><div class="Real-P">An element with the same name as the grammar's start symbol
is returned if and only if
<ul><li><i>$sI</i> can be derived from the
start symbol of <i>$sG</i> and</li>
<li>the returned element exhibits the
parse tree for some such derivation and</li>
<li>the <tt>return-tree</tt> option is set.</li>
</ul>
</div>
<div class="Real-P">The token <tt>ambiguous</tt> is returned as (part of) the value of 
an <i>ixml:state</i> attribute on the root element if and only if
there is more than one derivation for the input.</div>
</li>
<li><div class="Real-P">An &lt;<em>aparecium:no-parse</em>&gt; element is returned
(with diagnostic contents) if and only if <i>$cG</i> is
a usable grammar and <i>$sI</i> cannot be derived from
its start symbol.</div></li>
<li><div class="Real-P">An &lt;<em>aparecium:error</em>&gt; is returned if
<ul><li><i>$cG</i> is not usable (concretely, if <i>grammar-ok</i>
flags any errors_, or</li>
<li>parsing was not possible for any other reason.</li>
</ul>
</div></li>
<li><div class="Real-P">An &lt;<em>ixml</em>&gt; element with a parse-forest grammar is
returned if and only if 
<ul><li><i>$cG</i> is usable and</li>
<li>the <tt>return-pfg</tt> option is set.</li>
</ul>
</div></li>
<li><div class="Real-P">An &lt;<em>ixml</em>&gt; element with a compiled form of the
user-suppied grammar is returned if and only if
<ul><li><i>$cG</i> is usable and</li>
<li>the <tt>return-grammar</tt> option is set.</li>
</ul>
</div></li>
<li><div class="Real-P">An &lt;<em>aparecium:item-list</em>&gt; element with the set of all
Earley items generated in parsing is returned if and only if
<ul><li>the <tt>return-items</tt> option is set.</li>
</ul>
</div></li>
</ul>
</li>
</ul>

<div class="scrap"><span><a name="ap-pswcg">&#x3008; 17 Define parse-string-with-compiled-grammar() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   parse-string-with-compiled-grammar($Input, $Grammar)
   ......................................................
:)
declare function aparecium:parse-string-with-compiled-grammar(
  $sI as xs:string,
  $cG as element(ixml)
) as element() {
  aparecium:parse-string-with-compiled-grammar(
      $sI, $cG, $aparecium:options
  )
};

declare function aparecium:parse-string-with-compiled-grammar(
  $sI as xs:string,
  $cG as element(ixml),
  $options0 as map(*)
) as element() {
  let $options := map:merge(($options0, $aparecium:options))

  let $cg-ok := (:stat ...prof:time( ... tats:)
                aparecium:grammar-ok($cG, $options)
                (:stat ..., 'pswcg() calling grammar-ok():') ... tats:)

  let $result := if ($cg-ok/self::ixml) 
                 then (:stat ...prof:time( ... tats:)
                     earley:parse($sI, $cG, $options) 
                     (:stat ...
                     , '0 Outer call to earley:parse(): ')
                      ... tats:)
                 else element aparecium:error {
                   attribute id { "ap:tbd05" },
                   "Compiled grammar flawed:",
                   $cg-ok
                 }
		 
  return if (count($result) eq 1)
         then $result
         else &lt;forest 
              xmlns:ixml="http://invisiblexml.org/NS"
	      &gt;{$result}&lt;/forest&gt;
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#aparecium-main">Main interfaces for Aparecium 12</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-call-pscg">&#x23f4;</a></span><span class="arrow"><a href="#hi-calling">&#x23f6;</a></span><span class="arrow">&nbsp;</span></div><h4><a class="selflink" name="hi-call-doc" id="hi-call-doc" href="#hi-call-doc">3.2.5. </a>The <i>aparecium:doc()</i> function</h4>


<div class="Real-P">In the simple case, Aparecium is designed to be callable
in much the same way as the <tt>doc()</tt> function.
If the file at <i>http://example.com/local.css</i>
were in XML, the expression
<tt>doc("http://example.com/local.css")</tt>
would have a document node as its value.  But a file
named <i>local.css</i> is probably not in XML.
With Aparecium, the idea is to open it with a call like
<tt>aparecium:parse-resource( "http://example.com/local.css",
"http://example.com/grammars/css.ixml")</tt>, which will
fetch the CSS file and a grammar for CSS, use the grammar
to parse the CSS, and return the document node of an XML
document representing the resulting parse tree.</div>

<div class="Real-P">The <i>aparecium:doc()</i> function is intended to be as close
as possible to the <i>fn:doc()</i> function.

<i>This function is not yet implemented, because I haven't gotten
around to it yet.  To work well, it requires a bit more
infrastructure.</i>

<div class="scrap"><span><a name="ap-doc">&#x3008; 18 The doc() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   doc($InputURI)
   ......................................................
   Given the URI of the input, fetch the ixml grammar 
   describing it and return the XML representation of 
   the resource.
:)

(: TO BE IMPLEMENTED: use html fetch to get both HTTP
header and payload.  If MIME type is ixml, fetch grammar
and call parse-string.  Otherwise, if XML and 200 return
payload, otherwise return header and payload.

declare function aparecium:doc(
  $uriI as xs:string
) as element() {
  let $sI := unparsed-text($uriI),
      $sG := unparsed-text($uriG)
  return aparecium:parse-string($sI, $sG)
};
:)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#aparecium-main">Main interfaces for Aparecium 12</a> &#x3009; <br></span>
</div>

Before it can parse the resource, the <i>doc()</i> function
will need to find a grammar for it.  There are two ways this
can happen (maybe more).
<ul><li><div class="Real-P">The web server hosting the resource can label it with an HTTP
header in which a reference to the grammar is given.  In <a href="#Pemberton-2013"></a>, the example given is a CSS stylesheet which
can be served either as <tt>text/css</tt> (which is usual)
<em>or</em> with the HTTP mediatype header
<tt>application/xml-invisible;
syntax=http://example.com/syntax/css</tt>.  The media type
<tt>application/xml-invisible</tt> (not currently standardized)
signals that the resource is an invisible XML document; the
<tt>syntax</tt> parameter gives the URI of an appropriate ixml
grammar.</div>
<div class="Real-P">This approach allows ixml to fit nicely into the architecture of
the Web.  It has the drawback that for the foreseeable future few
servers will provide such HTTP headers; of lesser importance in the
long run (but one important reason the <i>aparecium:doc()</i> function
has not yet been implemented) is that this approach requires
the implementor of an invisible-XML parser to understand
content negotiation and implement it correctly.</div>
</li>
<li><div class="Real-P">Even if the web server does not provide a pointer to an
invisible-XML grammar, an ixml parser can keep a cache or directory of
grammars for a set of known media types, and use the media type
returned by the server to find an appropriate grammar.</div>
<div class="Real-P">A parser's installation package might, for example, install
grammars for common media types (<tt>text/css</tt>,
<tt>text/csv</tt>, 
<tt>text/markdown</tt>,
<tt>application/sql</tt>,

etc.) and use them when <i>doc()</i> is called on a resource
with a known media type.  Since grammars for known media types will be
useful for all ixml users, there might be reason to make the
collection of grammars available on the web.</div>
<div class="Real-P">A parser might allow the user to add grammars to the
cache, to fill gaps in the collection.</div>
<div class="Real-P">Unfortunately, a number of notations that might be of interest to
ixml users have no MIME type registered with IANA, so this approach
does not help for TeX or LaTeX files (even ones that do not change the
default parsing rules), or for grammars in well known notations like
ABNF or Wirth's EBNF or ISO-standard EBNF.  Other notations of
possible interest for ixml users (such as SVG path expressions,
XPath expressions, XSLT match patterns, and others) do not have
registered media types because they are generally embedded in other
contexts rather than being served as stand-alone resources.</div>
</li>
<li><div class="Real-P">In an environment where a small number of grammars are very
often used, an ixml parser might emulate web browsers which sniff
content by examining the first portion of a resource and seeing
whether it &#x2018;looks&#x2019; like a known media type.  In the
same way, an ixml parser could attempt to identify the grammar of an
undocumented (or <tt>text/plain</tt>) resource by attempting to
parse the first 100 characters using several grammars.  This seems
unlikely to be generally useful, however: there are too many possible
grammars.</div>
</li>
</ul>
</div>
</div>

</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-calling">&#x23f4;</a></span><span class="arrow"><a href="#highlevel">&#x23f6;</a></span><span class="arrow"><a href="#hi-prep-grammar">&#x23f5;</a></span></div><h3><a class="selflink" name="hi-prep-input" id="hi-prep-input" href="#hi-prep-input">3.3. </a>Preparing the input</h3>
<div class="Real-P">The input does not require any particular preparation (beyond
loading it from a URI in some cases). So this section turns out
to be empty.</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-prep-input">&#x23f4;</a></span><span class="arrow"><a href="#highlevel">&#x23f6;</a></span><span class="arrow"><a href="#hi-earley-parse">&#x23f5;</a></span></div><h3><a class="selflink" name="hi-prep-grammar" id="hi-prep-grammar" href="#hi-prep-grammar">3.4. </a>Preparing the grammar</h3><ul><li>3.4.1. <a href="#hi-compile-grammar">Compiling the grammar</a><ul><li>3.4.1.1. <a href="#higl-prolog">Module prolog</a></li><li>3.4.1.2. <a href="#higl-ME">Calculating the Gluschkov automaton <i>M</i><sub><i>E</i></sub></a></li><li>3.4.1.3. <a href="#higl-ME-terminals">Gluschkov automata for terminal symbols</a></li><li>3.4.1.4. <a href="#higl-ME-nonterminals">Gluschkov automata for nonterminal symbols</a></li><li>3.4.1.5. <a href="#higl-ME-opt-rep">Gluschkov automata for repetitions and options</a></li><li>3.4.1.6. <a href="#higl-ME-sequences">Gluschkov automata for sequences (&lt;<em>alt</em>&gt;)</a></li><li>3.4.1.7. <a href="#higl-ME-choice">Gluschkov automata for choice (&lt;<em>alts</em>&gt;)</a></li><li>3.4.1.8. <a href="#higl-ME-choice">Gluschkov automata for other elements</a></li></ul></li><li>3.4.2. <a href="#hi-check-compiled-grammar">Checking the compiled grammar</a><ul><li>3.4.2.1. <a href="#hi-ccg-what">What is checked</a></li><li>3.4.2.2. <a href="#hi-ccg-gok">The <i>grammar-ok()</i> function</a><ul><li>3.4.2.2.1. <a href="#hi-ccg-gok-str">Structural checks</a></li><li>3.4.2.2.2. <a href="#hi-ccg-gok-nonxml">Checking for non-XML names</a></li><li>3.4.2.2.3. <a href="#hi-ccg-gok-duprules">Checking for multiple definitions</a></li><li>3.4.2.2.4. <a href="#hi-ccg-gok-classes">Checking character classes</a></li><li>3.4.2.2.5. <a href="#hi-ccg-gok-hex">Checking hex literals</a></li><li>3.4.2.2.6. <a href="#hi-ccg-gok-range">Checking ranges</a></li><li>3.4.2.2.7. <a href="#hi-ccg-gok-undef">Checking for undefined nonterminals</a></li><li>3.4.2.2.8. <a href="#hi-ccg-gok-unreachable">Checking for unreachable rules</a></li><li>3.4.2.2.9. <a href="#hi-ccg-gok-unprod">Checking for unproductive nonterminals</a></li></ul></li></ul></li></ul>
<div class="Real-P">The grammar, on the other hand, does need preparation: once
it's in XML form, it's &#x2018;compiled&#x2019;, which
here means that attributes are added to each &lt;<em>rule</em>&gt; element
describing the right-hand side of the rule as a finite state
automaton, and providing some other information.</div>
<div class="Real-P">In the ideal case, there would be three slightly different data
flows, depending on how the grammar was supplied:
<ul><li>for a string: parsing into XML, hygiene and other conformance
checks, cleanup, compilation;</li>
<li>for XML: structural checks on the XML, hygiene and other
conformance checks, cleanup, compilation;</li>
<li>for a compiled grammar supplied by the user: structural checks
on the XML, hygiene and other conformance checks, cleanup.</li>
</ul>
For the first two, cleanup precedes compilation since cleanup of the
grammar can reduce its size, so the compiler has less work to do.</div>
<div class="Real-P">But the current code uses the same work-flow for all grammars: an
ixml grammar is parsed into XML; an XML grammar is compiled; a
compiled grammar is examined for structural integrity and hygiene
and then cleaned up if options permit it.</div>



<div class="Real-P"><i>Notes towards refactoring:</i> There are several operations
we need to perform on the grammar; how should they be sequenced?
A tentative sequence:
<ul><li>calculating effective mark for every nonterminal
reference(?)</li>
<li>regular expressions for terminals:<ul><li>generation of regular expressions for terminals</li>
<li>simplification of resulting expressions (to deal with
terminals which generate the empty language)</li>
</ul>
Simplification should precede calculation of Gluschkov automaton.
</li>
<li>inlining to reduce number of Earley items to create:
<ul><li>identification of nonterminals which should be inlined</li>
<li>rewriting the grammar with inlined hidden nonterminals</li>
<li>simplifying resulting expressions</li>
</ul>
Rewriting and simplification should precede calculation of Gluschkov
automaton.
The inlining of hidden nonterminals will interact with the detection
of hidden pseudo-terminals.
</li>
<li>rewriting to create pseudo-terminals:
<ul><li>marking all nonterminals as CDATA, element-only, or mixed</li>
<li>identification of nonterminals which are candidate
pseudo-terminals:<ul><li>regular (only regular descendants)</li>
<li>marked ^ with no ^ descendants, or marked - but with a parent
which is not a candidate pseudo-terminal</li>
</ul></li>
<li>calculating regular expressions for pseudo-tokens</li>
<li>marking pseudo-tokens</li>
</ul>
The detection of hidden pseudo-terminals will interact with
the inlining of hidden nonterminals.
</li>
<li>annotation of each rule with Gluschkov automaton for its
right-hand sides</li>
<li>calculating whether the grammar is LL(1)</li>
<li>determining whether a pseudo-token can be recognized greedily
or must be recognized cautiously.</li>
</ul>
<i>For now, the sequence is simpler: we calculate regexes for
terminals in the same pass as the Gluschkov automaton.  We do not
identify pseudo-terminals, we do not inline hidden nonterminals,</i>
</div>


<div class="div">

<div class="quicknav"><span class="arrow">&nbsp;</span><span class="arrow"><a href="#hi-prep-grammar">&#x23f6;</a></span><span class="arrow"><a href="#hi-check-compiled-grammar">&#x23f5;</a></span></div><h4><a class="selflink" name="hi-compile-grammar" id="hi-compile-grammar" href="#hi-compile-grammar">3.4.1. </a>Compiling the grammar</h4><ul><li>3.4.1.1. <a href="#higl-prolog">Module prolog</a></li><li>3.4.1.2. <a href="#higl-ME">Calculating the Gluschkov automaton <i>M</i><sub><i>E</i></sub></a></li><li>3.4.1.3. <a href="#higl-ME-terminals">Gluschkov automata for terminal symbols</a></li><li>3.4.1.4. <a href="#higl-ME-nonterminals">Gluschkov automata for nonterminal symbols</a></li><li>3.4.1.5. <a href="#higl-ME-opt-rep">Gluschkov automata for repetitions and options</a></li><li>3.4.1.6. <a href="#higl-ME-sequences">Gluschkov automata for sequences (&lt;<em>alt</em>&gt;)</a></li><li>3.4.1.7. <a href="#higl-ME-choice">Gluschkov automata for choice (&lt;<em>alts</em>&gt;)</a></li><li>3.4.1.8. <a href="#higl-ME-choice">Gluschkov automata for other elements</a></li></ul>

<div class="Real-P">Compilation is handled by a separate module,
<i>Gluschkov.xqm</i>, which has routines for annotating a
grammar with attributes that allow the right-hand sides to be
interpreted as Gluschkov automata: that is, finite state automata
whose states are the basic symbols of the regular expression.
<div class="scrap"><span><a name="d3e1336">&#x3008; 19  [File Gluschkov.xqm]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">module namespace gl =
"http://blackmesatech.com/2019/iXML/Gluschkov";

(: Constructs a Gluschkov automaton for ixml :)

(: GPL ...:) 

<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-prolog">Prolog for Gluschkov module 20</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME">Define function gl:ME() 21</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-merge">Define gl:merge() 35</a></em> &#x3009;</span>

<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-trace">Define trace() function for debugging 181</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>
</div>

<div class="Real-P">This module is one place affected by the syntax changes
between 2013 and 2021.  Most scraps have been written twice,
once in the initial version following the 2013 syntax,
and again for today's syntax. 
(Steven's original paper said something about bootstrapping
and supporting multiple syntaxes, but I got confused and am
not going to try to do that.  Too clever for me.)
Most of the old code should by now have been moved into
an <a href="#ob-ll-sym">appendix</a>.
</div>


<div class="div">

<div class="quicknav"><span class="arrow">&nbsp;</span><span class="arrow"><a href="#hi-compile-grammar">&#x23f6;</a></span><span class="arrow"><a href="#higl-ME">&#x23f5;</a></span></div><h5><a class="selflink" name="higl-prolog" id="higl-prolog" href="#higl-prolog">3.4.1.1. </a>Module prolog</h5>
<div class="Real-P">The module prolog defines a namespace for follow sets, and a
variable with the namespace name.  We also import the
<i>d2x</i> library so we can use its hex-to-decimal
conversion, and the Earley recognizer internal module, for
constructing regexes from terminal symbols.[<a name="ref-to-d3e1363" href="#d3e1363" title="&#xA;The resulting circular import seems to suggest a failure&#xA;of analysis:  perhaps the regex construction belongs here.&#xA;But I expect grammar compilation to be refa">4</a>]
<div class="scrap"><span><a name="gl-prolog">&#x3008; 20 Prolog for Gluschkov module &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">import module namespace d2x =
'http://blackmesatech.com/2019/iXML/d2x'
at "d2x.xqm";

import module namespace eri =
"http://blackmesatech.com/2019/iXML/Earley-rec-internals"
at "Earley-rec-internals.xqm";

declare namespace follow =
"http://blackmesatech.com/2016/nss/ixml-gluschkov-automata-followset";

declare namespace ap = 
"http://blackmesatech.com/2019/iXML/Aparecium";

declare variable $gl:follow-ns :=
"http://blackmesatech.com/2016/nss/ixml-gluschkov-automata-followset";
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e1336">[File Gluschkov.xqm] 19</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#higl-prolog">&#x23f4;</a></span><span class="arrow"><a href="#hi-compile-grammar">&#x23f6;</a></span><span class="arrow"><a href="#higl-ME-terminals">&#x23f5;</a></span></div><h5><a class="selflink" name="higl-ME" id="higl-ME" href="#higl-ME">3.4.1.2. </a>Calculating the Gluschkov automaton <i>M</i><sub><i>E</i></sub></h5>

<div class="Real-P">For a regular expression <i>E</i>, the Gluschkov automaton
(conventionally referred to as <i>M</i><sub><i>E</i></sub>) is a finite state automaton
derived from (and in some sense constructed on top of) <i>E</i>.  The
states of <i>M</i><sub><i>E</i></sub> are the basic symbols of <i>E</i>, with the fairly
straightforward interpretation that we are in a given state <i>q</i> if and
only if we have just read an input character (or, in the general case,
character sequence) that matches the atomic symbol <i>q</i>.  We calculate
the Gluschkov automaton by following the algorithm laid out in <a href="#ABK1993" title="&#xA;Anne Br&#xfc;ggemann-Klein,&#xA;Regular expressions into finite automata,&#xA;Theoretical Computer Science&#xA;120.2 (1993): 197-213.&#xA;">[Br&#xfc;ggemann-Klein 1993]</a>, adapted for the XML form of ixml grammars.</div>

<div class="Real-P">Each node <i>$E</i> in the expression gets:
<ul><li><em>id</em> to identify the expression; in the case of
positions (i.e.  occurrences of symbols in the alphabet, as opposed to
parenthesized expressions etc.), this also serves as an identifier for
the FSA state.</li>
<li><em>first</em> = set of positions which match the first symbol
of some word in <i>L($E)</i></li>
<li><em>last</em> = set of positions which match the last symbol
in some word in <i>L($E)</i></li>
<li><em>nullable</em> = true iff <i>L($E)</i> contains the empty
word[<a name="ref-to-d3e1429" href="#d3e1429" title="&#xA;&#xA;Note that if some nonterminal N is required in E,&#xA;nullable is false even when N generates the empty&#xA;string.&#xA;&#xA;It may be helpful in some contexts to distinguish">5</a>]</li>
</ul>
</div>

<div class="Real-P">We also have attributes to represent the
<i>follow</i>(<i>exp</i>, <i>sym</i>) function
for <i>exp</i>=<i>$E</i>.  For each position
<i>$p</i> in <i>$E</i> we have an attribute in the
<i>follow</i> namespace whose local name is the ID of
<i>$p</i>; the value of the attribute is the set of positions
which can follow <i>$p</i> in a path through
<i>$E</i>.
</div>

<div class="Real-P">By representing <i>follow($E,$p)</i> as an attribute on
<i>$E</i> we avoid having to traverse the tree multiple
times.</div>

<div class="Real-P">The construction of the Gluschkov automaton consists largely of
calculating, from the structure of <i>E</i>, which symbols can follow which
other symbols, and defining an appropriate transition function.  Along
the way, various auxiliary functions are computed for each
subexpression of <i>E</i>.</div>

<div class="Real-P">For the right-hand side of a rule in an ixml grammar, the basic
symbols of the expression are terminal and nonterminal symbols, and
the subexpressions include both the basic symbols and the other
elements in the XML representation of the right-hand side.  For each
subexpression, we add attributes to record various values:
<ul><li>an ID (for use in referring to the state)</li>
<li><em>nullable</em> (is the empty string in the language
defined by this sub-expression?)</li>
<li><em>first</em> (what are the initial states in the
sub-automaton for this sub-expression?)</li>
<li><em>last</em> (what are the final states in the
sub-automaton for this sub-expression?)</li>
<li>for each state <i>q</i> within (the sub-automaton for) this
sub-expression, what are the follow states of <i>q</i>?  Here, we need one
attribute for every state within the sub-expression; we make them by
creating, for each such state, an attribute with a local name matching
the ID of the state, in a namespace designed to hold such follow-state
attributes.  So if the states in a given expression are named
<i>q0</i>, <i>q1</i>, and <i>q2</i>, we would
have attributes named <i>follow:q0</i>,
<i>follow:q1</i>, and <i>follow:q2</i>.</li>
<li>For later use in recognition, it will also be helpful to
calculate an XPath 3 regular expression that matches the
terminal.</li>
</ul>
These attributes are for the most part of only transient interest:
they are essential for calculating information for the next higher
level of sub-expression, but the information we care about when
running the Earley parser is just the information on the top-level
element of the right-hand side.</div>

<div class="Real-P">Since the values of these attributes are in general calculated
inductively, the first step in handling any element <i>e</i> is to recur
to handle the element's children, and then to construct the values
for <i>e</i> itself.
<div class="scrap"><span><a name="gl-ME">&#x3008; 21 Define function gl:ME() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function gl:ME (
  $E as element(),
  $options as map(*)
) as element() {
  let $children := for $c in $E/node() 
                   return if ($c/self::element())
                          then gl:ME($c, $options)
                          else $c,
      $ch := $children[self::element()]
  return <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-identity">Handle leaf nodes 22</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-terminals">Handle terminal nodes 23</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-nonterminal">Handle nonterminal symbols 24</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-option">Handle options 25</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-repeats">Handle repetitions 27</a></em> &#x3009;</span>   
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-sep">Handle separator expressions 36</a></em> &#x3009;</span>     
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-alt">Handle alt elements 38</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-def">Handle alts elements (= def) 40</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-rule">Handle rule elements 44</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-comment">Handle comment elements 46</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-prolog">Handle prolog elements 47</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-ixml">Handle ixml elements (grammars) 48</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-whahhh">Handle unexpected elements 49</a></em> &#x3009;</span>
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e1336">[File Gluschkov.xqm] 19</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">The following sections describe the handling of individual kinds of
expressions.</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#higl-ME">&#x23f4;</a></span><span class="arrow"><a href="#hi-compile-grammar">&#x23f6;</a></span><span class="arrow"><a href="#higl-ME-nonterminals">&#x23f5;</a></span></div><h5><a class="selflink" name="higl-ME-terminals" id="higl-ME-terminals" href="#higl-ME-terminals">3.4.1.3. </a>Gluschkov automata for terminal symbols</h5>

<div class="Real-P">The &lt;<em>member</em>&gt; element is (and in older versions of the spec
grammar the &lt;<em>range</em>&gt; and &lt;<em>class</em>&gt; elements are) always a
child of &lt;<em>inclusion</em>&gt; or &lt;<em>exclusion</em>&gt;.  It is thus
internal to the basic symbol and need no decoration, but when the
function handles the parent, the function will call itself recursively
on the children; they should be returned without change.  The
&lt;<em>literal</em>&gt; element falls into this category when it is a child
of &lt;<em>inclusion</em>&gt; or &lt;<em>exclusion</em>&gt;, but it does no harm to
handle it separately.</div>

<div class="Real-P">Since all we do is return the elements without change, the code is
trivial.  <i>For now, we leave the code for &lt;<em>range</em>&gt; and
&lt;<em>class</em>&gt; in place.</i>
<div class="scrap"><span><a name="gl-ME-identity">&#x3008; 22 Handle leaf nodes &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/self::member) then $E
else if ($E/self::range) then $E
else if ($E/self::class) then $E
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 21</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">For terminal symbols, all attribute values are straightforward.
They are non-nullable, they are their own first and last states, and
they have no follow states.</div>

<div class="Real-P">The &lt;<em>insertion</em>&gt; element is less straightforward, perhaps,
but requires the same treatment.  I treat it as a terminal because it
is not defined by any rule in the grammar, but unlike a normal
terminal it consumes no input.  Despite consuming no input, however,
it is not nullable: a parse tree for the expression &#x201c;<tt>a, +"b",
c</tt>&#x201d; must include the insertion, unlike a parse tree for
&#x201c;<tt>a, (+"b")?, c</tt>&#x201d;, in which it's optional.  In this
respect, an insertion resembles a nonterminal defined with an empty
production rule.</div>
<div class="Real-P">
<div class="scrap"><span><a name="gl-ME-terminals">&#x3008; 23 Handle terminal nodes &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/self::inclusion or $E/self::exclusion
    or $E/self::literal
    or $E/self::insertion)
then
      let $id := if ($E/self::insertion)
                 then '_ins_' 
                 || (1 + count(($E/preceding::* | $E/ancestor::*)
                    [self::insertion])) 
                 || '.'
                 || (string-join(string-to-codepoints($E/@string), '.'))
                 else '_t_' 
                 || (1 + count(($E/preceding::* | $E/ancestor::*)
                    [self::inclusion 
                    or self::exclusion
		    or self::literal])), 
          $re := eri:reXTerminal($E)
      return element {name($E)} {
         $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @regex,
                     @follow:*)),
         attribute xml:id { $id },
         attribute nullable { false() },
         attribute first { $id },
         attribute last { $id },
         attribute {QName($gl:follow-ns, "follow:" || $id)} { },
	 attribute regex { $re },
         $children
      }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 21</a> &#x3009; <br></span>
</div>

The calculation of a regular expression to match the terminal is
delegated to <i>reXTerminal()</i> from the Earley
internals module.
</div>

</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#higl-ME-terminals">&#x23f4;</a></span><span class="arrow"><a href="#hi-compile-grammar">&#x23f6;</a></span><span class="arrow"><a href="#higl-ME-opt-rep">&#x23f5;</a></span></div><h5><a class="selflink" name="higl-ME-nonterminals" id="higl-ME-nonterminals" href="#higl-ME-nonterminals">3.4.1.4. </a>Gluschkov automata for nonterminal symbols</h5>

<div class="Real-P">Nonterminals are similarly straightforward:  from the
point of view of the Gluschkov automaton, they are
indistinguishable from terminals.
<div class="scrap"><span><a name="gl-ME-nonterminal">&#x3008; 24 Handle nonterminal symbols &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/self::nonterminal)
then
     let $id := $E/@name || '_'
                || (1 + count($E/preceding::nonterminal
                              [@name = $E/@name]))
     return element nonterminal {
       $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @follow:*)),
       attribute xml:id { $id },
       attribute nullable { false() },
       attribute first { $id },
       attribute last { $id },
       attribute {QName($gl:follow-ns, "follow:" || $id)} { },
       $children
     }</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 21</a> &#x3009; <br></span>
</div>

</div>

</div>

<div class="div">

<div class="quicknav"><span class="arrow"><a href="#higl-ME-nonterminals">&#x23f4;</a></span><span class="arrow"><a href="#hi-compile-grammar">&#x23f6;</a></span><span class="arrow"><a href="#higl-ME-sequences">&#x23f5;</a></span></div><h5><a class="selflink" name="higl-ME-opt-rep" id="higl-ME-opt-rep" href="#higl-ME-opt-rep">3.4.1.5. </a>Gluschkov automata for repetitions and options</h5>

<div class="Real-P">Syntactically, an option is an expression to which a question mark
has been added.  So any option <i>E</i> has the form (<i>F</i>?).  <i>E</i> is
nullable regardless of whether <i>F</i> is or not, and <i>E</i> has the same
first, final, and follow sets as <i>F</i>.
Note than an &lt;<em>option</em>&gt; should only ever have one child element:
a terminal symbol (inclusion, exclusion, literal), a nonterminal
symbol, or a set of alternatives (&lt;<em>alts</em>&gt;).  If we ever see
anything else, this case will not process it and it will fall through
to the error case.
<div class="scrap"><span><a name="gl-ME-option">&#x3008; 25 Handle options &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/self::option
    [count(*) eq 1]
    [child::*[self::inclusion
              or self::exclusion
              or self::literal
              or self::insertion
              or self::nonterminal 
	      or self::alts]])
then
     let $id := 'exp_option_' || (1 + count($E/preceding::option))
     return element option {
       $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @follow:*)),
       attribute xml:id { $id },
       attribute nullable { true() },
       attribute first { $children/@first },
       attribute last { $children/@last },
       for $follow-att in $children/@follow:* 
       return $follow-att,
       $children
     }</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 21</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">Repeats will have either one child element or two.  The
first will be a terminal, a nonterminal, or a set of alternatives;
the optional second child is a separator.  If anything else is
encountered, we are not ready for it and we'll fall through to
the error case.</div>

<div class="Real-P">In the 2013 grammar, a set of alternatives was a
&lt;<em>def</em>&gt; element: 
<div class="scrap"><span><a name="gl-ME-repeats-2013">&#x3008; 26 Handle repetitions (v0.1) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E[self::repeat0 or self::repeat1]
      [*[1][self::terminal or self::nonterminal or self::def]]
      [count(*) eq 1 or child::*[2][self::sep]]
         ) 
then
     let $gi := name($E)
     let $id := 'exp_' || $gi || '_' 
                || (1 + count($E/preceding::*[name() = $gi])),
         $F := gl:notrace($ch[1], "repetition factor F: "),
         $G := gl:notrace($ch[2], "repetition sep G: ")
     return element {$gi} {
       $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @follow:*)),
       attribute xml:id { $id },
       attribute nullable { 
         if ($gi = 'repeat0') 
         then true() 
         else $F/@nullable
       },
       attribute first { 
         if (xs:boolean($F/@nullable) = true())
         then concat($F/@first, ' ', $G/@first)
         else $F/@first
       },
       attribute last { 
         if (xs:boolean($F/@nullable) = true())
         then concat($F/@last, ' ', $G/@last)
         else $F/@last
       },
       <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-rep-follow">Calculate follow:* attributes for repetitions 28</a></em> &#x3009;</span>
       ,
       $children
     }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>
</div>

<div class="Real-P">In 2021, the functionality is the same, but the
choice element is named &lt;<em>alts</em>&gt;:
<div class="scrap"><span><a name="gl-ME-repeats">&#x3008; 27 Handle repetitions &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E[self::repeat0 or self::repeat1]
      [*[1]
        [self::inclusion or self::exclusion
        or self::literal
        or self::insertion
        or self::nonterminal
	or self::alts]]
      [count(*) eq 1 
      or child::*[2][self::sep]]) 
then let $gi := name($E)
     let $id := 'exp_' || $gi || '_' 
                || (1 + count($E/preceding::*[name() = $gi])),
         $F := gl:notrace($ch[1], "F: "),
         $G := gl:notrace($ch[2], "G: ")
     return element {$gi} {
       $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @follow:*)),
       attribute xml:id { $id },
       attribute nullable { 
         if ($gi = 'repeat0') 
         then true() 
         else $F/@nullable
       },
       attribute first { 
         if (xs:boolean($F/@nullable) = true())
         then concat($F/@first, ' ', $G/@first)
         else $F/@first
       },
       attribute last { 
         if (xs:boolean($F/@nullable) = true())
         then concat($F/@last, ' ', $G/@last)
         else $F/@last
       },
       <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-rep-follow">Calculate follow:* attributes for repetitions 28</a></em> &#x3009;</span>
       ,         
       $children
     }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 21</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">The calculation of the follow set here has several
cases.  Watch carefully.  First case:  no separator.
So for all positions <i>p</i> in the expression <i>E</i>,
<ul><li>if <i>p</i> is in last(<i>E</i>)
then follow(<i>E</i>*, <i>p</i>) is 
the union of follow(<i>E</i>, <i>p</i>) with first(<i>E</i>)</li>
<li>otherwise
follow(<i>E</i>*, <i>p</i>) is  
just follow(<i>E</i>, <i>p</i>)
with no additions.</li>
</ul>
<div class="scrap"><span><a name="gl-ME-rep-follow">&#x3008; 28 Calculate follow:* attributes for repetitions &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">       if (count($ch) eq 1)
       then
         let $lastF := tokenize($F/@last,'\s+'),
             $firstF := tokenize($F/@first,'\s+')
         for $a in $F/@follow:*
         return if (local-name($a) = $lastF)
           then attribute { 
               QName($gl:follow-ns, "follow:"||local-name($a) ) 
             } { 
               gl:merge((tokenize($a,'\s+'), $firstF))    
             }
           else $a
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e1810">Calculate follow-set for repetition with separator 29</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME-repeats-2013">Handle repetitions (v0.1) 26</a> &#x3009; &#x3008; <a href="#gl-ME-repeats">Handle repetitions 27</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">If there is a separator, then the same principle
applies, but things are complicated by the presence
of the separator in the way.
For all <i>p</i>
in <i>F</i>*<i>G</i> or <i>F</i>+<i>G</i>, its follow-set depends
on <ul><li>whether <i>p</i> is in <i>F</i> or in <i>G</i>,</li>
<li>whether it's in last(<i>F</i>) or last(<i>G</i>),
and </li>
<li>whether <i>F</i> and <i>G</i> are nullable.</li>
</ul>
So we break out the detailed calculations.
The overall pattern is as follows.  We pre-calculate
<ul><li>the two <i>last()</i> sets,</li>
<li>the two <i>first()</i> sets,</li>
<li>whether <i>F</i> and <i>G</i> are nullable, and</li>
<li>for each position in <i>F</i> or <i>G</i>, its local
name and its follow-set within <i>F</i> or <i>G</i>.</li>
</ul>
<div class="scrap"><span><a name="d3e1810">&#x3008; 29 Calculate follow-set for repetition with separator [continues <a href="#gl-ME-rep-follow">28 Calculate follow:* attributes for repetitions</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">       else (: count($children) eq 2 :)
         let $lastF := tokenize($F/@last,'\s+'),
             $lastG := tokenize($G/@last,'\s+'),
             $firstF := tokenize($F/@first,'\s+'),
             $firstG := tokenize($G/@first,'\s+'),
             $nullableF := (xs:boolean($F/@nullable) = true()), 
             $nullableG := (xs:boolean($G/@nullable) = true())
         return 
           for $a in $children/@follow:* 
           let $p := local-name($a),
               $follow0 := tokenize($a,'\s+')
           let $followset :=  
             <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-rep-follow-sep-1">Follow set when p in last(F), G nullable 30</a></em> &#x3009;</span>
             <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-rep-follow-sep-2">Follow set when p in last(F), G not nullable 31</a></em> &#x3009;</span>
             <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-rep-follow-sep-3">Follow set when p in last(G), F nullable 32</a></em> &#x3009;</span>
             <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-rep-follow-sep-4">Follow set when p in last(G), F not nullable 33</a></em> &#x3009;</span>
             <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-rep-follow-sep-5">Follow set when p non-final in F or G 34</a></em> &#x3009;</span>
           return attribute { 
                    QName($gl:follow-ns, 
                          "follow:"||local-name($a) ) 
                } { 
                    $followset    
                    }</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>

<div class="Real-P">If <i>p</i> is final in <i>F</i> and <i>G</i> is nullable, then it's final
in <i>F</i>*<i>G</i> or <i>F</i>+<i>G</i> and can thus be followed by any first
state of <i>G</i> and any first state of <i>F</i>, as well as (naturally)
its follow-set within <i>F</i>:
<div class="scrap"><span><a name="gl-ME-rep-follow-sep-1">&#x3008; 30 Follow set when p in last(F), G nullable &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">             if ($p = $lastF and $nullableG) 
             then gl:merge(($follow0, $firstG, $firstF))
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e1810">Calculate follow-set for repetition with separator 29</a> &#x3009; <br></span>
</div>
</div>

<div class="Real-P">If <i>p</i> is final in <i>F</i> and <i>G</i> is <em>not</em> nullable, 
then its follow-set omits the first sets of <i>F</i>. 
<div class="scrap"><span><a name="gl-ME-rep-follow-sep-2">&#x3008; 31 Follow set when p in last(F), G not nullable &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">             else if ($p = $lastF and not($nullableG))
             then gl:merge(($follow0, $firstG))
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e1810">Calculate follow-set for repetition with separator 29</a> &#x3009; <br></span>
</div>
</div>

<div class="Real-P">If <i>p</i> is final in <i>G</i> and <i>F</i> is nullable, 
then we again have a three-way merge for its follow-set:
its follow-set within <i>G</i>, the first-set of <i>F</i>, and
(skipping <i>F</i> entirely, since it's nullable)
the first-set of <i>G</i>. 
<div class="scrap"><span><a name="gl-ME-rep-follow-sep-3">&#x3008; 32 Follow set when p in last(G), F nullable &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">             else if ($p = $lastG and $nullableF)
             then gl:merge(($follow0, $firstG, $firstF))
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e1810">Calculate follow-set for repetition with separator 29</a> &#x3009; <br></span>
</div>
</div>

<div class="Real-P">If <i>p</i> is final in <i>G</i> and <i>F</i> is <em>not</em> nullable, 
then the first-set of <i>G</i> is not included in the follow-set
of <i>p</i>.
<div class="scrap"><span><a name="gl-ME-rep-follow-sep-4">&#x3008; 33 Follow set when p in last(G), F not nullable &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">             else if ($p = $lastG and not($nullableF))
             then gl:merge(($follow0, $firstF))
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e1810">Calculate follow-set for repetition with separator 29</a> &#x3009; <br></span>
</div>
</div>

<div class="Real-P">Finally, if none of the above are true, then <i>p</i>
is non-final in either <i>F</i> or <i>G</i> and its follow-set is
unaffected by the repetition operator, so we just copy it
out again.
<div class="scrap"><span><a name="gl-ME-rep-follow-sep-5">&#x3008; 34 Follow set when p non-final in F or G &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">             else string($a)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e1810">Calculate follow-set for repetition with separator 29</a> &#x3009; <br></span>
</div>
</div>

<div class="Real-P">We have appealed to a little utility function for merging
sets of IDs.  It's quite straightforward, really, thanks
to <i>distinct-values()</i>.
<div class="scrap"><span><a name="gl-merge">&#x3008; 35 Define gl:merge() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function gl:merge(
  $ids as xs:string*
) as xs:string {
  string-join(distinct-values($ids),' ')
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e1336">[File Gluschkov.xqm] 19</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">The &lt;<em>sep</em>&gt; element contains a single factor and
changes none of its properties.
<div class="scrap"><span><a name="gl-ME-sep">&#x3008; 36 Handle separator expressions &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/self::sep
           [count(*) eq 1]
           [child::*[self::inclusion
                     or self::exclusion 
                     or self::literal 
                     or self::insertion 
                     or self::nonterminal 
                     or self::alts]]
          ) then
     let $id := 'exp_sep_'
                || (1 + count($E/preceding::sep)) 
     return element sep {
       $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @follow:*)),
       attribute xml:id { $id },
       $ch/@nullable,
       $ch/@first,
       $ch/@last,
       $ch/@follow:*,
       $children
     }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 21</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">In 2013 the element names were different.  (Yawn.)
<div class="scrap"><span><a name="gl-ME-sep-2013">&#x3008; 37 Handle separator expressions (v0.1) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/self::sep
           [count(*) eq 1]
           [child::*[self::terminal 
                     or self::nonterminal
                     or self::def]]
          ) then
     let $id := 'exp_sep_'
                || (1 + count($E/preceding::sep)) 
     return element sep {
       $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @follow:*)),
       attribute xml:id { $id },
       attribute nullable { $ch/@nullable },
       attribute first { $ch/@first },
       attribute last { $ch/@last },
       for $follow-att in $ch/@follow:* 
       return $follow-att,
       $children
     }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>

</div>

</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#higl-ME-opt-rep">&#x23f4;</a></span><span class="arrow"><a href="#hi-compile-grammar">&#x23f6;</a></span><span class="arrow"><a href="#higl-ME-choice">&#x23f5;</a></span></div><h5><a class="selflink" name="higl-ME-sequences" id="higl-ME-sequences" href="#higl-ME-sequences">3.4.1.6. </a>Gluschkov automata for sequences (&lt;<em>alt</em>&gt;)</h5>

<div class="Real-P">An &lt;<em>alt</em>&gt; is one choice among (sometimes) several; it
contains a sequence of terms (i.e. terminal, nonterminal, repetition,
option, nested set of alternatives).  Since it's an arbitrary-length
sequence, not a binary operator, the calculation of first and last and
follow gets a bit tricky.  We may end up needing to normalize to
binary form just to keep things simple.
<div class="scrap"><span><a name="gl-ME-alt">&#x3008; 38 Handle alt elements &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/self::alt) then
     let $id := 'exp_alt_'
                || (1 + count($E/preceding::alt)) 
     return element alt {
       $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @follow:*)),
       attribute xml:id { $id },
       attribute nullable { 
         every $c in $ch except $E/comment
         satisfies (xs:boolean($c/@nullable) eq true())
       },
       attribute first { 
         string-join(
           for $c at $pos in $ch
           return if (every $lsib
	              in $ch[position() lt $pos]
                      satisfies
		      (xs:boolean($lsib/@nullable)
		      eq true() ))
                  then $c/@first
                  else (),
           ' '
         )
       },
       attribute last { 
         string-join(
           for $c at $pos in $ch
           return if (every $rsib
	              in $ch[position() gt $pos]
                      satisfies
		      (xs:boolean($rsib/@nullable)
		      eq true() ))
                  then $c/@last
                  else (),
           ' '
         )
       },
       <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-alt-follow">Calculate follow:* attributes for alt 39</a></em> &#x3009;</span>
       ,
       $children
     }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 21</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">Again, calculating the follow-set is the most complicated
of the subcalculations for this type of expression.  So let's
take it slowly.
<ul><li>For every position <i>p</i> in each child <i>c</i>, the follow set 
follow(<i>E</i>,<i>p</i>) includes follow(<i>c</i>,<i>p</i>).</li>
<li>In addition, if <i>p</i> is in last(<i>c</i>) and <i>c</i> has a following sibling,
then follow(<i>E</i>,<i>p</i>) should include start(next-sibling(<i>c</i>)).</li>
<li>
In addition, if <i>p</i> is in last(<i>c</i>) and <i>c</i> has a following sibling,
and also next-sibling(<i>c</i>) is nullable, 
then follow(<i>E</i>,<i>p</i>) should include start(nextsib(nextsib(<i>c</i>))).
</li>
<li>
And so forth.</li>
</ul>

<div class="scrap"><span><a name="gl-ME-alt-follow">&#x3008; 39 Calculate follow:* attributes for alt &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">       for $c at $cpos in $ch 
       for $a in $c/@follow:*
       let $p := local-name($a),
           $lastC := tokenize($c/@last,'\s+'),
           $rightsibs := $ch[position() gt $cpos],
           $followset := if ($p = $lastC)
	   then string-join(
             (  $a,
                for $rsib at $rpos in $rightsibs
                let $inbetweens := $rightsibs
		                   [position() lt $rpos]
                return if (every $msib in $inbetweens
                           satisfies
                           (xs:boolean($msib/@nullable)
			   = true() ))
                       then $rsib/@first
                       else ()
             ),
             ' '
           )
           else
             $a
       return attribute { 
             QName($gl:follow-ns, "follow:"||$p )
         } { 
             $followset    
         }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME-alt">Handle alt elements 38</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#higl-ME-sequences">&#x23f4;</a></span><span class="arrow"><a href="#hi-compile-grammar">&#x23f6;</a></span><span class="arrow"><a href="#higl-ME-choice">&#x23f5;</a></span></div><h5><a class="selflink" name="higl-ME-choice" id="higl-ME-choice" href="#higl-ME-choice">3.4.1.7. </a>Gluschkov automata for choice (&lt;<em>alts</em>&gt;)</h5>

<div class="Real-P">An &lt;<em>alts</em>&gt; element contains a set of alternatives,
each an &lt;<em>alt</em>&gt; element.
The 2013 alternative was the &lt;<em>def</em>&gt; element,
but note that &lt;<em>def</em>&gt; was required as the top-level
element of a right-hand side, which &lt;<em>alts</em>&gt; is not.
That doesn't affect the treatment of this element,
but it does affect
the treatment of rules, below. 
<div class="scrap"><span><a name="gl-ME-def">&#x3008; 40 Handle alts elements (= def) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E[self::<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-alts-gi">GI for alts element 42</a></em> &#x3009;</span>]) then
     let $id := 'exp_' || name($E) || '_' 
                || (1 + count(
                $E/preceding::<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-alts-gi">GI for alts element 42</a></em> &#x3009;</span>)
		) 
     <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-alternatives">Handle alternatives 41</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 21</a> &#x3009; <br></span>
</div>

We factor out the treatment of alternatives
so that we can re-use it for rules, below.
The properties should all be self-explanatory.
<div class="scrap"><span><a name="gl-ME-alternatives">&#x3008; 41 Handle alternatives &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">     return element {name($E)} {
       $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @follow:*)),
       attribute xml:id { $id },
       attribute nullable { 
         some $c in $ch
         satisfies
	 (xs:boolean($c/@nullable) eq true() )
       },
       attribute first { 
         string-join($ch/@first, ' ')
       },
       attribute last { 
         string-join($ch/@last, ' ')
       },
       
       (: follow-set is simple here. :) 
       for $a in $ch/@follow:*
       return $a,
       $children
     }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME-def">Handle alts elements (= def) 40</a> &#x3009; &#x3008; <a href="#gl-ME-rule">Handle rule elements 44</a> &#x3009; <br></span>
</div>
</div>

<div class="Real-P">As an experiment, I am putting the generic identifier
for the element in a scrap.  If this works, much of the
duplication earlier in this section can be removed.
(Why do ideas come so late?)
<div class="scrap"><span><a name="gl-alts-gi">&#x3008; 42 GI for alts element &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">alts</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME-def">Handle alts elements (= def) 40</a> &#x3009; &#x3008; <a href="#eri-grammars-constructors">Functions that construct or return grammars 145</a> &#x3009; <br></span>
</div>

In 2013, it was &lt;<em>def</em>&gt;:
<div class="scrap"><span><a name="gl-alts-gi-2013">&#x3008; 43 GI for alts element (v0.1) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">def</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>

</div>

<div class="Real-P">Since the alternatives inside a rule are not now wrapped
in a &lt;<em>def</em>&gt; or &lt;<em>alts</em>&gt; elements, we need to
put the properties for the rule as a whole on the &lt;<em>rule</em>&gt;
element.
<div class="scrap"><span><a name="gl-ME-rule">&#x3008; 44 Handle rule elements &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/self::rule) then
    let $id := $E/@name
    <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-ME-alternatives">Handle alternatives 41</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 21</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">In 2013, it was simpler.
<div class="scrap"><span><a name="gl-ME-rule-2013">&#x3008; 45 Handle rule elements (v0.1) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/self::rule) then 
    element rule {
      $E/@*,
      $children
    }</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>

</div>

</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#higl-ME-choice">&#x23f4;</a></span><span class="arrow"><a href="#hi-compile-grammar">&#x23f6;</a></span><span class="arrow">&nbsp;</span></div><h5><a class="selflink" name="higl-ME-choice" id="higl-ME-choice" href="#higl-ME-choice">3.4.1.8. </a>Gluschkov automata for other elements</h5>

<div class="Real-P">Finally, a few miscellaneous elements.  Comments
require no annotation.
<div class="scrap"><span><a name="gl-ME-comment">&#x3008; 46 Handle comment elements &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/self::comment) then
    $E
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 21</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">The &lt;<em>prolog</em>&gt; element is currently just for
documentation; it requires no annotation.
<div class="scrap"><span><a name="gl-ME-prolog">&#x3008; 47 Handle prolog elements &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/self::prolog) then
    $E
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 21</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">The &lt;<em>ixml</em>&gt; element also requires no
annotation.
<div class="scrap"><span><a name="gl-ME-ixml">&#x3008; 48 Handle ixml elements (grammars) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/self::ixml) then 
    element ixml {
      attribute follow:info { 
        "auxiliary namespace for FSA description"
      },
      $E/@*,
      $children
    }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 21</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">And finally, at the bottom of the if-then-else ladder,
we handle unexpected elements.
<div class="scrap"><span><a name="gl-ME-whahhh">&#x3008; 49 Handle unexpected elements &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/self::option or $E/self::sep)
then element ap:error {
       attribute id {"ap:tbd35"},
       element desc {
         "Element",
         name($E), 
         "with unexpected content:"
       },
       $E
     }
else if ($E[self::repeat1 or self::repeat0])
then element ap:error {
       attribute id {"ap:tbd36"},
       element desc {
         "Element",
         name($E), 
         "with unexpected content:"
       },
       $E
     }
else element ap:error {
       attribute id {"ap:tbd37"},
       element desc {
         "Element", 
         name($E),
         "was unexpected:"
       },
       $E
     }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 21</a> &#x3009; <br></span>
</div>

</div>
</div>

</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-compile-grammar">&#x23f4;</a></span><span class="arrow"><a href="#hi-prep-grammar">&#x23f6;</a></span><span class="arrow">&nbsp;</span></div><h4><a class="selflink" name="hi-check-compiled-grammar" id="hi-check-compiled-grammar" href="#hi-check-compiled-grammar">3.4.2. </a>Checking the compiled grammar</h4><ul><li>3.4.2.1. <a href="#hi-ccg-what">What is checked</a></li><li>3.4.2.2. <a href="#hi-ccg-gok">The <i>grammar-ok()</i> function</a><ul><li>3.4.2.2.1. <a href="#hi-ccg-gok-str">Structural checks</a></li><li>3.4.2.2.2. <a href="#hi-ccg-gok-nonxml">Checking for non-XML names</a></li><li>3.4.2.2.3. <a href="#hi-ccg-gok-duprules">Checking for multiple definitions</a></li><li>3.4.2.2.4. <a href="#hi-ccg-gok-classes">Checking character classes</a></li><li>3.4.2.2.5. <a href="#hi-ccg-gok-hex">Checking hex literals</a></li><li>3.4.2.2.6. <a href="#hi-ccg-gok-range">Checking ranges</a></li><li>3.4.2.2.7. <a href="#hi-ccg-gok-undef">Checking for undefined nonterminals</a></li><li>3.4.2.2.8. <a href="#hi-ccg-gok-unreachable">Checking for unreachable rules</a></li><li>3.4.2.2.9. <a href="#hi-ccg-gok-unprod">Checking for unproductive nonterminals</a></li></ul></li></ul>

<div class="Real-P">The grammar needs to be checked for problems. Most of this could
in principle be done either before or after compilation, but since
we allow the user to supply a compiled grammar we do it after.</div>


<div class="div">

<div class="quicknav"><span class="arrow">&nbsp;</span><span class="arrow"><a href="#hi-check-compiled-grammar">&#x23f6;</a></span><span class="arrow"><a href="#hi-ccg-gok">&#x23f5;</a></span></div><h5><a class="selflink" name="hi-ccg-what" id="hi-ccg-what" href="#hi-ccg-what">3.4.2.1. </a>What is checked</h5>
<div class="Real-P">What is checked for in the grammar is pretty much the same in all
cases, but what is done when problems are found depends in part on the
user's options.
<ul><li><div class="Real-P"><b>structural problems</b>: The grammar needs to be
structurally sound and usable for parsing; the grammar should also
satisfy the spec's requirement that a conforming XML grammar &#x201c;can be
derived from an ixml grammar in ixml form by parsing as described in
this specification&#x201d;.
<ul><li>If &#x201c;<tt>conformance</tt>&#x201d; = &#x201c;<tt>pedantic</tt>&#x201d; or
&#x201c;<tt>strict</tt>&#x201d;, then we check every element in the grammar to
ensure that it conforms to the implicit requirements of the ixml
specification grammar, with respect to:
<ul><li>its children and their sequence</li>
<li>its attributes and their lexical form</li>
</ul>
This should be at least approximately equivalent to validation against
a DTD or schema derived mechanically from the ixml grammar.</li>
<li>If &#x201c;<tt>conformance</tt>&#x201d; = &#x201c;<tt>tolerant</tt>&#x201d;,
the same checks are performed, but 
<ul><li>pragmas and namespace-qualified elements are ignored</li>
<li>namespace-qualified attributes are ignored</li>
</ul>
</li>
</ul>
</div>
</li>
<li><div class="Real-P"><b>compilation artifacts</b>: Every rule should have
the attributes supplied by the compiler.  We can't check them for
integrity, of course; this is just a sanity check in case the user
accidentally supplies an uncompiled grammar when we expect a compiled
one.</div></li>
<li><div class="Real-P"><b>non-XML names</b>: All nonterminals must either be
acceptable as XML names or marked &#x201c;<tt>-</tt>&#x201d;.</div></li>
<li><div class="Real-P"><b>uniqueness of rules</b>: Any two &lt;<em>rule</em>&gt;
elements must have different names.</div></li>
<li><div class="Real-P"><b>character classes</b>: Any character class
appearing as a member of a character set (an &lt;<em>inclusion</em>&gt; or an
&lt;<em>exclusion</em>&gt;) must be one listed in Unicode.</div></li>
<li><div class="Real-P"><b>undefined nonterminals</b>: Every nonterminal
referred to should be defined.</div></li>
<li><div class="Real-P"><b>unreachable nonterminals</b>: Every nonterminal
defined should be reachable from the start symbol.</div></li>
<li><div class="Real-P"><b>unproductive nonterminals</b>: Every nonterminal
defined should generate some set of strings.</div></li>
</ul>
</div>

<div class="Real-P">The ixml specification defines grammars as non-conforming if they
contain multiple rules for the same nonterminal or undefined
nonterminals, on the grounds that these often signal that the grammar
writer slipped up somewhere. Students of formal languages (e.g. <a href="#GJ" title="&#xA;Dick Grune and Ceriel J. H. Jacobs,&#xA;Parsing techniques:  a practical guide&#xA;(New York, et al.: Ellis Horwood, 1990;&#xA;Second edition New York:  Springer, 2007).">[Grune / Jacobs 2007]</a>) describe undefined, unreachable, and non-productive
nonterminals as <em>useless nonterminals</em> and treat them under
the heading &#x201c;Hygiene in context-free grammars&#x201d;, together with an
algorithm for cleaning up a grammar that contains them.[<a name="ref-to-d3e2207" href="#d3e2207" title="&#xA;Note that the class of hygiene problems catalogued in formal&#xA;language theory does not coincide exactly with the class of grammars&#xA;ixml defines as non-conformin">6</a>]
The code in this section will (at user option) detect these issues,
warn the user (or raise an error), and clean up the grammar.[<a name="ref-to-d3e2218" href="#d3e2218" title="&#xA;It is not essential to clean the grammar, but it will make the&#xA;grammar smaller and in some cases will avoid useless work by the&#xA;Earley parser.&#xA;">7</a>]
</div>

<div class="Real-P">The user can <i>[will be able to]</i> control some of what
happens here by setting the following options:
<ul><li><tt>multiple-definitions</tt></li>
<li><tt>undefined-nonterminals</tt></li>
<li><tt>unreachable-rules</tt></li>
<li><tt>unproductive-nonterminals</tt></li>
</ul>

For all four, possible values are &#x201c;<tt>error</tt>&#x201d;,
&#x201c;<tt>warning</tt>&#x201d;, or &#x201c;<tt>silence</tt>&#x201d;.  All four default
will eventually default to &#x201c;<tt>warning</tt>&#x201d;, unless the user
specifies strict conformance to the ixml spec, in which case the first
two will be set to &#x201c;<tt>error</tt>&#x201d;.  For the moment, however, we
define the default options to be what the spec requires and no more.
<div class="scrap"><span><a name="aparecium-other-default-options">&#x3008; 50 Other default options &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">        'multiple-definitions': 'error',
        'undefined-symbols': 'error',
        'unreachable-symbols': 'silence',
        'unproductive-symbols': 'silence',
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e2265"> 51</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#aparecium-variables">Variables (of interest only for maintainer) 13</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">We will also need to define an option to control how pedantically
Aparecium should adhere to the spec.  The neutral term is &#x201c;strict&#x201d;
conformance, but sometimes nothing but &#x201c;<tt>pedantic</tt>&#x201d; is
going to feel satisfactory.
<div class="scrap"><span><a name="d3e2265">&#x3008; 51  [continues <a href="#aparecium-other-default-options">50 Other default options</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">        'conformance': 'tolerant' 
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

<i>Thanks to Merriam-Webster for help finding something between
&#x201c;strict&#x201d; (&#x201c;punctilious&#x201d;, &#x201c;heavy-handed&#x201d;)
and &#x201c;lax&#x201d; (&#x201c;loose&#x201d;, &#x201c;slipshod&#x201d;).</i>
</div>

</div>

<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-ccg-what">&#x23f4;</a></span><span class="arrow"><a href="#hi-check-compiled-grammar">&#x23f6;</a></span><span class="arrow">&nbsp;</span></div><h5><a class="selflink" name="hi-ccg-gok" id="hi-ccg-gok" href="#hi-ccg-gok">3.4.2.2. </a>The <i>grammar-ok()</i> function</h5><ul><li>3.4.2.2.1. <a href="#hi-ccg-gok-str">Structural checks</a></li><li>3.4.2.2.2. <a href="#hi-ccg-gok-nonxml">Checking for non-XML names</a></li><li>3.4.2.2.3. <a href="#hi-ccg-gok-duprules">Checking for multiple definitions</a></li><li>3.4.2.2.4. <a href="#hi-ccg-gok-classes">Checking character classes</a></li><li>3.4.2.2.5. <a href="#hi-ccg-gok-hex">Checking hex literals</a></li><li>3.4.2.2.6. <a href="#hi-ccg-gok-range">Checking ranges</a></li><li>3.4.2.2.7. <a href="#hi-ccg-gok-undef">Checking for undefined nonterminals</a></li><li>3.4.2.2.8. <a href="#hi-ccg-gok-unreachable">Checking for unreachable rules</a></li><li>3.4.2.2.9. <a href="#hi-ccg-gok-unprod">Checking for unproductive nonterminals</a></li></ul>

<div class="Real-P">All of the grammar checking is managed by the Aparecium
<i>grammar-ok()</i> function.  The basic plan is
simple: we collect several lists of error elements
(&#x201c;<tt>lee-...</tt>&#x201d;), and if at the end all lists are empty,
we succeed.  If we find errors, we wrap them with the grammar
and return an &lt;<em>aparecium:error</em>&gt; element.
<div class="scrap"><span><a name="ap-grok">&#x3008; 52 The grammar-ok() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: grammar-ok(): check grammar 
:)
declare function aparecium:grammar-ok(
  $G as element(),
  $options as map(*)
) as element() {
  if ($G/self::ixml)
  then 
  let $dummy := () (: trace($G/rule[1]/@name/string(),
                'grammar-ok() called on grammar for: ') :)
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ap-grok-str">Check for structural problems 53</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ap-grok-comp">Check for compiler attributes 54</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ap-grok-names">Check for non-XML names 57</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ap-grok-uniqdef">Check rules for uniqueness 58</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ap-grok-charclass">Check character classes 59</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ap-grok-hexref">Check hexadecimal character references 60</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ap-grok-ranges">Check ranges 67</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ap-grok-alldef">Check for undefined symbols 68</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ap-grok-reach">Check for unreachable symbols (rsn) 69</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ap-grok-prod">Check for unproductive symbols (rsn) 70</a></em> &#x3009;</span>
  let $lee-all := ($lee-struc, $lee-comp,
                   $lee-names,  
                   $lee-uniqdef, $lee-charclass,
                   $lee-hex, $lee-ranges,
                   $lee-alldef, 
                   $lee-reachable, $lee-productive)
  return if (empty($lee-all/self::aparecium:error))
  then $G
  else (: not(empty($lee-all/self::ap:error)) :)
    element aparecium:error {
      attribute id { "ap:tbd06" },
      element p { "Errors found in grammar." },
      $lee-all,
      $G
  }
  else (: not($G/self::ixml) :) 
    element aparecium:error {
      attribute id { "ap:tbd07" },
      element p { "This is not a grammar." },
      $G
  }
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#aparecium-tertiary">Tertiary interfaces (of interest only for maintainer) 189</a> &#x3009; <br></span>
</div>

</div>


<div class="div">

<div class="quicknav"><span class="arrow">&nbsp;</span><span class="arrow"><a href="#hi-ccg-gok">&#x23f6;</a></span><span class="arrow"><a href="#hi-ccg-gok-nonxml">&#x23f5;</a></span></div><h6><a class="selflink" name="hi-ccg-gok-str" id="hi-ccg-gok-str" href="#hi-ccg-gok-str">3.4.2.2.1. </a>Structural checks</h6>
<div class="Real-P">For now, our structural checks are rudimentary, more symbolic than
real.  We have already checked that <i>$G</i> is an
&lt;<em>ixml</em>&gt; element; here we check that all the children of
&lt;<em>ixml</em>&gt; are rules or comments or pragmas, and all the
children of &lt;<em>rule</em>&gt; elements are &lt;<em>alt</em>&gt; or
comments or pragmas.
<div class="scrap"><span><a name="ap-grok-str">&#x3008; 53 Check for structural problems &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $lee-struc := (
      let $le0 := $G/*
          [not(self::prolog or self::rule or self::comment or self::pragma)]
      for $e in $le0 
      return element aparecium:error {
        attribute id { "ap:tbd08" },
        "Unexpected " || $e/name() 
        || " element as child of ixml."
      },

      let $le0 := $G/rule/*
          [not(self::alt or self::comment or self::pragma)]
      for $e in $le0 
      return element aparecium:error {
        attribute id { "ap:tbd09" },
        "Unexpected " || $e/name() 
        || " element as child of rule."
      }


  )
      
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#ap-grok">The grammar-ok() function 52</a> &#x3009; <br></span>
</div>

Later, this will be replaced with code to validate every
child against the appropriate content model and check
attributes.  <i>The simplest approach would be to call
the function <i>validate:rng()</i>, which is
predefined in BaseX.  That would introduce an
implementation dependency; to hide it, write an ixml:validate
function which calls an RNG validator if one is available
and performs some simple fallback checking otherwise.</i>
</div>
<div class="Real-P">Since we cannot check the compilation of the grammar
in detail, we limit ourselves to checking that every
rule has the attributes assigned by the compiler.
<div class="scrap"><span><a name="ap-grok-comp">&#x3008; 54 Check for compiler attributes &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $lee-comp := ()
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#ap-grok">The grammar-ok() function 52</a> &#x3009; <br></span>
</div>

<i>The data flow has gotten confused. Let's leave this out for
now.</i>
<div class="scrap"><span><a name="d3e2362">&#x3008; 55 Check for compiler attributes &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $lee-comp := (
      for $r in $G/rule[not(@xml:id)
          or not(@nullable)
          or not(@first)
          or not(@last)
          ]
      return element aparecium:error { 
        attribute id { "ap:tbd10" },
        "Compilation problem?  Rule " || $r/@name 
        || " lacks compiler attributes."
      }
  )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>

</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-ccg-gok-str">&#x23f4;</a></span><span class="arrow"><a href="#hi-ccg-gok">&#x23f6;</a></span><span class="arrow"><a href="#hi-ccg-gok-duprules">&#x23f5;</a></span></div><h6><a class="selflink" name="hi-ccg-gok-nonxml" id="hi-ccg-gok-nonxml" href="#hi-ccg-gok-nonxml">3.4.2.2.2. </a>Checking for non-XML names</h6>

<div class="Real-P">The ixml spec makes it a dynamic error in the grammar
for a nonterminal with a non-XML name to be serialized.
We detect the problem statically:  if a name is not
castable as xs:NCName, then it must be marked as hidden,
either on the &lt;<em>rule</em>&gt; element or on all
references to it.[<a name="ref-to-d3e2375" href="#d3e2375" title="&#xA;Strictly speaking, a nonterminal which is only&#xA;ever used in an attribute value can use any mark&#xA;desired, since the mark is ignored.  In this case,&#xA;Aparecium wi">8</a>]
<div class="scrap"><span><a name="ap-grok-names-conformance">&#x3008; 56 Check for non-XML names (strict conformance) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $lee-names := (
      for $r in $G/rule
                [not(@name castable as xs:NCName)]
      let $nt := $r/@name/string(),
          $mark := string($r/@mark),
          $references := $G//nonterminal[@name eq $nt],
          $rmarks := distinct-values(
	      for $ref in $references
              return string($ref/@mark)
          )
      where (( ($mark = ('^', '@', ''))
               and ($rmarks = ('^', '@', '')) )
            or ( ($mark eq '-')
               and ($rmarks = ('^', '@')) ))
      return element aparecium:error {
               attribute id { "ap:tbd11" },
               $nt || " is not allowed as an XML name."
               || " It must be marked as hidden."
             }
  ) 
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>
</div>
<div class="Real-P">The only problem with the code just given is that
when Aparecium compiles a grammar it adds attributes in
which nonterminal symbols are used as NCNames.  So in fact
we need to signal an error on <em>all</em> non-NCName
nonterminals, not just those which are not hidden.
<div class="scrap"><span><a name="ap-grok-names">&#x3008; 57 Check for non-XML names &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $lee-names := (
      for $r in $G/rule
                [not(@name castable as xs:NCName)]
      let $nt := $r/@name/string(),
          $mark := string($r/@mark),
          $references := $G//nonterminal[@name eq $nt],
          $rmarks := distinct-values(
	      for $ref in $references
              return string($ref/@mark)
          ),
          $is-hidden := (( ($mark = ('^', '@', ''))
               and ($rmarks = ('^', '@', '')) )
            or ( ($mark eq '-')
               and ($rmarks = ('^', '@')) ))
      return if ($is-hidden)
          then element aparecium:error {
               attribute id { "ap:tbd22" },
               $nt || " is not allowed as an XML name."
               || " Aparecium does not support nonterminals"
               || " which are not XML names, even when hidden."
          }
          else element aparecium:error {
               attribute id { "ap:tbd11" },
               $nt || " is not allowed as an XML name."
               || " It must be marked as hidden."
          }
  ) 
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#ap-grok">The grammar-ok() function 52</a> &#x3009; <br></span>
</div>

This is stricter than is warranted by the spec, so it's non-conforming
behavior.  It can be changed to conformant behavior only when
the form of compiled grammars is changed.[<a name="ref-to-d3e2391" href="#d3e2391" title="&#xA;Two possible changes would allow Aparecium to be more conformant on&#xA;this point: (1) using follow:info elements with&#xA;state and follow attributes instead of&#xA;foll">9</a>]
</div>

</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-ccg-gok-nonxml">&#x23f4;</a></span><span class="arrow"><a href="#hi-ccg-gok">&#x23f6;</a></span><span class="arrow"><a href="#hi-ccg-gok-classes">&#x23f5;</a></span></div><h6><a class="selflink" name="hi-ccg-gok-duprules" id="hi-ccg-gok-duprules" href="#hi-ccg-gok-duprules">3.4.2.2.3. </a>Checking for multiple definitions</h6>

<div class="Real-P">The ixml spec requires that no nonterminal have
two &lt;<em>rule</em>&gt; elements.  So we group by name and
seek groups with count greater than one.
<div class="scrap"><span><a name="ap-grok-uniqdef">&#x3008; 58 Check rules for uniqueness &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $lee-uniqdef := (
      for $r in $G/rule
      let $nt := string($r/@name)
      group by $nt
      return if (count($r) gt 1)
      then (
        trace((), 
           "Symbol " || $nt 
           || " defined " || count($r) || "&#xd7;: "),
        element aparecium:error {
        attribute id { "ap:tbd12" },
        $nt || " is defined " ||
        (if (count($r) eq 2)
        then "twice"
        else count($r) || " times")
        || "."
      })
      else ()
  )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#ap-grok">The grammar-ok() function 52</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-ccg-gok-duprules">&#x23f4;</a></span><span class="arrow"><a href="#hi-ccg-gok">&#x23f6;</a></span><span class="arrow"><a href="#hi-ccg-gok-hex">&#x23f5;</a></span></div><h6><a class="selflink" name="hi-ccg-gok-classes" id="hi-ccg-gok-classes" href="#hi-ccg-gok-classes">3.4.2.2.4. </a>Checking character classes</h6>

<div class="Real-P">In character sets, classes referred to must be
classes listed in Unicode.  The XML representation of
classes is changing, so this code will (for now)
check both forms.
<div class="scrap"><span><a name="ap-grok-charclass">&#x3008; 59 Check character classes &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $lee-charclass := (
      for $cc in ($G//class/@code,
                  $G//member/@code)
      let $nt := string($cc/ancestor::rule/@name)
      where not(matches($cc,
                '^(L[ultmo]?'
                || '|M[nce]?'
                || '|N[dlo]?'
                || '|P[cdseifo]?'
                || '|Z[slp]?'
                || '|S[mcko]?'
                || '|C[cfon]?)$'))
      return element aparecium:error {
        attribute id { "ap:tbd16" },
        "Character class", string($cc), 
        "in the definition of", $nt, 
        "is not known."
      }
  )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#ap-grok">The grammar-ok() function 52</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-ccg-gok-classes">&#x23f4;</a></span><span class="arrow"><a href="#hi-ccg-gok">&#x23f6;</a></span><span class="arrow"><a href="#hi-ccg-gok-range">&#x23f5;</a></span></div><h6><a class="selflink" name="hi-ccg-gok-hex" id="hi-ccg-gok-hex" href="#hi-ccg-gok-hex">3.4.2.2.5. </a>Checking hex literals</h6>

<div class="Real-P">In hex literals, the hex numeral must denote a number
in the Unicode code point range (so 0 to x10FFFF = 1114111),
which must not be 
that of a Unicode surrogate code point (range xD800 (= 55,296) to xDFFF (= 57343))
or
that of a Unicode non-character (range xFDD0 to xFDEF = 64976 to 65007, also
characters FFFE and FFFF in every plane).
<div class="scrap"><span><a name="ap-grok-hexref">&#x3008; 60 Check hexadecimal character references &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $lee-hex := (
      for $hexref in ($G//literal/@hex,
                  $G//member/@hex,
                  $G//member/(@from | @to)
                      [starts-with(., '#') 
                      and string-length(.) gt 1]
		  )
      let $nt := string($hexref/ancestor::rule/@name),
          $hexstring := if (starts-with($hexref, '#'))
                        then substring($hexref, 2)
                        else string($hexref),
          $int := try { 
                    d2x:x2d($hexstring) 
                  } catch err:FOAR0002 {  
                    -1 (: out of range, assume too big :)
                  } catch * {  
                    -2 (: who knows?  Assume bad hex :)
                  }
      return <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ap-grok-hexref-cases">Diagnose errors and return appropriate errors 61</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#ap-grok">The grammar-ok() function 52</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">We should now be able to diagnose any errors and return
the appropriate error element.  First we check for the value
-1, which will be returned only if we caught error FOAR0002.
<div class="scrap"><span><a name="ap-grok-hexref-cases">&#x3008; 61 Diagnose errors and return appropriate errors &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">        if ($int eq -1)
        then element aparecium:error {
             attribute id { "ap:tbd18" },
             attribute code { "ixml:S07" },
             "Hex value ", $hexstring, 
             "in the definition of", $nt, 
             "is too large. Entirely too large."
	} 
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e2452">Other error during hex-decimal conversion 62</a>&#x3009;, &#x3008;<a href="#d3e2457">Check range 63</a>&#x3009;, &#x3008;<a href="#d3e2463">Check for surrogate code points 64</a>&#x3009;, &#x3008;<a href="#d3e2468">Check for BOM and BOM-similar code points 65</a>&#x3009;, &#x3008;<a href="#d3e2473">No error found, return nothing 66</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#ap-grok-hexref">Check hexadecimal character references 60</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Then we check for any other errors we encountered; I have
no real idea what they might be, so diagnosing it as a bad
hex value is kind of a stab in the dark.
<div class="scrap"><span><a name="d3e2452">&#x3008; 62 Other error during hex-decimal conversion [continues <a href="#ap-grok-hexref-cases">61 Diagnose errors and return appropriate errors</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">        else if ($int eq -2)
        then element aparecium:error {
             attribute id { "ap:tbd19" },
             attribute code { "ixml:S08" },
             "Hex value ", $hexstring, 
             "in the definition of", $nt, 
             "cannot be converted to an integer."
        } 
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>
</div>
<div class="Real-P">From now on we are on firmer footing.  First, we check the range:
Unicode code points lie between 0 and 1114111 inclusive.
<div class="scrap"><span><a name="d3e2457">&#x3008; 63 Check range [continues <a href="#ap-grok-hexref-cases">61 Diagnose errors and return appropriate errors</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">        else if ($int lt 0 or $int gt 1114111)
        then element aparecium:error {
             attribute id { "ap:tbd26" },
             attribute code { "ixml:S07" },
             "Hex value ", $hexstring, 
             "( = ", string($int), ")", 
             "in the definition of", $nt,
             "lies outside the Unicode range",
	     "(0 to 1114111)."
        } 
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>
</div>
<div class="Real-P">Code points U+D800 to U+DBFF are starting characters for surrogate
pairs, and U+DC00 to U+DFFF are ending characters for surrogates. 
<div class="scrap"><span><a name="d3e2463">&#x3008; 64 Check for surrogate code points [continues <a href="#ap-grok-hexref-cases">61 Diagnose errors and return appropriate errors</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">        else if ($int ge 55296 and $int le 57343)
              (: xD800 to xDFFFF :)
        then element aparecium:error {
             attribute id { "ap:tbd27" },
             attribute code { "ixml:S08" },
             "Hex value ", $hexstring, 
             "( = ", string($int), ")", 
             "in the definition of", $nt,
             "is not a Unicode character",
	     "(it is a surrogate code point)."
        } 
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>
</div>

<div class="Real-P">Code points FFFE and FFFF are non-characters in every code page;
this has something to do with the BOM and ensuring there are no false
positives in detecting the BOM.
<div class="scrap"><span><a name="d3e2468">&#x3008; 65 Check for BOM and BOM-similar code points [continues <a href="#ap-grok-hexref-cases">61 Diagnose errors and return appropriate errors</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">        else if (ends-with(upper-case($hexstring), 'FFFF')
             or  ends-with(upper-case($hexstring), 'FFFE'))
        then element aparecium:error {
             attribute id { "ap:tbd28" },
             attribute code { "ixml:S08" },
             "Hex value ", $hexstring, 
             "( = ", string($int), ")", 
             "in the definition of", $nt,
             "is not a Unicode character",
	     "(it is a non-character)."
        }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>
</div>
<div class="Real-P">If none of the above apply, then we have found no error
and return nothing.
<div class="scrap"><span><a name="d3e2473">&#x3008; 66 No error found, return nothing [continues <a href="#ap-grok-hexref-cases">61 Diagnose errors and return appropriate errors</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">        else ()
  )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-ccg-gok-hex">&#x23f4;</a></span><span class="arrow"><a href="#hi-ccg-gok">&#x23f6;</a></span><span class="arrow"><a href="#hi-ccg-gok-undef">&#x23f5;</a></span></div><h6><a class="selflink" name="hi-ccg-gok-range" id="hi-ccg-gok-range" href="#hi-ccg-gok-range">3.4.2.2.6. </a>Checking ranges</h6>

<div class="Real-P">The spec forbids ranges in which the starting code point
is greater than the closing code point.
<div class="scrap"><span><a name="ap-grok-ranges">&#x3008; 67 Check ranges &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $lee-ranges := (
      for $ref in $G//member[@from and @to]
      let $nt := string($ref/ancestor::rule[1]/@name),
          $cp-from := if (string-length($ref/@from) eq 1)
                      then string-to-codepoints($ref/@from)
	              else d2x:x2d(substring($ref/@from, 2)),
          $cp-to := if (string-length($ref/@to) eq 1)
                    then string-to-codepoints($ref/@to)
                    else d2x:x2d(substring($ref/@to, 2))
      return if ($cp-to lt $cp-from)
      then element aparecium:error {
           attribute id { "ap:tbd29" },
           attribute code { "ixml:S09" },
           "Range", 
           $ref/@from/string(), '-', $ref/@to/string(),
           '(=', $cp-from, '-', $cp-to, ")",
           "in the definition of",
           $nt || " is not a good range.",
           "(The end of the range must",
           "be higher than the beginning.)" 
      }
      else ()
  )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#ap-grok">The grammar-ok() function 52</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-ccg-gok-range">&#x23f4;</a></span><span class="arrow"><a href="#hi-ccg-gok">&#x23f6;</a></span><span class="arrow"><a href="#hi-ccg-gok-unreachable">&#x23f5;</a></span></div><h6><a class="selflink" name="hi-ccg-gok-undef" id="hi-ccg-gok-undef" href="#hi-ccg-gok-undef">3.4.2.2.7. </a>Checking for undefined nonterminals</h6>

<div class="Real-P">The spec forbids references to undefined
nonterminals; here we group references by name
and look each name up.
<div class="scrap"><span><a name="ap-grok-alldef">&#x3008; 68 Check for undefined symbols &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $lee-alldef := (
      for $ref in $G//nonterminal
      let $nt := string($ref/@name)
      group by $nt
      return if (empty($G/rule[@name eq $nt]))
      then element aparecium:error {
        attribute id { "ap:tbd13" },
        attribute code { "ixml:S02" },
        $nt || " is referred to but not defined." 
      }
      else ()
  )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#ap-grok">The grammar-ok() function 52</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-ccg-gok-undef">&#x23f4;</a></span><span class="arrow"><a href="#hi-ccg-gok">&#x23f6;</a></span><span class="arrow"><a href="#hi-ccg-gok-unprod">&#x23f5;</a></span></div><h6><a class="selflink" name="hi-ccg-gok-unreachable" id="hi-ccg-gok-unreachable" href="#hi-ccg-gok-unreachable">3.4.2.2.8. </a>Checking for unreachable rules</h6>

<div class="Real-P">Unreachable nonterminals are not defined as an error
by the ixml spec.  They should be detected and warnings
should be issued, but for now we simply ignore them.
<div class="scrap"><span><a name="ap-grok-reach">&#x3008; 69 Check for unreachable symbols (rsn) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $lee-reachable := ()
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#ap-grok">The grammar-ok() function 52</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-ccg-gok-unreachable">&#x23f4;</a></span><span class="arrow"><a href="#hi-ccg-gok">&#x23f6;</a></span><span class="arrow">&nbsp;</span></div><h6><a class="selflink" name="hi-ccg-gok-unprod" id="hi-ccg-gok-unprod" href="#hi-ccg-gok-unprod">3.4.2.2.9. </a>Checking for unproductive nonterminals</h6>
<div class="Real-P">Unproductive nonterminals are not defined as an error
by the ixml spec.  They should be detected and warnings
should be issued, but for now we simply ignore them,
just as for unreachable nonterminals.
<div class="scrap"><span><a name="ap-grok-prod">&#x3008; 70 Check for unproductive symbols (rsn) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $lee-productive := ()
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#ap-grok">The grammar-ok() function 52</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">
That code should clear the hygiene problems.
</div>
</div>
</div>

</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-prep-grammar">&#x23f4;</a></span><span class="arrow"><a href="#highlevel">&#x23f6;</a></span><span class="arrow"><a href="#hi-earley-set">&#x23f5;</a></span></div><h3><a class="selflink" name="hi-earley-parse" id="hi-earley-parse" href="#hi-earley-parse">3.5. </a>Managing the parsing process</h3>

<div class="Real-P">The Earley-parser module provides a single public interface to the
parsing routines of the Earley-parser-internals module.  The
<i>earley:parse()</i> function calls the internal functions to
construct the required set of Earley items,
a parse-forest grammar for the results,
and a parse tree, and return whichever of those
is requested.

<div class="scrap"><span><a name="ep-parse">&#x3008; 71 Define earley:parse() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function ep:parse(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :),
  $options as map(*)
) as element() {

  let $map := (:stat ...prof:time( ... tats:)
              er:recognizeX($I, $G, $options),
              (:stat ...'0a recognize(): '),... tats:)
      $completion-item := $map('Completions'),
      $pfg := <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epp-make-pfg">Make parse-forest grammar or dummy 72</a></em> &#x3009;</span>,
      $ast0 := <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epp-make-ast">Make AST or no-parse 73</a></em> &#x3009;</span>,
      $ast := <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epp-ep-versioncheck">Check results for version mismatch 202</a></em> &#x3009;</span>

  return if ($options('return-tree') 
            and not($options('return-pfg'))
            and not($options('return-items'))
            and not($options('return-grammar')))
      then $ast
      else element ap:results {
               if ($options('return-tree'))
               then element ap:ast { $ast }
               else (),
               if ($options('return-pfg'))
               then element ap:pfg { $pfg }
               else (),
               if ($options('return-items'))
               then element ap:items { 
                      let $mei := $map('Closure')
                      for $n in map:keys($mei('to'))
                      order by $n descending
                      for $ei in $mei('to')($n)
                      return eri:eXei($ei)
                    }
               else (),
               if ($options('return-grammar'))
               then element ap:compiled-grammar { 
                        $map('Grammar')
                    }
               else ()
           }

};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e7058">[File Earley-parser.xqm] 244</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">We make the pfg ...
<div class="scrap"><span><a name="epp-make-pfg">&#x3008; 72 Make parse-forest grammar or dummy &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">              (:stat ...prof:time(... tats:)
              if (exists($map('Completions')))
              then epi:parse-forest-grammar(
                       $map('Completions'), 
                       $map('Closure'), 
                       $I,
                       $options)
              else element ap:no-pfg {
                "Parse failed, no parse-forest grammar."
              }
              (:stat ..., '0b making pfg: ')... tats:)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#ep-parse">Define earley:parse() 71</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">If the PFG has successfully been constructed,
we can extract a parse-tree from it.
<div class="scrap"><span><a name="epp-make-ast">&#x3008; 73 Make AST or no-parse &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">              (:stat ...prof:time(... tats:)
              if (exists($pfg/self::ixml))
              then epi:tree-from-pfg($pfg, 'document', ())
              else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epp-make-noparse">Make no-parse result 74</a></em> &#x3009;</span>
              (:stat ..., '0c extracting tree: ')... tats:)

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#ep-parse">Define earley:parse() 71</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">If there is no PFG, there is no parse.  We return an
&lt;<em>aparecium:no-parse</em>&gt; element to say so.
<div class="scrap"><span><a name="epp-make-noparse">&#x3008; 74 Make no-parse result &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $high-water := max(map:keys($map('Closure')('to')))
  let $start := max((1, (1 + $high-water - 30))),
      $end := min((string-length($I),
                   ($high-water + 30))),
      $cL := min(($high-water, 30)),
      $cR := min(($end - $high-water, 30)),
      $sL := concat(if ($high-water gt 30)
                    then '...'
                    else '',
                    substring($I, $start, $cL)
             ),
      $sR := concat(substring($I, $high-water+1, 30 (: $cR :) ),
                    if ($cR lt 30)
                    then ''
                    else '...'
             )
  return     
  element ap:no-parse {
    attribute ixml:state { "failed" },
    element p { 
      "Sorry, no parse for this string and grammar." 
    },
    element p {
      "The parser gave up at character",
      string($high-water) || ": ",
      "parsing succeeded up through", 
      element q {
          replace($sL,'&amp;#xA;','&amp;amp;#xA;')
      },
      "but failed on",
      element q {
          replace($sR, '&amp;#xA;', '&amp;amp;#xA;')
      }
    },
    element p {
      "Expecting one of: ",
      string-join(
           for $ei in $map('Closure')('to')($high-water)
           for $sym in eri:lsymExpectedXEi($ei)[eri:fTerminal(.)]
           return concat('"', eri:reXTerminal($sym), '"'),
           ', '
      )
    }
  }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epp-make-ast">Make AST or no-parse 73</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-earley-parse">&#x23f4;</a></span><span class="arrow"><a href="#highlevel">&#x23f6;</a></span><span class="arrow"><a href="#hi-ptc">&#x23f5;</a></span></div><h3><a class="selflink" name="hi-earley-set" id="hi-earley-set" href="#hi-earley-set">3.6. </a>Generating the Earley set</h3><ul><li>3.6.1. <a href="#hies-scan">The scanner</a></li><li>3.6.2. <a href="#hies-pred">The predictor</a></li><li>3.6.3. <a href="#hies-comp">The completer</a></li><li>3.6.4. <a href="#hies-recognizer">The recognizer</a></li></ul>
<div class="Real-P">Watch this space.</div>


<div class="div">

<div class="quicknav"><span class="arrow">&nbsp;</span><span class="arrow"><a href="#hi-earley-set">&#x23f6;</a></span><span class="arrow"><a href="#hies-pred">&#x23f5;</a></span></div><h4><a class="selflink" name="hies-scan" id="hies-scan" href="#hies-scan">3.6.1. </a>The scanner</h4>

<div class="Real-P">There are two versions of the scanner.  The basic version
consults <i>ixi:fMatchesIPT()</i> to see whether we have a
match; if so, we get the match length and return the advance over
the terminal.
<div class="scrap"><span><a name="er-scan">&#x3008; 75 Define scan() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ****************************************************** 
   * ix:scan($E, $I)
   ****************************************************** :)
(: If $E expects any terminals which occur as expected, 
   return the advance of E over those terminals.  There 
   may be more than one. :)
   
declare function ix:scan(
  $E as item() (: ITEM :),
  $I as item() (: INPUT :)
) as item()* (: ITEM? :) {
  let $p := ixi:pToXEi($E),
      $lt := ixi:lsymExpectedXEi($E)[ixi:fTerminal(.)]
  for $t in $lt
  return
    if (ixi:fMatchesIPT($I, $p, $t))
    then ixi:leiAdvanceEiSymP($E,$t,$p + ixi:match-length($I,$p,$t))
    else ()
};

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">Other versions of this code are in &#x3008; <a href="#er-scan-pfg">Define scan()  (v. pfg) 76</a> &#x3009; <br></span><span class="scrapinbound">This code is used in &#x3008; <a href="#Earley-rec">[File Earley-recognizer.xqm] 9</a> &#x3009; <br></span>
</div>

The double call 
seems wasteful; it seems simpler to ask the matching
function to tell us how many characters of the input the terminal
consumed.</div>

<div class="Real-P">The <i>pfg</i> version of the code uses a single call
<i>ixi:cMatchesIPT()</i> to see whether we have a match and
how long it is.  If we have a match, we return both the advance over
the terminal and a new form of item, with a terminal rather than a
nonterminal in the rule position, and a rule index of
&#x201c;<tt>#terminal</tt>&#x201d; or (for insertions)
the string &#x201c;<tt>#ins_</tt>&#x201d; followed by a dot-separated
list of code points in the string to be inserted.
<i>This is a hideous hack that reflects the fact that I have not
found a way to integrate text insertions cleanly into the parsing
model.</i>
<div class="scrap"><span><a name="er-scan-pfg">&#x3008; 76 Define scan() &#x3009; (for version <em>pfg</em>) &#x2261;</a></span>
<pre class="scrapbody">(: ****************************************************** 
   * ix:scan($E, $I)
   ****************************************************** :)
(: If $E expects any terminals which occur as expected, 
   return the advance of E over those terminals.  There 
   may be more than one.  :)
   
declare function ix:scan(
  $E as item() (: ITEM :),
  $I as item() (: INPUT :)
) as item()* (: ITEM? :) {
  let $p := ixi:pToXEi($E),
      $lt := ixi:lsymExpectedXEi($E)[ixi:fTerminal(.)]
  for $t in $lt
  return
    let $c := ixi:cMatchesIPT($I, $p, $t)
    return 
    if ($c ge 0)
    then (ixi:leiAdvanceEiSymP($E, $t, $p + $c),
         ixi:eiMakePPT($p, $p + $c, $t))
    else ()
};

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#er-scan">Define scan() 75</a> &#x3009; </span>
</div>

</div>
</div>

<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hies-scan">&#x23f4;</a></span><span class="arrow"><a href="#hi-earley-set">&#x23f6;</a></span><span class="arrow"><a href="#hies-comp">&#x23f5;</a></span></div><h4><a class="selflink" name="hies-pred" id="hies-pred" href="#hies-pred">3.6.2. </a>The predictor</h4>

<div class="Real-P">
<div class="scrap"><span><a name="er-pred">&#x3008; 77 Define pred() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ****************************************************** 
   * ix:pred($E, $G)
   ****************************************************** :)
(: If $E predicts any non-terminals, return items which 
   expect those non-terminals at the appropriate location. 
   :)
   
declare function ix:pred(
  $E as item() (: ITEM :),
  $G as item() (: GRAMMAR :)
) as item()* (: ITEM :) {
  (: iterate over
       $ln nonterminals expected by $E,
       $lr rules in $G for $n,
       $lri initial positions in $r
     also return advance of $E for nullable $n
   :)
   let $p := ixi:pToXEi($E),
       $ln := ixi:lsymExpectedXEi($E)[ixi:fNonterminal(.)]
   for $n in $ln
   let $fNullable := ixi:fNullableNG($n/@name, $G),
       $lr := ixi:lrulesXNG($n,$G)
   return (
     (: first, return advance of $E if $n nullable :)
     if ($fNullable)
     then ixi:leiAdvanceEiSymP($E,$n,$p)
     else (),
       
     (: then iterate over rules and initial locations for $n :)
     for $r in $lr
     let $lri := ixi:lriStartstatesXR($r)
     for $ri in $lri
     return ixi:eiMakePPRRi($p, $p, $r, $ri)
   )
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#Earley-rec">[File Earley-recognizer.xqm] 9</a> &#x3009; <br></span>
</div>
</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hies-pred">&#x23f4;</a></span><span class="arrow"><a href="#hi-earley-set">&#x23f6;</a></span><span class="arrow"><a href="#hies-recognizer">&#x23f5;</a></span></div><h4><a class="selflink" name="hies-comp" id="hies-comp" href="#hies-comp">3.6.3. </a>The completer</h4>

<div class="Real-P">
<div class="scrap"><span><a name="er-comp">&#x3008; 78 Define comp() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ****************************************************** 
   * ix:comp($Ec, $Ep)
   ****************************************************** :)
(: If $Ec and $Ep are a prediction/completion pair, return
   the advance of $Ep over the non-terminal predicted by 
   $Ec. :)
   
(: comp($Ec, $Ep): if $Ec is a completion item, 
   and $Ep a prediction item,
   and $Ep predicts a nonterminal $n at position $pPTo,
   and $Ec completes $n starting at $pCFrom=$pPTo,
   then advance $Ep over $n and place the new to-position
   at the to-position of $Ec.
   
   The test for whether $Ep expects $n is handled
   by leiAdvanceEiSymP, so we need not make it here.
:)
declare function ix:comp(
  $Ec as item() (: ITEM :),
  $Ep as item() (: ITEM :)
) as item()* (: ITEM :) {
  let $pCFrom := ixi:pFromXEi($Ec),
      $pCTo   := ixi:pToXEi($Ec),
      (: $pPFrom := ixi:pFromXEi($Ep), :)
      $pPTo   := ixi:pToXEi($Ep),
      $n      := ixi:nLhsXEi($Ec),
      $RESULT := if (ixi:fFinalEi($Ec)
                    and $pPTo eq $pCFrom)
                 then ixi:leiAdvanceEiSymP($Ep, $n, $pCTo)
                 else ()
  return $RESULT
};

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#Earley-rec">[File Earley-recognizer.xqm] 9</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hies-comp">&#x23f4;</a></span><span class="arrow"><a href="#hi-earley-set">&#x23f6;</a></span><span class="arrow">&nbsp;</span></div><h4><a class="selflink" name="hies-recognizer" id="hies-recognizer" href="#hies-recognizer">3.6.4. </a>The recognizer</h4>
<div class="Real-P">The <i>ix:recognize()</i> function accepts an input string
and a grammar, and returns a boolean: true if the input is a sentence
in the language defined by the grammar, false otherwise.  On the way
to reaching that result, of course, a lot of intermediate results will
be calculated, some of them of interest for other purposes (e.g. for
the parser as a whole).  So there are two recognition functions: one
to calculate and expose all the intermediate results, and one to
expose only the boolean result, which calls the other function to do
the preliminary work.  The <i>ix:recognize()</i> function
works as a kind of wrapper around the other function:
<div class="scrap"><span><a name="er-recognize">&#x3008; 79 Define recognize() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function ix:recognize(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :),
  $options as map(*)
) as xs:boolean {
  let $m := ix:recognizeX($I, $G, $options)
  return $m('Result')
};

</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e2650">Define recognizeX() 80</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#Earley-rec">[File Earley-recognizer.xqm] 9</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The <i>ix:recognizeX()</i> function (an extended
recognizer, if you will)
<div class="scrap"><span><a name="d3e2650">&#x3008; 80 Define recognizeX() [continues <a href="#er-recognize">79 Define recognize()</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function ix:recognizeX(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :),
  $options as map(*)
) as map(*) {
  let $G2 := ixi:augment-grammar($G),
      $symStart0 := ixi:symStartG($G),
      $symStart2 := ixi:symStartG($G2),
      $rInitial := ixi:lrulesXNG(
        &lt;nonterminal name="{$symStart2}"/&gt;, 
        $G2)[1],
      $riInitial := ixi:lriStartstatesXR($rInitial)[1],
      $eiInitial := ixi:eiMakePPRRi(0, 0, 
                                    $rInitial, 
                                    $riInitial),
      $len := ixi:inputlength($I),
      
      $meiClosure := 
          ixi:earley-closure($eiInitial, $I, $G2),
      (: $leiCompletions := $meiClosure
         [ixi:fFinalEiPPN(.,0,$len,$symStart2)], :)
      $leiCompletions := $meiClosure('from')(0)
                         [ixi:fFinalEiPPN(., 0,
                                          $len,
                                          $symStart2)],
      $result := exists($leiCompletions)

  return map {
    'Grammar' : $G2,
    'Initial-Item' : $eiInitial,
    'Input' : $I,
    'Input-Length' : $len,
    'Closure' : $meiClosure,
    'Completions' : $leiCompletions,
    'Result' : $result
  }
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-earley-set">&#x23f4;</a></span><span class="arrow"><a href="#highlevel">&#x23f6;</a></span><span class="arrow"><a href="#hi-pfg">&#x23f5;</a></span></div><h3><a class="selflink" name="hi-ptc" id="hi-ptc" href="#hi-ptc">3.7. </a>Direct generation of parse tree</h3><ul><li>3.7.1. <a href="#hi-ptc-raw">Raw parse trees</a></li><li>3.7.2. <a href="#hi-ptc-ast">Abstract syntax trees</a></li></ul>
<div class="Real-P">In version 0.2 of Aparecium, we generate one
or more parse trees directly from the Earley set.
(In future versions, it is expected that we will
generate a parse-forest grammar from the Earley
set, and generate trees from that grammar, or
return the grammar to the user.  But at the moment
that's just pie in the sky.)</div>
<div class="Real-P">We generate the parse trees in two steps.
From the Earley set, we generate a raw parse tree
which records every nonterminal used (we may
regret this, eventually).  From the raw parse tree,
we create the abstract syntax tree by attending to
the marks on the nonterminals.
</div>

<div class="div">

<div class="quicknav"><span class="arrow">&nbsp;</span><span class="arrow"><a href="#hi-ptc">&#x23f6;</a></span><span class="arrow"><a href="#hi-ptc-ast">&#x23f5;</a></span></div><h4><a class="selflink" name="hi-ptc-raw" id="hi-ptc-raw" href="#hi-ptc-raw">3.7.1. </a>Raw parse trees</h4>
<div class="Real-P">For raw parse trees, we use a generic XML
representation with two element types:
<ul><li>&lt;<em>nt</em>&gt; elements record that a given nonterminal was parsed
at a given location, with attributes providing details:
<ul><li><em>name</em> gives the nonterminal symbol.</li>
<li><em>_from</em> and <em>_to</em> give the
range in the input.</li>
<li><em>mark</em> records the mark effective for this instance of
the nonterminal.  If a nonterminal in a right-hand side carries a
mark, we record it here; if not, we fetch the default value; if no
default value is specified, we supply the value
&#x201c;<tt>^</tt>&#x201d;.</li>
</ul>
</li>
<li>&lt;<em>lit</em>&gt;, &lt;<em>inc</em>&gt;, and &lt;<em>exc</em>&gt; elements record
that a given terminal was found at a given location, with attributes
providing details:
<ul><li><em>name</em> gives the nonterminal symbol.</li>
<li><em>_from</em> and <em>_to</em> give the
range in the input.  For &lt;<em>inc</em>&gt; and &lt;<em>exc</em>&gt;
the two values will be the same, but not necessarily so
for literals.</li>
<li><em>tmark</em> records the terminal mark effective for this
the nonterminal.  This is what makes it possible to suppress
terminals marked &#x201c;<tt>-</tt>&#x201d; (or inject
terminals marked &#x201c;<tt>+</tt>&#x201d;, which doesn't seem
to have made it into the spec yet).</li>
</ul>
</li>
</ul>
Representing nonterminal nodes as &lt;<em>nt</em>&gt; elements
instead of elements with the nonterminal itself as a name
allows terminals marked for suppression to be distinguished
reliably from nonterminals marked &#x201c;<tt>-</tt>&#x201d;.
(It also allows the raw parse tree to be produced even if
the nonterminal is not a legal XML name.)
</div>
<div class="Real-P">N.B. The initial implementation of raw parse trees
used nonterminals as element names; there may be traces
of that state of affairs in this document.</div>
<div class="Real-P"><i>all-node-sequences() should be described here.</i>
For the moment, see <a href="#epi-all-nodes">Finding a sequence of items for a single right-hand side</a>.</div>
</div>

<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-ptc-raw">&#x23f4;</a></span><span class="arrow"><a href="#hi-ptc">&#x23f6;</a></span><span class="arrow">&nbsp;</span></div><h4><a class="selflink" name="hi-ptc-ast" id="hi-ptc-ast" href="#hi-ptc-ast">3.7.2. </a>Abstract syntax trees</h4>
<div class="Real-P"><i>The epi:astXparsetree() function should
go here.  For now, see <a href="#epi-ast-from-raw">Extracting the abstract syntax tree from the raw parse tree</a>.</i></div>
</div>

</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-ptc">&#x23f4;</a></span><span class="arrow"><a href="#highlevel">&#x23f6;</a></span><span class="arrow"><a href="#hi-rpt-ex-pfg">&#x23f5;</a></span></div><h3><a class="selflink" name="hi-pfg" id="hi-pfg" href="#hi-pfg">3.8. </a>Generating the parse-forest grammar</h3><ul><li>3.8.1. <a href="#hi-pfg-intro">Short description of parse-forest grammars</a></li><li>3.8.2. <a href="#hi-pfg-const">Constructing a parse-forest grammar</a></li><li>3.8.3. <a href="#hi-pfgc-top">The parse-forest-grammar() function</a></li><li>3.8.4. <a href="#hi-pfgc-make-rules">The <i>make-pfg-rules()</i> function</a></li><li>3.8.5. <a href="#hi-pfgc-walks">Finding walks through a rule's right-hand-side</a></li><li>3.8.6. <a href="#hi-pfgc-makerule">Making a production rule for a given walk</a></li><li>3.8.7. <a href="#hi-pfgc-recur">Preparing for the next iteration</a></li><li>3.8.8. <a href="#hi-pfgc-find-walks">The <i>find-walks()</i> function</a></li><li>3.8.9. <a href="#hi-pfgc-make-rhs">The <i>rhs-from-walk()</i> function</a></li><li>3.8.10. <a href="#hi-pfgc-make-lei">The <i>lei-from-walk()</i> function</a></li><li>3.8.11. <a href="#hi-pfgc-find-dups">The <i>dups-from-walk()</i> function</a></li></ul>

<div class="Real-P">Another way to describe a set of derivations is to use a
parse-forest grammar.  It may be helpful to begin with a
brief description.</div>


<div class="div">

<div class="quicknav"><span class="arrow">&nbsp;</span><span class="arrow"><a href="#hi-pfg">&#x23f6;</a></span><span class="arrow"><a href="#hi-pfg-const">&#x23f5;</a></span></div><h4><a class="selflink" name="hi-pfg-intro" id="hi-pfg-intro" href="#hi-pfg-intro">3.8.1. </a>Short description of parse-forest grammars</h4>

<div class="Real-P">A parse-forest grammar is a way of describing the parse trees for
exactly one sentence in some language defined by another grammar (what
we may call its &#x2018;base grammar&#x2019;.</div>

<div class="Real-P">It is perhaps best explained by example. Consider the sentence
&#x201c;<tt>7-4+2</tt>&#x201d; parsed against the following simple and
ambiguous grammar:
<pre style="margin-left: 2em; background-color: #CCD; margin-right: 3em;">S = expr.
expr = num; expr, addop, expr.
num = ["0" - "9"]+.
addop = "+"; "-".
</pre></div>
<div class="Real-P">One parse tree for the sentence is<pre style="margin-left: 2em; background-color: #CCD; margin-right: 3em;">  &lt;S&gt;
    &lt;expr&gt;
      &lt;expr&gt;
        &lt;expr&gt;&lt;num&gt;7&lt;/num&gt;&lt;/expr&gt;
        &lt;addop&gt;-&lt;/addop&gt;
        &lt;expr&gt;&lt;num&gt;4&lt;/num&gt;&lt;/expr&gt;
      &lt;/expr&gt;    
      &lt;addop&gt;+&lt;/addop&gt;
      &lt;expr&gt;&lt;num&gt;2&lt;/num&gt;&lt;/expr&gt;
    &lt;/expr&gt;
  &lt;/S&gt;</pre>
Another is:
<pre style="margin-left: 2em; background-color: #CCD; margin-right: 3em;">  &lt;S&gt;
    &lt;expr&gt;
      &lt;expr&gt;&lt;num&gt;7&lt;/num&gt;&lt;/expr&gt;
      &lt;addop&gt;-&lt;/addop&gt;
      &lt;expr&gt;     
        &lt;expr&gt;&lt;num&gt;4&lt;/num&gt;&lt;/expr&gt;
        &lt;addop&gt;+&lt;/addop&gt;
        &lt;expr&gt;&lt;num&gt;2&lt;/num&gt;&lt;/expr&gt;
      &lt;/expr&gt;
    &lt;/expr&gt;
  &lt;/S&gt;</pre>
</div>
<div class="Real-P">Each parse tree can be described in a parse-tree grammar which has
a structure similar to that of the original grammar.  For every
nonterminal <i>N</i> in the parse tree which dominates some substring from
position <i>x</i> to position <i>y</i> in the sentence, the parse-tree grammar
will have a nonterminal with a name constructed from <i>N</i>, <i>x</i>, and <i>y</i>
with a rule showing how <i>N</i> produces that segment.  The first parse tree, for example,
can be written as a parse-tree grammar thus:<pre style="margin-left: 2em; background-color: #CCD; margin-right: 3em;">
S&#xb7;0&#xb7;5 = expr&#xb7;0&#xb7;5.
expr&#xb7;0&#xb7;5 = expr&#xb7;0&#xb7;3, addop&#xb7;3&#xb7;4, expr&#xb7;4&#xb7;5.
expr&#xb7;0&#xb7;3 = expr&#xb7;0&#xb7;1, addop&#xb7;1&#xb7;2, expr&#xb7;2&#xb7;3.
expr&#xb7;0&#xb7;1 = num&#xb7;0&#xb7;1.
expr&#xb7;2&#xb7;3 = num&#xb7;2&#xb7;3.
expr&#xb7;4&#xb7;5 = num&#xb7;4&#xb7;5.
num&#xb7;0&#xb7;1 = "7".
num&#xb7;2&#xb7;3 = "4".
num&#xb7;4&#xb7;5 = "2".
addop&#xb7;1&#xb7;2 = "-".
addop&#xb7;3&#xb7;4 = "+".
</pre></div>
<div class="Real-P">The second tree can likewise be described in a grammar, which
shares a great many of the rules from the first parse-tree grammar.
It may be obvious to the reader that both trees can be described in
the same grammar, thus:<pre style="margin-left: 2em; background-color: #CCD; margin-right: 3em;">
S&#xb7;0&#xb7;5 = expr&#xb7;0&#xb7;5.
expr&#xb7;0&#xb7;5 = expr&#xb7;0&#xb7;3, addop&#xb7;3&#xb7;4, expr&#xb7;4&#xb7;5
         | expr&#xb7;0&#xb7;1, addop&#xb7;1&#xb7;2, expr&#xb7;2&#xb7;5.
expr&#xb7;0&#xb7;3 = expr&#xb7;0&#xb7;1, addop&#xb7;1&#xb7;2, expr&#xb7;2&#xb7;3.
expr&#xb7;2&#xb7;5 = expr&#xb7;2&#xb7;3, addop&#xb7;3&#xb7;4, expr&#xb7;4&#xb7;5.
expr&#xb7;0&#xb7;1 = num&#xb7;0&#xb7;1.
expr&#xb7;2&#xb7;3 = num&#xb7;2&#xb7;3.
expr&#xb7;4&#xb7;5 = num&#xb7;4&#xb7;5.
num&#xb7;0&#xb7;1 = "7".
num&#xb7;2&#xb7;3 = "4".
num&#xb7;4&#xb7;5 = "2".
addop&#xb7;1&#xb7;2 = "-".
addop&#xb7;3&#xb7;4 = "+".
</pre></div>

<div class="Real-P">Note that in the grammar describing a single tree, every rule has
exactly one right-hand side; in the grammar describing multiple trees,
<i>expr&#xb7;0&#xb7;5</i> has two right-hand sides, reflecting the fact
that it can produce the string in two different ways.</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-pfg-intro">&#x23f4;</a></span><span class="arrow"><a href="#hi-pfg">&#x23f6;</a></span><span class="arrow"><a href="#hi-pfgc-top">&#x23f5;</a></span></div><h4><a class="selflink" name="hi-pfg-const" id="hi-pfg-const" href="#hi-pfg-const">3.8.2. </a>Constructing a parse-forest grammar</h4>

<div class="Real-P">Our overarching task here can be described thus:  We are given
<ul><li>an Earley set closed under the <i>scan</i>,
<i>pred</i>, and <i>comp</i> relations, and</li>
<li>a completion item in that set.</li>
</ul>
From these, we are to construct a parse-forest grammar
describing the set of parse trees whose existence is
implied by the completion item.</div>

<div class="Real-P">A brute-force approach would simply construct a grammar rule for
every possible realization of every completion item in the Earley set,
but that would produce rules for matches that never made it into a
successful parse.[<a name="ref-to-d3e2827" href="#d3e2827" title="&#xA;Since those rules would be a potentially&#xA;informative description of the garden paths followed by the parser&#xA;before they reached a dead end, they might be usefu">10</a>]</div>

<div class="Real-P">Since we are given a completion item of the form (<i>x</i> <i>y</i> <i>N</i>
<i>q</i><sub><i>f</i></sub>)[<a name="ref-to-d3e2843" href="#d3e2843" title="Here qf is any final state in the&#xA;definition of N.">11</a>] a simple way to handle the task is:
<ul><li>
<div class="Real-P">Construct the production rule for <i>N</i>&#xb7;<i>x</i>&#xb7;<i>y</i>.</div>
</li>
<li>
<div class="Real-P">For each nonterminal in the right-hand side of the rule just
constructed, construct the production rule for that nonterminal.</div>
</li>
</ul>
</div>

<div class="Real-P">The first step will entail finding a sequence of completion items
that correspond to a <em>satisfactory walk</em> through the
right-hand side of the production rule for <i>N</i> in the base
grammar.[<a name="ref-to-d3e2878" href="#d3e2878" title=" I call it a&#xA;satisfactory walk because (a) the sequence of&#xA;nonterminals satisfies the constraints of the right-hand side, and&#xA;(b) the walk is acceptable to the ">12</a>] That is a walk through the RHS
<ul><li>beginning in the start state <i>q</i><sub>0</sub>,</li>
<li>ending in some final state <i>q</i><sub><i>f</i></sub>, and</li>
<li>in which the steps collectively cover the input segment from
<i>x</i> to <i>y</i>.</li>
</ul>
For each item in the walk an appropriate new nonterminal can be
constructed, and those nonterminals will be written into into the
right-hand side of the production rule, in the appropriate sequence.
If there is more than one such walk through the rule for <i>N</i>, then
<i>N</i> is ambiguous, and we want all of those walks.[<a name="ref-to-d3e2918" href="#d3e2918" title="At the moment, there are some infinitely ambiguous&#xA;sentences for which we will not in fact get all of the walks&#xA;(informally, those involving infinite&#xA;horizontal">13</a>]</div>

<div class="Real-P">The second step can be handled by calling the same function we
called to handle the completion we started with.  Since in cases of
ambiguity the same nonterminal may appear in more than one walk
through <i>N</i> and thus in more than one right-hand side for <i>N</i>&#xb7;<i>x</i>&#xb7;<i>y</i>, we
should keep track of what nonterminals we have already constructed or
already placed in the queue.</div>

</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-pfg-const">&#x23f4;</a></span><span class="arrow"><a href="#hi-pfg">&#x23f6;</a></span><span class="arrow"><a href="#hi-pfgc-make-rules">&#x23f5;</a></span></div><h4><a class="selflink" name="hi-pfgc-top" id="hi-pfgc-top" href="#hi-pfgc-top">3.8.3. </a>The parse-forest-grammar() function</h4>
<div class="Real-P">The top-level function for making the parse-forest grammar will
thus place the initial completion item in a work queue and delegate
responsibility for generating the appropriate production rules to a
separate recursive function, wrapping the result in an &lt;<em>ixml</em>&gt;
element or an &lt;<em>error</em>&gt; element.</div>
<div class="Real-P">To simplify later operations, </div>

<div class="Real-P">
<div class="scrap"><span><a name="epi-parse-forest-grammar">&#x3008; 81 Define parse-forest-grammar() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:parse-forest-grammar(
  $leiCompletions as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#adt-list-ei">Type: list of Earley items 124</a></em> &#x3009;</span>,
  $leiClosure as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#adt-eiclosure">Type:  Earley closure 125</a></em> &#x3009;</span>,
  $I as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#adt-input">Type: input string 126</a></em> &#x3009;</span>,
  $options as map(*)
) as element() {
  let $rules := epi:make-pfg-rules(
                    $leiCompletions,
                    $leiClosure,
		    $I, 
                    ())
		    
  return 
    <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-pfg-return">Return parse-forest grammar containing $rules 82</a></em> &#x3009;</span>
};
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-make-pfg-rules">Define function epi:make-pfg-rules() 84</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-find-walks">The find-walks() function 92</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-rhs-from-walk">The rhs-from-walk() function 98</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-lei-from-walk">The lei-from-walk() function 104</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-find-dups-in-walk">The dups-from-walk() function 105</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e434">[File Earley-parser-internals.xqm] 8</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">After the work has been done, the <i>parse-forest-grammar()</i>
function returns the result:  either an error element or the
desired ixml element.
<div class="scrap"><span><a name="epi-pfg-return">&#x3008; 82 Return parse-forest grammar containing $rules &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    (: if we got an error back, pass it along :)
    <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-pfg-error-return">If there is an error, return an error element 83</a></em> &#x3009;</span>

    (: if we are error-free, wrap it in ixml :)
    else element ixml {
           element comment {
             "Parse-forest grammar generated ",
             current-dateTime()
           },
           $rules                
         }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-parse-forest-grammar">Define parse-forest-grammar() 81</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The error checking is currently very simple:  if there is an
error element among the rules, we wrap the entire set of rules in
an enclosing error element.
<div class="scrap"><span><a name="epi-pfg-error-return">&#x3008; 83 If there is an error, return an error element &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    if ($rules/self::ap:error)
    then element ap:error {
           attribute id { "ap:tbd30" },
           element comment {
             "Failure generating PFG. ",
             "Sorry!" 
           },
           $rules                
           }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-pfg-return">Return parse-forest grammar containing $rules 82</a> &#x3009; <br></span>
</div>
</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-pfgc-top">&#x23f4;</a></span><span class="arrow"><a href="#hi-pfg">&#x23f6;</a></span><span class="arrow"><a href="#hi-pfgc-walks">&#x23f5;</a></span></div><h4><a class="selflink" name="hi-pfgc-make-rules" id="hi-pfgc-make-rules" href="#hi-pfgc-make-rules">3.8.4. </a>The <i>make-pfg-rules()</i> function</h4>

<div class="Real-P">The <i>epi:make-pfg-rules()</i> function has a familiar
basic structure: if there is work in the queue, we do it, we check to
see whether it has generated further work, and we recur to handle the
remaining items in the queue.  If the queue is empty, we are done and
can return the accumulated intermediate results.
<div class="scrap"><span><a name="epi-make-pfg-rules">&#x3008; 84 Define function epi:make-pfg-rules() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:make-pfg-rules(
  $leiQueue as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#adt-list-ei">Type: list of Earley items 124</a></em> &#x3009;</span>,
  $leiClosure as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#adt-eiclosure">Type:  Earley closure 125</a></em> &#x3009;</span>,
  $I as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#adt-input">Type: input string 126</a></em> &#x3009;</span>,
  $leRules as element()*
    (: accumulator, element(rule|error)* :)
) as element()* {
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-mpr-stop">If PFG queue is empty, return accumulator 85</a></em> &#x3009;</span>
  else 
  let $ei := head($leiQueue)
  
  let $dummy := eri:notrace(eri:sXei($ei), 'Making production rule for item: ')

  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-mpr-find-walk">Set $walks to possible child sequences for $ei 88</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-mpr-make-rule">Set $rule to production rule for $ei 89</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-mpr-update-queue">Set $new-queue to include new completions 90</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-mpr-recur">Recursive call with new queue and accumulator 91</a></em> &#x3009;</span>

};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-parse-forest-grammar">Define parse-forest-grammar() 81</a> &#x3009; <br></span>
</div>
</div>

<div class="Real-P">The base case is unsurprising:
<div class="scrap"><span><a name="epi-mpr-stop">&#x3008; 85 If PFG queue is empty, return accumulator &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  if (empty($leiQueue))
  then $leRules
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-make-pfg-rules">Define function epi:make-pfg-rules() 84</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">When there is work to be done, of course, the case is more
complex.  The following subsections describe it.</div>

</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-pfgc-make-rules">&#x23f4;</a></span><span class="arrow"><a href="#hi-pfg">&#x23f6;</a></span><span class="arrow"><a href="#hi-pfgc-makerule">&#x23f5;</a></span></div><h4><a class="selflink" name="hi-pfgc-walks" id="hi-pfgc-walks" href="#hi-pfgc-walks">3.8.5. </a>Finding walks through a rule's right-hand-side</h4>
<div class="Real-P">The core task of making the parse-forest grammar seems to be
finding the sequences of completion items which represent the
parse-tree children of the node represented by the current completion
item.  It's complicated by several factors:
<ul><li><div class="Real-P">We must move back and forth continually between the parent
level, moving forward state by state in the FSA for the parent
nonterminal <i>N</i>, and the child level, identifying completion items
for each child <i>C</i>.  The information we want is never where we are
at any time, figuratively speaking.</div>

<div class="Real-P">Concretely: at any given point, the state of our effort to find
walks depends on the set of walks we have accumulated, and for each
walk <i>w</i> some relevant properties are given by the most recent
completion item <i>i</i> and others by the state <i>q</i> in the FSA reached
by the walk:
<ul><li>Does <i>w</i> end in a final state of the FSA? (i.e. is <i>q</i> &#x2208;
<i>F</i> for this FSA?)</li>
<li>Does <i>w</i> cover the required range of input? (i.e. is
<i>ei</i>('to') = <i>ei</i>('to'), where <i>ei</i> is the completion item
represented by the left-hand side of the rule?)</li>
<li>Can <i>w</i> be extended? (i.e. is <i>follow(<i>q</i>)</i>
empty?)</li>
</ul></div></li>
<li><div class="Real-P">We would like to be able to find all the walks, not just
one.  The ixml spec wants us to report ambiguity, and that means we
must at least know whether more than one walk exists.</div>
</li>
<li><div class="Real-P">We need to be alert for cycles in the walk.  These will
always be edge cases: they can arise only if repeatable sequences of
children can and do produce the empty string.  But they can
occur.</div></li>
<li><div class="Real-P">Each walk is (notionally at least) a sequence of completion
items describing parse-tree children.  But we can't return a set of
walks by returning a sequence of sequences, so we need to some other
representation.</div>

<div class="Real-P">Candidates include:
<ul><li><b>arrays of sequences</b>:<ul><li><b>sequences of Earley items</b>: walks as sequences
of completion items, sets of walks as arrays of sequences</li>
<li><b>sequences of pairs</b>: walks as sequences of pairs
consisting of a completion item and a state, sets of walks as arrays
of such sequences</li>
<li><b>sequences of strings</b>: walks as sequences of
strings of the form &#x201c;<i>x</i>&#xb7;<i>y</i>&#xb7;<i>N</i>&#x201d; (or
&#x201c;<i>N</i>&#xb7;<i>x</i>&#xb7;<i>y</i>&#x201d;, or
&#x201c;<i>x</i>&#xb7;<i>y</i>&#xb7;<i>N</i>&#x21d2;<i>q</i>&#x201d;, or
&#x201c;<i>N</i>&#xb7;<i>x</i>&#xb7;<i>y</i>&#x21d2;<i>q</i>&#x201d;), sets of walks as arrays of
such sequences</li>
</ul>
</li>
<li><b>sequences of strings</b>:<ul><li><b>long strings</b>: walks as strings made by joining
strings of the form &#x201c;<i>x</i>&#xb7;<i>y</i>&#xb7;<i>N</i>&#x201d; together with
&#x201c;<tt>/</tt>&#x201d; or &#x201c;<tt>+</tt>&#x201d; or
&#x201c;<tt>,&amp;#x20;</tt>&#x201d; or some other concatenation mark,
sets of walks as sequences of such string</li>
</ul></li>
<li><b>maps</b>:<ul><li><b>prefix trees</b>: a set of walks as a map
representing a prefix tree, each walk then a path from the root of
the tree to a leaf; the trees will contain either just completion
items or a mix of completion items and state in the FSA we are
walking through</li>
<li><b>step lists with shared tails</b>: each walk as a
map representing one step in the walk, with keys
&#x201c;<tt>state</tt>&#x201d; (= <i>q</i>), &#x201c;<tt>item</tt>&#x201d; (=<i>i</i>),
&#x201c;<tt>pred</tt>&#x201d; (a pointer to the map for the preceding step in
the walk, empty for the first step); a set of walks is just a set of
such maps.  Walks which share a prefix will use the same map to
represent that shared prefix, so this is effectively just an
upside-down tree, which we hold by its leaves and not its
root.</li>
</ul>
</li>
<li><b>elements</b>:<ul><li><b>&lt;<em>walks</em>&gt; and &lt;<em>step</em>&gt; elements</b>: a
set of walks as a &lt;<em>walks</em>&gt; element, contain a set of
&lt;<em>step</em>&gt; elements, which in turn may each contain a
&lt;<em>walks</em>&gt; element.  Each &lt;<em>walks</em>&gt; element specifies a
starting state and position, each step a destination state and
position.  If a step has no successors, it has no &lt;<em>walks</em>&gt;
element.  If a step's destination state is final in the FSA and its
destination position is the desired ending position, the path from
the root to that step is a complete walk through the FSA and
represents a right-hand side of a rule in the PFG.</li>
</ul></li>
</ul>
The current implementation uses step lists with shared
tails.</div></li>
</ul>
</div>

<div class="Real-P">The basic plan is an iterative function[<a name="ref-to-d3e3225" href="#d3e3225" title="&#xA;By iterative function I mean a recursive&#xA;function where recursion serves only to provide a looping&#xA;construct.&#xA;">14</a>] which performs a breadth-first search and assembles the
result.[<a name="ref-to-d3e3233" href="#d3e3233" title="&#xA;If we are not trying to return all walks but only a finite number&#xA;of walks, a depth-first search might be better.  But at the moment I&#xA;am reacting, and possibl">15</a>] We have an accumulator of some sort that holds a set of
walks found so far, each of which is either complete (it goes all
the way to a final state in the right-hand side of <i>N</i>) or not, and
either extensible or not.[<a name="ref-to-d3e3243" href="#d3e3243" title="&#xA;&#xA;In principle, a walk can be extended if the last state reached by&#xA;the walk has follow states.  But since right-hand sides in an EBNF can&#xA;have cycles, we cut o">16</a>] The result is complete when no walks can be extended,
or when we have found enough walks to go on with.
<ul><li><div class="Real-P">If the result is complete, return all of the complete walks
found so far.</div></li>
<li><div class="Real-P">Otherwise, for each walk <i>w</i> that can be extended:
<ul><li><div class="Real-P">Find all possible extensions to <i>w</i>.</div></li>
<li><div class="Real-P">For each possible extension <i>e</i>, make a new walk <i>w&#x2032;</i> by
adding <i>e</i> to the end of <i>w</i>.</div></li>
<li><div class="Real-P">For each new walk <i>w&#x2032;</i>, see if <i>w&#x2032;</i> is complete and mark it
appropriately so it can be found again.</div></li>
</ul></div></li>
</ul>
When a complete walk is extended, the original walk needs to be
kept around unchanged so it can be returned in the result.
When incomplete walks are extended, the original walks can be
discarded.</div>

<div class="Real-P">Each walk is a step list, and each step is represented
by a map:
<div class="scrap"><span><a name="pfg-adt-walk">&#x3008; 86 Type: walk in a RHS &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">map(xs:string, item()*)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-rhs-from-walk">The rhs-from-walk() function 98</a> &#x3009; &#x3008; <a href="#epi-lei-from-walk">The lei-from-walk() function 104</a> &#x3009; &#x3008; <a href="#epi-find-dups-in-walk">The dups-from-walk() function 105</a> &#x3009; <br></span>
</div>

A collection of walks is just a sequence of walks:
<div class="scrap"><span><a name="pfg-adt-walks">&#x3008; 87 Type: collection of walks &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">map(xs:string, item()*)*
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-find-walks">The find-walks() function 92</a> &#x3009; &#x3008; <a href="#epi-find-dups-in-walk">The dups-from-walk() function 105</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">Since we will need recursion to iterate over the steps in the
walks we are constructing, the task of generating child sequences
for <i>ei</i> will just be delegated to a separate function,
<i>epi:find-walks()</i>.  We prime the pump by creating a
walk with a single step.  And if the parent FSA is nullable, we add that walk to the 

<div class="scrap"><span><a name="epi-mpr-find-walk">&#x3008; 88 Set $walks to possible child sequences for $ei &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $r0 := $ei('rule')
  let $w  := map { 'item': $ei, 
                   'state': 'q0',
                   'follow-states': 
                       tokenize($r0/@first),
                   'final': 
                       xs:boolean($r0/@nullable)
             }

  let $walks := epi:find-walks(
                  $ei       (: completion for parent :),
                  $leiClosure, 
                  $I, 
                  $w                        (: queue :),
                  if (xs:boolean($r0/@nullable)
                      and ($ei('from') eq $ei('to'))) 
                  then $w 
                  else ()             (: accumulator :),
                  map { 'tree-count': 2 } (: options :)
                )

   let $dummy := if (count($walks) gt 0)
                 then (eri:notrace(count($walks), 'Find-walks found # walks'
                       || ' for ' || eri:sXei($ei)),
                     for $w at $walknum in $walks 
                     return eri:notrace($w, 'Walk no. ' || $walknum || ' is:'))
                 else ()
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-make-pfg-rules">Define function epi:make-pfg-rules() 84</a> &#x3009; <br></span>
</div>

The &#x201c;<tt>follow-states</tt>&#x201d; and &#x201c;<tt>final</tt>&#x201d;
values are redundant; we store them in the map to avoid
calculating them repeatedly.
The last argument (a map of options) should be replaced
in due course with options supplied by the user.
</div>
<div class="Real-P"></div>
<div class="Real-P">The <i>epi:find-walks()</i> function will be defined <a href="#hi-pfgc-find-walks">below</a>.</div>

</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-pfgc-walks">&#x23f4;</a></span><span class="arrow"><a href="#hi-pfg">&#x23f6;</a></span><span class="arrow"><a href="#hi-pfgc-recur">&#x23f5;</a></span></div><h4><a class="selflink" name="hi-pfgc-makerule" id="hi-pfgc-makerule" href="#hi-pfgc-makerule">3.8.6. </a>Making a production rule for a given walk</h4>

<div class="Real-P">Given a completion item (<i>x</i> <i>y</i> <i>N</i> <i>q</i><sub><i>f</i></sub>) and a set of walks
through the rule for <i>N</i>, we now make a production rule for <i>N</i>&#xb7;<i>x</i>&#xb7;<i>y</i> with an
appropriate expression on the right-hand side.

<div class="scrap"><span><a name="epi-mpr-make-rule">&#x3008; 89 Set $rule to production rule for $ei &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $rule := element rule {
                   attribute name {
                       concat($r0/@name,
                           '&#xb7;',
                           $ei('from'),
                           '&#xb7;',
                           $ei('to') (: ,
                           '&#xb7;',
                           $ei('ri') :)
                       )
                   },
                   $r0/@mark,
                   if (empty($walks))
                   then element ap:error {
		     attribute id { "ap:tbd21" },
                     element p { 
                       "In make-pfg-rules," ||
                       "find-walks() failed." },
                     element p { "Here is what I know." },
                     element dump { 
                       element var {
                         attribute name { "ei" },
                         eri:eXei($ei)
                       },
                       element var {
                         attribute name { "ei?rule" },
                         $r0
                       },
                       element var {
                         attribute name { "closure" },
                         for $n in map:keys($leiClosure('to'))
  		         order by $n descending
  		         for $ei in $leiClosure('to')($n)
  		         return eri:eXei($ei)
                       }
                     }
                   } 
                   else for $w in $walks
                   return element alt { 
                       epi:rhs-from-walk($w, $I, ())
                   }
               }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-make-pfg-rules">Define function epi:make-pfg-rules() 84</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The <i>epi:rhs-from-walk()</i> function will be defined
<a href="#hi-pfgc-make-rhs">below</a>.</div>

</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-pfgc-makerule">&#x23f4;</a></span><span class="arrow"><a href="#hi-pfg">&#x23f6;</a></span><span class="arrow"><a href="#hi-pfgc-find-walks">&#x23f5;</a></span></div><h4><a class="selflink" name="hi-pfgc-recur" id="hi-pfgc-recur" href="#hi-pfgc-recur">3.8.7. </a>Preparing for the next iteration</h4>

<div class="Real-P">Given a queue, an accumulator, and a new production rule (or the
set of walks that produced it), identify which completion items need
to be added to the queue.  That would be: all the completion items in
the walks, unless they are already in the queue or already handled in
the accumulator.  First we extract them all, and dedup them, then
we filter them against the items already in the queue, and finally
against the items we already have rules for.
<div class="scrap"><span><a name="epi-mpr-update-queue">&#x3008; 90 Set $new-queue to include new completions &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $lei0 := for $w in $walks
               return epi:lei-from-walk($w, ()), 
               (: all completion items in $walks :)
	       
      $lei1 := $lei0[
                 not(some $i in 1 to (position() - 1)
                  satisfies deep-equal(., $lei0[$i]) 
                  (: satisfies .?sig eq $lei0[$i]?sig :)
		  (: satisfies ((.?from eq $lei0[$i]?from)
                    and      (.?to   eq $lei0[$i]?to  )
                    and deep-equal(
                              .?rule,   $lei0[$i]?rule)) :)
                 )
               ],
               (: list of distinct completion items :)

      $lei2 := $lei1[
                 not(some $i in 2 to (count($leiQueue))
                   satisfies deep-equal(., $leiQueue[$i]) 
                   (: satisfies .?sig eq $leiQueue[$i]?sig   :)
		   (: satisfies ((.?from eq $lei0[$i]?from)
                     and      (.?to   eq $lei0[$i]?to  )
                     and deep-equal(
                              .?rule,   $lei0[$i]?rule)) :)
                 )
               ]
               (: completion items not in the queue :)

  let $ls-defined := ($leRules, $rule)
                     /@name/string(),

      $lei3 := for $ei in $lei2
               let $s := $ei('rule')/@name/string()
                         || '&#xb7;'
                         || $ei('from')
                         || '&#xb7;'
                         || $ei('to') (:
                         || '&#xb7;'
                         || $ei('ri') :)
               where not($s = $ls-defined)
               return $ei
               (: new completion items, 
                  not in queue and not already done :)

  let $new-queue := (tail($leiQueue), $lei3)

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-make-pfg-rules">Define function epi:make-pfg-rules() 84</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Given a production rule <i>$rule</i> and and the updated
queue <i>$new-queue</i>, call
<i>make-pfg-rules()</i> recursively.
<div class="scrap"><span><a name="epi-mpr-recur">&#x3008; 91 Recursive call with new queue and accumulator &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  return epi:make-pfg-rules(
           $new-queue,
           $leiClosure,
           $I,
           ($leRules, $rule)
         )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-make-pfg-rules">Define function epi:make-pfg-rules() 84</a> &#x3009; <br></span>
</div>

</div>

</div>

<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-pfgc-recur">&#x23f4;</a></span><span class="arrow"><a href="#hi-pfg">&#x23f6;</a></span><span class="arrow"><a href="#hi-pfgc-make-rhs">&#x23f5;</a></span></div><h4><a class="selflink" name="hi-pfgc-find-walks" id="hi-pfgc-find-walks" href="#hi-pfgc-find-walks">3.8.8. </a>The <i>find-walks()</i> function</h4>
<div class="Real-P">This bit is, frankly, the part of parse-forest extraction
I have had the most trouble thinking through clearly.</div>
<div class="Real-P">We are given:
<ul><li>an Earley item, which should be a completion (i.e.
<i>ri</i> &#x2208; <i>F</i> for the FSA)</li>
<li>an Earley closure</li>
<li>an input string</li>
<li>a queue of walks which begin at the
start state and are attested by appropriate completion
items, which may or may not be satisfactory</li>
<li>an accumulator of acceptable walks</li>
<li>a map of options, in particular the &#x201c;<tt>tree-count</tt>&#x201d;
option</li>
</ul>
From these we are to generate a set of walks, represent as step
lists.  The accumulator is needed because we extend everything in
the queue if we can, and that may cause a satisfactory walk to be
lost.
<i>To do: check for loops.</i>
<div class="scrap"><span><a name="epi-find-walks">&#x3008; 92 The find-walks() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:find-walks(
  $eiParent as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#adt-ei">Type: Earley item 123</a></em> &#x3009;</span>,
  $mei as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#adt-eiclosure">Type:  Earley closure 125</a></em> &#x3009;</span>,
  $I as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#adt-input">Type: input string 126</a></em> &#x3009;</span>,
  $queue as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#pfg-adt-walks">Type: collection of walks 87</a></em> &#x3009;</span>,
  $acc as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#pfg-adt-walks">Type: collection of walks 87</a></em> &#x3009;</span>,
  $options as map(*)
) as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#pfg-adt-walks">Type: collection of walks 87</a></em> &#x3009;</span> {
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#pfg-fw-if-done">If we have all our walks, return 93</a></em> &#x3009;</span>
  else 

let $dummy := eri:notrace((),
concat('find-walks:  called for parent ',
       eri:sXei($eiParent),
       ' with ',
       count($acc),
       ' in accumulator and ',
       count($queue),
       ' in the queue. ... ... ... ... '
       ))

  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#pfg-fw-set-new-queue">Set new queue by extending all walks in the queue 94</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#pfg-fw-set-new-acc">Add satisfactory walks to the accumulator 97</a></em> &#x3009;</span>
  return epi:find-walks(
      $eiParent, 
      $mei,
      $I,
      $new-queue,
      $new-acc,
      $options
  )
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-parse-forest-grammar">Define parse-forest-grammar() 81</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">We stop when we have as many walks as are specified in the
&#x201c;<tt>tree-count</tt>&#x201d; option, or when the queue is empty.[<a name="ref-to-d3e3450" href="#d3e3450" title="&#xA;If this is the only source of ambiguity in the parse, returning&#xA;n walks will give us n trees.  If there are multiple sources of&#xA;ambiguity, the parse-forest gra">17</a>]
<div class="scrap"><span><a name="pfg-fw-if-done">&#x3008; 93 If we have all our walks, return &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  if (($options('tree-count') ne -1)
      and 
      (count($acc) ge $options('tree-count')))
  then (eri:notrace((), 'find-walks:  returning ' || count($acc) || ' walks, maxed.'), $acc)
  else if (empty($queue))
  then (eri:notrace((), 'find-walks:  returning ' || count($acc) || ' walks, queue 0.'), $acc)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-find-walks">The find-walks() function 92</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">Otherwise, we attempt to extend each walk in the queue.  To
reduce the number of times we have to do a search in the Earley
closure, we group the walks by their current position (here
<i>x</i>),[<a name="ref-to-d3e3470" href="#d3e3470" title="Note that the current position is the&#xA;from value for the starter step (a completion for&#xA;the parent) but the to value for any other&#xA;step.">18</a>] their follow state (here <i>qNext</i>), and
the nonterminal (or terminal) we are seeking to match (here <i>N</i> and
<i>T</i>[<a name="ref-to-d3e3485" href="#d3e3485" title="Note that N and T are uniquely&#xA;determined by qNext and thus redundant, but including&#xA;them as grouping keys allows them to be referred to without&#xA;subscripts.">19</a>]
<div class="scrap"><span><a name="pfg-fw-set-new-queue">&#x3008; 94 Set new queue by extending all walks in the queue &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $new-queue := 
      for $w at $queue-num in $queue
      let $x := if ($w?state eq 'q0')
                then $w('item')('from')
                else $w('item')('to'),
          $qqNext := $w('follow-states')

let $dummy := eri:notrace(eri:sXei($w('item')),
'find-walks:  walk ' || $queue-num || ' in queue starts with: ') 

      for $qNext in $qqNext
      let $symbol := $eiParent('rule')//*[@xml:id=$qNext],
          $N := $symbol/self::nonterminal/@name/string(),
          $T := $symbol[eri:fTerminal(.)]/@xml:id/string(),
	  $symbol-mark := $symbol/(@mark, @tmark)/string()

      let $dummy := if (exists($T)) then eri:notrace($T,
          'find-walks: seeking completion items for this terminal:')
          else if (exists($N)) then eri:notrace($N, 
          'find-walks:  seeking completion items for this nonterminal:')
          else eri:notrace($symbol,
          'find-walks:  symbol broke my classification:')

      group by $x, $qNext, $N, $T
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e3508">Find follow-on completion items 95</a>&#x3009;, &#x3008;<a href="#d3e3511">Extend the walk 96</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-find-walks">The find-walks() function 92</a> &#x3009; <br></span>
</div>

We can now do a single search that will work for every
walk that is expecting a given symbol at a given location.
We look for items in the closure which:
<ul><li>start at <i>x</i>,</li>
<li>relate to the given terminal or nonterminal,</li>
<li>are final, and</li>
<li>advance no further than the endpoint of the
parent completion item.</li>
</ul>
And then we de-dup them:  if any items differ only in
their rule index, we take only one of them.
<div class="scrap"><span><a name="d3e3508">&#x3008; 95 Find follow-on completion items [continues <a href="#pfg-fw-set-new-queue">94 Set new queue by extending all walks in the queue</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      let $items0 := $mei('from')($x)
                     [(.?rule/@name eq $N)
                      or (.?rule/@xml:id eq $T)]
                     [eri:fFinalEi(.) 
                      or (.?ri eq '#terminal')
                      or starts-with(.?ri, '#ins_')]
                     [.?to le $eiParent('to')],
$dummy := for $i in $items0 return eri:notrace($i,
'find-walks:  found follow-on completions.'),
          $items  := for $i at $index in $items0
                     where not(
                       some $j in 1 to ($index - 1) 
                       satisfies (
                         $items0[$j]?from eq $i?from
                         and 
                         $items0[$j]?to eq $i?to
                         and deep-equal(
                           $items0[$j]?rule, $i?rule
                         )
                       )
                     )
                     return $i

, $dummy := for $i in $items return eri:notrace($i,
'find-walks:  deduped list of follow-on completions.')


</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

For each such item, we extend the walk we started with:
<div class="scrap"><span><a name="d3e3511">&#x3008; 96 Extend the walk [continues <a href="#pfg-fw-set-new-queue">94 Set new queue by extending all walks in the queue</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      for $i in $items
      for $walk-index in 1 to count($w)
      let $fNull := ($i('to') eq $i('from')),
          $leiDups := if ($fNull)
                      then epi:dups-from-walk(
                               $qNext, $i, $w[$walk-index], ()
                           )
                      else ()

      let $qqNextfollow := tokenize(
                               $eiParent('rule')
                               /attribute::follow:*
                               [local-name() eq $qNext]
                           ),
          $f-qnext-final := ($qNext = 
                           eri:lriFinalstatesXR(
                               $eiParent('rule')
                           ))

      return if ($fNull and count($leiDups) gt 1)
      then ()
      else map {
                 'item' : $i,
                 'state' : $qNext,
                 'follow-states' : $qqNextfollow,
                 'final' : $f-qnext-final,
                 'mark'  : $symbol-mark,
                 'pred'  : $w[$walk-index]
             }

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>
</div>
<div class="Real-P">Some of the extensions we just made may be satisfactory walks;
if so, we add them to the accumulator:
<div class="scrap"><span><a name="pfg-fw-set-new-acc">&#x3008; 97 Add satisfactory walks to the accumulator &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $new-acc := ($acc, $new-queue
                         [ .?final ]
                         [ .?item?to eq $eiParent?to ])

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-find-walks">The find-walks() function 92</a> &#x3009; <br></span>
</div>

</div>
</div>

<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-pfgc-find-walks">&#x23f4;</a></span><span class="arrow"><a href="#hi-pfg">&#x23f6;</a></span><span class="arrow"><a href="#hi-pfgc-make-lei">&#x23f5;</a></span></div><h4><a class="selflink" name="hi-pfgc-make-rhs" id="hi-pfgc-make-rhs" href="#hi-pfgc-make-rhs">3.8.9. </a>The <i>rhs-from-walk()</i> function</h4>
<div class="Real-P">We are given a walk <i>w</i> represented as a map describing one
step and pointing to its predecessor; we are to return an ixml
right-hand side for the sequence.</div>
<div class="Real-P">We do this by walking through the list step by step, pushing the
appropriate symbol onto the front of the accumulator.
<div class="scrap"><span><a name="epi-rhs-from-walk">&#x3008; 98 The rhs-from-walk() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:rhs-from-walk(
  $w as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#pfg-adt-walk">Type: walk in a RHS 86</a></em> &#x3009;</span>?,
  $I as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#adt-input">Type: input string 126</a></em> &#x3009;</span>,
  $acc as element()*
) as element()* {

  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-rfw-stop">If we're done, return 99</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-rfw-terminal">If this step is a terminal, return a literal 100</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-rfw-insertion">If this step is an insertion, return an insertion 101</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-rfw-nonterminal">If this step is a nonterminal, return a nonterminal 102</a></em> &#x3009;</span>
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-parse-forest-grammar">Define parse-forest-grammar() 81</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">The termination condition is evident: if we are out of steps,
then we are done.  We are out of steps when we are looking at state
<i>q</i><sub>0</sub> (and of course if somehow we have run off the edge).
<div class="scrap"><span><a name="epi-rfw-stop">&#x3008; 99 If we're done, return &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  if (empty($w) or ($w('state') eq 'q0')) 
  then $acc
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-rhs-from-walk">The rhs-from-walk() function 98</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">If the walk includes a completion item for a terminal,
of the form (<i>x</i> <i>y</i> _t_<i>n</i> '#terminal'), then we
construct a &lt;<em>literal</em>&gt; element and recur.
<div class="scrap"><span><a name="epi-rfw-terminal">&#x3008; 100 If this step is a terminal, return a literal &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  if ($w('item')('ri') eq '#terminal')
  then let $ei := $w('item')
       let $x := $ei('from'),
           $y := $ei('to'),
           $symbol := element literal {
               attribute tmark { $w('mark') },
               attribute string {
                   substring($I, $x+1, ($y - $x))              
               }
           },

           $new-acc := ($symbol, $acc),
	   $next-step := $w('pred')
       return epi:rhs-from-walk($next-step, $I, $new-acc)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-rhs-from-walk">The rhs-from-walk() function 98</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">If the walk includes a completion item for an insertion,
of the form (<i>x</i> <i>x</i> _ins_<i>n</i> '#ins_' || <i>s</i>), then we
construct an &lt;<em>insertion</em>&gt; element and recur.
<div class="scrap"><span><a name="epi-rfw-insertion">&#x3008; 101 If this step is an insertion, return an insertion &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  if (starts-with($w('item')('ri'), '#ins_'))
  then let $ei := $w('item')
       let $x := $ei('from'),
           $y := $ei('to'),
           $symbol := element insertion {
               let $s0 := substring-after(
                            $w('item')('ri'),
                            '#ins_'
                          ),
                   $ls0 := tokenize($s0, '\.'),
                   $codepoints := for $n in $ls0 
                                  return xs:integer($n),
                   $s := codepoints-to-string($codepoints)
               return
                   if ((count($codepoints) eq 1)
                      and
                      $codepoints lt 32)
                   then (: we have a c0 control character :)
                      attribute hex { d2x:d2x($codepoints) }
                   else attribute string { $s }
           },

           $new-acc := ($symbol, $acc),
	   $next-step := $w('pred')
       return epi:rhs-from-walk($next-step, $I, $new-acc)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-rhs-from-walk">The rhs-from-walk() function 98</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Otherwise, we extract the nonterminal symbol from
the rule in the item, append start and end positions,
construct an ixml &lt;<em>nonterminal</em>&gt; element for the
newly constructed nonterminal name, and recur.
<div class="scrap"><span><a name="epi-rfw-nonterminal">&#x3008; 102 If this step is a nonterminal, return a nonterminal &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  if (exists($w('item')('rule')/self::rule[@name]))
  then let $ei := $w('item'),

           $symbol := element nonterminal {
               attribute name {
                   $ei('rule')/@name/string()
                   || '&#xb7;'
                   || $ei('from')
                   || '&#xb7;'
                   || $ei('to') (:
                   || '&#xb7;'
                   || $ei('ri') :)
               },
               if (exists($w('mark')))
               then attribute mark { $w('mark') }
               else ()
           },
           $new-acc := ($symbol, $acc),
           $next-step := $w('pred')
       return epi:rhs-from-walk($next-step, $I, $new-acc)
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e3602">Otherwise, something has gone very wrong 103</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-rhs-from-walk">The rhs-from-walk() function 98</a> &#x3009; <br></span>
</div>

And as a catch-all, if we have a step but cannot
treat it as a terminal or as a nonterminal,
then we return an error.
<div class="scrap"><span><a name="d3e3602">&#x3008; 103 Otherwise, something has gone very wrong [continues <a href="#epi-rfw-nonterminal">102 If this step is a nonterminal, return a nonterminal</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  else 
let $dummy := eri:trace($w('item'), 'rhs-from-walk:  item fell through!') return
       element ap:error {
           attribute id { "ap:tbd25" },
           element p { 'Unexpected disaster 83' },
           $acc,
           $w?state
       }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

<i>BaseX will serialize $w, but Saxon will not,
so we trace just $w?state, not $w.  This should be
cleaner, probably; I'm beginning to hack at things
in order to get the program to run under Saxon.</i>
</div>
</div>

<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-pfgc-make-rhs">&#x23f4;</a></span><span class="arrow"><a href="#hi-pfg">&#x23f6;</a></span><span class="arrow"><a href="#hi-pfgc-find-dups">&#x23f5;</a></span></div><h4><a class="selflink" name="hi-pfgc-make-lei" id="hi-pfgc-make-lei" href="#hi-pfgc-make-lei">3.8.10. </a>The <i>lei-from-walk()</i> function</h4>
<div class="Real-P">We are given a walk <i>w</i> represented as a map describing one
step and pointing to its predecessor; we are to return a sequence
of the Earley items (they will all be completions) in that
sequence, leaving out the one at the very end that represents
the parent node.[<a name="ref-to-d3e3621" href="#d3e3621" title="&#xA;Might it be faster to do this at the same time we&#xA;generate the right-hand side from the walk?">20</a>]</div>

<div class="Real-P">We do this by walking through the list step by step, pushing each
item onto the front of the accumulator.  Unless it's a terminal
or an insertion, in which case we skip it.
<div class="scrap"><span><a name="epi-lei-from-walk">&#x3008; 104 The lei-from-walk() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:lei-from-walk(
  $w as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#pfg-adt-walk">Type: walk in a RHS 86</a></em> &#x3009;</span>?,
  $acc as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#adt-list-ei">Type: list of Earley items 124</a></em> &#x3009;</span>
) as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#adt-list-ei">Type: list of Earley items 124</a></em> &#x3009;</span> {
  if (empty($w)) 
  then $acc
  else if ($w('state') eq 'q0')
  then $acc
  else if ($w('item')('ri') eq '#terminal')
  then epi:lei-from-walk($w('pred'), $acc)
  else if (starts-with($w('item')('ri'), '#ins_'))
  then epi:lei-from-walk($w('pred'), $acc)
  else epi:lei-from-walk($w('pred'),
                         ($w('item'), $acc))
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-parse-forest-grammar">Define parse-forest-grammar() 81</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P"><i>To do:  move de-duping into lei-from-walk()?
Every item we can avoid adding to the accumulator
is an item we don't need to carry around.</i></div>
</div>

<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-pfgc-make-lei">&#x23f4;</a></span><span class="arrow"><a href="#hi-pfg">&#x23f6;</a></span><span class="arrow">&nbsp;</span></div><h4><a class="selflink" name="hi-pfgc-find-dups" id="hi-pfgc-find-dups" href="#hi-pfgc-find-dups">3.8.11. </a>The <i>dups-from-walk()</i> function</h4>
<div class="Real-P">We are given a state <i>q</i>, an item <i>ei</i>, and a walk <i>w</i>;
we are to return the steps in <i>w</i> that have the same
state and item.  If there is more than one (or some
threshold), the caller will detect a loop in the walk
and cut the walk off to avoid going round the loop
indefinitely.</div>

<div class="Real-P">We do this by walking through the list step by step, pushing the
duplicate steps onto the front of the accumulator.

<div class="scrap"><span><a name="epi-find-dups-in-walk">&#x3008; 105 The dups-from-walk() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:dups-from-walk(
  $q as xs:string,
  $ei as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#adt-ei">Type: Earley item 123</a></em> &#x3009;</span>,
  $w as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#pfg-adt-walk">Type: walk in a RHS 86</a></em> &#x3009;</span>?,
  $acc as item()*
) as <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#pfg-adt-walks">Type: collection of walks 87</a></em> &#x3009;</span> {
  if (empty($w)) 
  then $acc
  else if ($w('state') eq 'q0')
  then $acc
  else if ( 
            (: $ei?sig eq $w?item?sig :)
            deep-equal($ei, $w('item')) 
            and 
            $q eq $w('state')
          )
  then epi:dups-from-walk($q, $ei, $w('pred'), ($w, $acc))
  else epi:dups-from-walk($q, $ei, $w('pred'), $acc)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-parse-forest-grammar">Define parse-forest-grammar() 81</a> &#x3009; <br></span>
</div>

</div>
</div>

</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-pfg">&#x23f4;</a></span><span class="arrow"><a href="#highlevel">&#x23f6;</a></span><span class="arrow"><a href="#hi-ast-ex-rpt">&#x23f5;</a></span></div><h3><a class="selflink" name="hi-rpt-ex-pfg" id="hi-rpt-ex-pfg" href="#hi-rpt-ex-pfg">3.9. </a>Extracting a parse tree from the parse-forest grammar</h3>

<div class="Real-P">If the user asks for a parse-forest grammar instead of a parse
tree, we can just return the grammar.  But if the user asks for a
tree, or a forest, we need to turn the grammar into a parse tree.
Since the current code for direct construction of the tree behaves
very badly in some cases, constructing the grammar and then from it
the tree is likely to be faster.  At least, I hope so.</div>
<div class="Real-P">So we want a function to extract a tree.  For now, we extract
just one tree, selected at random. <i>To do: construct <i>n</i>
trees; construct tree-cursor.</i></div>
<div class="Real-P">The initial call to <i>epi:tree-from-pfg()</i> function
supplies a parse-forest grammar and returns a parse tree.  Recursive
calls will supply elements from the parse-forest grammar and
use a <i>nodetype</i> parameter to specify what they
are interested in getting back; the nodetype value may be any of
&#x201c;<tt>document</tt>&#x201d; (expected only on the initial call), 
&#x201c;<tt>element</tt>&#x201d;, 
&#x201c;<tt>attribute</tt>&#x201d;, 
&#x201c;<tt>value</tt>&#x201d;, or
&#x201c;<tt>content</tt>&#x201d;.
<div class="scrap"><span><a name="epi-tree-from-pfg">&#x3008; 106 The epi:tree-from-pfg() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:tree-from-pfg(
  $pfg as element() 
      (: ixml, rule, alt, nonterminal, literal :),
  $nodetype as xs:string,
  $mark as xs:string?
) as node()* {
  if ($pfg/self::ixml)
  then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tfg-ixml">Extract tree from ixml parse-forest grammar 107</a></em> &#x3009;</span>
  else if ($pfg/self::rule)
  then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tfg-rule">Extract subtree from rule element 109</a></em> &#x3009;</span>
  else if ($pfg/self::alt)
  then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tfg-alt">Extract sequence of nodes from alt element 119</a></em> &#x3009;</span>
  else if ($pfg/self::nonterminal)
  then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tfg-nonterminal">Extract subtree from nonterminal element 120</a></em> &#x3009;</span>
  else if ($pfg/self::literal)
  then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tfg-literal">Extract character data from literal element 121</a></em> &#x3009;</span>
  else if ($pfg/self::insertion)
  then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tfg-insertion">Extract character data from insertion element 122</a></em> &#x3009;</span>
  else element eek {
      element desc {
          "tree-from-pfg got "
          || "an unexpected argument."
      },
      eri:trace($pfg, 'Unexpected argument!')
  }
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e434">[File Earley-parser-internals.xqm] 8</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">We start with the parse-forest grammar itself, an &lt;<em>ixml</em>&gt;
element.  We check to see whether the grammar is ambiguous or not by
looking for rules with multiple right-hand sides.  Then we start
serialization.  To avoid producing a &lt;<em>Goal</em>&gt; element for the
start-symbol introduced by the Earley recognizer, we start work with
the nonterminal on the right-hand side of the first rule.[<a name="ref-to-d3e3731" href="#d3e3731" title=" Actually, Goal should carry&#xA;mark=&#34;-&#34; in any case.">21</a>] If the
parse-forest grammar describes more than one tree, we should mark
the tree we return with <tt>ixml:state="ambiguous"</tt>.
<div class="scrap"><span><a name="epi-tfg-ixml">&#x3008; 107 Extract tree from ixml parse-forest grammar &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      let $f-ambig := exists($pfg//rule[count(alt) gt 1]),
          $tree0 := epi:tree-from-pfg(
                        $pfg/rule[1]/alt/nonterminal,
                        'element',
                        ()
                    ),
          $tree1 := if (exists($tree0
                       /descendant-or-self::ap:error))
                    then element ap:error {
                           attribute ixml:state { "failed" },
                           attribute id { "ap:tbd31" },
                           attribute code { "ixml:D01" },
                           attribute ap:desc { "Dynamic error: ill-formed output" },
                           $tree0
                         }
                    else $tree0
      return if (not($f-ambig))
             then $tree1
             else element { name($tree1) } {
                     attribute ixml:state { 
                        "ambiguous" ,
                        $tree1/@ixml:state
                     },
                     ($tree1/attribute::* 
                       except $tree1/@ixml:state),
                     $tree1/child::node()
                  }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-tree-from-pfg">The epi:tree-from-pfg() function 106</a> &#x3009; <br></span>
</div>
</div>

<div class="Real-P">Another version of this code uses XQuery Update to inject the
attribute.  I took this out because Saxon PE and HE don't seem to
support the update facility.
<div class="scrap"><span><a name="d3e3749">&#x3008; 108 Extract tree from ixml parse-forest grammar &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      let $f-ambig := exists($pfg//rule[count(alt) gt 1]),
          $tree0 := epi:tree-from-pfg(
                        $pfg/rule[1]/alt/nonterminal,
                        'element',
                        ()
                    ),
          $tree1 := copy $x-tree := $tree0
                   modify insert node 
                       attribute ixml:state { "ambiguous" }
                       into $x-tree
                   return $x-tree
      return if ($f-ambig) then $tree1 else $tree0
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>

</div>
<div class="Real-P">
<i>To do: check to make sure there are no top-exposed attributes or
text nodes.</i>
The code just given does not test on <i>$nodetype</i>:
since an &lt;<em>ixml</em>&gt; element should never be consulted
when constructing an attribute, we assume &#x201c;<tt>document</tt>&#x201d;.
<i>To do:  check anyway, just in case?</i>
</div>

<div class="Real-P">For a rule with multiple right-hand sides, the &lt;<em>alt</em>&gt;
element to use is chosen at random.  If the current nodetype is
&#x201c;<tt>element</tt>&#x201d;, multiple passes over the content will be
needed, and they should all use the same right-hand side.  So
element and attribute construction is handled here, not on
nonterminal references.
<div class="scrap"><span><a name="epi-tfg-rule">&#x3008; 109 Extract subtree from rule element &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      if ($pfg/ap:error)
      then $pfg
      else
      let $mark := ($mark, 
                    $pfg/@mark/string(),
                    '^')[1]
      let $n := count($pfg/alt),     
          $ran := <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tfg-random">Select random integer in 0..$n 110</a></em> &#x3009;</span>,
          $i := 1 + $ran,
          $ccc := $pfg/alt[$i]/*,
          $ls0 := tokenize($pfg/@name, '&#xb7;'),
          $nm0 := $ls0[1],
          $fr  := $ls0[2],
          $to  := $ls0[3],
          $nm  := if ($nm0 castable as xs:Name)
                  then $nm0
                  else xs:QName('ap:error')
      return <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tfg-rule-elem">Serialize rule as element 111</a></em> &#x3009;</span>
          else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tfg-rule-attr">Serialize rule as attribute 114</a></em> &#x3009;</span>
          else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tfg-rule-content">Serialize rule as content 115</a></em> &#x3009;</span>
          else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tfg-rule-av">Serialize rule as attribute value 116</a></em> &#x3009;</span>
          else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tfg-rule-zero">Serialize nothing, stop recursion 117</a></em> &#x3009;</span>
          else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tfg-rule-wha">Return an error element 118</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-tree-from-pfg">The epi:tree-from-pfg() function 106</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The generation of a random number is vendor-specific, so
we factor it out into a separate bit of code.
<div class="scrap"><span><a name="epi-tfg-random">&#x3008; 110 Select random integer in 0..$n &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: What random number function is available? :)
let $f1 := function-lookup(
              QName('http://basex.org/modules/random', 
                    'integer'), 
              1),
    $f2 := function-lookup(
              QName('http://exslt.org/random', 
                    'random-sequence'), 
           2),
    $f3 := function-lookup(
              QName('http://exslt.org/math', 
                    'random'), 
           0)

return 

(: basex random:integer() :)
if (exists($f1)) 
then $f1($n)

(: exslt-random:random-sequence() returns fraction 
   in 0..1; multiply by $n and take the floor to
   get the number we need :)
else if (exists($f2)) 
then let $frac := $f2(1,seconds-from-dateTime(current-dateTime()))
     return if ($frac eq 1) 
            then 0 
            else floor($frac * $n)

(: exslt-math:random(); use same procedure :)
else if (exists($f3)) 
then let $frac := $f3()
     return if ($frac eq 1) 
            then 0 
            else floor($frac * $n)

else error(QName(
"http://blackmesatech.com/2019/iXML/Aparecium",
"tbd17"), 'No random number generator found!')
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-tfg-rule">Extract subtree from rule element 109</a> &#x3009; <br></span>
</div>

<i>To do: move this into a library of vendor-sensitive
functions.</i>
This code prefers EXSLT's <i>random-sequence()</i>
function to their <i>random()</i> function,
because Saxonica's documentation says explicitly that
their optimization sometimes ensures that <i>random()</i>
always returns the same number. That would be disastrous
here, if the number chosen were one that led to a loop.
</div>
<div class="Real-P">When the rule is marked &#x201c;<tt>^</tt>&#x201d;
and <i>$nodetype</i> is &#x201c;<tt>element</tt>&#x201d;
or &#x201c;<tt>content</tt>&#x201d;, the rule is serialized
as an element.
<div class="scrap"><span><a name="epi-tfg-rule-elem">&#x3008; 111 Serialize rule as element &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if (($nodetype = ('element', 'content'))
                 and ($mark eq '^'))
          then element { $nm } {
                   if ($nm0 ne $nm)
                   then (attribute id { "ixml:D03"}, 
                         attribute ap:gi { $nm0 })
                   else (),
                   <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tfgre-get-atts">Collect and serialize attributes 113</a></em> &#x3009;</span>,
                   <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-tfgre-get-children">Create and serialize children 112</a></em> &#x3009;</span>
               }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-tfg-rule">Extract subtree from rule element 109</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Fetching the children is simple: we just recur on each
child and return the results.
<div class="scrap"><span><a name="epi-tfgre-get-children">&#x3008; 112 Create and serialize children &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">                   for $c in $ccc
                   return epi:tree-from-pfg(
                              $c, 
                              'content',
                              ()
                   )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-tfg-rule-elem">Serialize rule as element 111</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Fetching the attributes is a bit more complicated;
it requires checking to make sure we are not
being asked to serialize two attribute nodes with the same name.
<div class="scrap"><span><a name="epi-tfgre-get-atts">&#x3008; 113 Collect and serialize attributes &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">                   let $lnAtts := 
                      for $c in $ccc
                      return epi:tree-from-pfg(
                                 $c, 
                                 'attribute',
                                 ()
                      )
let $dummy := eri:notrace(count($lnAtts), 'Gathering attributes, found #: ')
let $dummy := eri:notrace($lnAtts, 'Gathering attributes, found these: ')
                   let $lnAok := 
                       $lnAtts
                       [every $i in 1 to (position() - 1)
                        satisfies
                        $lnAtts[$i]/name() ne ./name()]
let $dummy := eri:notrace(count($lnAok), 'Of these some are OK: ')
	           let $lnAdups := $lnAtts
                       [some $i in 1 to (position() - 1)
                        satisfies
                        $lnAtts[$i]/name() eq ./name()]
let $dummy := eri:notrace(count($lnAdups), 'Of these some are dups: ')
                   return ($lnAok,
		       for $n in $lnAdups
                       return element ap:error {
                          attribute id { "ap:tbd32" },
                          attribute code { "ixml:D02" },
                          $n,
                          "Dynamic error: Duplicate attribute name"
                       })
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-tfg-rule-elem">Serialize rule as element 111</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">When the rule is marked &#x201c;<tt>@</tt>&#x201d; and
<i>$nodetype</i> is &#x201c;<tt>attribute</tt>&#x201d;, the rule is
serialized as an attribute.
<div class="scrap"><span><a name="epi-tfg-rule-attr">&#x3008; 114 Serialize rule as attribute &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if (($nodetype = ('attribute'))
                 and ($mark eq '@'))
          then attribute { $nm } {
                   if ($nm0 ne $nm)
                   then text { concat('[', $nm0, ']=') }
                   else (),
		   (: hack :)
                   string-join(
                   for $c in $ccc
                   let $node := epi:tree-from-pfg(
                              $c, 
                              'value',
                              ()
                   )
                   return $node
                   , '')
               }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-tfg-rule">Extract subtree from rule element 109</a> &#x3009; <br></span>
</div>

<i>We should detect the case where $nm ne $nm0 and report it as
dynamic error D03.  But it's not clear how best to report that.  (Perhaps
checks on the PFG could detect this and other dynamic errors?)</i>
</div>

<div class="Real-P">When the rule is marked &#x201c;<tt>-</tt>&#x201d; and
<i>$nodetype</i> is &#x201c;<tt>content</tt>&#x201d;, the rule is
serialized without an enclosing element.
<div class="scrap"><span><a name="epi-tfg-rule-content">&#x3008; 115 Serialize rule as content &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if (($nodetype = ('content', 'element', 'attribute'))
                 and ($mark eq '-'))
          then for $c in $ccc
               return epi:tree-from-pfg(
                          $c, 
                          $nodetype,
                          ()
               )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-tfg-rule">Extract subtree from rule element 109</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">When <i>$nodetype</i> is &#x201c;<tt>value</tt>&#x201d;, the
marking on the rule is ignored and the content is serialized as part
of the attribute value.
<div class="scrap"><span><a name="epi-tfg-rule-av">&#x3008; 116 Serialize rule as attribute value &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if (($nodetype = ('value')))
          then for $c in $ccc
               return epi:tree-from-pfg(
                          $c,
                          'value',
                          ()
               ) 
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-tfg-rule">Extract subtree from rule element 109</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">When <i>$nodetype</i> and the mark are incompatible,
the rule is not serialized at all.
<div class="scrap"><span><a name="epi-tfg-rule-zero">&#x3008; 117 Serialize nothing, stop recursion &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if (($nodetype = ('content'))
                 and ($mark = ('@')))
          then ()
          else if (($nodetype = ('attribute'))
                 and ($mark = ('^')))
          then ()
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-tfg-rule">Extract subtree from rule element 109</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">
If we encounter a combination we have not specified,
then something is wrong.  Say so.
<div class="scrap"><span><a name="epi-tfg-rule-wha">&#x3008; 118 Return an error element &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if (($nodetype = ('element'))
                 and ($mark = ('@')))
          then element ap:error {
                 attribute id { "ap:tbd33" },
                 attribute code { "ixml:D05" },
                 attribute ap:desc {
                   "Attribute cannot be root.",
                   if ($nm ne $nm0)
                   then "&amp;#xA;Also, the attribute"
                        || " name is not a legal"
                        || " XML name."
                   else ()
                 },
                 attribute ap:attribute-name {
                   $nm0
                 },
                 attribute ap:attribute-value {
                   for $c in $ccc
                   return epi:tree-from-pfg(
                              $c,
                              'value',
                              ()
                   )
                 }
               }
          else element ap:error {
            attribute id { "ap:tbd20" },
            "Ran off a cliff, ",
            "I don't remember a thing. ",
            "Nodetype is '" || $nodetype || "'",
            "and mark is '" || $mark || "'."
          }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-tfg-rule">Extract subtree from rule element 109</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">An &lt;<em>alt</em>&gt; element is similarly transparent:  we
just process all the children.  (Actually, the function
should never be called with &lt;<em>alt</em>&gt;, since
rule handling skips straight to the children.)
<div class="scrap"><span><a name="epi-tfg-alt">&#x3008; 119 Extract sequence of nodes from alt element &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      for $c in $pfg/*
      return epi:tree-from-pfg($c, $nodetype, ())
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-tree-from-pfg">The epi:tree-from-pfg() function 106</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">When we encounter a nonterminal element, we just recur
on the relevant rule, passing along any mark we find.
<div class="scrap"><span><a name="epi-tfg-nonterminal">&#x3008; 120 Extract subtree from nonterminal element &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      let $nt := $pfg/@name/string(),
          $rule := $pfg/ancestor::ixml[1]
                   /rule[@name eq $nt]
      return epi:tree-from-pfg($rule, 
                   $nodetype, 
                   $pfg/@mark/string())
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-tree-from-pfg">The epi:tree-from-pfg() function 106</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">
Extracting a literal is simple:  it's always literally present
in the <em>string</em> attribute, or else in the <em>hex</em>
attribute.
<div class="scrap"><span><a name="epi-tfg-literal">&#x3008; 121 Extract character data from literal element &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">       let $s := if (exists($pfg/@string))
           then string($pfg/@string)
           else if (exists($pfg/@hex))
           then eri:charXhex($pfg/@hex)
           else '&amp;#x1D350;' (: tetragram for failure U+1D350 :)

       return if ($pfg/@tmark eq '-') 
              then ()
              else if ($nodetype = ('element', 'attribute'))
              then () (: is this an error? :)
              else text { $s }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-tree-from-pfg">The epi:tree-from-pfg() function 106</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">
Extracting an insertion is also simple:  it's always literally present
in the <em>string</em> attribute, or else in the <em>hex</em>
attribute.
<div class="scrap"><span><a name="epi-tfg-insertion">&#x3008; 122 Extract character data from insertion element &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">       let $s := if (exists($pfg/@string))
           then string($pfg/@string)
           else if (exists($pfg/@hex))
           then eri:charXhex($pfg/@hex)
           else '&amp;#x1D350;' (: tetragram for failure U+1D350 :)

       return if ($nodetype = ('attribute'))
              then () (: not an error :)
              else text { $s }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-tree-from-pfg">The epi:tree-from-pfg() function 106</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#hi-rpt-ex-pfg">&#x23f4;</a></span><span class="arrow"><a href="#highlevel">&#x23f6;</a></span><span class="arrow">&nbsp;</span></div><h3><a class="selflink" name="hi-ast-ex-rpt" id="hi-ast-ex-rpt" href="#hi-ast-ex-rpt">3.10. </a>Extracting an abstract syntax tree from a raw parse tree</h3>
<div class="Real-P">Watch this space.</div>
<div class="Real-P">We have this code; it's just someplace else</div>
</div>
</div>



<div class="div">

<div class="quicknav"><span class="arrow"><a href="#highlevel">&#x23f4;</a></span><span class="arrow"><a href="#toc">&#x23f6;</a></span><span class="arrow"><a href="#alt-calls">&#x23f5;</a></span></div><h2><a class="selflink" name="lowlevel" id="lowlevel" href="#lowlevel">4. </a>Low-level utility routines</h2><ul><li>4.1. <a href="#ll-types">Abstract types</a></li><li>4.2. <a href="#ll-items">Working with Earley items</a><ul><li>4.2.1. <a href="#ll-items-con">Earley items - constructors</a></li><li>4.2.2. <a href="#ll-items-extr">Earley items - extractors</a></li><li>4.2.3. <a href="#ll-items-predicates">Earley items - predicates</a></li><li>4.2.4. <a href="#ll-items-closure">Earley set closure</a></li></ul></li><li>4.3. <a href="#ll-grammars">Working with grammars</a></li><li>4.4. <a href="#ll-rules">Working with rules</a></li><li>4.5. <a href="#ll-symbols">Working with symbols</a><ul><li>4.5.1. <a href="#ll-sym-match-length">The <i>match-length()</i> function</a></li><li>4.5.2. <a href="#d3e4498">Making regular expressions from terminal symbols</a></li><li>4.5.3. <a href="#d3e4626">Testing for symbol type</a></li><li>4.5.4. <a href="#d3e4649">Matching symbols against rule indices</a></li></ul></li><li>4.6. <a href="#ll-input">Dealing with the input</a></li><li>4.7. <a href="#ll-utils">Utilities and miscellaneous</a><ul><li>4.7.1. <a href="#ll-utils-strings">Routines for strings and characters</a></li><li>4.7.2. <a href="#ll-utils-tracing">Trace routines</a></li></ul></li></ul>


<div class="div">

<div class="quicknav"><span class="arrow">&nbsp;</span><span class="arrow"><a href="#lowlevel">&#x23f6;</a></span><span class="arrow"><a href="#ll-items">&#x23f5;</a></span></div><h3><a class="selflink" name="ll-types" id="ll-types" href="#ll-types">4.1. </a>Abstract types</h3>
<div class="Real-P">XQuery does not allow for user-defined types, so we cannot
hide the details of our representations behind type names.
But for purposes of exposition, we can perhaps hide them behind
scrap names, to keep internal details out of the high-level
code at least within this document.</div>
<div class="Real-P"><i>N.B. At the moment none of the high-level scraps refer
to these scraps.  That's to be done.  I'm starting by defining
the scraps.</i></div>

<div class="Real-P">We sporadically use some type-related naming conventions, in
a sort of Hungarian notation, at least some of the time.
<ul><li><em>ei</em>: Earley item (aka ITEM, map(xs:string, item())</li>
<li><em>e</em>:  Earley item</li>
<li><em>f</em>:  Boolean (flag)</li>
<li><em>G</em>:  the grammar</li>
<li><em>I</em>:  the input</li>
<li><em>mei</em>:  map of Earley items (= map(xs:integer, map(xs:string, ITEM*))
       = map(xs:integer, map(xs:string, map(xs:string, item())*))</li>
<li><em>n</em>:  non-terminal symbol (may sometimes be nt)</li>
<li><em>p</em>:  position in input (to, from)</li>
<li><em>pt</em>:  raw parse tree (or subtree)</li>
<li><em>r</em>:  rule in grammar</li>
<li><em>ri</em>:  rule index (position in rule)  </li>
<li><em>s</em>:  string</li>
<li><em>sym</em>:  symbol from grammar</li>
<li><em>t</em>:  terminal symbol   </li>
</ul>
</div>
<div class="Real-P">Functions:
<ul><li><em>aXb</em>: return thing A from thing B</li>
</ul></div>

<div class="Real-P">An Earley item is represented as a map, with
keys &#x201c;<tt>from</tt>&#x201d;, &#x201c;<tt>to</tt>&#x201d;,
&#x201c;<tt>rule</tt>&#x201d;, and &#x201c;<tt>ri</tt>&#x201d;
(&#x2018;<span>rule index</span>&#x2019;, or state).  
<div class="scrap"><span><a name="adt-ei">&#x3008; 123 Type: Earley item &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">map(*)</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-find-walks">The find-walks() function 92</a> &#x3009; &#x3008; <a href="#epi-find-dups-in-walk">The dups-from-walk() function 105</a> &#x3009; <br></span>
</div>

A sequence of them is the obvious:
<div class="scrap"><span><a name="adt-list-ei">&#x3008; 124 Type: list of Earley items &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">map(*)*</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-parse-forest-grammar">Define parse-forest-grammar() 81</a> &#x3009; &#x3008; <a href="#epi-make-pfg-rules">Define function epi:make-pfg-rules() 84</a> &#x3009; &#x3008; <a href="#epi-lei-from-walk">The lei-from-walk() function 104</a> &#x3009; <br></span>
</div>

The first version of the code used elements, not maps;
maps are slightly faster.
</div>

<div class="Real-P">The Earley set we are constructing is itself a map, of maps.
At the moment the outer map has keys &#x201c;<tt>from</tt>&#x201d;
and &#x201c;<tt>to</tt>&#x201d;, which denote maps indexed by integer,
whose values are Earley items.  
<div class="scrap"><span><a name="adt-eiclosure">&#x3008; 125 Type:  Earley closure &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">map(xs:string,
    map(xs:integer,
        map(xs:string, item())*)) </pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-parse-forest-grammar">Define parse-forest-grammar() 81</a> &#x3009; &#x3008; <a href="#epi-make-pfg-rules">Define function epi:make-pfg-rules() 84</a> &#x3009; &#x3008; <a href="#epi-find-walks">The find-walks() function 92</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">The input we are parsing is just a string:
<div class="scrap"><span><a name="adt-input">&#x3008; 126 Type: input string &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">xs:string</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-parse-forest-grammar">Define parse-forest-grammar() 81</a> &#x3009; &#x3008; <a href="#epi-make-pfg-rules">Define function epi:make-pfg-rules() 84</a> &#x3009; &#x3008; <a href="#epi-find-walks">The find-walks() function 92</a> &#x3009; &#x3008; <a href="#epi-rhs-from-walk">The rhs-from-walk() function 98</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#ll-types">&#x23f4;</a></span><span class="arrow"><a href="#lowlevel">&#x23f6;</a></span><span class="arrow"><a href="#ll-grammars">&#x23f5;</a></span></div><h3><a class="selflink" name="ll-items" id="ll-items" href="#ll-items">4.2. </a>Working with Earley items</h3><ul><li>4.2.1. <a href="#ll-items-con">Earley items - constructors</a></li><li>4.2.2. <a href="#ll-items-extr">Earley items - extractors</a></li><li>4.2.3. <a href="#ll-items-predicates">Earley items - predicates</a></li><li>4.2.4. <a href="#ll-items-closure">Earley set closure</a></li></ul>

<div class="div">

<div class="quicknav"><span class="arrow">&nbsp;</span><span class="arrow"><a href="#ll-items">&#x23f6;</a></span><span class="arrow"><a href="#ll-items-extr">&#x23f5;</a></span></div><h4><a class="selflink" name="ll-items-con" id="ll-items-con" href="#ll-items-con">4.2.1. </a>Earley items - constructors</h4>
<div class="Real-P">
<div class="scrap"><span><a name="eri-items">&#x3008; 127 Earley items (constructors, extractors, etc.) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ****************************************************** 
   * Earley items
   ****************************************************** :)
(: We represent an Earley item as a map with keys 'from', 
   'to', 'rule', and 'ri' (rule index).  For any item $ei, 
   $ei('from') and $ei('to') are integers, $ei('rule') is 
   element() (either a rule or a terminal symbol), and 
   $ei('ri') is a string (an NCName, in fact, but typed 
   only as a string).
:)

(: ******************************************************
   * Earley items:  constructors
  :)

<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-make-p-p-r-ri">Define eiMakePPRRi() 128</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-lei-advance-ei-sym-p">Define leiAdvanceEiSymP() 130</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e4127">Extractors for Earley items 131</a>&#x3009;, &#x3008;<a href="#d3e4133">Extractors for Earley items 132</a>&#x3009;, &#x3008;<a href="#d3e4180">Predicates for Earley items 133</a>&#x3009;, &#x3008;<a href="#d3e4185">Define fExpectsN-Ei() 134</a>&#x3009;, &#x3008;<a href="#d3e4203">Define fScanrelEE() 135</a>&#x3009;, &#x3008;<a href="#d3e4210">Define fAdvanceNrelEE() 136</a>&#x3009;, &#x3008;<a href="#eri-items-closure">Calculating the closure of an Earley set 137</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e503">[File Earley-rec-internals.xqm] 11</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">To construct an Earley function from known values, we call
<i>eiMakePPRRi</i>:
<div class="scrap"><span><a name="eri-make-p-p-r-ri">&#x3008; 128 Define eiMakePPRRi() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   ei Make P P R Ri: make an Earley item from two 
   positions, a rule, and a rule index
  :)
declare function ixi:eiMakePPRRi(
  $From as xs:integer,
  $To as xs:integer,
  $r as element(rule),
  $ri as xs:string
) as map(xs:string, item()) {  
  map {
    'from' : $From,
    'to' : $To,
    'rule' : $r,
    'ri' : $ri 
    (: ,
    'sig' : concat('(', $From, 
                   '.', $To,
                   '.', $r/@name,
                   '/', $ri
            )
    :)(: ,
    'final' : (($ri = tokenize($r/@last, '\s+')
                      [normalize-space()])
               or (($ri eq 'q0') 
                  and 
                  ($r/@nullable = ('true', '1')))),
    'extensible' : ('' ne normalize-space(
                       $r/attribute::follow:*
                       [local-name() eq $ri]
                   ))
     :)
  }
};
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e4104">Define eiMakePPT() 129</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#eri-items">Earley items (constructors, extractors, etc.) 127</a> &#x3009; <br></span>
</div>

We provide the &#x201c;<tt>sig</tt>&#x201d; field to provide a simple way of
comparing Earley items for equality, and the &#x201c;<tt>final</tt>&#x201d;
and &#x201c;<tt>extensible</tt>&#x201d; fields to speed up some frequent
operations.  <i>At the moment, neither &#x201c;<tt>final</tt>&#x201d; nor
&#x201c;<tt>extensible</tt>&#x201d; is actually used elsewhere.</i>
</div>
<div class="Real-P">In special cases, we also make items for terminal symbols:
<div class="scrap"><span><a name="d3e4104">&#x3008; 129 Define eiMakePPT() [continues <a href="#eri-make-p-p-r-ri">128 Define eiMakePPRRi()</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   ei Make P P T: make an Earley item from two 
   positions and a terminal.
  :)
declare function ixi:eiMakePPT(
  $From as xs:integer,
  $To as xs:integer,
  $t as element()
) as map(xs:string, item()) {  
  map {
    'from' : $From,
    'to' : $To,
    'rule' : $t,
    'ri' : if ($t/self::insertion[exists(@string)]) 
           then "#ins_" 
                || string-join(
                     string-to-codepoints($t/@string),
                     '.')
           else if ($t/self::insertion[exists(@hex)]) 
           then "#ins_" || string(d2x:x2d($t/@hex))
           else "#terminal" 
    (:,
    'sig' : concat('(', $From, 
                   '.', $To,
                   '.', $t,
                   '/', '#terminal'
            )
    :)(:
    'final' : true(),
    'extensible' : false()
    :)
  }
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">The function <i>leiAdvanceEiSymP()</i>
takes (as its name signals) an Earley item, a symbol,
and a position, and returns the list of Earley items
which are advances from that position on that symbol.
<div class="scrap"><span><a name="eri-lei-advance-ei-sym-p">&#x3008; 130 Define leiAdvanceEiSymP() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   ixi:lei Advance Ei Sym P($E, $sym, $p): return the 
   set of Earley items (lei) that arise if you advance 
   $E over $sym, or over any equivalent symbol, to reach 
   position $p.
:)
declare function ixi:leiAdvanceEiSymP(
  $E as map(xs:string, item()),
  $sym as element(),
  $pNew as xs:integer
) as map(xs:string, item())* {
  let $pFr := $E('from'),
      $pTo := $E('to')
  return if ($pNew lt xs:integer($pTo))
      then () (: $E cannot advance backwards :)
      else 
  let $r := $E('rule'),
      $ri0 := $E('ri'),
      $lriFollow := if ($ri0 eq 'q0')
                    then $r/@first
                    else $r/@follow:*[local-name() = $ri0],
      $lri := tokenize($lriFollow,'\s+')[normalize-space()]
  for $ri in $lri
  where ixi:fSymbolmatchRRiSym($r,$ri,$sym)
    (: and $pNew ge xs:integer($pTo) :)
  return ixi:eiMakePPRRi($pFr, $pNew, $r, $ri) 
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#eri-items">Earley items (constructors, extractors, etc.) 127</a> &#x3009; <br></span>
</div>

</div>
</div>

<div class="div">

<div class="quicknav"><span class="arrow"><a href="#ll-items-con">&#x23f4;</a></span><span class="arrow"><a href="#ll-items">&#x23f6;</a></span><span class="arrow"><a href="#ll-items-predicates">&#x23f5;</a></span></div><h4><a class="selflink" name="ll-items-extr" id="ll-items-extr" href="#ll-items-extr">4.2.2. </a>Earley items - extractors</h4>
<div class="Real-P">For the <em>to</em> and <em>from</em> pointers,
the rule, and the rule's nonterminal, the extractor
functions are very straightforward.
<div class="scrap"><span><a name="d3e4127">&#x3008; 131 Extractors for Earley items [continues <a href="#eri-items">127 Earley items (constructors, extractors, etc.)</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   * Earley items:  extractors
   :)

(: See also sXei() below under Utilities :)

(: ......................................................
   pTo X Ei($E): extract 'to' position from item
   :)
declare function ixi:pToXEi(
  $E as map(xs:string, item())
) as xs:integer {
  $E('to')
};

(: ......................................................
   pFrom X Ei($E): extract 'from' position from item
   :)
declare function ixi:pFromXEi(
  $E as map(xs:string, item())
) as xs:integer {
  $E('from')
};

(: ......................................................
   r X Ei($E): extract rule from item
   :)
declare function ixi:rXEi(
  $E as map(xs:string, item())
) as element() {
  $E('rule')
};

(: ......................................................
   nLhs X Ei($E): extract nonterminal on lhs of rule 
   from item
   :)
declare function ixi:nLhsXEi(
  $E as map(xs:string, item())
) as element(nonterminal) {
  element nonterminal {
    attribute name { $E('rule')/@name }
  }
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">To get the list of expected symbols, more work is needed.
<div class="scrap"><span><a name="d3e4133">&#x3008; 132 Extractors for Earley items [continues <a href="#eri-items">127 Earley items (constructors, extractors, etc.)</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody"> (: ......................................................
   lsymExpected X Ei($E): extract list of expected 
   symbols from item
   :)
declare function ixi:lsymExpectedXEi(
  $E as map(xs:string, item())
) as element()* {
  (: results will be element() or element(nonterminal). :)
  let $symCur := $E('ri'),
      $r := $E('rule'),
      $sFollowset := if ($symCur = 'q0') 
                     then $r/@first
                     else $r/@follow:*[local-name()=$symCur],
      $lsymFollow := tokenize($sFollowset,'\s+')[normalize-space(.)]
  for $sym in $lsymFollow
  let $e := $r//*[@xml:id = $sym]
  return $e
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">Q. would this be faster with the <tt>for</tt> loop replaced by
<tt>return $r/descendant::*[@xml:id =
tokenize($sFollowset,'\s+')]</tt> or <tt>return
$r/descendant::*[@xml:id = $lsymFollow]</tt>, maybe?
</div>
<div class="Real-P">A. Let's see.
<ul><li><b>Loop:</b>  1:13.6 user time (two runs, same time),
            1:09.8 / 1:10.8 real time (?)</li>
<li><b>XPath:</b>  <tt>$r/descendant::*
            [@xml:id = tokenize($sFollowset,'\s+')]</tt>:
            1:19.9, 1:21.8 user</li>
<li><b>XPath:</b>  <tt>$r/descendant::*
            [@xml:id = $lsymFollow]</tt>:
1:12.5, 1:12.4</li>
</ul>
So:  not, it would not be noticeably faster,
and might be slower.
</div>
</div>

<div class="div">

<div class="quicknav"><span class="arrow"><a href="#ll-items-extr">&#x23f4;</a></span><span class="arrow"><a href="#ll-items">&#x23f6;</a></span><span class="arrow"><a href="#ll-items-closure">&#x23f5;</a></span></div><h4><a class="selflink" name="ll-items-predicates" id="ll-items-predicates" href="#ll-items-predicates">4.2.3. </a>Earley items - predicates</h4>
<div class="Real-P">We use predicate functions to ask several questions
about Earley items:
<ul><li>Is it final?  Does it mark the completion of the rule?
Sometimes we specify the left-hand side of the rule,
sometimes also the position.</li>
<li>Does it expect any nonterminals?</li>
<li>Does the scan relation hold between two given Earley items?</li>
<li>Does the advance-over-symbol-S relation hold between two given
Earley items?</li>
</ul>
</div>
<div class="Real-P">There are several functions for asking whether an item is
a completion.
<div class="scrap"><span><a name="d3e4180">&#x3008; 133 Predicates for Earley items [continues <a href="#eri-items">127 Earley items (constructors, extractors, etc.)</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   * Earley items:  predicates
   :)
(: ......................................................
   fFinal Ei P P N($E, $pFr, $pTo, $N): is $E a
   completion item for symbol N, running between the 
   two positions? (Used just once, in recognizeX, to 
   check for completions of the start symbol that cover 
   the entire input string.)
   :)
declare function ixi:fFinalEiPPN(
  $E as map(xs:string, item()),
  $pFrom as xs:integer,
  $pTo as xs:integer,
  $sym as xs:string
) as xs:boolean {
  (xs:integer($E('from')) eq $pFrom)
  and (xs:integer($E('to')) eq $pTo)
  and ($E('rule')/@name eq $sym)
  and ($E('ri') = ixi:lriFinalstatesXR($E('rule')))
};

(: ......................................................
   ixi:fFinalEiPN($E, $pTo, $sym):  true iff $E is a 
   completion item ending at position $P for nonterminal 
   $N 
   :)
declare function ixi:fFinalEiPN(
  $E as map(xs:string, item()),
  $pTo as xs:integer,
  $n as element(nonterminal)
) as xs:boolean {
  let $f := xs:integer($E('to')) eq $pTo
            and $E('rule')/@name eq $n/@name
            and $E('ri') = ixi:lriFinalstatesXR($E('rule'))

  return $f
};

(: ......................................................
   fFinal Ei($E): is $E a completion item?  I.e. is its 
   rule index in a final location?
   :)
declare function ixi:fFinalEi(
  $E as map(xs:string, item())
) as xs:boolean {
  $E('ri') = ixi:lriFinalstatesXR($E('rule'))
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P"><div class="scrap"><span><a name="d3e4185">&#x3008; 134 Define fExpectsN-Ei() [continues <a href="#eri-items">127 Earley items (constructors, extractors, etc.)</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   fExpectsN - Ei($E):  does $E expect any nonterminals?
   :)
declare function ixi:fExpectsN-Ei(
  $E as map(xs:string, item())
) as xs:boolean {
  exists(ixi:lsymExpectedXEi($E)[ixi:fNonterminal(.)])
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">Abstractly, the scan relation scan(E1,E2) holds iff
<ul><li>E1 expects terminal T</li>
<li>and E1 wins</li>
<li>and E2 = advance(E1, T)</li>
</ul>
And E2 = advance(E1, T) iff
<ul><li>from(E1) = from(E2)</li>
<li>and rule(E1) = rule(E2)</li>
<li>and seen-so-far(E1) || T = seen-so-far(E2)</li>
<li>and E1 wins on T [redundant, why?]</li>
<li>else advance(E1, T) = empty set.</li>
</ul>
So:
<div class="scrap"><span><a name="d3e4203">&#x3008; 135 Define fScanrelEE() [continues <a href="#eri-items">127 Earley items (constructors, extractors, etc.)</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   fScanrel E E($E1, $E2):  does the scan relation hold 
   for E1, E2?
   (Used once, in Earley parser internals, to find 
   related items.)
   :)
   (: N.B. does not test that the symbol in question 
      is a terminal. Does it matter?
   :)   
declare function ixi:fScanrelEE(
  $E1 as map(xs:string, item()),
  $E2 as map(xs:string, item())
) as xs:boolean {
  let $fFrom := ($E1('from') eq $E2('from')),
        (: test 1 of advance() :)
      $lsymFollow := ixi:lsymExpectedXEi($E1), 
      $lSsymFollow := for $e in $lsymFollow return $e/@xml:id,
      $fStates1 := ($E2('ri') = $lSsymFollow),
        (: test 3, 4 of advance(), 1,2 of scan() :)
      $fRules := deep-equal($E1('rule'), $E2('rule')),
	(: test 2 of advance() :)
      $f := ($fFrom and $fStates1 and $fRules), 
      $trace := ($f,
                'fScanrelEE(' 
                || ixi:sXei($E1) || ',' 
                || ixi:sXei($E2) || ') ==&gt; '
                )
  return $f
      (: 
               .('from') = $Ecur('from')
               and .('to') = $pMedial
               and .('ri') = $lsPrevstates
               and deep-equal(./rule, $Ecur/rule)
      :)
};

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">
<div class="scrap"><span><a name="d3e4210">&#x3008; 136 Define fAdvanceNrelEE() [continues <a href="#eri-items">127 Earley items (constructors, extractors, etc.)</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   fAdvanceNrel E E ($E1, $E2):  does the 
   advance-over-symbol-N relation hold for E1, E2?
   (Used once, in Earley parser internals, to find 
   related items.)

   By definition (see paper) E2 = advance(E1, T) iff
      * from(E1) = from(E2)
      * and rule(E1) = rule(E2)
      * and seen-so-far(E1) || T = seen-so-far(E2)
      * and E1 wins on T
      * else advance(E1, T) = empty set.

   Note that for the "E1 wins" clause we rely on the 
   truth of all items in the closure.  E1 must be  
   winning, because otherwise an E2 that satisfies 
   the other tests would not be in the closure.
   :)
declare function ixi:fAdvanceNrelEE(
  $E1 as map(xs:string, item()),
  $E2 as map(xs:string, item())
) as xs:boolean {
  let $fFrom := ($E1('from') eq $E2('from')),
      $lsymFollow := ixi:lsymExpectedXEi($E1),
      $lSsymFollow := for $e in $lsymFollow 
                      return $e/@xml:id,
      $fStates1 := ($E2('ri') = $lSsymFollow),
      $fRules := deep-equal($E1('rule'), $E2('rule')),
      $f := ($fFrom and $fStates1 and $fRules),
      $trace := ($f,
                'fScanrelEE(' 
                || ixi:sXei($E1) || ',' 
                || ixi:sXei($E2) || ') ==&gt; '
                )
  return $f
      (: 
               .('from') = $Ecur('from')
               and .('to') = $eiCC('from')
               and .('ri') = $lsPrevstates 
               and deep-equal(./rule, $Ecur/rule)
      :)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
</div>

<div class="div">

<div class="quicknav"><span class="arrow"><a href="#ll-items-predicates">&#x23f4;</a></span><span class="arrow"><a href="#ll-items">&#x23f6;</a></span><span class="arrow">&nbsp;</span></div><h4><a class="selflink" name="ll-items-closure" id="ll-items-closure" href="#ll-items-closure">4.2.4. </a>Earley set closure</h4>
<div class="Real-P">The heart of the Earley algorithm is the calculating the
closure of the Earley set.
<div class="scrap"><span><a name="eri-items-closure">&#x3008; 137 Calculating the closure of an Earley set [continues <a href="#eri-items">127 Earley items (constructors, extractors, etc.)</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: *******************************************************
   * Earley items:  closure (the big kahuna)
   :)
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e4229">Define earley-closure($lei, $I, $G) 138</a>&#x3009;, &#x3008;<a href="#d3e4248">Define earley-closure($pending, $accumulator, $I, $G) 139</a>&#x3009;, &#x3008;<a href="#d3e4359">Define earley-closure($pending, $accumulator, $I, $G) 143</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">We will want an accumulator to hold the set, so the
user's call to <i>earley-closure</i> merely
initializes an accumulator and calls another function to
do the work.
<div class="scrap"><span><a name="d3e4229">&#x3008; 138 Define earley-closure($lei, $I, $G) [continues <a href="#eri-items-closure">137 Calculating the closure of an Earley set</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody"> (: ......................................................
   ixi:earley-closure($lei, $I, $G2): 
   Calculate closure of $lei over the relations scan(), 
   pred(), and comp().
:)
declare function ixi:earley-closure(
  $leiPending as map(xs:string, item())* (: ITEM* :), 
  $I as xs:string,
  $G as element(ixml)
) as map(xs:string,
         map(xs:integer,
             map(xs:string,
                 item())*)) (:MEI:) {
  let $meiAcc := map { 
                   'from' : map:merge(
                     for $ei in $leiPending
		     return map:entry($ei('from'), $ei),
                     $ixi:combinedups
                   ),
                   'to' : map:merge(
                     for $ei in $leiPending
		     return map:entry($ei('to'), $ei),
                     $ixi:combinedups
		   ) }
		       
  return ixi:earley-closure($leiPending, $meiAcc, $I, $G)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">The larger function is this one.</div>
<div class="Real-P">We calculate the closure of the set of Earley items in $accumulator
over the relations scan(), pred(), and comp().
</div>
<div class="Real-P">Every item in $pending is also in $accumulator.  The items in
$pending have not yet been examined; the other items in $accumulator
have been dealt with and need not be dealt with again.
</div>
<div class="Real-P">N.B. To keep the control flow simple, this function does not
attempt to handle all of the items at position $p before moving to $p
+ 1, and it does not assume that all predictions of a nonterminal $n
beginning at position $p are present when a completion for $n at $p is
found.
</div>
<div class="Real-P">One immediate consequence of this is that every item making a
prediction must also check for completions of its predicted
non-terminals, which increases the number of times we must scan
through the accumulator and offers a low-hanging target for improving
speed. <i>TO DO: pluck that low-hanging fruit.</i></div>

<div class="Real-P">The function has two cases: either we are done, or we are not yet
done.
<div class="scrap"><span><a name="d3e4248">&#x3008; 139 Define earley-closure($pending, $accumulator, $I, $G) [continues <a href="#eri-items-closure">137 Calculating the closure of an Earley set</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   ixi:earley-closure($pending, $accumulator, $I, $G2):
:)
declare function ixi:earley-closure(
  $leiPending as map(xs:string, item())* (: pending items :),
  $meiAccum as map(xs:string, map(xs:integer, map(xs:string, item())*))
            (: accumulator of type MEI :),
  $I as xs:string,
  $G as element(ixml)
) as map(xs:string, map(xs:integer, map(xs:string, item())*)) (:MEI:) {
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-items-closure-termination">Terminating case for Earley closure 140</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-items-closure-normal">Normal case for Earley closure 141</a></em> &#x3009;</span>};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">The base case arises when the pending list is done.  If nothing
remains to be done, then we are done and can return the accumulator.
<div class="scrap"><span><a name="eri-items-closure-termination">&#x3008; 140 Terminating case for Earley closure &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  if (empty($leiPending))
  then $meiAccum
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e4248">Define earley-closure($pending, $accumulator, $I, $G) 139</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">In the normal case, we have items to process.  We
<ul><li>take the head of the pending list,</li>
<li>run the PCS function on it,</li>
<li>dedup the returned items,</li>
<li>drop any items that are already in the accumulator, and</li>
<li>recur, while adding new items to the accumulator.</li>
</ul>
<div class="block-note;" style="margin-left: 2em; font-size: smaller;"><div><b>NOTE:</b></div>
Note, February 2022.
<div class="Real-P">When trying to find out where time is going in the recognizer, the
first step is to wrap each step here in prof:time().  The conjecture
before examining the results is that 80% of the time, or more, will be
spent in <i>ixi:leiPCSrel()</i>, and minimal time in the
deduping steps.</div>
<div class="Real-P">If this conjecture holds true, the second step will be to
instrument <i>leiPCSrel()</i>.  But: one thing at a time.</div>
</div>
<div class="block-note;" style="margin-left: 2em; font-size: smaller;"><div><b>NOTE:</b></div>
Note, February 2022.
<div class="Real-P">Results of one run on test0 (trivial examples):
<ul><li>1.63 ms checking PCS results against accumulator</li>
<li>0.54 ms deduping PCS results</li>
<li>35.48 ms running PCS function</li>
</ul>
So nearer 94% than 80% of the time.  (It might be nice to have an
automated way of getting these numbers, but for now what I did is
copy and paste the messages out of the GUI's info window, use an
impromptu Emacs keyboard macro to change lines like
&#x201c;<tt>PCS: 0.87 ms</tt>&#x201d; to
&#x201c;<tt>0.87 ; ms PCS:</tt>&#x201d;, sort to get the
different measurements together, and wrap each set of
messages in &#x201c;<tt>(+</tt>&#x201d; ... &#x201c;<tt>)</tt>&#x201d;.
Then ^x^e to evaluate the Lisp expression.)
</div>
<div class="Real-P">On a longer test set (test2), which ran for 1215 seconds,
the results were:
<ul><li>1,782.91 ms checking PCS results against accumulator</li>
<li>357.39 ms deduping PCS results</li>
<li>19,967.69 ms running PCS function</li>
</ul>
As the accumulator gets larger, searching it for items already present
appears to become more expensive.  But running PCS is still taking 90%
of the measured time.
</div>
<div class="Real-P">Further testing seems unnecessary.</div>

</div>
<div class="scrap"><span><a name="eri-items-closure-normal">&#x3008; 141 Normal case for Earley closure &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $E := head($leiPending), 

      (: get everything from leiPCSrel :)
      $leiCs0 := ixi:leiPCSrel($E,$meiAccum,$I,$G),
                 
      
      (: dedup results from leiPCSrel :) 
      $leiCs := $leiCs0[
                   not(some $i in 1 to (position() - 1)
                       satisfies deep-equal(., $leiCs0[$i])
                   )],
        	
      (: remove non-new results from leiPCSrel :)
      $leiNew := for $ei in $leiCs
	         let $from := $ei('from')
		 where not(some $e in $meiAccum('from')($from)
		           satisfies deep-equal($e, $ei))
		 return $ei,

      <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-itcl-traces">Issue trace messages for earley-closure() 142</a></em> &#x3009;</span>
		 
      $meiNewaccum := map {
	'from' : map:merge(
	  ( $meiAccum('from'),
	  for $ei in $leiNew return map:entry($ei('from'), $ei) ),
	  $ixi:combinedups),
        'to' : map:merge(
	  ( $meiAccum('to'),
	  for $ei in $leiNew return map:entry($ei('to'), $ei) ),
	  $ixi:combinedups) }
      
  return ixi:earley-closure(
    (tail($leiPending), $leiNew),
    $meiNewaccum,
    $I,
    $G)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e4248">Define earley-closure($pending, $accumulator, $I, $G) 139</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">When debugging this, it is helpful to have trace messages showing
each step in this process.
<div class="scrap"><span><a name="eri-itcl-traces">&#x3008; 142 Issue trace messages for earley-closure() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      $dummy := ixi:notrace(count($leiPending), 
                            'e-c() has pending items: '), 
      $dummy := ixi:notrace(
                    ixi:sXei($E),
                    'ixi:earley-closure running on item: '), 
      $dummy := ixi:notrace(count($leiCs0), 
                    'e-c() initial closure has items: '), 
      $dummy := ixi:notrace(count($leiCs), 
                     'e-c() deduped closure has items: '), 
      $dummy := ixi:notrace(count($leiNew), 
                     'e-c() New items: '), 
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#eri-items-closure-normal">Normal case for Earley closure 141</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The function <i>leiPCSrel()</i> takes an Earley
item (and an accumulator, the input, and the grammar) and
returns all the items that stand in the scan, pred, or
comp relations to the given item.
<div class="block-note;" style="margin-left: 2em; font-size: smaller;"><div><b>NOTE:</b></div>
February 2022: timings within this function on test0:
<ul><li>89.09 ms in ix:scan()</li>
<li>173.29 ms in ix:pred()</li>
<li>118.13 ms looking for completion and performing comp()</li>
<li>186.01 ms looking for prediction and performing comp()</li>
</ul>
and on ABNF.ixml (which ran 1675 seconds):
<ul><li>3972.56 ms in ix:scan()</li>
<li>6868.14 ms in ix:pred()</li>
<li>4076.04 ms looking for completion and performing comp()</li>
<li>11520.97 ms looking for prediction and performing comp()</li>
</ul>
That's only 27 seconds out of 1675 - where did that time all
go?!

</div>
<div class="scrap"><span><a name="d3e4359">&#x3008; 143 Define earley-closure($pending, $accumulator, $I, $G) [continues <a href="#eri-items-closure">137 Calculating the closure of an Earley set</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   leiPCSrel($E, $leiA, $I, $G): return all items $E2 
   such that 
   $E2 = scan($E, $I)
   or $E2 = pred($E, $G)
   or comp($E1, $E3) for some $E3 in $leiA
   or comp($E3, $E1) for some $E3 in $leiA
:)
declare function ixi:leiPCSrel(
  $E as map(xs:string, item()),
  $meiAccum as map(xs:string, item())*,
  $I as xs:string,
  $G as element(ixml)
) as map(xs:string, item())* {
  (: If $E expects terminals, perform scan :)
  
  ix:scan($E,$I),
  
  
  (: If $E expects nonterminals, perform prediction :)
  
  ix:pred($E,$G), 
  
  
  (: If $E expects a nonterminal, look for a 
     completion $Ec and perform comp($Ec,$E) :)
  
  if (ixi:fExpectsN-Ei($E))
  then for $Ec in $meiAccum('from')($E('to'))
       where ixi:fFinalEi($Ec)
       return ix:comp($Ec,$E)
  else (), 
  
    
  (: If $E is a completion, look for a prediction $Ep 
     and perform comp($E,$Ep) :)
  
  if (ixi:fFinalEi($E)) 
  then for $Ep in $meiAccum('to')($E('from'))
       where ixi:fExpectsN-Ei($Ep)
       return ix:comp($E,$Ep)
  else ()
  
    
  (: N.B. In BNF, $E can only expect one symbol, so 
     either scan or pred applies, but not both.  But 
     we are expecting EBNF and $E can predict several 
     things at the same time as being a completion. :)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#ll-items">&#x23f4;</a></span><span class="arrow"><a href="#lowlevel">&#x23f6;</a></span><span class="arrow"><a href="#ll-rules">&#x23f5;</a></span></div><h3><a class="selflink" name="ll-grammars" id="ll-grammars" href="#ll-grammars">4.3. </a>Working with grammars</h3>

<div class="Real-P">
<div class="scrap"><span><a name="eri-grammars">&#x3008; 144 Grammars (constructors, extractors, etc.) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ****************************************************** 
   * Grammars
   ****************************************************** :)
(: A grammar is an ixml element with no namespace. :)

<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-grammars-constructors">Functions that construct or return grammars 145</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-grammars-extractors">Functions that extract information from grammars 148</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-grammars-predicates">Functions that check grammar properties 149</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e503">[File Earley-rec-internals.xqm] 11</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">We have just one routine that constructs grammars; it takes an
existing grammar and gives it a new start-symbol with a single rule.
This allows us to know without any further analysis that the start
symbol of the augmented grammar is non-recursive and has just one
rule. [<i>To do:</i> write a version of this that accepts a
start-symbol as a parameter.]</div>
<div class="Real-P">This is the same in v0.1 and v0.2 except that we use a different
element name to wrap the right-hand side of the rule.
<div class="scrap"><span><a name="eri-grammars-constructors">&#x3008; 145 Functions that construct or return grammars &#x3009;  &#x2261;</a></span>
<pre class="scrapbody"> (: ******************************************************
   * Grammars: constructors
   :)
   
(: ......................................................
   augment-grammar($G):  given grammar, augment it as 
   Earley prescribes.
   :)
declare function ixi:augment-grammar(
  $G as element(ixml)
) as element(ixml) {
  let $symStart := ixi:symStartG($G),
      $symGoal := ixi:makeGoalsymbolG($G),
      $fNullable := ixi:fNullableNG($symStart, $G)
  return element ixml {
    element rule {
      attribute name {$symGoal}, 
      attribute xml:id {$symGoal || '_rule'},
      attribute nullable { false() },
      attribute first {$symStart || '_0'},
      attribute last {$symStart || '_0'},
      attribute { xs:QName('follow:'||$symStart||'_0') } 
                {()},        
      element <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#gl-alts-gi">GI for alts element 42</a></em> &#x3009;</span> {
        attribute xml:id {$symGoal || '_def_0'},
        attribute nullable { false() },
        attribute first {$symStart || '_0'},
        attribute last {$symStart || '_0'},
        attribute { xs:QName('follow:'||$symStart||'_0') } 
                  {()},
        element alt {
          attribute xml:id {$symGoal || '_alt_0'},
          attribute nullable { false() },
          attribute first {$symStart || '_0'},
          attribute last {$symStart || '_0'},
          element nonterminal {
            attribute name { $symStart },
            attribute xml:id {$symStart || '_0'},
            attribute nullable { false() },
            attribute first {$symStart || '_0'},
            attribute last {$symStart || '_0'}
          } (: end nonterminal :)
        } (: end alt :)
      } (: end def :)
    }, (: end rule :)
    $G/rule
  } (: end ixml :)
};
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e4396">Goal-symbol construction 146</a>&#x3009;, &#x3008;<a href="#d3e4403">Goal-symbol construction 147</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#eri-grammars">Grammars (constructors, extractors, etc.) 144</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">We have a small utility function for making a new
goal symbol that differs from all existing symbols.
<div class="scrap"><span><a name="d3e4396">&#x3008; 146 Goal-symbol construction [continues <a href="#eri-grammars-constructors">145 Functions that construct or return grammars</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody"> (: ......................................................
   makeGoalsymbolG($G):  make a new goal symbol for 
   grammar G, ensuring that it's not the same as any 
   existing symbol.
   :)
declare function ixi:makeGoalsymbolG(
  $G as element(ixml)
) as xs:string {
  let $ln := distinct-values($G/rule/@name),
      $n := ('Goal', '_Goal_', '_G_o_a_l_', '_G-o-a-l_')
            [not(. = $ln)][1]
  return if (exists($n)) 
    then $n 
    else ixi:mungesymbol(ixi:symStartG($G), $ln)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">And another utility for munging a given symbol.
<div class="scrap"><span><a name="d3e4403">&#x3008; 147 Goal-symbol construction [continues <a href="#eri-grammars-constructors">145 Functions that construct or return grammars</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   mungesymbol:  given a symbol, munge it (by adding _ 
   fore and aft) until it is no longer in the list of 
   symbols $ln (which is the symbols already in the 
   grammar).
   :)
declare function ixi:mungesymbol(
  $n as xs:string,
  $ln as xs:string*
) as xs:string {
  if ($n = $ln)
    then ixi:mungesymbol('_' || $n || '_', $ln)
    else $n
};

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">
<div class="scrap"><span><a name="eri-grammars-extractors">&#x3008; 148 Functions that extract information from grammars &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   * Grammars: extractors
   :)
   
(: ......................................................
   symStart G():  return start symbol(s) of G
   :)
declare function ixi:symStartG(
  $G as element(ixml)
) as xs:string+ {
  $G/rule[1]/@name/normalize-space()
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#eri-grammars">Grammars (constructors, extractors, etc.) 144</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">
<div class="scrap"><span><a name="eri-grammars-predicates">&#x3008; 149 Functions that check grammar properties &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   * Grammars:  predicates
   *
   * Note that predicates relating to symbols in context 
   * are here, not under symbol.  (Test:  is $G a 
   * parameter?)
   :)
(: ixi:fNullableNG($n, $G):  is nonterminal n nullable 
   in G? 

   For non-terminal N, fNullableNG(N,G) means an N 
   element in the result tree may be empty.

   Here 'nullable' means it has a right-hand side whose
   regex matches the empty string, which means in turn
   that the parse tree may be empty, and non-terminal N
   may appear as an N element in the result.
   
   N.B. this is not the same as fGES.
  
:)
declare function  ixi:fNullableNG(
  $n as xs:string, (: element(nonterminal), :)
  $G as element(ixml)
) as xs:boolean {
  exists($G/rule[@name = $n][@nullable = ('true', '1')])
};


(: ixi:fGesNG($n, $G):  does nonterminal n generate the 
   empty string in G? 
   
   N.B. this is not the same as fNullable.
   
   Discussions of parsing often use 'nullable' for 
   nonterminals that generate the empty string, but in 
   the grammar 
     S: X. X: .
   X is nullable and GES, S is GES but not nullable.
   
   For non-terminal N, fGesNG(N,G) means an N element
   in the result tree may have string(N) = ''.
   
:)
(: this is a transitive closure algorithm and will 
   require more work (including an accumulator to 
   avoid looping).
   
   For now, suppress it and do without it.
:)
(:
declare function  ixi:fGesNG(
  $n as element(), 
  $G as element(ixml)
) as xs:boolean {
  ($n/self::nonterminal 
     and ixi:fNullable($n, $G)
         or 
         (some $d 
          in $G/rule[@name=$n]/alt
          satisfies ixi:fGesNG($d,$G)))
  or ($n/self::def
     and ($n/@nullable = ('true','1'))
  or 
  ()
 
};
:)

(: ixi:lrulesXNG($n,$G) :)
declare function ixi:lrulesXNG(
  $n as element(nonterminal),
  $G as element(ixml)
) as element(rule)* {
  $G/rule[@name = $n/@name]
};


(: ******************************************************
   * Grammars: predicates
   :)

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#eri-grammars">Grammars (constructors, extractors, etc.) 144</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#ll-grammars">&#x23f4;</a></span><span class="arrow"><a href="#lowlevel">&#x23f6;</a></span><span class="arrow"><a href="#ll-symbols">&#x23f5;</a></span></div><h3><a class="selflink" name="ll-rules" id="ll-rules" href="#ll-rules">4.4. </a>Working with rules</h3>

<div class="Real-P">
<div class="scrap"><span><a name="eri-rules">&#x3008; 150 Rules (constructors, extractors, etc.) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ****************************************************** 
   * Rules and rule indexes
   ****************************************************** :)
(: A rule is a rule element as defined in the ixml DTD, but 
   augmented with glushkov attributes.
   
   Note that functions relating to rules in context are 
   not here but under Grammars above.  (Test: is $G a 
   parameter?) Functions here relate solely to the rule 
   in isolation. That may be why there are so few of them.
:)

(: ******************************************************
   * Rules and rule indexes: constructors
   :)
   
(: ******************************************************
   * Rules and rule indexes: extractors
   :)

(: ixi:lriFinalstatesXR($r) :)
declare function ixi:lriFinalstatesXR(
  $r as element()
) as xs:string* {
  if ($r/self::rule)
  then 
  (
    if ($r/@nullable = ('true', '1'))
    then 'q0' else (),
    tokenize($r/@last,'\s+')[normalize-space()]
  )
  else ()

};

(: ixi:lriStartstatesXR($Rule):  return list of 
   start-position identifiers.
 :)
declare function ixi:lriStartstatesXR(
  $r as element()
) as xs:string* {
  'q0'
};

(: ******************************************************
   * Rules and rule indexes: predicates
   :)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e503">[File Earley-rec-internals.xqm] 11</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#ll-rules">&#x23f4;</a></span><span class="arrow"><a href="#lowlevel">&#x23f6;</a></span><span class="arrow"><a href="#ll-input">&#x23f5;</a></span></div><h3><a class="selflink" name="ll-symbols" id="ll-symbols" href="#ll-symbols">4.5. </a>Working with symbols</h3><ul><li>4.5.1. <a href="#ll-sym-match-length">The <i>match-length()</i> function</a></li><li>4.5.2. <a href="#d3e4498">Making regular expressions from terminal symbols</a></li><li>4.5.3. <a href="#d3e4626">Testing for symbol type</a></li><li>4.5.4. <a href="#d3e4649">Matching symbols against rule indices</a></li></ul>

<div class="Real-P">A symbol is (represented by) an element: one of &lt;<em>nonterminal</em>&gt;,
&lt;<em>literal</em>&gt;, &lt;<em>inclusion</em>&gt;, or &lt;<em>exclusion</em>&gt;.
</div>
<div class="Real-P">(Any reference to elements named &#x201c;&lt;<em>terminal</em>&gt;&#x201d; is a
relic from the 2016 grammar of ixml and now constitutes an error.)
</div>

<div class="Real-P">Note that functions relating to symbols in context are not here but
under Grammars above.  (If <i>$G</i> is a parameter, it's with
grammars.)  Functions here relate solely to the symbol in isolation.
That may be why there are so few of them.</div>

<div class="Real-P">Similarly any function that involves the input string is not here
but under Input, below.
<div class="scrap"><span><a name="eri-symbols">&#x3008; 151 Symbols (constructors, extractors, etc.) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ****************************************************** 
   * Symbols
   ****************************************************** :)

(: ******************************************************
   * Symbols: constructors
   :)
   
(: ******************************************************
   * Symbols: extractors
   :)
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-sym-match-length">Define match-length() 152</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-sym-reXTerminal">Define reXTerminal(), regex from terminal 153</a></em> &#x3009;</span>
 
(: ******************************************************
   * Symbols: predicates
   :)
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-sym-fTerminal">Define fTerminal() 160</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-sym-fNonterminal">Define fNonterminal() 161</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-sym-fSymbolmatchRRiSym">Define fSymbolmatchRRiSym() 162</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e503">[File Earley-rec-internals.xqm] 11</a> &#x3009; <br></span>
</div>

</div>


<div class="div">

<div class="quicknav"><span class="arrow">&nbsp;</span><span class="arrow"><a href="#ll-symbols">&#x23f6;</a></span><span class="arrow"><a href="#d3e4498">&#x23f5;</a></span></div><h4><a class="selflink" name="ll-sym-match-length" id="ll-sym-match-length" href="#ll-sym-match-length">4.5.1. </a>The <i>match-length()</i> function</h4>
<div class="Real-P">In tree-builder, we want match-length info just from terminal; we
don't have access to $I.  If terminals ever become variable-length,
this will break. <i>Is this still true, or does <i>scan()</i>
now produce Earley items from which the length and the string
can be found without <i>$I</i>?</i></div>
<div class="Real-P">See also match-length#3 below under Input.
<div class="scrap"><span><a name="eri-sym-match-length">&#x3008; 152 Define match-length() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   match-length($t):  return length of any string that 
   matches the specified terminal.  
   :)
declare function ixi:match-length(
  $t as element()
) as xs:integer {
  if ($t/self::literal) then ixi:string-length($t)
  else 1
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#eri-symbols">Symbols (constructors, extractors, etc.) 151</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#ll-sym-match-length">&#x23f4;</a></span><span class="arrow"><a href="#ll-symbols">&#x23f6;</a></span><span class="arrow"><a href="#d3e4626">&#x23f5;</a></span></div><h4><a class="selflink" name="d3e4498" id="d3e4498" href="#d3e4498">4.5.2. </a>Making regular expressions from terminal symbols</h4>
<div class="Real-P">The function <i>reXTerminal($t)</i> returns a regular
expression, given a terminal element.  Note that the regular
expression will match one character (or none) in the input; we don't
have terminal symbols with indeterminate length in the input.
</div>
<div class="Real-P">This function is initially needed only for character sets
(&lt;<em>inclusion</em>&gt; and &lt;<em>exclusion</em>&gt;), but let's make it handle
literals as well, just in case.</div>
<div class="Real-P">To do: make the compilation step do this once for all for each
terminal, so that we're not doing it again and again.
<div class="scrap"><span><a name="eri-sym-reXTerminal">&#x3008; 153 Define reXTerminal(), regex from terminal &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   re X Terminal($t): return a regular expression, given 
   a terminal element.
   :)
declare function ixi:reXTerminal(
  $t as element() (: incl, excl, literal :)
) as xs:string {
  if ($t/self::literal) 
  then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-sym-reXT-literal">Make character-escaped string from literal 154</a></em> &#x3009;</span>
  else 
  let $le := $t/*,
      $lsRegexbits := 
          for $e in $le
          return if ($e/self::range
                    or $e/self::member/@from)
                 then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-sym-reXT-range">Make positive character group for range 156</a></em> &#x3009;</span>
                 else if ($e/self::literal
                    or $e/self::member/@string
                    or $e/self::member/@hex) 
                 then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-sym-reXT-lit">Make positive character group from literal 159</a></em> &#x3009;</span>
                 else if ($e/self::class
                    or $e/self::member/@code)
                 then ixi:catescXS($e/@code) 
                 else () (: error :)
  return if ($t/self::inclusion
             and exists($lsRegexbits))
    then "[" || string-join($lsRegexbits,'') || "]"
    else if ($t/self::exclusion
             and exists($lsRegexbits))
    then "[^" || string-join($lsRegexbits,'') || "]"
    else if ($t/self::inclusion)
    then "[^\i\I]" (: empty inclusion matches nothing :)
    else if ($t/self::exclusion)
    then "[\s\S]" (: empty inclusion excludes nothing :)
    else if ($t/self::insertion)
    then "[^\p{Z}\P{Z}]?" (: insertion matches empty sequence :)
    else "--error in reXTerminal--"
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#eri-symbols">Symbols (constructors, extractors, etc.) 151</a> &#x3009; <br></span>
</div>

We use &#x201c;<tt>[\s\S]</tt>&#x201d; and &#x201c;<tt>[^\i\I]</tt>&#x201d; as
XPath representations of the empty inclusion and the empty exclusion,
respectively.  Any pair of complementary character class escapes would
work as well: &#x201c;<tt>\w\W</tt>&#x201d; &#x201c;<tt>\i\I</tt>&#x201d;, etc.
 
We will use a different pair each time we generate such a character
class, to help make clear where that character class was generated.
Insertions could just be written with the empty string, but writing
&#x201c;<tt>[^\p{Z}\P{Z}]?</tt>&#x201d; should make them easier to trace.
</div>

<div class="Real-P">An important wrinkle is that not every integer between #0000 and
#10FFFF (0..1114111) can be turned into an XML character.  So we need
to check that hex-encoded characters are in fact XML characters, and
adapt the regular expression accordingly if they are not.
</div>
<div class="Real-P">A literal with a <em>string</em> attribute cannot contain a
non-XML character: by the time we have a compiled grammar, we are
looking at XDM instances and any non-XML characters will have caused
failures earlier on.  So any <em>string</em> attribute just needs to
be escaped.
<div class="scrap"><span><a name="eri-sym-reXT-literal">&#x3008; 154 Make character-escaped string from literal &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      if (exists($t/@string))
      then ixi:sceXS($t/@string)
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e4569"> 155</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#eri-sym-reXTerminal">Define reXTerminal(), regex from terminal 153</a> &#x3009; <br></span>
</div>

A hex value, on the other hand, must be checked.  For encoded
terminals, a hex value denoting a non-XML character cannot match
anything in the input and is therefore equivalent to a regular
expression matching nothing (not to be confused with matching
the empty string).  We'll use &#x201c;<tt>[^\c\C]</tt>&#x201d;
for that case: since &#x201c;<tt>\c</tt>&#x201d; and &#x201c;<tt>\C</tt>&#x201d;
are complements and together match every XML character,
&#x201c;<tt>[^\c\C]</tt>&#x201d; will not match anything at all.
<div class="scrap"><span><a name="d3e4569">&#x3008; 155  [continues <a href="#eri-sym-reXT-literal">154 Make character-escaped string from literal</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      else try { ixi:sceXS(
                    codepoints-to-string(
                       d2x:x2d($t/@hex)
                    ) 
                 )
               } catch * {
                  "[^\c\C]"
               }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">For what it's worth, the original version of the code just
given was too trusting:
&#x201c;<tt>ixi:sceXS( ixi:string-value($t) )</tt>&#x201d;.
When a hex-encoded literal referred to a non-XML character,
things blew up.
</div>
<div class="Real-P">Ranges require special care, because if hex-encoded the range ends
may involve non-XML characters.  If so, we find the nearest XML
character guaranteed to produce the same rules on XML strings, and
then build the range.  In the process, we may end up missing one or
both ends of the range (if <em>from</em> is greater than #10FFFF or
<em>to</em> is less than 9), or the two may move past each other
(as they would for &#x201c;<tt>[#10 - #1F]</tt>&#x201d;); in that case,
we return nothing at all.
<div class="scrap"><span><a name="eri-sym-reXT-range">&#x3008; 156 Make positive character group for range &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">                      <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-sym-reXT-from">Set $cpFrom, $sFrom to effective codepoint and string 157</a></em> &#x3009;</span>
                      <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-sym-reXT-to">Set $cpTo, $sTo to effective codepoint and string 158</a></em> &#x3009;</span>
                      return if (exists($cpFrom)
                          and exists($cpTo)
                          and ($cpFrom le $cpTo))
                      then ixi:sceXS($sFrom)
                           || "-"
                           || ixi:sceXS($sTo)
                      else ()
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#eri-sym-reXTerminal">Define reXTerminal(), regex from terminal 153</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">
To handle a non-XML <em>from</em> value, we bump it up to
the next higher XML character, because that is where the effective
range begins.  For example, if the range is specified as
&#x201c;<tt>[#00 - #FF]</tt>&#x201d;, the lowest code point it can match
is #09, the first XML character greater than #00.
<div class="scrap"><span><a name="eri-sym-reXT-from">&#x3008; 157 Set $cpFrom, $sFrom to effective codepoint and string &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">        let $cpFrom0 := 
               if (matches($e/@from, 
                           '^#[0-9a-fA-F]+$'))
               then d2x:x2d(substring($e/@from, 2))
               else string-to-codepoints(
                       $e/@from/string()), 
            $cpFrom := try {
                  string-to-codepoints(
                     codepoints-to-string(
                        $cpFrom0))       
               } catch * {
                  (: bump it up to one of:
                     #9, #D, #20, #E000, #10000 :)
                  (9, 13, 32, 57344, 65536)
                  [$cpFrom0 le .][1]
               },
            $sFrom := codepoints-to-string($cpFrom)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#eri-sym-reXT-range">Make positive character group for range 156</a> &#x3009; <br></span>
</div>

The ranges allowed for XML characters are, in ixml notation,
&#x201c;<tt>[#9 - #A; #D; #20 - #D7FF; #E000 - #FFFD; #10000 -
#10FFFF]</tt>&#x201d;.  As may be seen, we simply find the lowest range
whose starting point is above the non-XML code point.  <i>(Strictly
speaking, we should perhaps catch only error FOCH0001, to avoid making
this adjustment for other unrelated errors.)</i>
</div>
<div class="Real-P">
Conversely, for the <em>to</em> value, we bump a non-XML
codepoint down to the top of next range of XML characters.
<div class="scrap"><span><a name="eri-sym-reXT-to">&#x3008; 158 Set $cpTo, $sTo to effective codepoint and string &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">        let $cpTo0 :=
               if (matches($e/@to, 
                           '^#[0-9a-fA-F]+$'))
               then d2x:x2d(substring($e/@to, 2))
               else string-to-codepoints(
                       $e/@to/string()), 
            $cpTo := try {
                  string-to-codepoints(
                     codepoints-to-string(
                        $cpTo0))       
               } catch * {
                  (: bump it down to one of:
                     #10FFFF, #FFFD, #D7FF, #D, #A :)
                  (1114111, 65533, 55295, 13, 10)
                  [$cpTo0 ge .] [1]
               },
            $sTo := codepoints-to-string($cpTo)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#eri-sym-reXT-range">Make positive character group for range 156</a> &#x3009; <br></span>
</div>

For range ends specified as literals, we engage in a little
unnecessary work of turning them into code points and then
back into strings.
</div>
<div class="Real-P">Literal character-set members also require special handling if they
are hex-encoded.  If they are XML characters, they are treated
normally; if they are not XML characters, they are dropped:  they
cannot match anything in an inclusion, and they cannot exclude
anything in an exclusion.
<div class="scrap"><span><a name="eri-sym-reXT-lit">&#x3008; 159 Make positive character group from literal &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">                             try {
                                ixi:sceXS(
                                   $e/ixi:string-value(
                                     $e))
                             } catch * {
                                ()
                             } 
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#eri-sym-reXTerminal">Define reXTerminal(), regex from terminal 153</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#d3e4498">&#x23f4;</a></span><span class="arrow"><a href="#ll-symbols">&#x23f6;</a></span><span class="arrow"><a href="#d3e4649">&#x23f5;</a></span></div><h4><a class="selflink" name="d3e4626" id="d3e4626" href="#d3e4626">4.5.3. </a>Testing for symbol type</h4>
<div class="Real-P">The function <i>fTerminal()</i> returns true iff the
argument is a terminal symbol or an insertion.  This version supports both my
interpretation of the 2016 syntax (with element type
&lt;<em>terminal</em>&gt;) and the 2019 syntax (literal, inclusion,
exclusion).
<div class="scrap"><span><a name="eri-sym-fTerminal">&#x3008; 160 Define fTerminal() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   f Terminal($sym):  is $sym a terminal symbol?
   :)
declare function ixi:fTerminal(
  $sym as item()
) as xs:boolean {
  exists($sym/self::element()[self::terminal
    or self::literal
    or self::inclusion
    or self::exclusion
    or self::insertion
  ])
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#eri-symbols">Symbols (constructors, extractors, etc.) 151</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The function <i>fNonterminal()</i> performs
a similar function for nonterminals.
<div class="scrap"><span><a name="eri-sym-fNonterminal">&#x3008; 161 Define fNonterminal() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   f Nonterminal($sym):  is $sym a nonterminal symbol?
   :)
declare function ixi:fNonterminal(
  $sym as item()
) as xs:boolean {
  exists($sym/self::element()/self::nonterminal)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#eri-symbols">Symbols (constructors, extractors, etc.) 151</a> &#x3009; <br></span>
</div>

</div>
</div>

<div class="div">

<div class="quicknav"><span class="arrow"><a href="#d3e4626">&#x23f4;</a></span><span class="arrow"><a href="#ll-symbols">&#x23f6;</a></span><span class="arrow">&nbsp;</span></div><h4><a class="selflink" name="d3e4649" id="d3e4649" href="#d3e4649">4.5.4. </a>Matching symbols against rule indices</h4>
<div class="Real-P">The function <i>fSymbolmatchRRiSym($r, $ri, $sym)</i>
determines whether a symbol element $sym matches rule index $ri in
rule $r.  Equivalently: in the FSA for rule $r, does state $ri mean
"we have just read (a string generated by) $sym"?</div>
<div class="Real-P">N.B. $sym is an element, not a name or string, so simple comparison 
is not enough here; we need a bit more.
</div>
<div class="Real-P">Called once, from ixi:leiAdvanceEiSymP(), called in turn thrice
from Earley-recognizer:
<ul><li>in ix:scan() with terminal from rule (so 'terminal' element),</li>
<li>in ix:pred() with nullable nonterminal from rule,</li>
<li>in ix:comp() with constructed nonterminal element created
for the call.</li>
</ul>
So for nonterminals, we need to compare the @name attributes.
</div>
<div class="Real-P">For terminals, the likelihood is that $sym is the element we just
tested the input against, so we will use deep equality as a test.
</div>
<div class="Real-P">Note that this means that in a rule like 
<pre style="margin-left: 2em; background-color: #CCD; margin-right: 3em;">a: 'b', 'c'; 'b', 'd'.</pre>
we will not be advancing both paths on a 'b'.  The caller will
(or: must) call this once for each prediction, so with two different
'terminal' elements.  Since we may be dealing with a copy of the
terminal element, not the original, we must avoid reliance on
element identity.
</div>
<div class="Real-P">Note that this will not be called with a state of 'q0'; it's always
called with a state name corresponding to a symbol.  (We are,
as it were, always checking from the end of the arc, not the start.)</div>
<div class="Real-P">
To do: adjust to 2019 syntax, which no longer has a single 'terminal' 
element type but has 'quoted', 'inclusion', and 'exclusion'.
<div class="scrap"><span><a name="eri-sym-fSymbolmatchRRiSym">&#x3008; 162 Define fSymbolmatchRRiSym() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   fSymbolmatch R Ri Sym($r, $ri, $sym): does symbol 
   element $sym match rule index $ri in rule $r?  
   
   :)
declare function ixi:fSymbolmatchRRiSym(
  $r as element(rule),
  $ri as xs:string,
  $sym as element() (: nonterminal or terminal :)
) as xs:boolean {  
  if ($sym/@xml:id = $ri)
  then true()
  else let $state := $r/descendant::*[@xml:id = $ri]
       return if (local-name($sym) ne local-name($state))
           (: we have a terminal trying to match a nonterminal,
              or vice versa, or different kinds of terminal;
              return false :)
         then false()
         
         else if (ixi:fTerminal($sym))
           (: we have terminals; they match if their children 
              are deep-equal.  NB we are relying on the fact
              that we have just extracted the terminal element
              from the rule we are working on, so it really
              ought to be deep-equal to itself.
              :)
         then deep-equal($state, $sym)
         (: was: 
         then deep-equal($state/*, $sym/*) 
         but when the terminal element is empty, that doesn't work.
         :)
         
         else if (ixi:fNonterminal($sym))
           (: we have non-terminals, they match on name :)
         then ($sym/@name eq $state/@name) 
         
         else (: something wrong :) false()
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#eri-symbols">Symbols (constructors, extractors, etc.) 151</a> &#x3009; <br></span>
</div>

</div>
</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#ll-symbols">&#x23f4;</a></span><span class="arrow"><a href="#lowlevel">&#x23f6;</a></span><span class="arrow"><a href="#ll-utils">&#x23f5;</a></span></div><h3><a class="selflink" name="ll-input" id="ll-input" href="#ll-input">4.6. </a>Dealing with the input</h3>

<div class="Real-P">There are no useful constructors for the input.
<div class="scrap"><span><a name="eri-input">&#x3008; 163 Input (constructors, extractors, etc.) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ****************************************************** 
   * Input
   ****************************************************** :)
(: For now, the input is always a string. :)

(: ******************************************************
   * Input: constructors
   :)
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#eri-input-ext">Extractors for input 164</a>&#x3009;, &#x3008;<a href="#eri-input-pred">Predicates for input: fMatchesIPT() 165</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e503">[File Earley-rec-internals.xqm] 11</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">And not much by way of extractors.
<div class="scrap"><span><a name="eri-input-ext">&#x3008; 164 Extractors for input [continues <a href="#eri-input">163 Input (constructors, extractors, etc.)</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   * Input: extractors
   :)
(: ......................................................
   inputlength(): how long is the input?
   
   Used (once) for construction of an Earley item 
   signaling completion
   :)
declare function ixi:inputlength(
  $I as xs:string
) as xs:integer {
  string-length($I)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>

<div class="Real-P">On the other hand, knowing whether the input at a
particular position matches a given terminal symbol is
central to parsing.  For this task, we have two versions
of the function.  The original just returned a Boolean
value, and matched either a literal string or matched a
single character against a character-set expression.


<div class="scrap"><span><a name="eri-input-pred">&#x3008; 165 Predicates for input: fMatchesIPT() [continues <a href="#eri-input">163 Input (constructors, extractors, etc.)</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   * Input: predicates
   :)

(: ......................................................
   fMatches I P T($I, $P, $T): does input $I match 
   terminal $T at position $P?

   The terminals are elements in a rule's right-hand side (not
   strings).  Possible forms:
   In 2016 syntax:  terminal[quoted/@dstring], 
     terminal[quoted/@sstring],
     terminal[quoted/text()], charset, exclude.
   In 2019 syntax:  literal[@dstring], literal[@sstring],
     literal[@hex], inclusion, exclusion.
   In 2022 syntax:  literal[@string], literal[@hex], 
     inclusion, exclusion.
   
   Note that position is 0-based, not 1-based, so we add 1 to it
   for XQuery substring calls.
   :)
declare function ixi:fMatchesIPT( 
  $I as xs:string, 
  $p as xs:integer,
  $t as element()
) as xs:boolean {
  if ($t/self::literal) then
     if (1 eq 0) then (: tracing code :)
     let $sProbe := ixi:string-value($t),
         $cPrLen := string-length($sProbe),
         $sInseg := substring($I,$p+1,$cPrLen),
         $fYesno := ($sProbe eq $sInseg)
     return $fYesno
     else (: normal code :)
     let $sProbe := ixi:string-value($t),
         $cPrLen := string-length($sProbe),
         $sInseg := substring($I,$p+1,$cPrLen),
         $fYesno := ($sProbe eq $sInseg)
     return $fYesno
  else if ($t/self::inclusion or $t/self::exclusion) then
     let $sProbe := ixi:notrace(ixi:reXTerminal($t), 
                              'regex for char set:'), 
         $sInseg := ixi:notrace(substring($I,$p+1,1), 
                              'substring (1 char):'),
         $fYesno := ixi:notrace(matches($sInseg,'^'||$sProbe||'$'),
	                      'matches?')
     return $fYesno
  else (: error :) false()
  (: :)
  (: 
  $cMatchlength := if ($t/self::literal)
  let $s := substring($I,$p + 1), 
            (: Earley is 0-based, XPath 1-based :)
      $f := if ($t/self::literal) 
            then starts-with($s,ixi:string-value($t/quoted))
            else if ($t/self::inclusion or $t/self::exclusion)
            then let $re := ixi:reXTerminal($t)
                 return matches($s,$re)
            else (: error :) false(),
       $trace := ixi:notrace($f,
       concat(
         '&amp;#xA;### fMatchesIPT: &amp;#xA;',
         '  Input = ', $I, '&amp;#xA;',
         '  p =', $p, '&amp;#xA;',
         '  quoted = ', if ($t/self::literal) 
                      then ixi:string-value($t) 
                      else '(SEE RE)', '&amp;#xA;',
         '  re = ', if ($t/self::inclusion or $t/self::exclusion)
           then ixi:reXTermin
al($t)
           else '(SEE LITERAL)',
         '&amp;#xA;Result: '
       )
       )
  return $f
  :)
};
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#eri-input-pred-matchlength">match-length(I,p,t) 167</a>&#x3009;<br></span>

<span class="scrapinbound">Other versions of this code are in &#x3008; <a href="#eri-inpred-pfg">Predicates for input: cMatchIPT()  (v. pfg) 166</a> &#x3009; <br></span><span class="scrapinbound"></span>
</div>
</div>

<div class="Real-P">It will however simplify the construction of the parse tree if the
Earley set contains an item recording that this particular terminal
symbol matched a particular substring of the input.  That will also
simplify the <i>match-length()</i> functions, or more likely
render them unnecessary.  So in version <i>pfg</i>, we return
a match length, not a Boolean, and rename the function accordingly.
We use -1, not 0, as the failure signal, since insertions will match
zero characters, and eventually I hope to use this for arbitrary
regular expressions which might succeed with a zero-length match.

<div class="scrap"><span><a name="eri-inpred-pfg">&#x3008; 166 Predicates for input: cMatchIPT() &#x3009; (for version <em>pfg</em>) &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   * Input: predicates
   :)

(: ......................................................
   cMatches I P T($I, $P, $T): does input $I match 
   terminal $T at position $P?  For how many characters?
   
   Note that position is 0-based, not 1-based, so we add 1 to it
   for XQuery substring calls.
   :)
declare function ixi:cMatchesIPT( 
  $I as xs:string, 
  $p as xs:integer,
  $t as element()
) as xs:integer {
  if ($t/self::literal) then
     let $sProbe := ixi:string-value($t),
         $cPrLen := string-length($sProbe),
         $sInseg := substring($I,$p+1,$cPrLen),
         $fYesno := ($sProbe eq $sInseg)
     return if ($fYesno) 
            then $cPrLen 
            else -1
  else if ($t/self::inclusion or $t/self::exclusion) then
     let $sProbe := ixi:notrace(ixi:reXTerminal($t), 
                              'regex for char set:'), 
         $sInseg := ixi:notrace(substring($I,$p+1,1), 
                              'substring (1 char):'),
         $fYesno := ixi:notrace(matches($sInseg,'^'||$sProbe||'$'),
	                      'matches?')
     return if ($fYesno)
            then 1
            else -1
  else if ($t/self::insertion) then
     0
  else (: error :) -1
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#eri-input-pred">Predicates for input: fMatchesIPT() 165</a> &#x3009; </span>
</div>

</div>

<div class="Real-P">

<div class="scrap"><span><a name="eri-input-pred-matchlength">&#x3008; 167 match-length(I,p,t) [continues <a href="#eri-input-pred">165 Predicates for input: fMatchesIPT()</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   match-length($I,$p,$t): return length of the match in
   input $I at position $p of terminal $t.

   In practice, this is called only when we know there
   is a match, but because of the name, and the
   theoretical possibility of input-dependent answers
   (if we were to allow repetition operators inside
   terminals), we also support cases where there is no
   match and the answer is 0.

   If we later allow repetition operators inside
   terminals, this will become more complex, but for
   now, the value is always 1 if there is a match at all
   for charset and exclude non-terminals, and
   string-length of the literal for quoted strings.

   To do: adjust for 2019 syntax.
 :)
declare function ixi:match-length(
  $I as xs:string,
  $p as xs:integer,
  $t as element()
) as xs:integer {
  if (not(ixi:fMatchesIPT($I, $p, $t))) then 0
  else if ($t/self::literal) then ixi:string-length($t)
  else 1
};

(: See also match-length#1 above under Symbols. :)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div></div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#ll-input">&#x23f4;</a></span><span class="arrow"><a href="#lowlevel">&#x23f6;</a></span><span class="arrow">&nbsp;</span></div><h3><a class="selflink" name="ll-utils" id="ll-utils" href="#ll-utils">4.7. </a>Utilities and miscellaneous</h3><ul><li>4.7.1. <a href="#ll-utils-strings">Routines for strings and characters</a></li><li>4.7.2. <a href="#ll-utils-tracing">Trace routines</a></li></ul>

<div class="Real-P">
<div class="scrap"><span><a name="eri-utils-and-misc">&#x3008; 168 Utilities for recognizer internals module &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ****************************************************** 
   * Utilities
   ****************************************************** :)
(: Things with no other obvious home. :)

(: ******************************************************
   * Utilities: string to regex conversion, 
   * string-length, string-value, ...
   :)
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e4742">Define sceXS() to read range ends 169</a>&#x3009;, &#x3008;<a href="#d3e4748">Define catescXS() to build category escape 170</a>&#x3009;, &#x3008;<a href="#d3e4754">Define charXhex() to get character given hex expression 171</a>&#x3009;, &#x3008;<a href="#d3e4760">Define string-length() 172</a>&#x3009;, &#x3008;<a href="#d3e4767">Define string-value() 173</a>&#x3009;, &#x3008;<a href="#d3e4780">Define s X ei() to build string form of Earley item 174</a>&#x3009;, &#x3008;<a href="#d3e4786">Define eXei() to build 'item' element for Earley item 175</a>&#x3009;, &#x3008;<a href="#d3e4792">Define trace() function for debugging 176</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e503">[File Earley-rec-internals.xqm] 11</a> &#x3009; <br></span>
</div>

</div>

<div class="div">

<div class="quicknav"><span class="arrow">&nbsp;</span><span class="arrow"><a href="#ll-utils">&#x23f6;</a></span><span class="arrow"><a href="#ll-utils-tracing">&#x23f5;</a></span></div><h4><a class="selflink" name="ll-utils-strings" id="ll-utils-strings" href="#ll-utils-strings">4.7.1. </a>Routines for strings and characters</h4>
<div class="Real-P">The function <i>sceXS()</i>
<div class="scrap"><span><a name="d3e4742">&#x3008; 169 Define sceXS() to read range ends [continues <a href="#eri-utils-and-misc">168 Utilities for recognizer internals module</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   sce X S($s) : given a string or hex
   expression $s (e.g. from a character terminal), check
   to see if it's a hex expression (in which case expand
   and recur) or a magic character (in which case escape
   it) or is best represented for purposes of regex
   mapping) with a single-character escape (in which
   case escape it).
   
   N.B. this is more than strictly necessary for
   character class escapes, but it seems better to be
   more general.
   
:)
declare function ixi:sceXS(
  $s as xs:string
) as xs:string {
  (: reEscapists:  regex matching characters 
     which must or may be escaped. :)  
  if (matches($s,'^#[0-9a-fA-F]+$'))
  then ixi:sceXS(ixi:charXhex(
    $s
    (: ixi:notrace($s,'sceXS calling charXhex on ' || $s)) :)
  ))
  else if (string-length($s) gt 1)
  then ixi:escapedstringXS($s) 
  else if (not(contains("&amp;#xA;&amp;#xD;&amp;#x9;\|.-^?$*+{}()[]",$s))) 
  then $s
  else if (contains("\|.-^?$*+{}()[]",$s)) 
  then concat("\" (:":), $s)   (: commented dq helps emacs :) 
  else if ($s eq '&amp;#xA;')
  then "\n"
  else if ($s eq '&amp;#xD;')
  then "\r"
  else if ($s eq '&amp;#x9;')
  then "\t"
  else $s

};

declare function ixi:escapedstringXS(
  $s as xs:string
) as xs:string {
  let $reEscapists := concat('[',
                      '&amp;#xA;&amp;#xD;&amp;#x9;', 
                      '\\\|\.\-\^\?\$\*\+',
		      '\{\}\(\)\[\]',
                      ']') 
  return if (matches($s, $reEscapists))
  then string-join(
    for $i in 1 to string-length($s)
    return ixi:sceXS(substring($s, $i, 1)),
    '')
  else $s
};

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">
<div class="scrap"><span><a name="d3e4748">&#x3008; 170 Define catescXS() to build category escape [continues <a href="#eri-utils-and-misc">168 Utilities for recognizer internals module</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   catesc X S($s): given a one- or two-character string
   from a class element, return the appropriate category
   escape in XSD/XPath notation.

   I should do some sanity checking here, but at the
   moment I'm impatient, so I just wrap it in braces
   with \p in front.

   The 2019 spec says "it is an error if there is no
   such class", so probably I should raise an error if
   the category given does not match the list.  But for
   now, I'll just ignore it and return '.'  to match one
   character, on the theory of "carry on irregardless."

   To do:  figure out how Aparecium should handle errors.
:)
declare function ixi:catescXS(
  $s as xs:string
) as xs:string {
  if (matches($s,'^(L[ulmo]?'
     || '|M[nce]?'
     || '|N[dlo]?'
     || '|P[cdseifo]?'
     || '|Z[slp]?'
     || '|S[mcko]?'
     || '|C[cfon]?)$'))
  then '\p{' || $s || '}'
  else '.'
  (: Letters: u[pper] l[ower] t[itlecase] m[odifier] o[other]
     Marks: n[onspacing], [spacing ]c[ombining], e[nclosing]
     Numbers: d[ecimal digit] l[etter] o[ther]
     Punctuation: c[onnector] d[ash] s [= open]
         e [= close] i[nitial quote] f[inal quote] o[ther]
     Z separators: s[pace] l[ine] p[aragraph]
     Symbols: m[ath] c[urrency] k[=modifier] o[ther]
     C other: c[ontrol] f[ormat] o[=private  use] n[ot assigned]
  :)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">
<div class="scrap"><span><a name="d3e4754">&#x3008; 171 Define charXhex() to get character given hex expression [continues <a href="#eri-utils-and-misc">168 Utilities for recognizer internals module</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   char X hex ($s): accept a hex expression, return the
   character.
:)
declare function ixi:charXhex(
  $s0 as xs:string
) as xs:string {
  (: let $tracing := ixi:notrace($s0,
     'charXhex called with |' || $s0 || '|') :)
  let $s := if (starts-with($s0,'#'))
            then substring($s0,2)
            else $s0
  return if (not(matches($s, '^[0-9a-fA-F]+$')))
         then '---error in charXhex---'
         else codepoints-to-string(d2x:x2d($s))
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">
<div class="scrap"><span><a name="d3e4760">&#x3008; 172 Define string-length() [continues <a href="#eri-utils-and-misc">168 Utilities for recognizer internals module</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   string-length:  calculate 'real' length of string.

   We use this to hide possible variation in the form of
   'quoted' strings.  (Q. Does that mean we are
   expecting quote doubling to show up in the XML form
   of the literal?  It shouldn't.)

   To do: sanity check this, and delete if unnecessary.
   :)
declare function ixi:string-length(
  $q as element(literal)
) as xs:integer {
  string-length(ixi:string-value($q))
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">
<div class="scrap"><span><a name="d3e4767">&#x3008; 173 Define string-value() [continues <a href="#eri-utils-and-misc">168 Utilities for recognizer internals module</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   string-value:  calculate 'real' value of string.

   We use this to hide possible variation in the form of
   quoted strings.  (Q. Does that mean we are expecting
   quote doubling to show up in the XML form of the
   literal?  It shouldn't.)

   To do:  sanity check this, and delete if unnecessary.
   :)
declare function ixi:string-value(
  $q as element() (: literal or member :)
) as xs:string {
  let $s := if ($q/@string)
            then string($q/@string)
            else if ($q/@dstring)
            then replace($q/@dstring,'""','"') (:":)
            else if ($q/@sstring) 
            then replace($q/@sstring,"''", "'") 
            else if ($q/@hex) 
            then ixi:charXhex($q/@hex)
            else string($q)
  return if (matches($s,'^#[0-9a-fA-F]+$'))
         then ixi:charXhex(
               ixi:notrace($s,'string-value calls cXh on ' || $s) 
             )
         else $s
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
</div>

<div class="div">

<div class="quicknav"><span class="arrow"><a href="#ll-utils-strings">&#x23f4;</a></span><span class="arrow"><a href="#ll-utils">&#x23f6;</a></span><span class="arrow">&nbsp;</span></div><h4><a class="selflink" name="ll-utils-tracing" id="ll-utils-tracing" href="#ll-utils-tracing">4.7.2. </a>Trace routines</h4>
<div class="Real-P">For debugging, it's helpful to make traces a little easier.</div>
<div class="Real-P">First, a function to display an Earley item as a string.
<div class="scrap"><span><a name="d3e4780">&#x3008; 174 Define s X ei() to build string form of Earley item [continues <a href="#eri-utils-and-misc">168 Utilities for recognizer internals module</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   s X ei($E): a utility function to help make traces
   more legible.
   :)
declare function ixi:sXei(
  $E as map(xs:string, item())
) as xs:string {
  'item('
  || $E('from') || ' ' 
  || $E('to') || ' '
  || $E('rule')/@name || '/' || $E('ri')
  || ')'
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">Next, a function to build an XML element representing an Earley
item.  This is used less in tracing than in returning verbose results.
<div class="scrap"><span><a name="d3e4786">&#x3008; 175 Define eXei() to build 'item' element for Earley item [continues <a href="#eri-utils-and-misc">168 Utilities for recognizer internals module</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   e X ei($E):  a utility function to help make traces 
   and dumps more legible.
   :)
declare function ixi:eXei(
  $E as map(xs:string, item())
) as element(item) {
  element item {
    attribute from { $E('from') },
    attribute to { $E('to') },
    attribute rulemark { 
        $E('rule')/(@mark, @tmark)[1] 
    },
    attribute rulename { 
        $E('rule')/(@name, @xml:id)[1] 
    },
    attribute ri { $E('ri') }
    }
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">The actual trace function has two forms:  one for when
we want debugging and tracing turned on, and one for when
we want to turn it off globally.  There probably should be
better ways of turning tracing on and off. 
<div class="scrap"><span><a name="d3e4792">&#x3008; 176 Define trace() function for debugging [continues <a href="#eri-utils-and-misc">168 Utilities for recognizer internals module</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody"><span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-trace-function">Define trace() function 177</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#eri-notrace-function">Define notrace() function for debugging 179</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>
</div>
<div class="Real-P">The <i>ixi:trace()</i> function is just a wrapper around
the built-in trace function which inserts newlines. 
<div class="scrap"><span><a name="eri-trace-function">&#x3008; 177 Define trace() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   trace($i, $s):  a utility function to help make code 
   being traced stay more legible.
   :)
declare function ixi:trace(
  $x as item()?,
  $s as xs:string
) as item()? {
  trace($x, '&amp;#xA;' || $s || '&amp;#xA;')
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e4792">Define trace() function for debugging 176</a> &#x3009; <br></span>
</div>

An alternative form also inserts asterisks, but in general that proves
a little too busy.
<div class="scrap"><span><a name="d3e4807">&#x3008; 178 Starry trace() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function ixi:trace(
  $x as item()?, 
  $s as xs:string
) as item()? {
  trace(($x,'')[1], 
    '&amp;#xA;&amp;#xA;********&amp;#xA;' || $s || '&amp;#xA;')
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>

</div>
<div class="Real-P">It will be easier to turn tracing on and off at particular
locations if we also define a <i>notrace()</i> function, which
discards the string and returns the first argument. The dummy form
just throws away the string and returns the item in the first
argument.
<div class="scrap"><span><a name="eri-notrace-function">&#x3008; 179 Define notrace() function for debugging &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   notrace($i, $s):  a utility function to help make 
   code being traced stay more legible.
   :)
declare function ixi:notrace(
  $x as item()?,
  $s as xs:string
) as item()? {
  $x 
}; 
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e4792">Define trace() function for debugging 176</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The dummy form of <i>trace()</i> does the same thing
as <i>notrace()</i>
<div class="scrap"><span><a name="eri-trace-dummy">&#x3008; 180 Define trace() function for debugging &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   trace($i, $s):  a utility function to help make code 
   being traced stay more legible.
   :)
declare function ixi:trace(
  $x as item()?,
  $s as xs:string
) as item()? {
  $x 
}; 
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>

</div>
<div class="Real-P">We also want these available in other modules, like the
Gluschkov module.
<div class="scrap"><span><a name="gl-trace">&#x3008; 181 Define trace() function for debugging &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   trace($i, $s):  a utility function to help make code 
   being traced stay more legible.
   :)
declare function gl:trace(
  $x as item()?,
  $s as xs:string
) as item() {
  trace($x, '&amp;#xA;' || $s || '&amp;#xA;')  
};  
declare function gl:notrace(
  $x as item()?,
  $s as xs:string
) as item()? {
  $x 
}; 
(:
declare function gl:trace($x as item()?, $s as xs:string) as item() {
  $x 
};
:)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e1336">[File Gluschkov.xqm] 19</a> &#x3009; <br></span>
</div>

</div>

</div>
</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#lowlevel">&#x23f4;</a></span><span class="arrow"><a href="#toc">&#x23f6;</a></span><span class="arrow"><a href="#quarry">&#x23f5;</a></span></div><h2><a class="selflink" name="alt-calls" id="alt-calls" href="#alt-calls">5. </a>Alternative interfaces</h2><ul><li>5.1. <a href="#alt-calls-secondary">Secondary user-facing calls</a></li><li>5.2. <a href="#alt-calls-other">Non-user-facing functions</a></li></ul>
<div class="Real-P">The file Aparecium.xqm offers several different calls
intended for users of the library.  They are defined here.</div>


<div class="div">

<div class="quicknav"><span class="arrow">&nbsp;</span><span class="arrow"><a href="#alt-calls">&#x23f6;</a></span><span class="arrow"><a href="#alt-calls-other">&#x23f5;</a></span></div><h3><a class="selflink" name="alt-calls-secondary" id="alt-calls-secondary" href="#alt-calls-secondary">5.1. </a>Secondary user-facing calls</h3>

<div class="Real-P">There are a number of high-level functions for parsing and
compiling grammars; they are used by the primary interfaces and they
may be useful for users in particular circumstances; they are
defined here.
<div class="scrap"><span><a name="aparecium-secondary">&#x3008; 182 Secondary interfaces (a bit specialized) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   * Secondary interfaces (a bit more specialized) 
   ******************************************************
   :)
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ap2-pgfu">Define parse-grammar-from-uri() 183</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ap2-pgfs">Define parse-grammar-from-string() 184</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ap2-cgfu">Define compile-grammar-from-uri() 186</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ap2-cgfs">Define compile-grammar-from-string() 187</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ap2-cgfx">Define compile-grammar-from-xml() 188</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e339">[File Aparecium.xqm] 1</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The <i>parse-grammar-from-uri()</i> function
is given the URI of an ixml grammar and returns the XML 
representation of the grammar.  It   
retrieves the grammar and parses it by calling
<i>parse-grammar-from-string()</i>.
<div class="scrap"><span><a name="ap2-pgfu">&#x3008; 183 Define parse-grammar-from-uri() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   parse-grammar-from-uri($ixmlGrammar)
   ......................................................
:)
declare function aparecium:parse-grammar-from-uri(
  $uriG as xs:string
) as element() {
  aparecium:parse-grammar-from-uri(
      $uriG,
      $aparecium:options
  )
};
declare function aparecium:parse-grammar-from-uri(
  $uriG as xs:string,
  $options as map(*)
) as element() {
  let $sG := if (unparsed-text-available($uriG))
             then unparsed-text($uriG)
             else ()
  return if (exists($sG)) 
         then aparecium:parse-grammar-from-string(
                  $sG, 
                  $options
              )
         else element aparecium:error {
           attribute id { "ap:tbd14" },
           "Grammar (" || $uriG || ") not found."
         }
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#aparecium-secondary">Secondary interfaces (a bit specialized) 182</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">The <i>parse-grammar-from-string()</i> function is given
an ixml grammar as a string and returns the XML representation of
the grammar.  It parses the input grammar by calling
<i>parse-string-with-compiled-grammar()</i> with the ixml
grammar for ixml grammars.
<div class="scrap"><span><a name="ap2-pgfs">&#x3008; 184 Define parse-grammar-from-string() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   parse-grammar-from-string($ixmlGrammar)
   ......................................................
:)

declare function aparecium:parse-grammar-from-string(
  $G as xs:string
) as element() {
  aparecium:parse-grammar-from-string(
      $G,
      $aparecium:options
  )
};

declare function aparecium:parse-grammar-from-string(
  $G as xs:string,
  $options as map(*)
) as element() {
  (: CGIG:  compiled grammar for ixml grammars :)
  let $CGIG := doc($aparecium:ixml.gl.xml)/ixml,
      (: PG: parsed grammar :)
      $PG0 := aparecium:parse-string-with-compiled-grammar(
                  $G,
                  $CGIG,
                  $options
              ),
      $PG := (:stat ...prof:time( ... tats:)
             aparecium:grammar-ok($PG0, $options)
             (:stat ..., 'pgfs() calling grammar-ok():') ... tats:)
  return $PG
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#aparecium-secondary">Secondary interfaces (a bit specialized) 182</a> &#x3009; <br></span>
</div>

The call to <i>grammar-ok()</i> replaces
some earlier rudimentary checking, retained here
for the moment in case it's needed.
<div class="scrap"><span><a name="d3e4885">&#x3008; 185 Old code for result &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($PG/self::forest) 
      then trace($PG/ixml,
                 'Warning:  submitted grammar was ambiguous.') 
      else if ($PG/self::Goal) 
      then $PG/ixml 
      else if ($PG/self::ixml) 
      then $PG
      else &lt;ixml&gt;
        &lt;!--* Something is very wrong here *--&gt;
        { $PG }
      &lt;/ixml&gt;
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>

</div>
<div class="Real-P">The <i>compile-grammar-from-uri()</i> function
is given the URI of an ixml grammar and returns the
&#x2018;compiled&#x2019; form of the grammar.
<div class="scrap"><span><a name="ap2-cgfu">&#x3008; 186 Define compile-grammar-from-uri() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   compile-grammar-from-uri($ixmlGrammar)
   ......................................................
:)  

declare function aparecium:compile-grammar-from-uri(
  $uriG as xs:string
) as element() {
  aparecium:compile-grammar-from-uri(
    $uriG,
    $aparecium:options
  )
};

declare function aparecium:compile-grammar-from-uri(
  $uriG as xs:string,
  $options as map(*)
) as element() {
  let $xmlG := aparecium:parse-grammar-from-uri($uriG, $options)
  return gluschkov:ME($xmlG, $options)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#aparecium-secondary">Secondary interfaces (a bit specialized) 182</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The <i>compile-grammar-from-string()</i>
function takes an ixml grammar in string form and
returns the compiled representation of the grammar.  
<div class="scrap"><span><a name="ap2-cgfs">&#x3008; 187 Define compile-grammar-from-string() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   compile-grammar-from-string($ixmlGrammar)
   ......................................................
:)  
 
declare function aparecium:compile-grammar-from-string(
  $sG as xs:string
) as element() {
  aparecium:compile-grammar-from-string(
    $sG, 
    $aparecium:options
  )
};

declare function aparecium:compile-grammar-from-string(
  $sG as xs:string,
  $options as map(*)
) as element() {
  let $xmlG := aparecium:parse-grammar-from-string($sG)
  return gluschkov:ME($xmlG, $options)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#aparecium-secondary">Secondary interfaces (a bit specialized) 182</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">The <i>compile-grammar-from-xml()</i> function takes an
ixml grammar in XML form (a &#x2018;vxml grammar&#x2019;) and
returns its compiled representation.
<div class="scrap"><span><a name="ap2-cgfx">&#x3008; 188 Define compile-grammar-from-xml() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ......................................................
   compile-grammar-from-xml($ixmlGrammar)
   ......................................................
   Given the XML representation of an ixml grammar,
   returns an annotated representation of the grammar
   that makes it usable by the Earley parser.
:)   

declare function aparecium:compile-grammar-from-xml(
  $xmlG as element()
) as element(ixml) {
  aparecium:compile-grammar-from-xml(
    $xmlG,
    $aparecium:options
  )
};

declare function aparecium:compile-grammar-from-xml(
  $xmlG as element(),
  $options as map(*)
) as element(ixml) {
  let $G := (:stat ...prof:time( ... tats:)
            aparecium:grammar-ok($xmlG, $options)
            (:stat ..., 'cgfx() calling grammar-ok():') ... tats:)
  return if ($G/self::ixml)
         then gluschkov:ME($xmlG, $options)
         else element aparecium:error {
           attribute id { "ap:tbd15" },
           "compile-grammar-from-xml(): ",
           "Unable to compile grammar: ",
	   "grammar not ok."
         }
};

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#aparecium-secondary">Secondary interfaces (a bit specialized) 182</a> &#x3009; <br></span>
</div>

</div>
</div>

<div class="div">

<div class="quicknav"><span class="arrow"><a href="#alt-calls-secondary">&#x23f4;</a></span><span class="arrow"><a href="#alt-calls">&#x23f6;</a></span><span class="arrow">&nbsp;</span></div><h3><a class="selflink" name="alt-calls-other" id="alt-calls-other" href="#alt-calls-other">5.2. </a>Non-user-facing functions</h3>
<div class="Real-P">Some things are in the Aparecium module because
they have to be, even though they are of no interest
to library users.</div>
<div class="Real-P">
<div class="scrap"><span><a name="aparecium-tertiary">&#x3008; 189 Tertiary interfaces (of interest only for maintainer) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   * Tertiary interfaces (of interest only for maintainer) 
   ******************************************************
   :)

(: This is bootstrapping code (for building the Gluschkov
   automaton of the ixml grammar for ixml grammars.  It 
   should be run once whenever the grammar changes -- that 
   is, almost never.  But for now, it's here. 
   :)
  
(: Note that these don't save the result to disk; that's
   not automated yet.
   :)

   (: reparse-ixml-grammar(): produce fresh XML version :)
   
   (: The path starting from Goal on all these is a 
      temporary hack. :)
   
declare function aparecium:reparse-ixml-grammar(
) as element(ixml) {
  aparecium:parse-grammar-from-uri(
      $aparecium:ixml.ixml
  )/Goal/ixml
};
 
(: recompile-ixml-grammar(): produce fresh annotated XML
:)
declare function aparecium:recompile-ixml-grammar(
) as element(ixml) {
  aparecium:compile-grammar-from-uri(
      $aparecium:ixml.ixml
  )/Goal/ixml
};

<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ap-grok">The grammar-ok() function 52</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e339">[File Aparecium.xqm] 1</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Where are these things we may need? They really should be in a
collection, but collections are more complicated.  Maybe later.  So we
use global variables (sigh).
</div>
<div class="Real-P">It is embarrassing to move things around by changing these
strings, but ... that's what currently happens.
First, what directory are these things in?
<div class="scrap"><span><a name="d3e4937">&#x3008; 190 Location of library [continues <a href="#aparecium-variables">13 Variables (of interest only for maintainer)</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare variable $aparecium:libloc as xs:string
  := '../lib';
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

(Earlier values include 'http://blackmesatech.com/2018/demos/lib'
and 'http://localhost/~cmsmcq/blackmesatech.com/2019/demos/lib'.
The call <tt>Q{org.basex.util.Prop}HOMEDIR()</tt> is
helpful in BaseX.)
</div>
<div class="Real-P">Where is the master (local) copy of the ixml grammar 
for ixml grammars?  We have three forms:  the ixml grammar,
the &#x2018;visible XML&#x2019; representation of
the grammar, and the &#x2018;compiled&#x2019;
representation, with annotations describing each RHS as
an FSA.
<div class="scrap"><span><a name="d3e4950">&#x3008; 191 Location of ixml grammar [continues <a href="#aparecium-variables">13 Variables (of interest only for maintainer)</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare variable $aparecium:ixml.ixml as xs:string
  := $aparecium:libloc || '/ixml.2022-06-07.ixml';

declare variable $aparecium:ixml.xml as xs:string
  := $aparecium:libloc || '/ixml.2022-06-07.01.inlined.xml';
  
declare variable $aparecium:ixml.gl.xml as xs:string
  := $aparecium:libloc || '/ixml.2022-06-07.inlined.compiled.xml';  
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

<i>It may be premature, but I'm using a pre-processed ixml grammar
in which invisible nonterminals have been inlined.  (See the Makefile
for details of the pipeline.)</i>
</div>
<div class="Real-P">Maintenance note: to move to a new version of the ixml grammar, the
following steps should suffice:
<ol><li>Place the new ixml.ixml and ixml.xml into the library
  directory (embedding the date into the file name to reduce confusion
  later).</li>
<li>Update the scrap above to show the new filenames.</li>
<li>Compile the new grammar to the ...compiled.xml file.</li>
<li>Run regression tests.</li>
<li>Make comparison copy of compiled grammar; recompile; compare.
  Since the first compilation used the old grammar, and the second
  used the new grammar, the first and second compiled versions may
  differ; the second and third should not.</li>
</ol>
</div>
</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#alt-calls">&#x23f4;</a></span><span class="arrow"><a href="#toc">&#x23f6;</a></span><span class="arrow">&nbsp;</span></div><h2><a class="selflink" name="quarry" id="quarry" href="#quarry">6. </a>Unsorted bits of legacy code</h2><ul><li>6.1. <a href="#legacy-Earley-parser.xqm">Earley parser</a></li><li>6.2. <a href="#legacy-Earley-parser-internals.xqm">Parser internals</a><ul><li>6.2.1. <a href="#epi-earley-parse-function">The <i>earley-parse()</i> function</a><ul><li>6.2.1.1. <a href="#sec-epi-ep-failure">Handling parsing failures in <i>earley-parse()</i></a></li><li>6.2.1.2. <a href="#sec-epi-ep-success">Success cases in <i>earley-parse()</i></a></li><li>6.2.1.3. <a href="#sec-epi-ep-versioncheck">Checking the ixml version number</a></li></ul></li><li>6.2.2. <a href="#epi-tree-returns">Functions to return one or more trees</a><ul><li>6.2.2.1. <a href="#epi-trf-all-trees">The <i>all-trees()</i> function</a></li><li>6.2.2.2. <a href="#epi-trf-anytree">The <i>any-tree()</i> function</a></li><li>6.2.2.3. <a href="#epi-trf-cursor">The <i>tree-cursor()</i> function</a></li><li>6.2.2.4. <a href="#epi-trf-pfm">The <i>parse-forest-map()</i> function</a></li></ul></li><li>6.2.3. <a href="#epi-all-nodes">Finding a sequence of items for a single right-hand side</a></li><li>6.2.4. <a href="#epi-ast-from-raw">Extracting the abstract syntax tree from the raw parse tree</a><ul><li>6.2.4.1. <a href="#epi-ast-init">The initial call</a></li><li>6.2.4.2. <a href="#epi-ast-outer">The document-element constructor</a></li><li>6.2.4.3. <a href="#epi-ast-element">The element constructor</a></li><li>6.2.4.4. <a href="#epi-ast-attcoll">The attribute collector</a></li><li>6.2.4.5. <a href="#epi-ast-attvalue">The attribute value constructor</a></li><li>6.2.4.6. <a href="#epi-ast-content">The content collector</a></li></ul></li></ul></li></ul>	
<div class="Real-P">The first version of this document is being made
by taking the existing code and embedding it in
this document.  This section and its subsections
contain portions of the code that have not yet
been broken out into pieces.</div>



<div class="div">

<div class="quicknav"><span class="arrow">&nbsp;</span><span class="arrow"><a href="#quarry">&#x23f6;</a></span><span class="arrow"><a href="#legacy-Earley-parser-internals.xqm">&#x23f5;</a></span></div><h3><a class="selflink" name="legacy-Earley-parser.xqm" id="legacy-Earley-parser.xqm" href="#legacy-Earley-parser.xqm">6.1. </a>Earley parser</h3>
<div class="Real-P">The file Earley-parser.xqm has the top-level
function definitions for the parser.  These
functions call the recognizer and construct
a parse tree to return.</div>
<div class="Real-P">General remarks:
</div>
<div class="Real-P">We have a few problems, for which we might as well sketch our
solutions.
<ul><li><div class="Real-P">Some sentences are infinitely ambiguous; they have loops in their
derivation tree:  A is parent of sole child B is parent of sole child
A.</div>
<div class="Real-P">Solution;  cut out those loops, return only loopless trees.</div>
<div class="Real-P">Mechanism:  keep track of the set of ancestors in progress, don't
accept another node for the same nonterminal with the same frontier.</div>
<div class="Real-P">Alternative solution:  fix maximum height of a tree for a given frontier,
e.g. at 1 + number of non-terminals.  (Not an overall limit, just
a limit for a subtree with a fixed frontier.)</div>
</li>
<li><div class="Real-P">Some sentences are infinitely ambiguous: there may be zero or more
adjacent instances of nodes generating the empty string, e.g. in 
the RHS X*, Y, Z*.  (This is an EBNF-specific problem, not possible
for BNF.)</div>
<div class="Real-P">Solution:  cut out loops, return only loopless paths through a RHS.</div>
<div class="Real-P">Mechanism:  keep track of the states you have visited, don't accept
another node for the same state (RHS position, *not* nonterminal)
and the same frontier.</div>
<div class="Real-P">Alternative solution:  fix maximum width for sequence of zero-width
sibling nodes, e.t. at twice the number of positions in the RHS. </div>
</li>
<li><div class="Real-P">The user may want all trees, or one arbitrarily chosen tree, or one
tree with the option to fetch more.</div>
</li>
</ul>
</div>
<div class="Real-P">It's the job of <i>earley:parse()</i> to organize all of
this.  It accepts input, compiled grammar, and options, calls the
Earley recognizer to build the Earley set, and depending on the
options calls appropriate functions to produce the desired results.
It also takes care of wrapping the results in a container if
necessary, and flagging errors.</div>
<div class="Real-P">Description:
<ul><li><div class="Real-P"><b>Pre-requisites:</b></div>
<ul><li><div class="Real-P"></div></li>
</ul>
</li>
<li><div class="Real-P"><b>Invariants:</b></div>
<ul><li><div class="Real-P"></div></li>
</ul>
</li>
<li><div class="Real-P"><b>Post-conditions / assurances:</b></div>
<ul><li><div class="Real-P"></div></li>
</ul>
</li>
</ul></div>

</div>

<div class="div">

<div class="quicknav"><span class="arrow"><a href="#legacy-Earley-parser.xqm">&#x23f4;</a></span><span class="arrow"><a href="#quarry">&#x23f6;</a></span><span class="arrow">&nbsp;</span></div><h3><a class="selflink" name="legacy-Earley-parser-internals.xqm" id="legacy-Earley-parser-internals.xqm" href="#legacy-Earley-parser-internals.xqm">6.2. </a>Parser internals</h3><ul><li>6.2.1. <a href="#epi-earley-parse-function">The <i>earley-parse()</i> function</a><ul><li>6.2.1.1. <a href="#sec-epi-ep-failure">Handling parsing failures in <i>earley-parse()</i></a></li><li>6.2.1.2. <a href="#sec-epi-ep-success">Success cases in <i>earley-parse()</i></a></li><li>6.2.1.3. <a href="#sec-epi-ep-versioncheck">Checking the ixml version number</a></li></ul></li><li>6.2.2. <a href="#epi-tree-returns">Functions to return one or more trees</a><ul><li>6.2.2.1. <a href="#epi-trf-all-trees">The <i>all-trees()</i> function</a></li><li>6.2.2.2. <a href="#epi-trf-anytree">The <i>any-tree()</i> function</a></li><li>6.2.2.3. <a href="#epi-trf-cursor">The <i>tree-cursor()</i> function</a></li><li>6.2.2.4. <a href="#epi-trf-pfm">The <i>parse-forest-map()</i> function</a></li></ul></li><li>6.2.3. <a href="#epi-all-nodes">Finding a sequence of items for a single right-hand side</a></li><li>6.2.4. <a href="#epi-ast-from-raw">Extracting the abstract syntax tree from the raw parse tree</a><ul><li>6.2.4.1. <a href="#epi-ast-init">The initial call</a></li><li>6.2.4.2. <a href="#epi-ast-outer">The document-element constructor</a></li><li>6.2.4.3. <a href="#epi-ast-element">The element constructor</a></li><li>6.2.4.4. <a href="#epi-ast-attcoll">The attribute collector</a></li><li>6.2.4.5. <a href="#epi-ast-attvalue">The attribute value constructor</a></li><li>6.2.4.6. <a href="#epi-ast-content">The content collector</a></li></ul></li></ul>
<div class="Real-P">The file Earley-parser-internals has low-level
function definitions for the parser,
which are intended to be subject to change
with minimal or no effect on the higher-level
functions.</div>

<div class="div">

<div class="quicknav"><span class="arrow">&nbsp;</span><span class="arrow"><a href="#legacy-Earley-parser-internals.xqm">&#x23f6;</a></span><span class="arrow"><a href="#epi-tree-returns">&#x23f5;</a></span></div><h4><a class="selflink" name="epi-earley-parse-function" id="epi-earley-parse-function" href="#epi-earley-parse-function">6.2.1. </a>The <i>earley-parse()</i> function</h4><ul><li>6.2.1.1. <a href="#sec-epi-ep-failure">Handling parsing failures in <i>earley-parse()</i></a></li><li>6.2.1.2. <a href="#sec-epi-ep-success">Success cases in <i>earley-parse()</i></a></li><li>6.2.1.3. <a href="#sec-epi-ep-versioncheck">Checking the ixml version number</a></li></ul>
<div class="Real-P">The function <i>earley-parse()</i> runs the Earley
recognizer on the input and returns results as specified
by the user.
<div class="scrap"><span><a name="epi-earley-parse">&#x3008; 192 Define earley-parse() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   earley-parse($I, $G, $f);  run Earley recognizer on 
   input $I and grammar $G, return results using 
   $f($leiClosure, $Ec, $I, $G)
:)
declare function epi:earley-parse(
  $I as xs:string,
  $G as element(ixml),
  $options as map(xs:string, item()*)?
) as item()* {
  let $dummy := eri:notrace((), 'epi:earley-parse() ...') 

  let $options := 
      if (empty($options))
      then map { 'return': 'any-tree',
                 'tree-count': 2,
                 'failure-dump': 'closure' }
      else $options

  let $mapResult := (:stat ...prof:time( ... tats:)
                    er:recognizeX($I, $G, $options),
                    (:stat ...'0a recognize(): '),... tats:)

      $meiClosure := $mapResult('Closure'),
      $leiCompletions := $mapResult('Completions')

  let $leResults0 := if ($mapResult('Result'))
      then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ep-success">If we have a parse result, return it 193</a></em> &#x3009;</span>
      else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ep-failure">Return parse-failure result 194</a></em> &#x3009;</span>

  let $leResults := <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ep-versioncheck">Check results for version mismatch 203</a></em> &#x3009;</span>

  return $leResults
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">Other versions of this code are in &#x3008; <a href="#d3e6978">Define earley-parse()  (v. v0.2) 239</a> &#x3009; <br></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e434">[File Earley-parser-internals.xqm] 8</a> &#x3009; <br></span>
</div>

The return type of the function is unhelpfully loose, because the
results may take very different forms (see further below).
</div>
<div class="Real-P">
An earlier version of <i>earley-parse()</i> that used
higher-level functions is reproduced in <a href="#obs-hlf">an
appendix</a>.  In order to support engines that do not implement
higher-level functions, the code has been revised so the standard
interfaces don't use higher-level functions.</div>

<div class="Real-P">In the case of parsing success, the <i>mapResult</i>
will have a &#x201c;<tt>Result</tt>&#x201d; value.  How we return
it depends on what option the user specified.
<div class="scrap"><span><a name="epi-ep-success">&#x3008; 193 If we have a parse result, return it &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">       if ($options?return = 'all-trees')
       then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ep-all-trees">Return (approximately) all trees 195</a></em> &#x3009;</span>
       else if ($options?return = 'tree-cursor')
       then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ep-tree-cursor">Return a tree cursor 200</a></em> &#x3009;</span>
       else if ($options?return = 'parse-forest-map')
       then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ep-parse-forest-map">Return a parse-forest map 201</a></em> &#x3009;</span>
       else if ($options?return = 'parse-forest-grammar')
       then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ep-parse-forest-grammar">Return a parse-forest grammar 199</a></em> &#x3009;</span>
       else (: default to any-tree :)
            <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ep-any-tree">Return any tree 196</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-earley-parse">Define earley-parse() 192</a> &#x3009; <br></span>
</div>

The results returned may vary widely in type.
<ul><li><div class="Real-P">If the <tt>return</tt> option has the value
&#x201c;<tt>all-trees</tt>&#x201d;, the function returns a sequence of elements
with unpredictable names (if <tt>tree-form</tt> is &#x201c;<tt>raw</tt>&#x201d;
they will all be named &lt;<em>nt</em>&gt;, but normally they will all have
the grammar's start symbol as their element name).</div></li>
<li><div class="Real-P">If <tt>return</tt> is &#x201c;<tt>tree-cursor</tt>&#x201d;, the
function will (eventually, when tree cursors are implemented) return
pair consisting of an XML element (the parse tree) and a
function.</div></li>
<li><div class="Real-P">If <tt>return</tt> is &#x201c;<tt>parse-forest-map</tt>&#x201d;,
the return value is a map.</div></li>
<li><div class="Real-P">If <tt>return</tt> is &#x201c;<tt>parse-forest-grammar</tt>&#x201d;,
the function returns an &lt;<em>ixml</em>&gt; element.</div></li>
<li><div class="Real-P">If parsing fails, regardless of the <tt>return</tt> value,
the function returns a &lt;<em>no-parse</em>&gt; element.
<i>To do: move this to the Aparecium namespace, so that it
cannot collide with a user-specified name.</i></div></li>
</ul>
</div>


<div class="div">

<div class="quicknav"><span class="arrow">&nbsp;</span><span class="arrow"><a href="#epi-earley-parse-function">&#x23f6;</a></span><span class="arrow"><a href="#sec-epi-ep-success">&#x23f5;</a></span></div><h5><a class="selflink" name="sec-epi-ep-failure" id="sec-epi-ep-failure" href="#sec-epi-ep-failure">6.2.1.1. </a>Handling parsing failures in <i>earley-parse()</i></h5>
<div class="Real-P">But first, let's talk about the failure case.
As P.J. Brown points out, in real life the failure case
is much more common that the &#x2018;success&#x2019; case, so
the primary job of a program like Aparecium is to report errors and
help the user understand them; a secondary task is, occasionally, to
produce the prescribed results for error-free input.</div>
<div class="Real-P">At the moment, we just return a &lt;<em>no-parse</em>&gt; element, and if
the user asks for a verbose dump we provide it.
<div class="scrap"><span><a name="epi-ep-failure">&#x3008; 194 Return parse-failure result &#x3009;  &#x2261;</a></span>
<pre class="scrapbody"> (: otherwise, send an apology and explanation :)
  let $closure := &lt;Closure&gt;{
      let $mei := $mapResult('Closure')
      for $n in map:keys($mei('to'))
      order by $n descending
      for $ei in $mei('to')($n)
      return eri:eXei($ei)
  }&lt;/Closure&gt;

  let $high-water := $closure/item[1]/@to/number()
  let $start := max((1, (1 + $high-water - 30))),
      $end := min((string-length($I),
                   ($high-water + 30))),
      $cL := min(($high-water, 30)),
      $cR := min(($end - $high-water, 30)),
      $sL := concat(if ($high-water gt 30)
                    then '...'
                    else '',
                    substring($I, $start, $cL)
             ),
      $sR := concat(substring($I, $high-water+1, 30 (: $cR :) ),
                    if ($cR lt 30)
                    then ''
                    else '...'
             )
  return     
  &lt;ap:no-parse xmlns:ixml="http://invisiblexml.org/NS" ixml:state="failed"&gt;
    &lt;p&gt;Sorry, no parse for this string and grammar.&lt;/p&gt;
    &lt;p&gt;The parser gave up at character {$high-water}:
        parsing succeeded up through &lt;q&gt;{
          replace($sL,'&amp;#xA;','&amp;amp;#xA;')
        }&lt;/q&gt;
        but failed on &lt;q&gt;{
          replace($sR, '&amp;#xA;', '&amp;amp;#xA;')
        }&lt;/q&gt;&lt;/p&gt;
    &lt;p&gt;Expecting one of: {
        string-join(
           for $ei in $mapResult('Closure')('to')($high-water)
           for $sym in eri:lsymExpectedXEi($ei)[eri:fTerminal(.)]
           return concat('"', eri:reXTerminal($sym), '"'),
           ', ')
        }&lt;/p&gt;{
    if ($options?failure-dump eq 'no')
    then ()
    else if ($options?failure-dump eq 'closure')
    then $closure    
    else if ($options?failure-dump eq 'yes')
    then &lt;dump&gt;
    &lt;p&gt;The map is:&lt;/p&gt;
   
    &lt;Initial-Item&gt;{eri:eXei($mapResult('Initial-Item'))}&lt;/Initial-Item&gt;
    &lt;Input&gt;{$mapResult('Input')}&lt;/Input&gt;
    &lt;Input-Length&gt;{$mapResult('Input-Length')}&lt;/Input-Length&gt;
    &lt;Completions&gt;{
       for $ei in $mapResult('Completions')
       return eri:eXei($ei)
    }&lt;/Completions&gt;
    &lt;Result&gt;{$mapResult('Result')}&lt;/Result&gt;
    &lt;Closure&gt;{$closure}&lt;/Closure&gt;
    &lt;grammar&gt;{(: 'Omitted.' :) $mapResult('Grammar') }&lt;/grammar&gt;
    &lt;/dump&gt;
    else ()
  }&lt;/ap:no-parse&gt;
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-earley-parse">Define earley-parse() 192</a> &#x3009; <br></span>
</div>

Further work is needed here, I think (but this is
better than it used to be).
</div>
<div class="Real-P">In a related vein (it's not necessary a failure case but it is a
potentially useful diagnostic), we also flag the results with a
<tt>version-mismatch</tt> token in the <em>ixml:state</em>
attribute, if the input grammar specifies a version number not known
to Aparecium. See below (section <a href="#sec-epi-ep-versioncheck">6.2.1.3</a>, &#x201c;Checking the ixml version number&#x201d;).
</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#sec-epi-ep-failure">&#x23f4;</a></span><span class="arrow"><a href="#epi-earley-parse-function">&#x23f6;</a></span><span class="arrow"><a href="#sec-epi-ep-versioncheck">&#x23f5;</a></span></div><h5><a class="selflink" name="sec-epi-ep-success" id="sec-epi-ep-success" href="#sec-epi-ep-success">6.2.1.2. </a>Success cases in <i>earley-parse()</i></h5>
<div class="Real-P">Now back to the success cases.
</div>
<div class="Real-P">If the user asks for &#x201c;<tt>all-trees</tt>&#x201d;,
we call <i>epi:all-trees()</i> to make a
list of (raw) parse trees, then turn them into
the required XML.
<div class="scrap"><span><a name="epi-ep-all-trees">&#x3008; 195 Return (approximately) all trees &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">        let $dummy := eri:notrace((), 
                      'epi:earley-parse() has result') 

        let $lpt := (:stat ...prof:time(... tats:)
                    epi:all-trees($leiCompletions, $meiClosure, $I)
                    (:stat ..., '0b making trees: ')... tats:)
        let $dummy := eri:notrace((), 
                      'epi:earley-parse() returning a result') 
        for $rpt at $npt in $lpt
        return if ($options?tree-form eq 'raw')
        then $rpt
        else if ($options?tree-form eq 'both')
        then ($rpt, epi:astXparsetree($rpt, count($lpt)))
        else epi:astXparsetree($rpt, count($lpt))
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ep-success">If we have a parse result, return it 193</a> &#x3009; <br></span>
</div>

The current implementation of <i>epi:all-trees()</i> is
sometimes very slow.  An alternative method would be: construct a
parse-forest grammar, and from it construct the trees required.
Another alternative would be to rewrite the direct construction of
parse trees to be smarter and faster.</div>

<div class="Real-P">The &#x201c;<tt>any-tree</tt>&#x201d; option has not been implemented
separately. As a stop-gap we can call <i>all-trees()</i> and
throw all but the first away.  In pathological cases that will waste
a lot of cycles, but not in most normal cases.
Or we can call <i>parse-forest-grammar()</i> and
then extract an arbitrary tree from that.  We choose based
on the user's options, but default to the indirect approach,
which I expect to be faster.
<div class="scrap"><span><a name="epi-ep-any-tree">&#x3008; 196 Return any tree &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">        if ($options?tree-constructor eq 'direct')
        then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ep-any-direct">Construct one tree directly 197</a></em> &#x3009;</span>
        else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ep-any-via-pfg">Construct one tree via parse-forest-grammar 198</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ep-success">If we have a parse result, return it 193</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The &#x2018;direct&#x2019; approach is not
really very direct: we call <i>all-trees()</i>
to construct all the trees, and then choose one.
<div class="scrap"><span><a name="epi-ep-any-direct">&#x3008; 197 Construct one tree directly &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">        let $lpt := (:stat ...prof:time(... tats:)
                    epi:all-trees($leiCompletions, $meiClosure, $I)
                    (:stat ..., '0b making trees: ')... tats:)
        let $dummy := eri:notrace((), 
                      'epi:earley-parse() returning a result') 
        for $rpt in $lpt[1]
        return if ($options?tree-form eq 'raw')
        then $rpt
        else if ($options?tree-form eq 'both')
        then ($rpt, epi:astXparsetree($rpt, count($lpt)))
        else epi:astXparsetree($rpt, count($lpt))
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ep-any-tree">Return any tree 196</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The &#x2018;indirect&#x2019; approach via the parse-forest
grammar involves first a call to construct the grammar and then
a call to extract the tree.
<div class="scrap"><span><a name="epi-ep-any-via-pfg">&#x3008; 198 Construct one tree via parse-forest-grammar &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">        let $pfg := (:stat ...prof:time(... tats:)
                    epi:parse-forest-grammar($leiCompletions, $meiClosure, $I, $options),
                    (:stat ...'0b making pfg: '),... tats:)
            $ast := (:stat ...prof:time(... tats:)
                    epi:tree-from-pfg($pfg, 'document', ())
                    (:stat ..., '0c extracting tree: ')... tats:)
		    
        let $dummy := eri:notrace((), 
                      'epi:earley-parse() returning a result') 

        return if (1 eq 0) (: debugging hack, delete sometime :)
        then element ap:wrap { 
                   element ap:ast { $ast }, 
                   element ap:pfg { $pfg }
        } 
        else $ast

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ep-any-tree">Return any tree 196</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Parse-forest grammars require no post-processing.
<div class="scrap"><span><a name="epi-ep-parse-forest-grammar">&#x3008; 199 Return a parse-forest grammar &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">        let $dummy := eri:notrace((), 
                      'epi:earley-parse() has result') 

        let $pfg := (:stat ...prof:time(... tats:)
                    epi:parse-forest-grammar($leiCompletions, $meiClosure, $I, $options)
                    (:stat ..., '0b making pfg: ')... tats:)
        let $dummy := eri:notrace((), 
                      'epi:earley-parse() returning a parse-forest grammart') 
        return $pfg
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ep-success">If we have a parse result, return it 193</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The tree cursor has not been implemented yet.
<div class="scrap"><span><a name="epi-ep-tree-cursor">&#x3008; 200 Return a tree cursor &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  &lt;tree-cursor-not-available/&gt;
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ep-success">If we have a parse result, return it 193</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Parse-forest maps have not been implemented
yet.
<div class="scrap"><span><a name="epi-ep-parse-forest-map">&#x3008; 201 Return a parse-forest map &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  &lt;parse-forest-map-not-available/&gt;
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ep-success">If we have a parse result, return it 193</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#sec-epi-ep-success">&#x23f4;</a></span><span class="arrow"><a href="#epi-earley-parse-function">&#x23f6;</a></span><span class="arrow">&nbsp;</span></div><h5><a class="selflink" name="sec-epi-ep-versioncheck" id="sec-epi-ep-versioncheck" href="#sec-epi-ep-versioncheck">6.2.1.3. </a>Checking the ixml version number</h5>

<div class="Real-P">The <i>early-parse()</i> function is as good a place as we
seem to have, for checking that the version number specified on an
ixml grammar is in fact known to the processor.  It makes no
difference for processing: Aparecium only knows ixml version 1.0 and
we will use ixml 1.0 no matter what the input says.  The spec requires
it (otherwise no new version will ever succeed, since deployed parsers
will refuse to try to handle it).</div>
<div class="Real-P">But if the input grammar specifies a version string other than
&#x201c;<tt>1.0</tt>&#x201d;, we should inject an <em>ixml:state</em>
attribute on the root element with the value
&#x201c;<tt>version-mismatch</tt>&#x201d;.  If the result already has an
<em>ixml:state</em> attribute, then we add the
<tt>version-mismatch</tt> token to its value.</div>
<div class="Real-P">We do this by checking the results, before we return them.
<div class="scrap"><span><a name="epp-ep-versioncheck">&#x3008; 202 Check results for version mismatch &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ( ($G/prolog/version/@string
           /string(), "1.0")[1] eq "1.0")
      then $ast0 (: $leResults0 :)
      else for $item in $ast0 (: $leResults0 :)
           return if ($item instance of element())
           then element {name($item)} {
                  ($item/@* except 
                    ($item/@ixml:state,
                     $item/@ap:version-string,
                     $item/@ap:version-used)),
                  attribute ixml:state {
                    $item/@ixml:state/string(),
                    'version-mismatch'
                  },
                  attribute ap:version-string {
                    string($G/prolog/version/@string)
                  },
                  attribute ap:version-used {
                    "1.0"
                  },
                  $item/child::node()
                }
           else $item
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#ep-parse">Define earley:parse() 71</a> &#x3009; <br></span>
</div>
 
</div>
<div class="Real-P">Temporarily, we have a duplicate copy of this code.
<div class="scrap"><span><a name="epi-ep-versioncheck">&#x3008; 203 Check results for version mismatch &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ( ($G/prolog/version/@string
           /string(), "1.0")[1] eq "1.0")
      then $leResults0 
      else for $item in $leResults0 
           return if ($item instance of element())
           then element {name($item)} {
                  ($item/@* except 
                    ($item/@ixml:state,
                     $item/@ap:version-string,
                     $item/@ap:version-used)),
                  attribute ixml:state {
                    $item/@ixml:state/string(),
                    'version-mismatch'
                  },
                  attribute ap:version-string {
                    string($G/prolog/version/@string)
                  },
                  attribute ap:version-used {
                    "1.0"
                  },
                  $item/child::node()
                }
           else $item
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-earley-parse">Define earley-parse() 192</a> &#x3009; <br></span>
</div>
 
</div>
</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#epi-earley-parse-function">&#x23f4;</a></span><span class="arrow"><a href="#legacy-Earley-parser-internals.xqm">&#x23f6;</a></span><span class="arrow"><a href="#epi-all-nodes">&#x23f5;</a></span></div><h4><a class="selflink" name="epi-tree-returns" id="epi-tree-returns" href="#epi-tree-returns">6.2.2. </a>Functions to return one or more trees</h4><ul><li>6.2.2.1. <a href="#epi-trf-all-trees">The <i>all-trees()</i> function</a></li><li>6.2.2.2. <a href="#epi-trf-anytree">The <i>any-tree()</i> function</a></li><li>6.2.2.3. <a href="#epi-trf-cursor">The <i>tree-cursor()</i> function</a></li><li>6.2.2.4. <a href="#epi-trf-pfm">The <i>parse-forest-map()</i> function</a></li></ul>


<div class="div">

<div class="quicknav"><span class="arrow">&nbsp;</span><span class="arrow"><a href="#epi-tree-returns">&#x23f6;</a></span><span class="arrow"><a href="#epi-trf-anytree">&#x23f5;</a></span></div><h5><a class="selflink" name="epi-trf-all-trees" id="epi-trf-all-trees" href="#epi-trf-all-trees">6.2.2.1. </a>The <i>all-trees()</i> function</h5>
<div class="Real-P">If the user wants all trees, we call the <i>all-trees()</i>
function.</div>
<div class="Real-P">For each completion item in $Ec, we return all parse trees for the
nonterminal $n in $Ec's left-hand side, as documented by $Closure
(a set of Earley items closed over scan(), pred(), and comp().</div>
<div class="Real-P">The result will be one or more elements for nonterminal <tt>$n</tt>.</div>
<div class="Real-P">The main function generates an empty vertical stack (to prevent
looping on infinite sets of trees with unbounded vertical depth)
and calls an auxiliary function to do the work.
<div class="scrap"><span><a name="epi-all-trees">&#x3008; 204 Define all-trees() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   all-trees($Closure, $Ec, $I, $G):  
:)
declare function epi:all-trees(
  $leiCompletions as map(*)*,
  $meiClosure as map(xs:string,
                     map(xs:integer,
                         map(xs:string, item())*)) 
                 (:MEI:),
  $I as xs:string
  (: $G as element(ixml) :)
) as element()* {
  (: Call auxiliary routine with a vertical stack for
     loop prevention. :)
  epi:all-trees($leiCompletions, $meiClosure, $I, ())
};
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e5325">Define auxiliary function for all-trees() 205</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e434">[File Earley-parser-internals.xqm] 8</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">The auxiliary function for generating all trees is initially called
for the item (0 $n Goal $q_final), but it's called again recursively,
once for every completion relevant to the tree(s) we are constructing.
<div class="scrap"><span><a name="d3e5325">&#x3008; 205 Define auxiliary function for all-trees() [continues <a href="#epi-all-trees">204 Define all-trees()</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   all-trees#5:  auxiliary function (more args, does the 
   work) 
:)
   
declare function epi:all-trees(
  $leiCompletions as map(*)*,
  $meiClosure as map(xs:string,
                     map(xs:integer,
                         map(xs:string, item())*)) (:MEI:),
  $I as xs:string,
  $leiVStack as map(*)*
  (: $G as element(ixml) :)
) as element()* {
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-all-trees-for">Iterate over the list of completion items 206</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-all-trees-call-ans">Get the sequences, or rather raw parse trees 207</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-all-trees-return-trees">Return the raw parse trees 208</a></em> &#x3009;</span>
}; 
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">For every original completion item in <tt>$leiCompletions</tt>,
return parse trees for its nonterminal.
<div class="scrap"><span><a name="epi-all-trees-for">&#x3008; 206 Iterate over the list of completion items &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  for $Ec at $nEc in $leiCompletions
             [not(
               some $eiV in $leiVStack
               satisfies deep-equal(.,$eiV)
             )]
  
  let $dummy := eri:notrace($Ec,
    'all-trees called with item '
    || $nEc || ' (of ' || count($leiCompletions)
    || ') = ' || eri:sXei($Ec) 
  )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e5325">Define auxiliary function for all-trees() 205</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">Here, <tt>$Ec</tt> is the completion item for
a nonterminal <tt>$n</tt>.
Its LHS tells us which nonterminal.
Its <i>from</i> and
<i>to</i> positions tell us the frontier
generated by <tt>$n</tt>.
</div>
<div class="Real-P">For each sequence <tt>$ln</tt> of adjacent nodes that
<ul><li>span the range <i>From</i> .. <i>To</i>, and</li>
<li>constitute a path through the RHS of <tt>$n</tt>,</li>
</ul>
return a raw parse-tree element for <tt>$n</tt> with content
<tt>$ln</tt>.
</div>
<div class="Real-P">
We want one parse tree for each possible sequence <tt>$ln</tt>,
but in order to iterate over them, we need to wrap them up in
something (since XDM sequences don't nest).  We will wrap them up in
elements (of type &lt;<em>nt</em>&gt;).  So in fact when we get the sequences
back, they will already be wrapped up in the element; all we need to
do is return them.
<div class="scrap"><span><a name="epi-all-trees-call-ans">&#x3008; 207 Get the sequences, or rather raw parse trees &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $parsetrees := epi:all-node-sequences(
    $Ec,
    $meiClosure,
    (),
    $Ec('from'), 
    $Ec('to'), 
    $I,
    ($Ec, $leiVStack),
    ()
  )</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e5325">Define auxiliary function for all-trees() 205</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">Once we get the trees, we just return them.
<div class="scrap"><span><a name="epi-all-trees-return-trees">&#x3008; 208 Return the raw parse trees &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  for $parsetree in $parsetrees
  let $dummy := eri:notrace($parsetree,
    'all-trees got this parsetree back from item Ec = ' || eri:sXei($Ec))
  return $parsetree 
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e5325">Define auxiliary function for all-trees() 205</a> &#x3009; <br></span>
</div>
</div>
</div>

<div class="div">

<div class="quicknav"><span class="arrow"><a href="#epi-trf-all-trees">&#x23f4;</a></span><span class="arrow"><a href="#epi-tree-returns">&#x23f6;</a></span><span class="arrow"><a href="#epi-trf-cursor">&#x23f5;</a></span></div><h5><a class="selflink" name="epi-trf-anytree" id="epi-trf-anytree" href="#epi-trf-anytree">6.2.2.2. </a>The <i>any-tree()</i> function</h5>
<div class="Real-P">If the user wants an arbitrary tree -- well, for now they are 
out of luck. 
<div class="scrap"><span><a name="epi-any-tree">&#x3008; 209 Define any-tree() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:any-tree(
  $leiCompletions as map(*)*,
  $leiClosure as map(*)*,
  $I as xs:string
) as element()* {
  &lt;any-tree-not-implemented-yet/&gt;
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e434">[File Earley-parser-internals.xqm] 8</a> &#x3009; <br></span>
</div>
</div>
</div>

<div class="div">

<div class="quicknav"><span class="arrow"><a href="#epi-trf-anytree">&#x23f4;</a></span><span class="arrow"><a href="#epi-tree-returns">&#x23f6;</a></span><span class="arrow"><a href="#epi-trf-pfm">&#x23f5;</a></span></div><h5><a class="selflink" name="epi-trf-cursor" id="epi-trf-cursor" href="#epi-trf-cursor">6.2.2.3. </a>The <i>tree-cursor()</i> function</h5>
<div class="Real-P">We want (eventually) to provide an interface for a kind of
&#x2018;tree cursor&#x2019;, which will allow the user to
iterate over the set of parse trees in the same way as a cursor
in SQL allows the application to read a sequence of results.
In XQuery, the basic idea is to return not a tree but a pair
consisting of (a) a tree and (b) a function to call to get
the next pair.  If there is a finite set of trees, then on
the last tree no function will be returned (or a special function
that raises a particular error when called?).</div>
<div class="Real-P">But for the moment, this is just a stub.
<div class="scrap"><span><a name="epi-tree-cursor">&#x3008; 210 Define tree-cursor() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:tree-cursor(
  $leiCompletions as map(*)*,
  $leiClosure as map(*)*,
  $I as xs:string
) as element()* {
  &lt;tree-cursor-not-implemented-yet/&gt;
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e434">[File Earley-parser-internals.xqm] 8</a> &#x3009; <br></span>
</div>
</div>
</div>

<div class="div">

<div class="quicknav"><span class="arrow"><a href="#epi-trf-cursor">&#x23f4;</a></span><span class="arrow"><a href="#epi-tree-returns">&#x23f6;</a></span><span class="arrow">&nbsp;</span></div><h5><a class="selflink" name="epi-trf-pfm" id="epi-trf-pfm" href="#epi-trf-pfm">6.2.2.4. </a>The <i>parse-forest-map()</i> function</h5>
<div class="Real-P">Also a stub are functions to return results in the form
of parse forests.  One is a function which when completed
should return a parse-forest map, that is a data structure
with a directed graph containing all parse trees as sub-graphs.
<div class="scrap"><span><a name="epi-parse-forest-map">&#x3008; 211 Define parse-forest-map() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:parse-forest-map(
  $leiCompletions as map(*)*,
  $leiClosure as map(*)*,
  $I as xs:string
) as map(*) {
  map { 'Result' : &lt;parse-forest-map-not-implemented-yet/&gt; }
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e434">[File Earley-parser-internals.xqm] 8</a> &#x3009; <br></span>
</div>
</div>
</div>
</div>

<div class="div">

<div class="quicknav"><span class="arrow"><a href="#epi-tree-returns">&#x23f4;</a></span><span class="arrow"><a href="#legacy-Earley-parser-internals.xqm">&#x23f6;</a></span><span class="arrow"><a href="#epi-ast-from-raw">&#x23f5;</a></span></div><h4><a class="selflink" name="epi-all-nodes" id="epi-all-nodes" href="#epi-all-nodes">6.2.3. </a>Finding a sequence of items for a single right-hand side</h4>
<div class="Real-P">One crucial step in finding a tree in the Earley set is
to identify a sequence of items that describe a path through
the right-hand side of a given rule.</div>
<div class="Real-P">The inspiration for the approach used here
is Maarten van Emden's solution to the Eight Queens problem at 
<a href="https://vanemden.wordpress.com/2008/04/27/programming-language-x/">https://vanemden.wordpress.com/2008/04/27/programming-language-x/</a>.
There is no code for stopping when you get a solution, no
overt backtracking,
just full speed ahead over all possibilities.</div>
<div class="Real-P">The result is a depth-first search which turns out in hindsight to
have some very unfortunate properties.  It's harder to understand than
I would like, and it has no form of memoization so given appropriate
input it may solve some subproblems many many times, with horrifying
effects on run time.</div>
<div class="Real-P">To perform this task, we define a function
<i>epi:all-node-sequences</i>(<tt>$item</tt>,
<tt>$closure</tt>, <tt>$acc</tt>, <tt>$from</tt>,
<tt>$to</tt>, <tt>$I</tt>), which iterates selectively (by
recursion) over elements in <tt>$closure</tt> to find items which
form a path through the RHS of a given rule in <i>G</i>.  The items have
the following properties.
<ul><li>All items in the path-sequence have locations in the same rule
for some non-terminal <tt>$n</tt>, namely
<tt>$item('rule')</tt>.  (If they didn't have that rule, they
could not describe a path through its RHS.)</li>
<li>All items in the path-sequence have the same
<i>from</i>-position (= <tt>$from</tt>).  (If they did
not, they would not describe a single instance of the rule's
nonterminal.)</li>
<li>The first item has <i>from</i>-position =
<i>to</i>-position = <tt>$from</tt>; that is, it is the
item produced by the predictor for an instance of the
nonterminal.</li>
<li>The last item has <i>from</i>-position =
<tt>$from</tt> and <i>to</i>-position =
<tt>$to</tt>; that is, it's the completion item for
one instance of the nonterminal.</li>
<li>Each item in the path-sequence advances the path by one symbol;
that is, for any two adjacent items
<i>EI</i>[<i>i</i>]
with <i>to</i> = <i>p1</i> 
and
<i>EI</i>[<i>i</i>+1]
with <i>to</i> = <i>p2</i>, either
<ul><li><i>EI</i>[<i>i</i>+1] will be the value of
<i>scan</i>(<i>E</i>[<i>i</i>],
<tt>$I</tt>) &#x2014; in this case,
<tt>$I</tt>[<i>p1</i> .. <i>p2</i>] matches the
terminal <i>EI</i>[<i>i</i>+1]('ri') &#x2014; or </li>
<li><i>EI</i>[<i>i</i>+1] will be the value of
<i>comp</i>(<i>EIc</i>,
<i>EI</i>[<i>i</i>]) for some <i>EIc</i> in
<tt>$closure</tt>.  In this case, <tt>$closure</tt> will
include some completion item <i>EIc</i> with
<i>from</i> = <i>p1</i>, <i>to</i> =
<i>p2</i>, <i>nonterminal</i> =
<i>EI</i>[<i>i</i>+1]('ri').</li>
</ul>
</li>
</ul>
</div>
<div class="Real-P">At each step (i.e. on each call to this function) we identify one
more item in the sequence.  There may be more than one (because there
may be multiple paths); if so, we iterate recursively on each of them
because we want all node sequences.
</div>
<div class="Real-P">The sequence we find is not represented explicitly, but implicitly
by the sequence of items passed as the current $item (in reverse
order, since we start with the completion).
</div>
<div class="Real-P">Along the way, we accumulate (in <tt>$acc</tt>) raw parse-tree
nodes corresponding to the path:
<ul><li><div class="Real-P">For normal <i>scan()</i> steps,

we create &lt;<em>lit</em>&gt;, &lt;<em>incl</em>&gt;, or &lt;<em>excl</em>&gt; elements
recording the matching string, with the <em>tmark</em> of the
terminal symbol </div></li>
<li><div class="Real-P">For <i>comp()</i> steps, we create &lt;<em>nt</em>&gt;
elements, with <em>name</em> and <em>mark</em> recording the
appropriate GI and annotation, and with content (found by a recursive
call) showing the raw parse tree for that nonterminal; if there is
more than one, we iterate over all of them.</div></li>
</ul>
</div>
<div class="Real-P">The function returns zero or more elements whose name is that on
the left-hand-side of <tt>$item</tt>, whose string value is the
input substring <tt>$from</tt> .. <tt>$to</tt>, and whose
children are the concatenation of (a) the children found by the
recursive call, with (b) those in the accumulator.
<div class="scrap"><span><a name="epi-all-node-sequences">&#x3008; 212 Define all-node-sequences() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   epi:all-node-sequences($item, $closure, 
                          $acc, 
                          $from, $to, $I)
:)
declare function epi:all-node-sequences(
  $Ecur as map(*),
  $meiClosure as map(xs:string, 
                     map(xs:integer, 
                         map(xs:string, 
                             item())*)),
  $lnAcc as item()*,
  $pFrom as xs:integer,
  $pTo as xs:integer,
  $I as xs:string,
  $leiVStack as map(*)*,
  $leiHStack as map(*)*
) as element()* {
  
  let $dummy := eri:notrace(eri:sXei($Ecur),
    'all-node-seqs (0) called with Ecur:')
  return 
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-loopcheck">Check for loops, which mean infinite ambiguity 213</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-basecase">Handle base case:  current item is initial 214</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-recursive">Handle recursive case 217</a></em> &#x3009;</span>  
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e434">[File Earley-parser-internals.xqm] 8</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Before we do any work, we should check to see whether we have
already dealt with this item, in this sequence of nodes.  If we have,
then we are looking at a sentence with an infinite number of parse
trees, and we need to snip the loop.
<div class="scrap"><span><a name="epi-ans-loopcheck">&#x3008; 213 Check for loops, which mean infinite ambiguity &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  (: 1. Before anything else, loop detection:  have we already 
     dealt with this item, in this sequence of nodes? :)
  if (some $eiH in $leiHStack satisfies deep-equal($Ecur, $eiH) )
  then let $dummy := eri:notrace(eri:sXei($Ecur),
           'all-node-seqs (case 1) returns empty sequence, '
           || 'current item has been seen before.')
       return ()
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-all-node-sequences">Define all-node-sequences() 212</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">The base case, on which we terminate because it means we have
completed the node sequence, is when the current Earley item is
initial.  The detection of this case is simplified by the fact that
all initial states are named q0, and only initial states are named q0.
So when we find such a state, we just wrap everything up and return it
to the caller.</div>
<div class="Real-P">N.B. we always return an element, regardless of how our
non-terminal is marked, but we pass the @mark attribute along
so the caller can convert the element to an attribute, or
replace it with its children, in a later pass which constructs
the AST from the raw parse tree.
<div class="scrap"><span><a name="epi-ans-basecase">&#x3008; 214 Handle base case:  current item is initial &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  (: 2. Base case:  $Ecur is initial. :)
  else if ($Ecur('ri') = 'q0'
      and $Ecur('from') eq $Ecur('to')
      and $Ecur('from') eq $pFrom)
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e5674">Construct an element holding the node sequence 215</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-all-node-sequences">Define all-node-sequences() 212</a> &#x3009; <br></span>
</div>

For a state named q0, from = to should always be true.
And for all q0, from = $pFrom should also always be true,
or should follow from the tests made by the caller. 
But we check anyway.  I don't trust this belt, and I don't trust 
these suspenders. </div>
<div class="Real-P">On the output element, we record the input span in
attributes named <em>_from</em> and <em>_to</em>,
and the mark.
<i>And for the moment, as a debugging measure, we also
see whether we can successfully identify the RHS nonterminal
that led to the prediction of this nonterminal.  We already
have a little context information in the form of 
the vertical stack <tt>$leiVStack</tt>,
the horizontal stack <tt>$leiHStack</tt>,
and the node list <tt>$lnAcc</tt>.
Let's examine the tops of those stacks.</i>
<div class="scrap"><span><a name="d3e5674">&#x3008; 215 Construct an element holding the node sequence [continues <a href="#epi-ans-basecase">214 Handle base case:  current item is initial</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  then 
    let $e := element nt {
                 $Ecur('rule')/@name,
                 attribute _from { $pFrom }, 
                 attribute _to { $pTo }, 
                 ( $Ecur('rule')/descendant::*
                                [@xml:id = $Ecur('ri')]
				/@mark
                   ,
                   $Ecur('rule')/@mark,
		   attribute mark { '^' }
                 )[1],
                 $lnAcc
               },
        $trace := eri:notrace(eri:sXei($Ecur),
                      'all-node-seqs (case 2) returns element ' 
		      || 'named ' || name($e) || ' for Ecur:')
    return $e
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">For safekeeping, here is the earlier version of this.
It used the nonterminal name as the GI for the element,
and it tried to handle attributes first.  Both of those
should now be handled by the AST constructor.
<div class="scrap"><span><a name="d3e5680">&#x3008; 216 Construct an element holding the node sequence [continues <a href="#epi-ans-basecase-2016"></a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  then 
    let $e := element {$Ecur('rule')/@name} {
                 attribute _from { $pFrom },
                 attribute _to { $pTo },
                 ( $Ecur('rule')/descendant::*
                                [@xml:id = $Ecur('ri')]
				/@mark
                   ,
                   $Ecur('rule')/@mark
                 )[1],
                 $lnAcc[self::attribute()],
                 $lnAcc[not(self::attribute())]                 
               },
        $trace := eri:notrace(eri:sXei($Ecur),
                      'all-node-seqs (case 2) returns element ' 
		      || 'named ' || name($e) || ' for Ecur:')
    return $e
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>

<div class="Real-P">In the recursive case, <tt>$Ecur</tt> shows, in its rule
location (= FSA state name or position), what symbol <tt>$sym</tt>
we must jump back past.  For example, if <tt>$Ecur</tt> is &#x201c;(0 8
Goal/ixml_0)&#x201d; (as it will be when we are constructing an XML
representation of an ixml grammar eight characters long), then we know
from the rule index <tt>ixml_0</tt> that we now need to find a
parse for <i>ixml</i> ending at position 8, and then
work out where that instance of <i>ixml</i> started.
</div>
<div class="Real-P">Find the item <tt>$eiPrev</tt> that was expecting that symbol
(there may be many); for each such item <tt>$eiPrev</tt>, the
Earley set documents a parse of <tt>$sym</tt> that dominates (or
generates) the input range from <tt>$eiPrev('to')</tt> to
<tt>$Ecur('to')</tt>.  In the example, we will first find
<tt>$sym</tt>, the nonterminal with an ID of <tt>ixml_0</tt>
in the rule for <i>Goal</i>.  How we look for
<tt>$eiPrev</tt> depends on what <tt>$sym</tt> is.
<div class="scrap"><span><a name="epi-ans-recursive">&#x3008; 217 Handle recursive case &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  (: 3. Recursive case. :)
  else (: 3. $Ecur('ri') is not a q0 / initial state :)
    (: 3.a some preparation common to T and N alike :)
    let $riCur := $Ecur('ri'),
        $sym := $Ecur('rule')/descendant::*[@xml:id = $riCur],
        $nParent := $Ecur('rule')/@name/string()
    return
      <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-rec-terminal">Handle recursion on terminal 218</a></em> &#x3009;</span>
      <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-rec-nonterminal">Handle recursion on nonterminal 220</a></em> &#x3009;</span>
      <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-rec-whazzat">Raise error if neither terminal nor nonterminal 225</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-all-node-sequences">Define all-node-sequences() 212</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">If <tt>$sym</tt> is terminal, then our clue for finding <tt>$eiPrev</tt>
is that the relation <tt>scan($eiPrev, $I) =
$Ecur</tt> holds. Find it, and then push
appropriate raw parse nodes 
onto the accumulator and recur.
Or rather, since there may be more than one,
find <em>them</em> (in <tt>$leiPrev</tt>) and then
recur on each of them, pushing the newly created parse node
<tt>$textnode</tt> onto the accumulator.
<div class="scrap"><span><a name="epi-ans-rec-terminal">&#x3008; 218 Handle recursion on terminal &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      (: 3.b current $sym is terminal :)
      if (eri:fTerminal($sym)) then
         let $trace := eri:notrace(eri:sXei($Ecur),
                       'all-node-seqs (case 3b) '
                       || 'unscanning terminal symbol '
		       || $riCur) 
         let $cSymlength := eri:match-length($sym),
             $pMedial := xs:integer($Ecur('to')) - $cSymlength,
             $leiPrev := $meiClosure('to')($pMedial)[ 
                eri:fScanrelEE(.,$Ecur)
                (: and xs:integer(.('to')) eq $pMedial :)
             ],
	     $sVal := substring($I,$pMedial+1,$cSymlength),
	     
             $textnode := element { 
                (: Rename the terminal to reduce confusion
                between grammar and parse tree :)
                if ($sym/self::inclusion) 
                then 'incl' 
                else if ($sym/self::exclusion) 
                then 'excl' 
                else if ($sym/self::literal)
                then 'lit' 
		else 'terminal---'
	     } {
	        $sym/@xml:id, 
		$sym/@tmark,
	        $sym/@regex, 
		attribute string { $sVal },
		attribute cps { string-to-codepoints($sVal) }
             }

         (: recur on each possible previous node :)
         for $eiPrev in $leiPrev
         let $trace := if (count($leiPrev) gt 1)
	               then eri:notrace(eri:sXei($Ecur),
                            'all-node-seqs (case 3b) finds '
			    || count($leiPrev)
                            || ' predecessors, now recurring on eiPrev='
			    || eri:sXei($eiPrev))
		       else eri:notrace(eri:sXei($Ecur),
                            'all-node-seqs (case 3b) finds '
		            || count($leiPrev)
                            || ' predecessors, now recurring on eiPrev='
			    || eri:sXei($eiPrev))

         return epi:all-node-sequences($eiPrev,
                                       $meiClosure,
                                       ($textnode, $lnAcc),
                                       $pFrom,
                                       $pTo,
                                       $I,
                                       $leiVStack,
                                       ($Ecur, $leiHStack)
                                      )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ans-recursive">Handle recursive case 217</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">The initial version rendered terminals as text nodes and not as
elements.  So it had no place to put a <em>tmark</em>.
<div class="scrap"><span><a name="epi-ans-rec-terminal-2016">&#x3008; 219 Handle recursion on terminal &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      (: 3.b current $sym is terminal :)
      if (eri:fTerminal($sym)) then
         let $trace := eri:notrace(eri:sXei($Ecur),
                       'all-node-seqs (case 3b) '
                       || 'unscanning terminal symbol '
		       || $riCur) 
         let $cSymlength := eri:match-length($sym),
             $pMedial := xs:integer($Ecur('to')) - $cSymlength,
             $leiPrev := $meiClosure('to')($pMedial)[ 
                eri:fScanrelEE(.,$Ecur)
                (: and xs:integer(.('to')) eq $pMedial :)
              ],
             $textnode := text { substring($I,$pMedial+1,$cSymlength) }
             (: let $trace := eri:notrace($textnode,
	                      'Adding a text node: ') :)
         (: recur on each possible previous node :)
         for $eiPrev in $leiPrev
         let $trace := if (count($leiPrev) gt 1)
	               then eri:notrace(eri:sXei($Ecur),
                            'all-node-seqs (case 3b) finds '
			    || count($leiPrev)
                            || ' predecessors, now recurring on eiPrev='
			    || eri:sXei($eiPrev))
		       else eri:notrace(eri:sXei($Ecur),
                            'all-node-seqs (case 3b) finds '
		            || count($leiPrev)
                            || ' predecessors, now recurring on eiPrev='
			    || eri:sXei($eiPrev))

         return epi:all-node-sequences($eiPrev,
                                       $meiClosure,
                                       ($textnode, $lnAcc),
                                       $pFrom,
                                       $pTo,
                                       $I,
                                       $leiVStack,
                                       ($Ecur, $leiHStack)
                                      )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>

</div>
<div class="Real-P">If <tt>$sym</tt> is nonterminal, we can find
<tt>$eiPrev</tt> by exploiting the fact that the relation
<tt>comp($EComp, $eiPrev, $G) = $Ecur</tt> holds.  The closure
should include at least one completion item of the form
(<tt>$eiPrev('to')</tt>, <tt>$Ecur('to')</tt>,
<tt>$sym</tt>, <tt>$ri</tt>), where <tt>$ri</tt> is a
final state of a rule for <tt>$sym</tt>.
</div>
<div class="Real-P">We're going to break this down into steps.
First, just identify this case (and possibly issue
a trace message).
<div class="scrap"><span><a name="epi-ans-rec-nonterminal">&#x3008; 220 Handle recursion on nonterminal &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      (: 3.c current $sym is nonterminal :)
      else if ($sym/self::nonterminal) then 
         let $trace := eri:notrace(eri:sXei($Ecur), 
                       'all-node-seqs (case 3c) '
		       || 'trying to unparse nonterminal '
		       || $riCur) 
         <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-recnt-leiprev">Find the child completions for $sym 221</a></em> &#x3009;</span>
         <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-recnt-lnodechild">Find parse trees for the child completions 222</a></em> &#x3009;</span>
         <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-recnt-recur">Recur on each predictor 223</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ans-recursive">Handle recursive case 217</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">Then find all completion items (<tt>$leiPrev</tt>) for
nonterminal <tt>$sym</tt> finishing at this position.  That is, if
<tt>$sym</tt> is a RHS reference to <i>ixml</i>, the
completion items will have the form (<i>start</i>,
<i>to</i>, <i>ixml</i>/<i>q_f</i>).  What we
want is every item in the closure which (a) has the right
<i>to</i>-position and (b) is final for the right nonterminal.
<div class="scrap"><span><a name="epi-ans-recnt-leiprev">&#x3008; 221 Find the child completions for $sym &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">         let $leiPrev := $meiClosure('to')($Ecur('to'))[
           eri:fFinalEiPN(.,$Ecur('to'),$sym)
         ]
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ans-rec-nonterminal">Handle recursion on nonterminal 220</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Now, for each child completion, find all possible parse trees, and
then find all possible predictor items for <tt>$sym</tt> at the
start position of the completion item.  That is, all items ending
at that position, for which <tt>$sym</tt> is in the follow set.
<div class="scrap"><span><a name="epi-ans-recnt-lnodechild">&#x3008; 222 Find parse trees for the child completions &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">         for $eiCC at $nEiCC in $leiPrev
         let $trace := eri:notrace(eri:sXei($Ecur),
	       'all-node-seqs (case 3c) finds completion item '
               || '(' || $nEiCC || ' of '
	       || count($leiPrev) || ')'
               || ' for ' || $sym/@name
	       || ', namely ' || eri:sXei($eiCC)
	       || ' and calls all-trees for it.')
         let $lnodeChild := epi:all-trees($eiCC,
                                          $meiClosure,
	                                  $I,
					  $leiVStack), 
             $leiPredictors := $meiClosure('to')($eiCC('from'))
	                       [eri:fAdvanceNrelEE(.,$Ecur)
                                (: and .('to') eq $eiCC('from') :)]

	 (:
         let $trace := for $nCh in $lnodeChild
                       return eri:notrace($nCh,
                              'all-node-seqs got this back'
			      || ' from all-trees:') 
         :)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ans-rec-nonterminal">Handle recursion on nonterminal 220</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">For each pair of parse tree and predictor item,
we need to recur appropriately.
<div class="scrap"><span><a name="epi-ans-recnt-recur">&#x3008; 223 Recur on each predictor &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">         for $eiPred at $nEiP in $leiPredictors
         let $trace := eri:notrace(eri:sXei($Ecur),
	       'all-node-seqs (case 3c) finds predictor '
               || '(' || $nEiP || ' of '
	       || count($leiPredictors) || ')'
               || ' for ' || $sym/@name
	       || ', namely ' || eri:sXei($eiPred))
         
         for $nodeCh0 at $nNch in $lnodeChild
         <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-ans-recnt-munge-mark">Adjust mark attribute on $nodeCh as needed 224</a></em> &#x3009;</span>
         let $trace := eri:notrace(eri:sXei($Ecur),
	       'all-node-seqs recurs on child'
               || '(' || $nNch
	       || ' of ' || count($lnodeChild) || '),'
               || ' (predictor' || $nEiP
	       || ' of ' || count($leiPredictors) || '),'
               || ' (Completion' || $nEiCC
	       || ' of ' || count($leiPrev) || '),'
			   )

         return epi:all-node-sequences($eiPred,
                                       $meiClosure,
                                       ($nodeCh, $lnAcc),
                                       $pFrom,
                                       $pTo,
                                       $I,
                                       $leiVStack,
                                       ($Ecur, $leiHStack)
                                      )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ans-rec-nonterminal">Handle recursion on nonterminal 220</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">There's one more complication.  The trees produced
by the call to <i>all-trees()</i> have <em>mark</em>
attributes reflecting the mark on the rule for the nonterminal.
If a mark is specified on the RHS reference to the nonterminal
(that would be the <tt>$sym</tt> element), it needs to
over-ride the mark on the rule.  So before we pop the
child nodes into the accumulator, we make sure their
<em>mark</em> attribute is correct.
<div class="scrap"><span><a name="epi-ans-recnt-munge-mark">&#x3008; 224 Adjust mark attribute on $nodeCh as needed &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">         let $nodeCh := 
             if (exists($sym/@mark)) 
             then element { name($nodeCh0) } {
	         $nodeCh0/(@* except @mark), 
	         $sym/@mark,
		 $nodeCh0/node()
	     }
             else $nodeCh0
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ans-recnt-recur">Recur on each predictor 223</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">If what we are looking at has not been recognized
as a terminal or a nonterminal, then we are out of luck
and can only report a problem.
<div class="scrap"><span><a name="epi-ans-rec-whazzat">&#x3008; 225 Raise error if neither terminal nor nonterminal &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      else (: not terminal, not nonterminal, we have a problem :)
        &lt;error-in-all-node-sequences
          from="{$pFrom}" to="{$pTo}"&gt;{
            eri:sXei($Ecur)
          }&lt;/error-in-all-node-sequences&gt;
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-ans-recursive">Handle recursive case 217</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Here we appear to have some cruft that has been commented
out but not removed.
<div class="scrap"><span><a name="epi-lnDepXCleC">&#x3008; 226 Define lnDepXClEc() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: lnDepXClEc($Closure, $Ec):  from the Earley closure $Closure,
   extract the dependents of the node completed by $Ec.
:)
(: 
declare function epi:lnDepXClEc(
  $leiClosure as map(*)*, 
  $Ec as map(*)
) as item()* {
  &lt;lnDepXClEc-not-implemented/&gt;
};
  :)
(: eMakeEcLndepLaLa($Ec,$ln,$lA,$lC):  given a completion item $Ec,
   a (possibly partial) list of dependent nodes $ln, and 
   accumulated lists of attributes and children, construct an
   element.
 :)
 (:
declare function epi:eMakeEcLndepLaLc(
  $Ec as map(*),
  $lnDep as item()*
) as element() {
  let $gi := $Ec('rule')/@name,
      $lAtts := $lnDep[self::attribute()],
      $lChildren := $lnDep[self::element() 
                     or self::text() 
                     or self::comment() 
                     or self::processing-instruction()]
  return element {$gi} { $lAtts, $lChildren }
};

:)  
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>
</div>
</div>

<div class="div">

<div class="quicknav"><span class="arrow"><a href="#epi-all-nodes">&#x23f4;</a></span><span class="arrow"><a href="#legacy-Earley-parser-internals.xqm">&#x23f6;</a></span><span class="arrow">&nbsp;</span></div><h4><a class="selflink" name="epi-ast-from-raw" id="epi-ast-from-raw" href="#epi-ast-from-raw">6.2.4. </a>Extracting the abstract syntax tree from the raw parse tree</h4><ul><li>6.2.4.1. <a href="#epi-ast-init">The initial call</a></li><li>6.2.4.2. <a href="#epi-ast-outer">The document-element constructor</a></li><li>6.2.4.3. <a href="#epi-ast-element">The element constructor</a></li><li>6.2.4.4. <a href="#epi-ast-attcoll">The attribute collector</a></li><li>6.2.4.5. <a href="#epi-ast-attvalue">The attribute value constructor</a></li><li>6.2.4.6. <a href="#epi-ast-content">The content collector</a></li></ul>
<div class="Real-P">The parse tree extraction routines defined elsewhere produce
the raw parse tree, but ixml requires that we return an abstract
syntax tree.  So we need a function to take a raw parse tree
and return the corresponding AST.</div>
<div class="Real-P">There are several different functions, depending on which
situation we are in.
<ul><li><div class="Real-P">The initial call expects to find the 'Goal' nonterminal at
the root of the raw parse tree; it then passes its child element to a
function that seeks to make the document element.</div>
<div class="Real-P">If that function returns multiple children, the function
provides an &lt;<em>ixml:multiple-roots</em>&gt; wrapper.</div></li>
<li><div class="Real-P">The function to make a document element
&#x2018;knows&#x2019; that so far we don't have any parent
element, so in the normal case it just recurs looking for a
nonterminal marked as an element.  It deals differently with
different cases:
<ul><li>A nonterminal marked &#x201c;<tt>^</tt>&#x201d; is passed to
an element constructor.</li>
<li>A nonterminal marked &#x201c;<tt>-</tt>&#x201d; is skipped; the
function recurs on its children.  (It is this recursion which
makes it possible for the function to return multiple results.)</li>
<li>A nonterminal marked &#x201c;<tt>@</tt>&#x201d; is serialized as an
element (as required by the spec).</li>
<li>A terminal is wrapped in an &lt;<em>ixml:wrapper</em>&gt;
element.</li>
</ul>
</div></li>
<li><div class="Real-P">The element constructor should be called only on nonterminals
marked as elements.  It serializes the nonterminal as an element and
calls other functions to collect its attributes and its
content.</div></li>
<li><div class="Real-P">The function to collect attributes for a parent element
just constructed will recur through the relevant subtree of the raw
parse tree, looking for nonterminals marked as attributes.  It will
recur through hidden nonterminals, stop the recursion on
element nonterminals, raise an error on terminals, and call an
attribute-value constructor when it finds a nonterminal marked as an
attribute.</div></li>
<li><div class="Real-P">The attribute-value constructor function recurs, gathering
character data from terminals and ignoring the markings on all
intervening nodes.</div></li>
<li><div class="Real-P">The function to gather content for a parent element just
constructed will recur through the relevant subtree of the raw parse
tree, ignoring attributes, serializing terminals, recurring through
hidden nonterminals, and calling the element constructor on
serializable nonterminals.</div></li>
</ul>
</div>

<div class="div">

<div class="quicknav"><span class="arrow">&nbsp;</span><span class="arrow"><a href="#epi-ast-from-raw">&#x23f6;</a></span><span class="arrow"><a href="#epi-ast-outer">&#x23f5;</a></span></div><h5><a class="selflink" name="epi-ast-init" id="epi-ast-init" href="#epi-ast-init">6.2.4.1. </a>The initial call</h5>

<div class="Real-P">The top-level AST constructor function descends past the Goal
wrapper and passes its one descendant to the document-element
constructor.  It assigns the result to a variable, so it can check how
many nodes came back: if more than one, a special wrapper is needed.
It also rewrites the outer element if needed, adding an ambiguity
flag.</div>
<div class="Real-P">To handle the ambiguity flag, we accept a parameter showing how
many parse trees the caller got back from the
<i>recognizeX()</i> function; if it's greater than one, we
mark the result with <tt>ixml:state="ambiguous"</tt>, declaring
the namespace as <tt>xmlns:ixml="http://invisiblexml.org/NS"</tt>.
<div class="scrap"><span><a name="epi-astXparsetree">&#x3008; 227 Define astXparsetree() to make AST from raw parse &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:astXparsetree(
  $E as element(nt),
  $cpt as xs:integer
) as node()* {
  if (empty($E/nt)) 
  then
      element ap:error {
          attribute id { "ap:tbd24" },
          text {
              "Parse tree had wrapper",
              "but no content."
          }
      }
  else
      let $doc0 :=
              for $c in $E/*
              return epi:doc-elementXpt($c),
          $doc1 :=
	      if (count($doc0) eq 1) 
              then $doc0 
	      else if (count($doc0) eq 0) 
              then element ixml:no-roots {}
	      else element ixml:multiple-roots {
	          $doc0
	      }
      return
          if ($cpt eq 1) 
          then $doc1
	  else element { name($doc1) } {
	       attribute ixml:state { 'ambiguous' },
	       $doc1/@*, 
	       $doc1/node()
	  }
};
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-docelXpt">Define doc-elementXpt() to make AST for document element 228</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-elXpt">Define elementXpt() to make AST for one element 230</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-attsXpt">Define attributesXpt() to collect attributes 231</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-avXpt">Define avXpt() to collect attribute value 232</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-contentXpt">Define contentXpt() 233</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e434">[File Earley-parser-internals.xqm] 8</a> &#x3009; <br></span>
</div>
</div>
</div>

<div class="div">

<div class="quicknav"><span class="arrow"><a href="#epi-ast-init">&#x23f4;</a></span><span class="arrow"><a href="#epi-ast-from-raw">&#x23f6;</a></span><span class="arrow"><a href="#epi-ast-element">&#x23f5;</a></span></div><h5><a class="selflink" name="epi-ast-outer" id="epi-ast-outer" href="#epi-ast-outer">6.2.4.2. </a>The document-element constructor</h5>
<div class="Real-P">The constructor for the document element is distinct from the
ordinary element constructor because in the special case that the
top-most node of the result is an attribute or a terminal symbol, we
want to coerce the result into an element.</div>
<div class="Real-P">
<div class="scrap"><span><a name="epi-docelXpt">&#x3008; 228 Define doc-elementXpt() to make AST for document element &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:doc-elementXpt(
  $E as element()*
) as node()* {
  (: Normal case :)
  if ($E/self::nt[@mark = '^' or not(@mark)]) 
  then epi:elementXpt($E)
  
  (: Hidden wrapper, recur :) 
  else if ($E/self::nt[@mark = '-']) 
  then for $c in $E/*
      return epi:doc-elementXpt($c) 

  (: Attribute (sic) :) 
  else if ($E/self::nt[@mark = '@']) 
  then element { $E/@name } {
      attribute ixml:warning {
          'Attribute found as root of AST'
      }
  }

  (: Terminal (sic) :) 
  else if ($E/self::*[name() = ('lit', 'incl', 'excl')])  
  then element ixml:terminal {
      attribute warning { 
          'Terminal found as root of AST'
      }, 
      text { <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-sXpt">Make string from raw parse tree terminal $E 229</a></em> &#x3009;</span> } 
  }
  
  (: Unexpected input: what? :)
  else &lt;oops&gt;{$E}&lt;/oops&gt;
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-astXparsetree">Define astXparsetree() to make AST from raw parse 227</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">There are a couple of places where we will need to
make a string from a raw parse tree terminal. This
involves checking that the terminal is not marked
hidden and then serializing from the list of code points.
(An approximation of the string value will be in the

<div class="scrap"><span><a name="epi-sXpt">&#x3008; 229 Make string from raw parse tree terminal $E &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/@tmark = '-')  
       then ()  
       else codepoints-to-string(
               for $t in tokenize(
                   normalize-space($E/@cps),
	           '\s')  
               return xs:integer($t)
       )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-docelXpt">Define doc-elementXpt() to make AST for document element 228</a> &#x3009; &#x3008; <a href="#epi-avXpt">Define avXpt() to collect attribute value 232</a> &#x3009; &#x3008; <a href="#epi-contentXpt">Define contentXpt() 233</a> &#x3009; <br></span>
</div>

</div>
</div>

<div class="div">

<div class="quicknav"><span class="arrow"><a href="#epi-ast-outer">&#x23f4;</a></span><span class="arrow"><a href="#epi-ast-from-raw">&#x23f6;</a></span><span class="arrow"><a href="#epi-ast-attcoll">&#x23f5;</a></span></div><h5><a class="selflink" name="epi-ast-element" id="epi-ast-element" href="#epi-ast-element">6.2.4.3. </a>The element constructor</h5>
<div class="Real-P">The ordinary element constructor creates an element with the
appropriate name, then calls two functions to traverse the current
part of the raw parse tree and collect attributes and content,
respectively.  The argument is required to be an &lt;<em>nt</em>&gt;
element and expected to be marked &#x201c;<tt>^</tt>&#x201d;.</div>
<div class="Real-P">
<div class="scrap"><span><a name="epi-elXpt">&#x3008; 230 Define elementXpt() to make AST for one element &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:elementXpt(
  $E as element()
) as node()* {
  element { $E/@name } {
      if ($E/@mark = ('-', '@'))
      then attribute ixml:warning {
          'Wrong mark (' || $E/@mark 
          || ') on nonterminal'
      }
      else (),
      for $c in $E/*
      return epi:attributesXpt($c), 
      for $c in $E/*
      let $dummy := eri:notrace(
          concat(name($c), '/', $c/@name, '/', $c/@xml:id),
          'constructing content from:') 
      let $n := epi:contentXpt($c)
      let $dummy := for $chunk in $n return
          if ($chunk instance of text())
          then eri:notrace(concat('/',
	       string-join(string-to-codepoints($chunk),' '), 
               '/'), 
               'eXpt got text node') 
          else if ($chunk instance of element())
	  then eri:notrace($chunk/name(), 'eXpt gets element:') 
	  else eri:notrace($chunk, 'eXpt gets unknown item:') 
      return $n
  }
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-astXparsetree">Define astXparsetree() to make AST from raw parse 227</a> &#x3009; <br></span>
</div>
</div>
</div>

<div class="div">

<div class="quicknav"><span class="arrow"><a href="#epi-ast-element">&#x23f4;</a></span><span class="arrow"><a href="#epi-ast-from-raw">&#x23f6;</a></span><span class="arrow"><a href="#epi-ast-attvalue">&#x23f5;</a></span></div><h5><a class="selflink" name="epi-ast-attcoll" id="epi-ast-attcoll" href="#epi-ast-attcoll">6.2.4.4. </a>The attribute collector</h5>
<div class="Real-P">The attribute collector traverses the subtree looking for things to
serialize as attributes on the current element.  For
each such nonterminal, it constructs the attribute and
called the attribute value constructor to construct
the value.
<div class="scrap"><span><a name="epi-attsXpt">&#x3008; 231 Define attributesXpt() to collect attributes &#x3009;  &#x2261;</a></span>
<pre class="scrapbody"> 
declare function epi:attributesXpt(
  $E as element()
) as attribute()* {
  (: Main case: make an attribute :)
  if ($E/self::nt[@mark = '@']) 
  then attribute { $E/@name } {
      string-join(
          (for $c in $E/*
          return epi:avXpt($c)),
	  '')
  }

  (: skip terminals and elements :)
  else if ($E/name() = ('lit', 'incl', 'excl')) 
  then () 
  else if ($E/self::nt[@mark = '^' or not(@mark)])
  then ()

  (: recur through hidden nt :)
  else if ($E/self::nt[@mark = '-']) 
      then for $c in $E/*
      return epi:attributesXpt($c)

  else eri:trace((),
      '! unexpected argument to attributesXpt()') 
     
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-astXparsetree">Define astXparsetree() to make AST from raw parse 227</a> &#x3009; <br></span>
</div>
</div>
</div>

<div class="div">

<div class="quicknav"><span class="arrow"><a href="#epi-ast-attcoll">&#x23f4;</a></span><span class="arrow"><a href="#epi-ast-from-raw">&#x23f6;</a></span><span class="arrow"><a href="#epi-ast-content">&#x23f5;</a></span></div><h5><a class="selflink" name="epi-ast-attvalue" id="epi-ast-attvalue" href="#epi-ast-attvalue">6.2.4.5. </a>The attribute value constructor</h5>
<div class="Real-P">The attribute value constructor traverses a subtree constructing
the string value of an attribute.  The spec says we serialize &#x201c;all
non-hidden terminal descendants of the node (regardless of marking of
intermediate nonterminals)&#x201d;. So we ignore the &#x201c;<tt>^</tt>&#x201d;
marking and treats it the same as &#x201c;<tt>-</tt>&#x201d;, recurring
through it. For an example of this treatment, see the handling of
<i>dchar</i> and <i>schar</i> in the current ixml
grammar.
<div class="scrap"><span><a name="epi-avXpt">&#x3008; 232 Define avXpt() to collect attribute value &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:avXpt(
  $E as element()
) as xs:string* {
  if ($E/(self::incl or self::excl or self::lit))
  then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-sXpt">Make string from raw parse tree terminal $E 229</a></em> &#x3009;</span> 
  else for $c in $E/*
       return epi:avXpt($c)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-astXparsetree">Define astXparsetree() to make AST from raw parse 227</a> &#x3009; <br></span>
</div>

</div>
</div>

<div class="div">

<div class="quicknav"><span class="arrow"><a href="#epi-ast-attvalue">&#x23f4;</a></span><span class="arrow"><a href="#epi-ast-from-raw">&#x23f6;</a></span><span class="arrow">&nbsp;</span></div><h5><a class="selflink" name="epi-ast-content" id="epi-ast-content" href="#epi-ast-content">6.2.4.6. </a>The content collector</h5>
<div class="Real-P">The content collector traverses the subtree looking for things to
serialize as content of the current element and either
serializing them itself (if terminals) or passing them to the
element constructor.
<div class="scrap"><span><a name="epi-contentXpt">&#x3008; 233 Define contentXpt() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function epi:contentXpt(
  $E as element()
) as item()* {
  if ($E/self::nt[@mark = '^' or not(@mark)])
  then epi:elementXpt($E)
  else if ($E/self::nt[@mark = '-'])
  then for $c in $E/*
       return epi:contentXpt($c)
  else if ($E/self::nt[@mark = '@'])
  then ()
  else if ($E[self::incl or self::excl or self::lit])
  then text { <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#epi-sXpt">Make string from raw parse tree terminal $E 229</a></em> &#x3009;</span> }
  else element ixml:unexpected {
       attribute f { "epi:contentXpt" }, 
       $E
  }
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#epi-astXparsetree">Define astXparsetree() to make AST from raw parse 227</a> &#x3009; <br></span>
</div>

</div>
</div>
</div>
</div>


</div>



<hr>


<div class="div">

<h2><a class="selflink" name="references" id="references" href="#references">A. </a>References</h2>
<div class="Real-P"><i>Incomplete.</i></div>
<div class="bibliography">

<p class="bibl"><a name="ABK1993" id="ABK1993"></a>
Anne Br&#xfc;ggemann-Klein,
&#x201c;Regular expressions into finite automata,&#x201d;
<em>Theoretical Computer Science</em>
120.2 (1993): 197-213.
</p>

<p class="bibl"><a name="GJ" id="GJ"></a>
Dick Grune and Ceriel J. H. Jacobs,
<em>Parsing techniques:  a practical guide</em>
(New York, et al.: Ellis Horwood, 1990;
Second edition New York:  Springer, 2007).</p>

<p class="bibl"><a name="Knuth-1984" id="Knuth-1984"></a>
Donald E. Knuth,
&#x201c;Literate Programming,&#x201d;
<em>The Computer Journal</em>
27 (1984):  97-111,
rpt. [rev.] in his
<em>Literate Programming</em>,
<em>CSLI Lecture Notes</em> Number 27
([Stanford, California]:  Center for the Study of Language and
Information, 1992), pp. 99-136, here p. 99.</p>

<p class="bibl"><a name="pemberton-2013" id="pemberton-2013"></a>
Pemberton, Steven.
2013.
&#x201c;Invisible XML&#x201d;.
Presented at Balisage: The Markup Conference 2013,
Montr&#xe9;al, Canada, August 6 - 9, 2013.
In
<em>Proceedings of Balisage: The Markup Conference 2013.</em>
Balisage Series on Markup Technologies, vol. 10 (2013).
DOI: 10.4242/BalisageVol10.Pemberton01.
On the web at
&lt;URL:<a href="http://www.balisage.net/Proceedings/vol10/html/Pemberton01/BalisageVol10-Pemberton01.html">http://www.balisage.net/Proceedings/vol10/html/Pemberton01/BalisageVol10-Pemberton01.html</a>&gt;.
Revised version (January 2014) at
&lt;URL:<a href="https://homepages.cwi.nl/~steven/Talks/2013/08-07-invisible-xml/invisible-xml-3.html">https://homepages.cwi.nl/~steven/Talks/2013/08-07-invisible-xml/invisible-xml-3.html</a>&gt;
</p>

<p class="bibl"><a name="pemberton-2021" id="pemberton-2021"></a>
Pemberton, Steven.
2021.
&#x201c;Invisible XML Specification
(Draft)&#x201d;.
On the web at
&lt;URL:<a href="https://invisiblexml.org/ixml-specification.html">https://invisiblexml.org/ixml-specification.html</a>&gt;
</p>

<p class="bibl"><a name="msm-1996" id="msm-1996"></a>
Sperberg-McQueen, C. M.
&#x201c;SWEB:
an SGML Tag Set for Literate Programming&#x201d;.
Unpublished technical report, 1993, rev. 1994, 1995, 1996.
On the web at
http://cmsmcq.com/1993/sweb.{<a href="http://cmsmcq.com/1993/sweb.xml">xml</a>,<a href="http://cmsmcq.com/1993/sweb.html">html</a>}.</p>

<p class="bibl"><a name="msm-2017" id="msm-2017"></a>
Sperberg-McQueen, C. M.
&#x201c;Translating imperative algorithms
into declarative, functional terms:
towards Earley parsing in XSLT and XQuery&#x201d;.
Presented at Balisage: The Markup Conference 2017,
Washington, DC, August 1 - 4, 2017.
In
<em>Proceedings of Balisage:
The Markup Conference 2017.</em>
<em>Balisage Series on Markup Technologies,
vol. 19 (2017)</em>.
&lt;URL:<a href="https://doi.org/10.4242/BalisageVol19.Sperberg-McQueen01">https://doi.org/10.4242/BalisageVol19.Sperberg-McQueen01</a>&gt;.
</p>

<p class="bibl"><a name="msm-2022" id="msm-2022"></a>
Sperberg-McQueen, C. M. &#x201c;Test harness
for Aparecium&#x201d;.  Unpublished technical report, 2022.</p>
</div>
</div>




<div class="div">

<h2><a class="selflink" name="to-do" id="to-do" href="#to-do">B. </a>To do</h2>
<div class="Real-P">As the reader will have noticed, in its current state this
program is not finished. Hence the following to-do lists.</div>


<div class="div">

<h3><a class="selflink" name="to-do-large" id="to-do-large" href="#to-do-large"></a>Overall plans</h3>

<div class="Real-P">At the moment (30 July 2022), the primary concerns are to
improve performance and robustness.</div>
<ul><li>
<div class="Real-P"><b>Bug fixes</b>.  Clear all test-case failures.</div>
</li>
<li>
<div class="Real-P"><b>Vendor neutrality</b>.  Take time to make frameworks to
run in multiple XQuery engines, both from whatever GUI interface they
provide and from the command line.  Initial targets:  BaseX, Saxon, eXist-db,
Xidel.

</div>
<div class="Real-P">XQilla and BerkeleyDB XML support XQuery 1.0, and possibly
3.0, but not 3.1, which means they have no support for maps,
which means they are not candidates for this work.</div>
<div class="Real-P">Not an atomic task; time-consuming steps should be broken up to
avoid blocking other work.</div>

<div class="Real-P">Current complaints by Saxon, when attempting to run the test driver:
<ul><li>Namespace &#x201c;<tt>prof</tt>&#x201d; not declared (calls
  to prof:time, prof:track).</li>
<li>Namespace &#x201c;<tt>file</tt>&#x201d; not declared (calls
  to file:create-dir, file:write).</li>
</ul>
Currently no complaint about xquery:eval, but that's presumably only a
matter of time.
</div>
</li>
<li><div class="Real-P"><b>Brown Sugar</b> plan.[<a name="ref-to-d3e6214" href="#d3e6214" title="&#xA;So called because this is a dirty form of the&#xA;sugar plan described below.&#xA;">22</a>]
Quick and dirty ad-hoc tokenization change for ixml grammar for ixml
grammars.  Hand-modify and hand-annotate the grammar, add support for
those annotations.</div>
<div class="Real-P">Note that the ixml grammar has both safe and unsafe tokenization
candidates: whitespace and comment-data are safe, and names are unsafe
owing to the full stop.  So this is a quick and dirty test of both
&#x2018;Sugar&#x2019; and &#x2018;Bruno&#x2019;.</div>
</li>
<li>
<div class="Real-P"><b>Direct tree construction</b>.  Revisit the old code for
direct construction of trees to try to fix its problems.</div>
<div class="Real-P">First try to restructure it in SWeb to make it easier to
understand.  Then try to isolate bottlenecks and causes of problems.
Then try to fix them.</div>
</li>
<li>
<div class="Real-P"><b>Revise and restructure</b>.  Revise the document
thoroughly, reorganizing as appropriate.  There are two audiences:
those interested in understanding how the implementation works, and
those maintaining the code.</div>
<div class="Real-P">Begin by introducing scraps to represent the abstract data types
<i>Earley item</i>, <i>Earley set</i>, etc., so that
the high-level algorithm can be followed independently of the chosen
representation.  Explain the high-level algorithm, then the
internals.</div>
<div class="Real-P">This is not an atomic task and may be interleaved with other
things.</div>
</li>
<li>
<div class="Real-P"><b>User options</b>.  Allow invoker to specify options, so
they can choose whether to get back one parse tree, several, a
parse-forest grammar, a raw parse tree, or the entire Earley set.</div>
<div class="Real-P">This will also require some extension to the test harness and
possibly to the test catalog schema.</div>
</li>
<li>
<div class="Real-P"><b>Grammar cleanup</b>.  Implement automatic cleanup
of grammar hygiene problems (unreachable, unproductive, and
undefined symbols); improve diagnostics.</div>
</li>
<li><div class="Real-P"><b>Robustness</b>.  Improve robustness and resistance
to unexpected error.  Not necessarily an atomic task, but worth a
concerted effort to walk through every scrap of code checking for
assumptions that need to be checked.</div></li>
<li><div class="Real-P"><b>Sugar</b>. Improve tokenization for
&#x2018;suitable&#x2019; nonterminals.  <i>This is only sensible
if the experience from Brown Sugar suggests it produces a useful
speedup.  I expect that it will.</i></div>

<div class="Real-P">Since ixml grammars don't have a distinct token level, either
analysis by the processor or manual annotation, or both, may be
required.  The goal is to identify nonterminals which can be
recognized with a single greedy regular-expression match, and
recognize them in that way.  I believe a nonterminal <i>N</i> is suitable
for this treatment if and only if:

<ul><li>
<div class="Real-P"><i>N</i> defines a regular language.  (Sufficient but not necessary
condition: no center embedding for them or any descendant.  A stronger
and easier condition: no self-embedding at all.)</div>
</li>
<li>
<div class="Real-P">Every nonterminal descendant of <i>N</i> is marked hidden.</div>
</li>
<li>
<div class="Real-P">Every terminal descendant of <i>N</i> is marked visible.</div>
</li>
<li>
<div class="Real-P"><i>N</i> is what we might call <em>end-stopped</em>, by analogy
with the metrical phenomenon in which syntactic and verse boundaries
fall together, thus clearly marking the boundary.  Concretely, <i>N</i> is
end-stopped if it is clear without lookahead where the end of an
occurrence of <i>N</i> falls: any legal character is either a continuation
of the <i>N</i> or the beginning of the next symbol, and no symbol can be
read in both ways.</div>

<div class="Real-P">Operationally, I think end-stopping can be detected as follows.
<ul><li>
<div class="Real-P">Construct the FSA for the <i>O</i><sub>0</sub> regular superset approximation of
<i>L(G)</i>, in the usual way.  For each nonterminal, keep track of the set
of states that recognize that nonterminal.  (Including states in
descendant nonterminals, if they have been retained; in practice, I
expect it will make sense to rewrite the rules for <i>N</i> as a regular
expression over characters.)</div></li>
<li>
<div class="Real-P">For every nonterminal <i>N</i> and every state which can reach the
final state of <i>N</i> via epsilon transitions, mark that state as a
member of <i>last</i>(<i>N</i>).  The terminal subset of this set
we can call <i>last</i><sub><i>T</i></sub>(<i>N</i>).</div>
</li>
<li>
<div class="Real-P">Remove epsilon transitions.</div>
</li>
<li>
<div class="Real-P">For each state <i>q</i> in <i>last</i><sub><i>T</i></sub>(<i>N</i>), classify the outgoing arcs: either they lead
to a state in the recognizer for <i>N</i>, or they lead to one of the
initial states in a recognizer for some nonterminal in
<i>follow(N)</i>.  We can call these <em>endotelic</em>
and <em>exotelic</em> arcs: they have goals inside, or outside,
the recognizer for <i>N</i>.</div>
</li>
<li>
<div class="Real-P">If no symbol occurs on both an endotelic and an exotelic arc,
then <i>N</i> is end-stopped: if an occurrence of <i>N</i> can be extended by
including the next character in the input, then in any correct parse
that character is included in the <i>N</i>.  If any symbol occurs on both
kinds of arc, then it is not clear without further information
whether it belongs in the <i>N</i> or outside it.</div>
</li>
</ul>
</div>
</li>
</ul></div>
</li>
<li>
<div class="Real-P"><b>Bruno</b>.  A brute-force variation on Sugar.  If an
otherwise suitable nonterminal <i>N</i> is not end-stopped
(e.g. <i>name</i> in the ixml specification grammar), it may
still be worthwhile to use regular expressions to match it using a
brute-force method to find the appropriate stopping point: register
them all:</div>
<ul><li>
<div class="Real-P">When <i>N</i> is predicted at position <i>p</i>, use a greedy match to find
the longest <i>N</i> in the input starting at <i>p</i>.  Assume this match has
length <i>n</i>.</div>
</li>
<li>
<div class="Real-P">For <i>i</i> in 0 to <i>n</i>:
<ul><li>
<div class="Real-P">Let <i>s</i> be the substring in the input beginning at <i>p</i> with length
<i>i</i>.</div>
</li>
<li>
<div class="Real-P">If <i>s</i> is an instance of <i>N</i>, record a completion item for <i>N</i> of the form
(<i>p</i>, <i>p</i>+<i>i</i>, <i>N</i>, <i>q</i><sub><i>f</i></sub>).</div>
</li>
</ul>
</div>
<div class="Real-P">This will reduce the number of items produced for the range
<i>I</i>[<i>p</i>, <i>p</i>+<i>n</i>] by about half, and may reduce run time: in the worst
case we will have
<ul><li><i>n</i> calls to construct substring <i>s</i></li>
<li><i>n</i> + 1 calls to <i>matches</i>(<i>s</i>, <i>pattern</i>)</li>
<li><i>n</i> completion items for <i>N</i></li>
<li>0 searches in the Earley set</li>
</ul>
for a total of <i>n</i> &#xd7; (cost of substring construction
+ cost of regex match + cost of item construction).
In the standard Earley algorithm, the cost will be
<ul><li><i>n</i> inspections of <i>I</i>[<i>p</i> + <i>i</i>]</li>
<li><i>n</i> progress or completion items for <i>N</i> (or whatever the
lowest-level parent of the repetition operator is)</li>
<li>an indeterminate number of other progress or completion items for descendants of <i>N</i></li>
<li>one or two searches in the Earley set for each item constructed</li>
</ul>
</div>
</li>
</ul>
<div class="Real-P"><i>This is only sensible if the experience from Brown Sugar
suggests it produces a useful speedup.  I expect that it
will.</i></div>
</li>
<li><div class="Real-P"><b>Diagnostics</b>.  Improve diagnostics in case of
failure.</div></li>
<li><div class="Real-P"><b>Recursive descent</b>.  Support recursive-descent
parsing.</div>

<ul><li><div class="Real-P">Develop code to check whether a grammar is LL(1) or
LL(k).</div></li>
<li>
<div class="Real-P">Make an LL(1) grammar out of the ixml grammar.</div>
<div class="Real-P">Automate the grammar rewrites necessary to do this, so it can be
re-done when the ixml grammar changes.</div>
</li>
<li>
<div class="Real-P">Write code to generate tables from an LL(1) parser to drive a
table-driven parser.</div>
</li>
<li>
<div class="Real-P">Write code to generate a recursive-descent parser for an LL(1)
grammar.</div>
</li>
<li>
<div class="Real-P">Make a recursive-descent or table-driven LL(1) parser for the ixml
spec grammar and use it when parsing input grammars.</div>
<div class="Real-P">I hope that this change will produce an order of magnitude speedup
in parsing input grammars.</div>
</li>
</ul>

<div class="Real-P">Initially, this code may be in Aparecium or in Gingersnap or in
both.  If the LL(1) checking runs fast enough, it will be needed in
Aparecium, so that when the user supplies an LL(1) grammar Aparecium
can use a faster parsing algorithm than Earley.</div>
</li>
<li><div class="Real-P"><b>Performance</b>.  Measure time, measure frequency
of operations, look for opportunities to do better.  If calculations
can be done statically, push them into the grammar compiler.</div>

<div class="Real-P">By no means an atomic task.</div>

<div class="Real-P">Note that several other items on this list are motivated largely or
exclusively by the desire to improve time performance: Brown Sugar,
revision of direct tree construction, Sugar, Bruno, and work on
recursive descent.</div>



</li>
<li><div class="Real-P"><b>SWeb upgrade</b>.  Upgrade the SWeb infrastructure
to support XSLT.</div></li>
<li><div class="Real-P"><b>XSLT</b>.  Create XSLT version of
Aparecium.</div></li>
<li><div class="Real-P"><b>BNF</b>.  Consider shifting to using BNF rather
than EBNF internally. This will make it simpler to handle various
forms of infinite ambiguity satisfactorily, but will have little
effect in ordinary grammars.</div>
<div class="Real-P">Some but not all of the effects of switching to BNF can be tested
by just comparing behavior on EBNF grammars and BNF equivalents.  This
does not however account for possibly faster compilation and
recognition; that would require alternate code.</div></li>
</ul>
</div>


<div class="div">

<h3><a class="selflink" name="to-do-code" id="to-do-code" href="#to-do-code"></a>Code changes</h3>
<div class="Real-P">Fixes / shorter-term changes to be made:</div>
<ul><li>16 Feb 22:  make compilation place a <em>follow:info</em> attribute
or something on the &lt;<em>ixml</em>&gt; element, to de-clutter the
compiled grammar.</li>
<li>16 Feb 22: Weed these to-do lists!</li>
<li>Make a common-utilities module for global project-level
variables (e.g. version number, tracing level) and tracing / debugging
routines.</li>
<li>Insert GPL notices in all modules.</li>
</ul>

<div class="Real-P">Enhancements longer-term changes to be made:</div>
<ul><li>Make marks work correctly.  Why is S appearing in output when
ixml is parsed?</li>
<li>Allow options to turn _from and _to attributes on and off?</li>
</ul>
</div>


<div class="div">

<h3><a class="selflink" name="to-do-sweb" id="to-do-sweb" href="#to-do-sweb"></a>SWeb upgrades</h3>
<div class="Real-P">To do asap:</div>
<ul><li>make RNC schema for p3 + SWeb + XSLT</li>
<li>ensure new schema allows any well formed XML in
scraps, but enforces parent/child relations on XSLT</li>
<li>add module to SWeb stylesheet, to handle
XSLT and other XML elements within scraps</li>
<li>when this document is a bit further along (and has
decent display / translation into XHTML), move to github.</li>
</ul>
<div class="Real-P">To do eventually:</div>
<ul><li>make RNC schema for TEI P5 + SWeb + XSLT</li>
<li>upgrade this document, SWeb weave processor, SWeb
tangle processor</li>
</ul>
</div>


<div class="div">

<h3><a class="selflink" name="d3e6634" id="d3e6634" href="#d3e6634"></a>To-do list from Earley recognizer internals module</h3>
<div class="Real-P">This module has a complicated enough to-do list of its own that
I'll give it here for the moment instead of inserting these into the
general to-do lists just given.</div>
<ul><li><div class="Real-P">establish coherent Hungarian type policy to distinguish 
     element and string representations of symbols.  We need
     shorthands for both.</div></li>
<li><div class="Real-P">fix symbol/position issue in leiAdvanceEiSymP()</div></li>
<li><div class="Real-P">finish minimal version</div></li>
<li><div class="Real-P">add support for #xxxx characters</div></li>
<li><div class="Real-P">clarify XML representation of terminals and other questions
with SP:
<ul><li>grammar says -quoted, I say quoted </li>
<li>grammar says quoted/@dstring, quoted/@sstring, 
       I think I prefer quoted with PCDATA (code
       currently handles all three)</li>
<li>grammar defines -character, I want character element
       as child of terminal (-character is fine for 
       @dstring and @sstring)</li>
<li>grammar and papers don't say what ^ means</li>
<li>how is start symbol determined?  For now I
       take LHS of first rule, like yacc.</li>
<li>if a rule reads "-foo: @bar, baz.", what happens?
       does @bar percolate up to parent element? (Do you
       know how to do this?)</li>
<li>Is a grammar specifying an @ mark on a repeatable 
       non-terminal ill-formed?  Or is the @ just ignored
       in that case?  (Tentative answer: both.)</li>
<li>True or false? 
       On a nonterminal, the mark "-" means "do not tag as element",
       but do promote the children.  On a terminal, it means
       "omit the entire thing".
</li>
</ul></div>
</li>
<li><div class="Real-P">do some sanity checking in reXTerminal to avoid having
     matches() blow up.</div></li>
<li><div class="Real-P">fix confusion over two senses of nullable:
<ul><li>locally nullable = nullable within the RHS (decorated 
       with ? or *, inside optional group, etc.)</li>
<li>generates null string in sentence</li>
</ul>
</div>
<div class="Real-P">N.B. a required non-terminal, not nullable in first
sense, can generate empty string and thus make its
parent nullable in the second sense.</div>
<div class="Real-P">Use fNullable for the first sense (already established)
and fGES (to be renamed for the second.</div>
</li>
<li><div class="Real-P">For testing purposes, provide a recognize function that
specifies a start symbol (analogous to phrase/2 in Prolog).</div></li>
</ul>
</div>


<div class="div">

<h3><a class="selflink" name="done-that" id="done-that" href="#done-that"></a>Done</h3>
<div class="Real-P">This section records things that were on the to-do lists above
and got done, in case that information is needed later.  Maybe I
just want to remember that some things do get done.</div>
<ul><li>
<div class="Real-P">Improve tree constructor. Or, rather, replace
it. Concretely:</div>
<ul><li><div class="Real-P">Define a function to generate a parse-forest grammar
from the Earley set, rather than a parse tree.</div></li>
<li><div class="Real-P">Define a function to extract one or more parse trees
from a parse-forest grammar.</div>
</li>
</ul>
<div class="Real-P">The parse-tree constructor currently suffers from dismal
performance on some tests; see in particular the zeroes test catalog.
It performs its work without backtracking but also without memoization
or a work queue or any mechanism to avoid doing the same task multiple
times.  The result can be a combinatorial explosion, with the same
subtrees being constructed hundreds and thousands of times even for
input of only ten characters.</div>
<div class="Real-P">Since I want to write a parse-forest grammar constructor in any
case, I have not attempted to instrument the current tree constructor;
my plan is just to construct a parse-forest grammar and then extract
the tree from that, if the user wishes.</div>

<div class="Real-P">My current expectation is that in most cases this will result in a
modest improvement in performance.  Performance should improve because
useless work will be avoided and necessary work will be performed
only once.  But the improvement will be modest, because not all
grammars cause much unnecessary or repeated work.</div>
<div class="Real-P">To be concrete: at the moment tree construction normally takes
between 15% and 50% of the running time, except in a few pathological
cases.  (Some timing data are in the A subdirectory of this project.)
A ten to twenty per cent improvement in the performance of tree
construction will thus provide a one to ten per cent overall
improvement.  In the pathological cases, the improvement should be
greater.
</div>
<div class="Real-P"><i>Parse-forest grammar constructor completed in early March
2022.  It appears not to suffer from the pathological behavior on
right-recursive grammars like some in the zeroes test set, but on
other test cases it is slower than the old code, not faster; the
overall test case times are 25% to 100% higher than for the old
code.</i></div>
</li>
<li>
<div class="Real-P">The current organization based on higher-level functions should be
scrapped, in order that Aparecium can run under Saxon.</div>
<div class="Real-P"><i>Done in connection with parse-forest grammars, March
2022.</i></div>
</li>
</ul>

</div>

<div class="div">

<h3><a class="selflink" name="puzzles" id="puzzles" href="#puzzles"></a>Puzzles to come back to</h3>
<div class="Real-P">As this project has proceeded, I have encountered some unexpected
phenomena.  Sometimes reflection or study has helped me to
understand what at first was puzzling, sometimes not.  The list
below mentions some things I have not yet understood and hope to
come back to and understand, some time.</div>
<ul><li>
<div class="Real-P">The rules in Earley items sometimes appear to have no parents,
sometimes to have an &lt;<em>ixml</em>&gt; parent which does not have the
children I expected it to have.</div>
<div class="Real-P">In v0.1, when Earley items were represented by elements, putting
a rule into an item required that it be copied.  But when Earley
items are represented by maps, copying should no longer be required.
Is there code that is forcing a copy, and if so where?</div>
</li>
<li>
<div class="Real-P">The code for attribute values in <i>tree-from-pfg()</i>
collects text nodes, but if the sequence of text nodes is
serialized, they are treated as if they were strings, or as if they
were not adjacent: whitespace is injected.  Why?</div>
<div class="Real-P">The current workaround with <i>string-join()</i> means I
didn't need to solve this problem to proceed, but it's puzzling.</div>
<div class="Real-P">This appears not to happen in mixed content; is it the fact of
being serialized as an attribute value that is causing the
issue?</div>
</li>
<li>
<div class="Real-P">In Earley recognition, the rule index is a salient part of an
Earley item; in generating a parse-forest grammar, it is irrelevant
and two items are equivalent if they have the same
<i>from</i>, <i>to</i>, and <i>rule</i>
values.</div>
<div class="Real-P">So when items are de-duped in <i>find-walks()</i>, it is
necessary to ignore the rule index.  (When this was not done,
duplicate right-hand sides and duplicate rules appeared in the
parse-forest grammar for &#x201c;<tt>a</tt>&#x201d; parsed against
&#x201c;<tt>S=S;'a'.</tt>&#x201d;)</div>
<div class="Real-P">In principle, it appears that the same ought to apply to
de-duping in <i>make-pfg-rules()</i>.  But when the code is
changed to do that, PFG generation breaks.  Why?</div>
</li>
<li>
<div class="Real-P">Why is tree construction via a parse-forest grammar slower than
direct tree construction?</div>
<div class="Real-P">Conjecture: because in unambiguous cases the PFG has more than
twice as many element nodes:  one for the nonterminal reference, one
for the rule, plus a &lt;<em>literal</em>&gt; element for each text node.</div>
<div class="Real-P">Can empirical counts confirm this?</div>
<div class="Real-P">Would a parse-forest map do better?</div>
</li>
</ul>
</div>
</div>


<div class="div">

<h2><a class="selflink" name="known-limits" id="known-limits" href="#known-limits">C. </a>Known limitations</h2>
<div class="Real-P">Apart from bugs and test failures (on which see
<a href="#known-bugs">below</a>), 
the known limitations and non-conformant behavior of Aparecium
are these.
<ul><li><div class="Real-P">On inputs over a few tens or hundreds of characters, Aparecium
is currently unreasonably slow.</div>
<div class="Real-P">It is hoped that performance will improve in future
versions.</div></li>
<li><div class="Real-P">The ixml specification says that nonterminals which are not
XML names must not be serialized (if they are, it leads to a dynamic
error); Aparecium requires that nonterminal symbols to be XML
non-colonized names (NCNames), whether they are marked hidden or not,
whether they are serialized or not.
</div>
<div class="Real-P">This is unlikely to change in the foreseeable future, as allowing
nonterminals which are not NCNames will require non-trivial rewrites
of existing code.</div></li>
<li><div class="Real-P">Aparecium does not currently support insertions.</div>
<div class="Real-P">This deficiency is expected to be remedied in the near future.
<i>Work is in progress.</i></div>
</li>
</ul>
</div>

</div>

<div class="div">

<h2><a class="selflink" name="known-bugs" id="known-bugs" href="#known-bugs">D. </a>Known bugs and test failures</h2>

<div class="Real-P">As of June 2022, Aparecium passes almost all tests in the ixml community
group's test catalog.  The exceptions are:
<ul><li><div class="Real-P">On some tests involving dynamic errors, Aparecium
fails with an uncaught exception instead of returning a result
with a diagnostic message.</div></li>
<li><div class="Real-P">Aparecium fails all tests involving textual
insertions.</div></li>
</ul>
</div>
<div class="Real-P">The test harness used is described in a separate document
(<a href="#test-harness"></a>).</div>
</div>


<div class="div">

<h2><a class="selflink" name="change-logs" id="change-logs" href="#change-logs">E. </a>Change logs</h2>

<div class="div">

<h3><a class="selflink" name="logs-v0.2" id="logs-v0.2" href="#logs-v0.2"></a>Change log for version 0.2</h3>
<ul><li>2021-08-03 : CMSMcQ : put all (well, almost all) code into
Aparecium.xml, an SWeb document.</li>
</ul>
</div>

<div class="div">

<h3><a class="selflink" name="logs-v0.1" id="logs-v0.1" href="#logs-v0.1"></a>Change log for version 0.1</h3>
<div class="Real-P">The lists below are extracted from the revision histories
at the beginnings of the individual modules.</div>
<div class="Real-P">Aparecium.xqm:
<ul><li>2021-10-03 : CMSMcQ : conversion to SWeb form.</li>
<li>2019-06-03 : CMSMcQ : rename parse-string-with-compiledgrammar as
                         parse-string-with-compiled-grammar.</li>
<li>2019-04-19 : CMSMcQ : force myself to write first version</li>
</ul>
</div>
<div class="Real-P">Earley-parser.xqm:
<ul><li>2021-10-03 : CMSMcQ : into sweb</li>
<li>2019-04-16 : CMSMcQ : copy to new location, use new namespace names</li>
<li>2018-04-05 : CMSMcQ : start file, hesitate a bit</li>
</ul>
</div>
<div class="Real-P">Earley-parser-internals.xqm:
<ul><li>2019-06-30 : CMSMcQ : remove profiling code again (done for now).</li>
<li>2019-06-29 : CMSMcQ : make item-as-map branch, change all type-aware
                         references to items.  Add profiling code.</li>
<li>2019-06-03 : CMSMcQ : first cut at trimming parse tree as specified in G</li>
<li>2019-04-22 : CMSMcQ : On error, give input in full</li>
<li>2019-04-16 : CMSMcQ : move to new location, assign new namespace name</li>
<li>2018-04-08 : CMSMcQ : when ixml.xml is corrected and smart quotes
                         corrected, parses all sample ixml grammars in
                         teststrings.xml</li>
<li>2018-04-08 : CMSMcQ : passes tests for grammars 1-4, parses most 
                         but not all sample ixml grammars.</li>
<li>2018-04-07 : CMSMcQ : made stubs of earley-parser and various
                         functions for returning parse information</li>
</ul>
</div>
<div class="Real-P">Earley-recognizer.xqm:
<ul><li>2019-06-30 : CMSMcQ : Remove profiling code again (done for now)</li>
<li>2019-06-29 : CMSMcQ : Add profiling code to try to find speed issues</li>
<li>2019-04-15 : CMSMcQ : Move to repo, adopt new namespace names.
                      Adjust spelling of some function calls.</li>
<li>2018-04-04 : CMSMcQ : Seem to have been interrupted in this; there is
                      almost nothing here.  Starting again, from sketch
                      made this morning away from desk.  (There are
                      earlier sketches which I am not now consulting.)
                      I'm transcribing the sketch, not trying to test.
                      item() used as type for Earley items.</li>
<li>2018-03-29 : CMSMcQ : made file.  Trying to do in XQuery what I did in
                      Prolog:  small top level ignorant of data
                      representation, lower level that knows.</li>
</ul>
</div>
<div class="Real-P">Earley-rec-internals.xqm:
<ul><li>2019-06-30 : CMSMcQ : remove profiling code (done for now)</li>
<li>2019-06-30 : CMSMcQ : restructure accumulator in earley-closure as
                      map indexed by both start and end points:
                      $acc($n)('from') provides all items with from=$n,
                      $acc($n)('to') all items with to=$n.
                      For now, no indexing by fFinal, fPredictive,
                      or non-terminal.</li>
<li>2019-06-29 : CMSMcQ : rewrite all Earley item constructors, extractors,
                      and functions to use maps and not elements</li>
<li>2019-06-29 : CMSMcQ : make item-as-map branch in git</li>
<li>2019-06-03 : CMSMcQ : make reXTerminal deal properly with hex characters</li>
<li>2019-05-27 : CMSMcQ : resuming work.</li>
<li>2019-04-21 : CMSMcQ : tracing and other changes</li>
<li>2019-04-17 : CMSMcQ : import d2x; add charXHex(); make fNullableNG 
                      take string, not element(nonterminal); make 
                      reXTerminal() handle quote.</li>
<li>2019-04-16 : CMSMcQ : moved to repo; adopted new namespace names.
                      Improved navigation comments.
                      Improved (or supplied) function comments.</li>
<li>2018-04-05 : CMSMcQ : fixed handling of 'quoted' to use attributes;
                      worked on supplying missing functions;
                      fixed symbol/position and initial-state 
                        confusions in functions for rules and items.</li>
<li>2018-04-04 : CMSMcQ : beginning filling out the details, guided
                      by "Unknown function" messages in earley0.xq
		      and here.</li>
<li>2018-03-29 : CMSMcQ : made file.
                      Trying to do in XQuery what I did in Prolog:
                      small top level ignorant of data representation,
                      lower level that knows.  This is the lower
                      level.  To-do list in ~/2018/Earley/status...asc</li>
</ul>
</div>
<div class="Real-P">Gluschkov.xqm:
<ul><li>2019-04-19 : CMSMcQ : Move to repo for easier imports.</li>
<li>2016-04-05 : CMSMcQ : Completed Gluschkov constructor for use in 
                         an Earley parser.</li>
</ul>
</div>
</div>
</div>


<div class="div">

<h2><a class="selflink" name="obsolete" id="obsolete" href="#obsolete">F. </a>Older versions of some code</h2>
<div class="Real-P">Some portions of v0.2 have been made obsolete.
In some cases, changes have been made directly in
the code; in others, scraps have been replaced but
the old scraps have been retained here for
some kind of completeness, which may or may not
make sense.</div>


<div class="div">

<h3><a class="selflink" name="obs-hlf" id="obs-hlf" href="#obs-hlf"></a>Code using higher-level functions</h3>
<div class="Real-P">The earlier versions of the high-level functions
<i>all-trees()</i>, <i>any-tree()</i>, etc. used
higher-level functions.  To work with engines that don't support
higher-level functions, they have been rewritten.
The code should be self-explanatory. </div>
<div class="Real-P">At least, I hope it is, since I don't want to
spend any time explaining it.
<div class="scrap"><span><a name="d3e6944">&#x3008; 234 Declare ep:alltrees() function &#x3009; (for version <em>v0.2</em>) &#x2261;</a></span>
<pre class="scrapbody">(: ep:alltrees($I,$G):  return all loopless parse trees :)
declare function ep:all-trees(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as element()+ {
  (: trace((), 'ep:all-trees calling epi:earley-parse'), :)

  epi:earley-parse($I, $G, epi:all-trees#3)
  
  (: trace((), 'epi:earley-parse has returned '
        || 'and ep:all-trees is about to do so.') :)
};

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#ep-alltrees">Declare ep:all-trees() function 245</a> &#x3009; </span>
</div>
</div>
<div class="Real-P">
<div class="scrap"><span><a name="d3e6949">&#x3008; 235 Declare ep:anytree() function &#x3009; (for version <em>v0.2</em>) &#x2261;</a></span>
<pre class="scrapbody">(: ep:anytree($I,$G):  return one (loopless) parse tree, 
   whichever is found first 
:)
declare function ep:any-tree(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as element()? {
  epi:earley-parse($I, $G, epi:any-tree#3)
};

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#ep-anytree">Declare ep:any-tree() function 246</a> &#x3009; </span>
</div>

</div>
<div class="Real-P">
<div class="scrap"><span><a name="d3e6955">&#x3008; 236 Declare ep:tree-cursor() function &#x3009; (for version <em>v0.2</em>) &#x2261;</a></span>
<pre class="scrapbody">declare function ep:tree-cursor(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as item()* {
  epi:earley-parse($I, $G, epi:tree-cursor#3)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#ep-tree-cursor">Declare ep:tree-cursor() function 247</a> &#x3009; </span>
</div>

</div>
<div class="Real-P">
<div class="scrap"><span><a name="d3e6962">&#x3008; 237 Declare ep:parse-forest-map() function &#x3009; (for version <em>v0.2</em>) &#x2261;</a></span>
<pre class="scrapbody">(: ep:parseforestmap($I,$G):  return a map containing an and/or tree
   representing the set of all parses.
:)
declare function ep:parse-forest-map(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as element()* {
  epi:earley-parse($I, $G, epi:parse-forest-map#3)
};

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#ep-parse-forest-map">Declare ep:parse-forest-map() function 248</a> &#x3009; </span>
</div>

</div>
<div class="Real-P">
<div class="scrap"><span><a name="d3e6968">&#x3008; 238 Declare ep:alltrees() function &#x3009; (for version <em>v0.2</em>) &#x2261;</a></span>
<pre class="scrapbody">(: ep:parseforestgrammar($I,$G):  return a BNF (not EBNF[?]) grammar
   describing the set of all parses of $I against $G.
:)
declare function ep:parse-forest-grammar(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as element()* {
  epi:earley-parse($I, $G, epi:parse-forest-grammar#3)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#ep-parse-forest-grammar">Declare ep:parse-forest-grammar() function 249</a> &#x3009; </span>
</div>

</div>

<div class="Real-P">All of the code just given requires <i>earley-parse()</i>
to accept a higher-level function to do crucial parts of the work.
It still doesn't seem like a bad idea, but when version <i>pfg</i>
was being developed it turned out that the code embeds some false
assumptions about what that function does.  Rather than unsnarl those
assumptions, I rewrote things to use options, rather than higher-level
functions, to control what gets returned (and other things).
<div class="scrap"><span><a name="d3e6978">&#x3008; 239 Define earley-parse() &#x3009; (for version <em>v0.2</em>) &#x2261;</a></span>
<pre class="scrapbody">(: ******************************************************
   earley-parse($I, $G, $f);  run Earley recognizer on 
   input $I and grammar $G, return results using 
   $f($leiClosure, $Ec, $I, $G)
:)
declare function epi:earley-parse(
  $I as xs:string,
  $G as element(ixml),
  $f as function(
    map(*)*  (: Ec :),
    map(*)* (: Closure :),
    xs:string (: Input :)
    (: , element(ixml) (: Grammar :) :)
  ) as item()* 
) as item()* {
  let $dummy := eri:notrace((), 'epi:earley-parse() ...') 
  let $mapResult := (:stat ...prof:time(... tats:)
                    er:recognizeX($I, $G, $options), 
                    (:stat ...'0a recognize(): '),... tats:)

      $meiClosure := $mapResult('Closure'),
      $leiCompletions := $mapResult('Completions')
  return if ($mapResult('Result'))
    then (: if we have a result, return each parse tree :)
        let $dummy := eri:notrace((), 
                      'epi:earley-parse() has result') 
        let $lpt := (:stat ...prof:time(... tats:)
                    $f($leiCompletions, $meiClosure, $I (: , $G :) )
                    (:stat ..., '0b making trees: ')... tats:)
        for $pt at $npt in $lpt
        let $dummy := eri:notrace((), 
                      'epi:earley-parse() returning a result') 
        (: return if (('raw','ast')[2] eq 'raw') 
	       then $pt  
               else epi:astXparsetree($pt, count($lpt)) :)
        (: What an ugly hack!  Clean this up! :)
        (: let $logfn := '/Users/cmsmcq/'
                      || '2021/Aparecium/tests/output/raw.'
	              || translate(
                           string(
                             adjust-dateTime-to-timezone(
                               current-dateTime(), 
                               ())),
                           ' :',
                           '__')
                      || $npt
                      || '.xml'   
        return (file:write($logfn, $pt), 
                epi:astXparsetree($pt, count($lpt))) :)
        return epi:astXparsetree($pt, count($lpt)) 
        
   else (: otherwise, send an apology and explanation :)
   &lt;no-parse&gt;
   &lt;p&gt;Sorry, no parse for this string and grammar.&lt;/p&gt;
   &lt;p&gt;The completions are:&lt;/p&gt;
   &lt;completions&gt;{$leiCompletions}&lt;/completions&gt;
   &lt;p&gt;The map is:&lt;/p&gt;
   
   &lt;Initial-Item&gt;{eri:eXei($mapResult('Initial-Item'))}&lt;/Initial-Item&gt;
   &lt;Input&gt;{$mapResult('Input')}&lt;/Input&gt;
   &lt;Input-Length&gt;{$mapResult('Input-Length')}&lt;/Input-Length&gt;
   &lt;Completions&gt;{
     for $ei in $mapResult('Completions')
     return eri:eXei($ei)
   }&lt;/Completions&gt;
   &lt;Closure&gt;{
     let $mei := $mapResult('Closure')
     for $n in map:keys($mei('to'))
     order by $n descending
     for $ei in $mei('to')($n)
     return eri:eXei($ei)
   }&lt;/Closure&gt;
   &lt;Result&gt;{$mapResult('Result')}&lt;/Result&gt;
   &lt;grammar&gt;{(: 'Omitted.' :) $mapResult('Grammar') }&lt;/grammar&gt;
   &lt;/no-parse&gt;
   (: we have to think about how to return that no-parse signal.
   :)
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#epi-earley-parse">Define earley-parse() 192</a> &#x3009; </span>
</div>

</div>
</div>


<div class="div">

<h3><a class="selflink" name="obs-ll-sym" id="obs-ll-sym" href="#obs-ll-sym"></a>Code for older versions of the ixml specification grammars</h3>
<div class="Real-P">The ixml specification grammar and its XML representation have
changed somewhat over time.  At various times, Aparecium has tried
to support multiple versions of the grammar.  Those efforts are now, I
hope, of no further interest.  In case I need them, however, I have
moved them here.</div>


<div class="div">

<h4><a class="selflink" name="obs-ll-sym-gl-regex" id="obs-ll-sym-gl-regex" href="#obs-ll-sym-gl-regex"></a>2013 code for terminal symbols in the Gluschkov automaton</h4>
<div class="Real-P">In the 2013 grammar supported by Aparecium 0.1, the elements
&lt;<em>quoted</em>&gt;, &lt;<em>charset</em>&gt;, and several others were always
assumed wrapped in a &lt;<em>terminal</em>&gt; element.  They thus occur below
the level of the basic symbol and need no decorations.  We need to
handle them, since when the function is called on their parent
element, it will recursively be called on them, too.  But they can and
should be returned without change. 
<div class="scrap"><span><a name="gl-ME-identity-2013">&#x3008; 240 Handle leaf nodes (v0.1) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/(self::quoted
      or self::charset or self::exclude
      or self::range
      or self::schar or self::dchar))
then 
      $E</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>

</div>
<div class="Real-P"><i>Old version of handling for terminal elements in the construction
of the Gluschkov automaton.</i> In 2013, all terminals
were &lt;<em>terminal</em>&gt; elements. 
<div class="scrap"><span><a name="gl-ME-terminals-2013">&#x3008; 241 Handle terminal nodes (v0.1) &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/self::terminal)
then let $id := '_t_' || (1 + count($E/preceding::terminal))
     return element terminal {
       $E/(@* except (@xml:id, 
                     @nullable, 
                     @first, 
                     @last, 
                     @follow:*)),
       attribute xml:id { $id },
       attribute nullable { false() },
       attribute first { $id },
       attribute last { $id },
       attribute {QName($gl:follow-ns, "follow:" || $id)} { },
       $children
}</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>
</div>

<div class="Real-P"><i>Old code for regexes in Gluschkov module.</i></div>
<div class="Real-P">For ranges, the calculation of the correct regular expression
is straightforward in the simple case:  put a hyphen
between the values of the <em>from</em> and
<em>to</em> attributes, and wrap the entire thing
in square brackets.  But while those attributes
will usually contain single characters, they can
contain doubled quotation marks or hexadecimal strings
preceded by '#'.  It would be tempting to inline this,
but it's just complicated enough that I am going to write
a utility function to do it.
<div class="scrap"><span><a name="gl-read-one-ixml-char">&#x3008; 242 Define gl:read-one-char-spec() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function gl:read-one-char-spec(
  $s as xs:string
) as xs:string {
  if (string-length($s) eq 1)
  then string($s)
  else if ($s eq '""') 
  then '"' 
  else if ($s eq "''") 
  then "'"
  else if (starts-with($s,'#'))
  then codepoints-to-string(d2x:x2d(substring($s, 2)))
  else ""
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>

</div>


<div class="Real-P">Armed with that little function, we can easily
specify the regex for a range.
<div class="scrap"><span><a name="gl-ME-identity">&#x3008; 243 Handle leaf nodes &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">if ($E/self::range)
then 
   element { name($E) } {
      $E/@*, 
      attribute regex {
         '['
         || gl:read-one-char-spec(string($E/@from))
	 || '-'
         || gl:read-one-char-spec(string($E/@to))
	 || ']'	 
      },
      $E/child::node()
   }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#gl-ME">Define function gl:ME() 21</a> &#x3009; <br></span>
</div>

</div>
</div>
</div>



<div class="div">

<h3><a class="selflink" name="legacy-Earley-parser-deadcode" id="legacy-Earley-parser-deadcode" href="#legacy-Earley-parser-deadcode"></a>Dead code from Earley-parser.xqm</h3>
<div class="Real-P"><i>This section contains code that should now all be dead.
It has not yet been deleted in case it is needed.</i></div>
<div class="Real-P"><i>Delete or revise this:  it's out of date.</i>
We will offer four functions (names subject to change):
<ul><li><div class="Real-P">ep:all-trees($I,$G) will return all loopless parse
trees</div></li>
<li><div class="Real-P">ep:any-tree($I, $G) will return the first tree it finds and
stop</div></li>
<li><div class="Real-P">ep:tree-cursor($I, $G) will return two items: the first tree
it finds and a function to call for the next tree (and the next
function); this involves wrapping up continuations and passing them
around.  (It may be helpful to do a five-finger exercise fetching the
items of a sequence one at a time.)</div></li>
<li><div class="Real-P">ep:parse-forest-grammar($I, $G) will return a parse-forest grammar for
the trees.  It can and should include the looped parse trees.  It may
have clean/dirty variants that do or don't bother to clean the grammar
up (tbd; dunno yet).</div></li>
</ul>
</div>
<div class="Real-P">These are all intended to be user-facing; there will be
corresponding functions internal to the module not intended to be
called by the user.
<div class="scrap"><span><a name="d3e7058">&#x3008; 244  [File Earley-parser.xqm]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: Goal:  to return the set of parse trees recorded implicitly in the
   Earley closure.
   :)
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#ep-parse">Define earley:parse() 71</a></em> &#x3009;</span>
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>

<div class="Real-P">The <i>alltrees()</i> function calls
the internal <i>earley-parse()</i> function
and passes options to it to signal what should be done
with the Earley set.
<div class="scrap"><span><a name="ep-alltrees">&#x3008; 245 Declare ep:all-trees() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ep:all-trees($I,$G):  return all loopless parse trees :)
declare function ep:all-trees(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as element()+ {

  epi:earley-parse($I, $G, 
      map { 'return': 'all-trees',
            'tree-count': -1,
            'failure-dump': 'closure'
      }
  )
  
};

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">Other versions of this code are in &#x3008; <a href="#d3e6944">Declare ep:alltrees() function  (v. v0.2) 234</a> &#x3009; <br></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>
</div>

<div class="Real-P">The <i>anytree()</i> function similarly
calls <i>earley-parse()</i> with a different
option.
<div class="scrap"><span><a name="ep-anytree">&#x3008; 246 Declare ep:any-tree() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ep:any-tree($I,$G):  return one (loopless) parse tree, 
   whichever is found first 
:)
declare function ep:any-tree(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as element()? {
  let $result := epi:earley-parse($I, $G, 
                    map { 'return': 'any-tree',
                          'tree-count': 1,
                          'ambiguity-test': true(),
                          'failure-dump': 'closure',
                          'tree-constructor': 'pfg'
                        }
                 )
  return if (count($result) eq 1) 
         then $result
         else if (empty($result))
         then element ap:error {
           attribute id { "ap:tbd23" },
           "Earley-parse returned nothing." 
	 }
         else element ap:error {
           attribute id { "ap:tbd34" },
           attribute code { "ixml:D06" },
           element ap:desc { "No root element." },
           $result
	 }
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">Other versions of this code are in &#x3008; <a href="#d3e6949">Declare ep:anytree() function  (v. v0.2) 235</a> &#x3009; <br></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>
</div>

<div class="Real-P">The <i>tree-cursor()</i> function (not yet
implemented) is intended to return a pair consisting of
(1) a parse tree, and (2) a function that will return
another pair for the next parse tree.  When there are
no more trees, a &#x201c;<tt>no-more-trees</tt>&#x201d; signal
will be returned instead of a function.</div>
<div class="Real-P">The name is intended to recall the cursor notion of SQL
results.</div>
<div class="Real-P">If you keep track of the number of trees delivered, the
no-more-trees signal can distinguish there-were-no-trees
from all-done-now signals.
<div class="scrap"><span><a name="ep-tree-cursor">&#x3008; 247 Declare ep:tree-cursor() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function ep:tree-cursor(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as item()* {
  epi:earley-parse($I, $G,  
      map { 'return': 'tree-cursor',
            'failure-dump': 'closure' }
  )
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">Other versions of this code are in &#x3008; <a href="#d3e6955">Declare ep:tree-cursor() function  (v. v0.2) 236</a> &#x3009; <br></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>

</div>
<div class="Real-P">The idea of the <i>parse-forest-map()</i>
function is to return not a parse tree but a parse forest,
in the form of a map.  It is currently not implemented,
and may be unnecessary.  The <i>parse-forest grammar()</i>
function may suffice.
<div class="scrap"><span><a name="ep-parse-forest-map">&#x3008; 248 Declare ep:parse-forest-map() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ep:parse-forest-map($I,$G):  return a map containing an and/or tree
   representing the set of all parses.
:)
declare function ep:parse-forest-map(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as element()* {
  epi:earley-parse($I, $G, 
      map { 'return': 'parse-forest-map', 
            'tree-count': -1,
            'failure-dump': 'closure'
      }
  )
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">Other versions of this code are in &#x3008; <a href="#d3e6962">Declare ep:parse-forest-map() function  (v. v0.2) 237</a> &#x3009; <br></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>

</div>
<div class="Real-P">The <i>parse-forest-grammar()</i> function
returns an ixml grammar describing a single sentence, from
which parse trees can be constructed.
<div class="scrap"><span><a name="ep-parse-forest-grammar">&#x3008; 249 Declare ep:parse-forest-grammar() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">(: ep:parse-forest-grammar($I,$G):  return a BNF (not EBNF[?]) grammar
   describing the set of all parses of $I against $G.
:)
declare function ep:parse-forest-grammar(
  $I as item() (: INPUT :),
  $G as item() (: GRAMMAR :)
) as element()* {
  epi:earley-parse($I, $G, 
      map { 'return': 'parse-forest-grammar',
            'tree-count': -1,
            'failure-dump': 'closure'
      }
  )
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">Other versions of this code are in &#x3008; <a href="#d3e6968">Declare ep:alltrees() function  (v. v0.2) 238</a> &#x3009; <br></span><span class="scrapinbound">This code is not used elsewhere.<br></span>
</div>

</div>
<div class="Real-P">Let us pause for a moment to summarize the options
these functions are assuming.  Options and their values
include:
<ul><li><b><tt>return</tt></b>:  one of
&#x201c;<tt>all-trees</tt>&#x201d;,
&#x201c;<tt>any-tree</tt>&#x201d;,
&#x201c;<tt>tree-cursor</tt>&#x201d;,
&#x201c;<tt>parse-forest-map</tt>&#x201d;,
&#x201c;<tt>parse-forest-grammar</tt>&#x201d;.</li>
<li><b><tt>tree-count</tt></b>: an integer specifying a
maximum number of trees to (find and) return.  The magic number -1
is used to signal that all (or as many as possible) should be
returned.</li>
<li><b><tt>ambiguity-test</tt></b>: an boolean value used
when the &#x201c;<tt>tree-count</tt>&#x201d; option is 1, to indicate whether
a second tree should be searched for (though not returned), so as to
correctly detect amgiguity.</li>
<li><b><tt>failure-dump</tt></b>: one of
&#x201c;<tt>yes</tt>&#x201d;, &#x201c;<tt>no</tt>&#x201d;, &#x201c;<tt>closure</tt>&#x201d;.
Used in case of parse failures to indicate whether all data
structures should be dumped; &#x201c;<tt>closure</tt>&#x201d; indicates that
just the closure should be provided.</li>
</ul>
</div>
</div>
</div>



<div class="div">

<h2><a class="selflink" name="indices" id="indices" href="#indices">G. </a>Indices</h2>
<div><h2>Index of file names</h2><ul><li>Aparecium.xqm: defined in &#x3008; <a href="#d3e339">1 [File Aparecium.xqm]</a> &#x3009; </li><li>Earley-parser-internals.xqm: defined in &#x3008; <a href="#d3e434">8 [File Earley-parser-internals.xqm]</a> &#x3009; </li><li>Earley-parser.xqm: defined in &#x3008; <a href="#d3e419">7 [File Earley-parser.xqm]</a> &#x3009; , &#x3008; <a href="#d3e7058">244 [File Earley-parser.xqm]</a> &#x3009; </li><li>Earley-rec-internals.xqm: defined in &#x3008; <a href="#d3e503">11 [File Earley-rec-internals.xqm]</a> &#x3009; </li><li>Earley-recognizer.xqm: defined in &#x3008; <a href="#Earley-rec">9 [File Earley-recognizer.xqm]</a> &#x3009; </li><li>Gluschkov.xqm: defined in &#x3008; <a href="#d3e1336">19 [File Gluschkov.xqm]</a> &#x3009; </li><li>compile-grammar.xq: defined in &#x3008; <a href="#d3e403">6 [File compile-grammar.xq]</a> &#x3009; </li><li>parse-resource-with-compiled-grammar.xq: defined in &#x3008; <a href="#d3e395">5 [File parse-resource-with-compiled-grammar.xq]</a> &#x3009; </li><li>parse-resource.xqy: defined in &#x3008; <a href="#d3e378">3 [File parse-resource.xqy]</a> &#x3009; , &#x3008; <a href="#d3e387">4 [File parse-resource.xqy]</a> &#x3009; </li></ul></div>
<div><h2>Index of scrap names</h2><ul><li><a href="#d3e339">[File Aparecium.xqm] 1</a></li><li><a href="#d3e378">[File parse-resource.xqy] 3</a></li><li><a href="#d3e387">[File parse-resource.xqy] 4</a></li><li><a href="#d3e395">[File parse-resource-with-compiled-grammar.xq] 5</a></li><li><a href="#d3e403">[File compile-grammar.xq] 6</a></li><li><a href="#d3e419">[File Earley-parser.xqm] 7</a></li><li><a href="#d3e434">[File Earley-parser-internals.xqm] 8</a></li><li><a href="#Earley-rec">[File Earley-recognizer.xqm] 9</a></li><li><a href="#d3e503">[File Earley-rec-internals.xqm] 11</a></li><li><a href="#d3e1336">[File Gluschkov.xqm] 19</a></li><li><a href="#d3e2265"> 51</a></li><li><a href="#d3e4569"> 155</a></li><li><a href="#d3e7058">[File Earley-parser.xqm] 244</a></li><li><a href="#pfg-fw-set-new-acc">Add satisfactory walks to the accumulator 97</a></li><li><a href="#epi-ans-recnt-munge-mark">Adjust mark attribute on $nodeCh as needed 224</a></li><li><a href="#d3e1810">Calculate follow-set for repetition with separator 29</a></li><li><a href="#gl-ME-alt-follow">Calculate follow:* attributes for alt 39</a></li><li><a href="#gl-ME-rep-follow">Calculate follow:* attributes for repetitions 28</a></li><li><a href="#eri-items-closure">Calculating the closure of an Earley set 137</a></li><li><a href="#ap-grok-charclass">Check character classes 59</a></li><li><a href="#d3e2468">Check for BOM and BOM-similar code points 65</a></li><li><a href="#ap-grok-comp">Check for compiler attributes 54</a></li><li><a href="#d3e2362">Check for compiler attributes 55</a></li><li><a href="#epi-ans-loopcheck">Check for loops, which mean infinite ambiguity 213</a></li><li><a href="#ap-grok-names">Check for non-XML names 57</a></li><li><a href="#ap-grok-names-conformance">Check for non-XML names (strict conformance) 56</a></li><li><a href="#ap-grok-str">Check for structural problems 53</a></li><li><a href="#d3e2463">Check for surrogate code points 64</a></li><li><a href="#ap-grok-alldef">Check for undefined symbols 68</a></li><li><a href="#ap-grok-prod">Check for unproductive symbols (rsn) 70</a></li><li><a href="#ap-grok-reach">Check for unreachable symbols (rsn) 69</a></li><li><a href="#ap-grok-hexref">Check hexadecimal character references 60</a></li><li><a href="#d3e2457">Check range 63</a></li><li><a href="#ap-grok-ranges">Check ranges 67</a></li><li><a href="#epp-ep-versioncheck">Check results for version mismatch 202</a></li><li><a href="#epi-ep-versioncheck">Check results for version mismatch 203</a></li><li><a href="#ap-grok-uniqdef">Check rules for uniqueness 58</a></li><li><a href="#epi-tfgre-get-atts">Collect and serialize attributes 113</a></li><li><a href="#d3e5674">Construct an element holding the node sequence 215</a></li><li><a href="#d3e5680">Construct an element holding the node sequence 216</a></li><li><a href="#epi-ep-any-direct">Construct one tree directly 197</a></li><li><a href="#epi-ep-any-via-pfg">Construct one tree via parse-forest-grammar 198</a></li><li><a href="#epi-tfgre-get-children">Create and serialize children 112</a></li><li><a href="#ep-alltrees">Declare ep:all-trees() function 245</a></li><li><a href="#d3e6944">Declare ep:alltrees() function  (v. v0.2) 234</a></li><li><a href="#d3e6968">Declare ep:alltrees() function  (v. v0.2) 238</a></li><li><a href="#ep-anytree">Declare ep:any-tree() function 246</a></li><li><a href="#d3e6949">Declare ep:anytree() function  (v. v0.2) 235</a></li><li><a href="#ep-parse-forest-grammar">Declare ep:parse-forest-grammar() function 249</a></li><li><a href="#d3e6962">Declare ep:parse-forest-map() function  (v. v0.2) 237</a></li><li><a href="#ep-parse-forest-map">Declare ep:parse-forest-map() function 248</a></li><li><a href="#d3e6955">Declare ep:tree-cursor() function  (v. v0.2) 236</a></li><li><a href="#ep-tree-cursor">Declare ep:tree-cursor() function 247</a></li><li><a href="#epi-all-node-sequences">Define all-node-sequences() 212</a></li><li><a href="#epi-all-trees">Define all-trees() 204</a></li><li><a href="#epi-any-tree">Define any-tree() 209</a></li><li><a href="#epi-astXparsetree">Define astXparsetree() to make AST from raw parse 227</a></li><li><a href="#epi-attsXpt">Define attributesXpt() to collect attributes 231</a></li><li><a href="#d3e5325">Define auxiliary function for all-trees() 205</a></li><li><a href="#epi-avXpt">Define avXpt() to collect attribute value 232</a></li><li><a href="#d3e4748">Define catescXS() to build category escape 170</a></li><li><a href="#d3e4754">Define charXhex() to get character given hex expression 171</a></li><li><a href="#er-comp">Define comp() 78</a></li><li><a href="#ap2-cgfs">Define compile-grammar-from-string() 187</a></li><li><a href="#ap2-cgfu">Define compile-grammar-from-uri() 186</a></li><li><a href="#ap2-cgfx">Define compile-grammar-from-xml() 188</a></li><li><a href="#epi-contentXpt">Define contentXpt() 233</a></li><li><a href="#epi-docelXpt">Define doc-elementXpt() to make AST for document element 228</a></li><li><a href="#d3e4786">Define eXei() to build 'item' element for Earley item 175</a></li><li><a href="#d3e4229">Define earley-closure($lei, $I, $G) 138</a></li><li><a href="#d3e4248">Define earley-closure($pending, $accumulator, $I, $G) 139</a></li><li><a href="#d3e4359">Define earley-closure($pending, $accumulator, $I, $G) 143</a></li><li><a href="#epi-earley-parse">Define earley-parse() 192</a></li><li><a href="#d3e6978">Define earley-parse()  (v. v0.2) 239</a></li><li><a href="#ep-parse">Define earley:parse() 71</a></li><li><a href="#eri-make-p-p-r-ri">Define eiMakePPRRi() 128</a></li><li><a href="#d3e4104">Define eiMakePPT() 129</a></li><li><a href="#epi-elXpt">Define elementXpt() to make AST for one element 230</a></li><li><a href="#d3e4210">Define fAdvanceNrelEE() 136</a></li><li><a href="#d3e4185">Define fExpectsN-Ei() 134</a></li><li><a href="#eri-sym-fNonterminal">Define fNonterminal() 161</a></li><li><a href="#d3e4203">Define fScanrelEE() 135</a></li><li><a href="#eri-sym-fSymbolmatchRRiSym">Define fSymbolmatchRRiSym() 162</a></li><li><a href="#eri-sym-fTerminal">Define fTerminal() 160</a></li><li><a href="#epi-make-pfg-rules">Define function epi:make-pfg-rules() 84</a></li><li><a href="#gl-ME">Define function gl:ME() 21</a></li><li><a href="#gl-merge">Define gl:merge() 35</a></li><li><a href="#gl-read-one-ixml-char">Define gl:read-one-char-spec() 242</a></li><li><a href="#eri-lei-advance-ei-sym-p">Define leiAdvanceEiSymP() 130</a></li><li><a href="#epi-lnDepXCleC">Define lnDepXClEc() 226</a></li><li><a href="#eri-sym-match-length">Define match-length() 152</a></li><li><a href="#eri-notrace-function">Define notrace() function for debugging 179</a></li><li><a href="#epi-parse-forest-grammar">Define parse-forest-grammar() 81</a></li><li><a href="#epi-parse-forest-map">Define parse-forest-map() 211</a></li><li><a href="#ap2-pgfs">Define parse-grammar-from-string() 184</a></li><li><a href="#ap2-pgfu">Define parse-grammar-from-uri() 183</a></li><li><a href="#ap-pr">Define parse-resource() 14</a></li><li><a href="#ap-ps">Define parse-string() 16</a></li><li><a href="#ap-pswcg">Define parse-string-with-compiled-grammar() 17</a></li><li><a href="#er-pred">Define pred() 77</a></li><li><a href="#eri-sym-reXTerminal">Define reXTerminal(), regex from terminal 153</a></li><li><a href="#er-recognize">Define recognize() 79</a></li><li><a href="#d3e2650">Define recognizeX() 80</a></li><li><a href="#d3e4780">Define s X ei() to build string form of Earley item 174</a></li><li><a href="#er-scan">Define scan() 75</a></li><li><a href="#er-scan-pfg">Define scan()  (v. pfg) 76</a></li><li><a href="#d3e4742">Define sceXS() to read range ends 169</a></li><li><a href="#d3e4760">Define string-length() 172</a></li><li><a href="#d3e4767">Define string-value() 173</a></li><li><a href="#eri-trace-function">Define trace() function 177</a></li><li><a href="#d3e4792">Define trace() function for debugging 176</a></li><li><a href="#eri-trace-dummy">Define trace() function for debugging 180</a></li><li><a href="#gl-trace">Define trace() function for debugging 181</a></li><li><a href="#epi-tree-cursor">Define tree-cursor() 210</a></li><li><a href="#ap-grok-hexref-cases">Diagnose errors and return appropriate errors 61</a></li><li><a href="#eri-items">Earley items (constructors, extractors, etc.) 127</a></li><li><a href="#d3e3511">Extend the walk 96</a></li><li><a href="#epi-tfg-insertion">Extract character data from insertion element 122</a></li><li><a href="#epi-tfg-literal">Extract character data from literal element 121</a></li><li><a href="#epi-tfg-alt">Extract sequence of nodes from alt element 119</a></li><li><a href="#epi-tfg-nonterminal">Extract subtree from nonterminal element 120</a></li><li><a href="#epi-tfg-rule">Extract subtree from rule element 109</a></li><li><a href="#epi-tfg-ixml">Extract tree from ixml parse-forest grammar 107</a></li><li><a href="#d3e3749">Extract tree from ixml parse-forest grammar 108</a></li><li><a href="#d3e4127">Extractors for Earley items 131</a></li><li><a href="#d3e4133">Extractors for Earley items 132</a></li><li><a href="#eri-input-ext">Extractors for input 164</a></li><li><a href="#d3e3508">Find follow-on completion items 95</a></li><li><a href="#epi-ans-recnt-lnodechild">Find parse trees for the child completions 222</a></li><li><a href="#epi-ans-recnt-leiprev">Find the child completions for $sym 221</a></li><li><a href="#gl-ME-rep-follow-sep-2">Follow set when p in last(F), G not nullable 31</a></li><li><a href="#gl-ME-rep-follow-sep-1">Follow set when p in last(F), G nullable 30</a></li><li><a href="#gl-ME-rep-follow-sep-4">Follow set when p in last(G), F not nullable 33</a></li><li><a href="#gl-ME-rep-follow-sep-3">Follow set when p in last(G), F nullable 32</a></li><li><a href="#gl-ME-rep-follow-sep-5">Follow set when p non-final in F or G 34</a></li><li><a href="#eri-grammars-predicates">Functions that check grammar properties 149</a></li><li><a href="#eri-grammars-constructors">Functions that construct or return grammars 145</a></li><li><a href="#eri-grammars-extractors">Functions that extract information from grammars 148</a></li><li><a href="#gl-alts-gi">GI for alts element 42</a></li><li><a href="#gl-alts-gi-2013">GI for alts element (v0.1) 43</a></li><li><a href="#epi-all-trees-call-ans">Get the sequences, or rather raw parse trees 207</a></li><li><a href="#d3e4396">Goal-symbol construction 146</a></li><li><a href="#d3e4403">Goal-symbol construction 147</a></li><li><a href="#eri-grammars">Grammars (constructors, extractors, etc.) 144</a></li><li><a href="#gl-ME-alt">Handle alt elements 38</a></li><li><a href="#gl-ME-alternatives">Handle alternatives 41</a></li><li><a href="#gl-ME-def">Handle alts elements (= def) 40</a></li><li><a href="#epi-ans-basecase">Handle base case:  current item is initial 214</a></li><li><a href="#gl-ME-comment">Handle comment elements 46</a></li><li><a href="#gl-ME-ixml">Handle ixml elements (grammars) 48</a></li><li><a href="#gl-ME-identity">Handle leaf nodes 22</a></li><li><a href="#gl-ME-identity">Handle leaf nodes 243</a></li><li><a href="#gl-ME-identity-2013">Handle leaf nodes (v0.1) 240</a></li><li><a href="#gl-ME-nonterminal">Handle nonterminal symbols 24</a></li><li><a href="#gl-ME-option">Handle options 25</a></li><li><a href="#gl-ME-prolog">Handle prolog elements 47</a></li><li><a href="#epi-ans-rec-nonterminal">Handle recursion on nonterminal 220</a></li><li><a href="#epi-ans-rec-terminal">Handle recursion on terminal 218</a></li><li><a href="#epi-ans-rec-terminal-2016">Handle recursion on terminal 219</a></li><li><a href="#epi-ans-recursive">Handle recursive case 217</a></li><li><a href="#gl-ME-repeats">Handle repetitions 27</a></li><li><a href="#gl-ME-repeats-2013">Handle repetitions (v0.1) 26</a></li><li><a href="#gl-ME-rule">Handle rule elements 44</a></li><li><a href="#gl-ME-rule-2013">Handle rule elements (v0.1) 45</a></li><li><a href="#gl-ME-sep">Handle separator expressions 36</a></li><li><a href="#gl-ME-sep-2013">Handle separator expressions (v0.1) 37</a></li><li><a href="#gl-ME-terminals">Handle terminal nodes 23</a></li><li><a href="#gl-ME-terminals-2013">Handle terminal nodes (v0.1) 241</a></li><li><a href="#gl-ME-whahhh">Handle unexpected elements 49</a></li><li><a href="#epi-mpr-stop">If PFG queue is empty, return accumulator 85</a></li><li><a href="#appr-errors">If input or grammar are not found, say so 15</a></li><li><a href="#epi-pfg-error-return">If there is an error, return an error element 83</a></li><li><a href="#epi-rfw-nonterminal">If this step is a nonterminal, return a nonterminal 102</a></li><li><a href="#epi-rfw-terminal">If this step is a terminal, return a literal 100</a></li><li><a href="#epi-rfw-insertion">If this step is an insertion, return an insertion 101</a></li><li><a href="#epi-ep-success">If we have a parse result, return it 193</a></li><li><a href="#pfg-fw-if-done">If we have all our walks, return 93</a></li><li><a href="#epi-rfw-stop">If we're done, return 99</a></li><li><a href="#eri-imports">Imports for recognizer internals 10</a></li><li><a href="#eri-input">Input (constructors, extractors, etc.) 163</a></li><li><a href="#eri-itcl-traces">Issue trace messages for earley-closure() 142</a></li><li><a href="#epi-all-trees-for">Iterate over the list of completion items 206</a></li><li><a href="#d3e4950">Location of ixml grammar 191</a></li><li><a href="#d3e4937">Location of library 190</a></li><li><a href="#aparecium-main">Main interfaces for Aparecium 12</a></li><li><a href="#epp-make-ast">Make AST or no-parse 73</a></li><li><a href="#eri-sym-reXT-literal">Make character-escaped string from literal 154</a></li><li><a href="#epp-make-noparse">Make no-parse result 74</a></li><li><a href="#epp-make-pfg">Make parse-forest grammar or dummy 72</a></li><li><a href="#eri-sym-reXT-range">Make positive character group for range 156</a></li><li><a href="#eri-sym-reXT-lit">Make positive character group from literal 159</a></li><li><a href="#epi-sXpt">Make string from raw parse tree terminal $E 229</a></li><li><a href="#aparecium-imports">Module imports for Aparecium top-level 2</a></li><li><a href="#d3e2473">No error found, return nothing 66</a></li><li><a href="#eri-items-closure-normal">Normal case for Earley closure 141</a></li><li><a href="#d3e4885">Old code for result 185</a></li><li><a href="#aparecium-other-default-options">Other default options 50</a></li><li><a href="#d3e2452">Other error during hex-decimal conversion 62</a></li><li><a href="#d3e3602">Otherwise, something has gone very wrong 103</a></li><li><a href="#d3e4180">Predicates for Earley items 133</a></li><li><a href="#eri-inpred-pfg">Predicates for input: cMatchIPT()  (v. pfg) 166</a></li><li><a href="#eri-input-pred">Predicates for input: fMatchesIPT() 165</a></li><li><a href="#gl-prolog">Prolog for Gluschkov module 20</a></li><li><a href="#epi-ans-rec-whazzat">Raise error if neither terminal nor nonterminal 225</a></li><li><a href="#epi-ans-recnt-recur">Recur on each predictor 223</a></li><li><a href="#epi-mpr-recur">Recursive call with new queue and accumulator 91</a></li><li><a href="#epi-ep-all-trees">Return (approximately) all trees 195</a></li><li><a href="#epi-ep-parse-forest-grammar">Return a parse-forest grammar 199</a></li><li><a href="#epi-ep-parse-forest-map">Return a parse-forest map 201</a></li><li><a href="#epi-ep-tree-cursor">Return a tree cursor 200</a></li><li><a href="#epi-tfg-rule-wha">Return an error element 118</a></li><li><a href="#epi-ep-any-tree">Return any tree 196</a></li><li><a href="#epi-ep-failure">Return parse-failure result 194</a></li><li><a href="#epi-pfg-return">Return parse-forest grammar containing $rules 82</a></li><li><a href="#epi-all-trees-return-trees">Return the raw parse trees 208</a></li><li><a href="#eri-rules">Rules (constructors, extractors, etc.) 150</a></li><li><a href="#aparecium-secondary">Secondary interfaces (a bit specialized) 182</a></li><li><a href="#epi-tfg-random">Select random integer in 0..$n 110</a></li><li><a href="#epi-tfg-rule-zero">Serialize nothing, stop recursion 117</a></li><li><a href="#epi-tfg-rule-attr">Serialize rule as attribute 114</a></li><li><a href="#epi-tfg-rule-av">Serialize rule as attribute value 116</a></li><li><a href="#epi-tfg-rule-content">Serialize rule as content 115</a></li><li><a href="#epi-tfg-rule-elem">Serialize rule as element 111</a></li><li><a href="#eri-sym-reXT-from">Set $cpFrom, $sFrom to effective codepoint and string 157</a></li><li><a href="#eri-sym-reXT-to">Set $cpTo, $sTo to effective codepoint and string 158</a></li><li><a href="#epi-mpr-update-queue">Set $new-queue to include new completions 90</a></li><li><a href="#epi-mpr-make-rule">Set $rule to production rule for $ei 89</a></li><li><a href="#epi-mpr-find-walk">Set $walks to possible child sequences for $ei 88</a></li><li><a href="#pfg-fw-set-new-queue">Set new queue by extending all walks in the queue 94</a></li><li><a href="#d3e4807">Starry trace() function 178</a></li><li><a href="#eri-symbols">Symbols (constructors, extractors, etc.) 151</a></li><li><a href="#eri-items-closure-termination">Terminating case for Earley closure 140</a></li><li><a href="#aparecium-tertiary">Tertiary interfaces (of interest only for maintainer) 189</a></li><li><a href="#ap-doc">The doc() function 18</a></li><li><a href="#epi-find-dups-in-walk">The dups-from-walk() function 105</a></li><li><a href="#epi-tree-from-pfg">The epi:tree-from-pfg() function 106</a></li><li><a href="#epi-find-walks">The find-walks() function 92</a></li><li><a href="#ap-grok">The grammar-ok() function 52</a></li><li><a href="#epi-lei-from-walk">The lei-from-walk() function 104</a></li><li><a href="#epi-rhs-from-walk">The rhs-from-walk() function 98</a></li><li><a href="#adt-eiclosure">Type:  Earley closure 125</a></li><li><a href="#adt-ei">Type: Earley item 123</a></li><li><a href="#pfg-adt-walks">Type: collection of walks 87</a></li><li><a href="#adt-input">Type: input string 126</a></li><li><a href="#adt-list-ei">Type: list of Earley items 124</a></li><li><a href="#pfg-adt-walk">Type: walk in a RHS 86</a></li><li><a href="#eri-utils-and-misc">Utilities for recognizer internals module 168</a></li><li><a href="#aparecium-variables">Variables (of interest only for maintainer) 13</a></li><li><a href="#eri-input-pred-matchlength">match-length(I,p,t) 167</a></li></ul></div>
</div>



</div><div class="notes"><hr><h3>Notes</h3><div class="note">[<a name="d3e125" id="d3e125" href="#ref-to-d3e125">1</a>] 
In most crucial ways, SWeb resembles Knuth's WEB system, as do
most other literate programming systems: code is presented in a
sequence determined by rhetorical and expository considerations and
not by the constraints imposed by the programming language, one code
scrap can refer to another (which generally takes the form of a
hyperlink in the readable documentation, and of a transclusion in
the machine-processable form), and some code scraps are identified
as continuations of others, without an explicit hyperlink from the
predecessor to the continuation.

<div class="Real-P">There are, of course, some differences.  WEB and CWEB are each
specialized to a particular programming language (C, Pascal) and
pretty-print code scraps using a characteristic typographic style;
SWeb follows the example of nuweb, noweb, and other
language-independent systems in presenting code verbatim, much as it
would appear in a programmer's editor before the widespread
introduction of syntax-coloring.  WEB documents consist of a flat
sequence of numbered &#x2018;modules&#x2019; each with at most
one scrap of code; SWeb documents have (or can have) a more
conventional hierarchical structure of sections and subsections; in
consequence, the numbering of code scraps is independent of document
structure.  WEB has a relatively simple but powerful macro system;
SWeb has none.</div>
</div><div class="note">[<a name="d3e220" id="d3e220" href="#ref-to-d3e220">2</a>] 
A simple example is the grammar <tt>S:  'a';
S.</tt>,
for which the single sentence (&#x201c;<tt>a</tt>&#x201d;)
has an infinite number of parses (one <i>S</i>
node, two <i>S</i> nodes, three, ...).
<div class="Real-P">Another is the grammar <tt>S: S*; {nil}.</tt>,
which provides an infinite number of parses for the
empty string, which vary both in depth and in width.</div>
</div><div class="note">[<a name="d3e1036" id="d3e1036" href="#ref-to-d3e1036">3</a>] 
Since in many cases, the grammar in question will just
have been checked, this may lead to unnecessary slowdowns
in some cases.  If it becomes an issue, we can pass an option
in signaling that the grammar has just been checked.  But in
fact it's quite possible that the XQuery engine will detect
the double call and re-use the answer from the first call.
</div><div class="note">[<a name="d3e1363" id="d3e1363" href="#ref-to-d3e1363">4</a>] 
The resulting circular import seems to suggest a failure
of analysis:  perhaps the regex construction belongs here.
But I expect grammar compilation to be refactored soonish,
and the import of <i>eri</i> may no longer be needed.
</div><div class="note">[<a name="d3e1429" id="d3e1429" href="#ref-to-d3e1429">5</a>] 

Note that if some nonterminal <i>N</i> is required in <i>E</i>,
<i>nullable</i> is false even when <i>N</i> generates the empty
string.

<div class="Real-P">It may be helpful in some contexts to distinguish between
&#x2018;<span>generates the empty string of symbols in <i>V</i></span>&#x2019;
(<i>nullable<sub>V</sub></i>) from &#x2018;<span>generates
the empty string of symbols in <i>T</i></span>&#x2019; (<i>nullable<sub>T</sub></i>).  Here, <i>nullable</i> is just
short for <i>nullable<sub>V</sub></i>.
</div>

</div><div class="note">[<a name="d3e2207" id="d3e2207" href="#ref-to-d3e2207">6</a>] 
Note that the class of hygiene problems catalogued in formal
language theory does not coincide exactly with the class of grammars
ixml defines as non-conforming: nothing in the ixml spec appears to
forbid unproductive nonterminals, or terminals which are referred to
but not reachable.
<div class="Real-P">And unlike ixml, formal language theory does not regard the
existence of multiple rules for a nonterminal as any sort of problem
at all.</div>
<div class="Real-P">To be blunt, I am inclined to think that the spec is here too
paternalistic, and that these peculiarities merit a warning, not an
error.  They pose no barrier to successful parsing: undefined
nonterminals will be dead ends in the derivation process, and
unreferenced rules will never play a role in any successful
derivation, but unless every rule in the grammar is useless, parsing
can go on regardless.</div>
<div class="Real-P">So Aparecium has user-settable options to treat multiple definitions,
undefined nonterminals, unreachable nonterminals, and unproductive
nonterminals as errors, as things eliciting warnings, or as things
to be accepted silently.</div>
</div><div class="note">[<a name="d3e2218" id="d3e2218" href="#ref-to-d3e2218">7</a>] 
It is not essential to clean the grammar, but it will make the
grammar smaller and in some cases will avoid useless work by the
Earley parser.
</div><div class="note">[<a name="d3e2375" id="d3e2375" href="#ref-to-d3e2375">8</a>] 
Strictly speaking, a nonterminal which is only
ever used in an attribute value can use any mark
desired, since the mark is ignored.  In this case,
Aparecium will flag an error even though the dynamic
error case cannot arise.
<div class="Real-P">Somehow, this does not worry me much.</div></div><div class="note">[<a name="d3e2391" id="d3e2391" href="#ref-to-d3e2391">9</a>] 
Two possible changes would allow Aparecium to be more conformant on
this point: (1) using &lt;<em>follow:info</em>&gt; elements with
<em>state</em> and <em>follow</em> attributes instead of
<em>follow:nt</em> attributes, or (2) representing the compiled
grammar as a map, not an XML document.
</div><div class="note">[<a name="d3e2827" id="d3e2827" href="#ref-to-d3e2827">10</a>] 
Since those rules would be a potentially
informative description of the garden paths followed by the parser
before they reached a dead end, they might be useful as a
grammar-debugging measure.  But for now we are interested only in
completions that actually play a role in a successful derivation of
the input.</div><div class="note">[<a name="d3e2843" id="d3e2843" href="#ref-to-d3e2843">11</a>] Here <i>q</i><sub><i>f</i></sub> is any final state in the
definition of <i>N</i>.</div><div class="note">[<a name="d3e2878" id="d3e2878" href="#ref-to-d3e2878">12</a>]  I call it a
<i>satisfactory</i> walk because (a) the sequence of
nonterminals satisfies the constraints of the right-hand side, and
(b) the walk is acceptable to the needs of further processing.  And
I need a short way to refer to the class of walks I'm looking
for.
<div class="Real-P">I often slip and refer to these as <em>paths</em> through
the right-hand side, but in graph theory a <em>path</em>
denotes a walk in which no vertex appears more than once.  If
the input grammar is BNF, any walk through any right-hand side
will be a path.  But we are working with EBNF.</div>
</div><div class="note">[<a name="d3e2918" id="d3e2918" href="#ref-to-d3e2918">13</a>] At the moment, there are some infinitely ambiguous
sentences for which we will not in fact get all of the walks
(informally, those involving infinite
&#x2018;horizontal&#x2019; ambiguity, as in &#x201c;<tt>S = A*,
'a'. A = .</tt>&#x201d;).  Our inability to capture horizontal
ambiguities completely appears to be a disadvantage of working
directly with EBNF instead of rewriting the grammar to BNF.  (An
equivalent BNF like &#x201c;<tt>S = _star_A, 'a'. _star_A = {}; A,
_star_A.  A = {}.</tt>&#x201d; does not present the
problem.)<div class="Real-P">The key appears to be that in an EBNF grammar there
may be an infinite number of walks through a right-hand side,
whereas in a BNF grammar that can never be so, because BNF lacks
repetition operators.</div> <div class="Real-P">Note also that the user does
<em>not</em> in fact always want all the walks.  Sometimes any
one will do, with or without the knowledge that the sentence is
ambiguous.</div></div><div class="note">[<a name="d3e3225" id="d3e3225" href="#ref-to-d3e3225">14</a>] 
By <i>iterative function</i> I mean a recursive
function where recursion serves only to provide a looping
construct.
</div><div class="note">[<a name="d3e3233" id="d3e3233" href="#ref-to-d3e3233">15</a>] 
If we are not trying to return all walks but only a finite number
of walks, a depth-first search might be better.  But at the moment I
am reacting, and possibly over-reacting, against the problems in the
depth-first implementation of the
<i>all-node-sequences()</i> function.
</div><div class="note">[<a name="d3e3243" id="d3e3243" href="#ref-to-d3e3243">16</a>] 

In principle, a walk can be extended if the last state reached by
the walk has follow states.  But since right-hand sides in an EBNF can
have cycles, we cut off any walk if its last state has already been
visited more than <i>n</i> times.

<div class="Real-P">If we set <i>n</i> to 0, then we eliminate all loops; that's sufficient
for all normal grammars.  If we set <i>n</i> higher, then we traverse each
loop at most <i>n</i> times; this may be interesting for people fascinated
by ambiguity.</div>

</div><div class="note">[<a name="d3e3450" id="d3e3450" href="#ref-to-d3e3450">17</a>] 
If this is the only source of ambiguity in the parse, returning
<i>n</i> walks will give us <i>n</i> trees.  If there are multiple sources of
ambiguity, the parse-forest grammar will generate more than <i>n</i>
trees, but the cost of returning a richer parse-forest grammar than
needed is lower than the cost of keeping track of how many trees we
could generate from the walks we have so far.  It's worth
remembering that ambiguities are not necessarily independent: having
two two-way ambiguities does not guarantee four trees.
</div><div class="note">[<a name="d3e3470" id="d3e3470" href="#ref-to-d3e3470">18</a>] Note that the current position is the
&#x201c;<tt>from</tt>&#x201d; value for the starter step (a completion for
the parent) but the &#x201c;<tt>to</tt>&#x201d; value for any other
step.</div><div class="note">[<a name="d3e3485" id="d3e3485" href="#ref-to-d3e3485">19</a>] Note that <i>N</i> and <i>T</i> are uniquely
determined by <i>qNext</i> and thus redundant, but including
them as grouping keys allows them to be referred to without
subscripts.</div><div class="note">[<a name="d3e3621" id="d3e3621" href="#ref-to-d3e3621">20</a>] 
Might it be faster to do this at the same time we
generate the right-hand side from the walk?</div><div class="note">[<a name="d3e3731" id="d3e3731" href="#ref-to-d3e3731">21</a>]  Actually, <i>Goal</i> should carry
&#x201c;<tt>mark="-"</tt>&#x201d; in any case.</div><div class="note">[<a name="d3e6214" id="d3e6214" href="#ref-to-d3e6214">22</a>] 
So called because this is a dirty form of the
&#x2018;sugar&#x2019; plan described below.
</div></div></body></html>

