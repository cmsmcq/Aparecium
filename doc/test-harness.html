<!DOCTYPE HTML><html>
<!--Need to find a way to insert the current date-->
<head><meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<title>Test harness for Aparecium</title>

<style type="text/css">
      p {
      margin-top: 0.6em;      
      margin-bottom: 0.6em;
    }
    p.bibl {
      margin-top: 0.6em;      
      margin-bottom: 0.6em;
      margin-left: 2em;
      text-indent: -2em;
    }
    .Real-P {
      margin-top: 0.6em;      
      margin-bottom: 0.6em;
    }
    div.sp {
      margin-top: 0.6em;      
      margin-bottom: 0.6em;
    }
    div.address {
      margin-top: 0.6em;      
      margin-bottom: 0.6em;
      margin-left: 2em;
    }
    div.note {
      margin-top: 1em;      
      margin-left: 2em;
      
    }
    pre {  
      font-family: monospace;
      margin-left: 2em 
    }  
    a:hover { 
      background: #CCF 
    }
    td.no { 
      background: #CCF 
    }
    .author { 
      font-size: x-large
    }
    .bio { 
      font-size: small;
      font-style: italic
    }
    span.decision { 
    }
    span.result { 
      font-weight: bold
    }
    span.aye { 
      display: block;
      margin-left: 2em;
    }
    span.nay { 
      display: block;
      margin-left: 2em;
    }
    span.abstain { 
      display: block;
      margin-left: 2em;
    }
    span.result { 
      display: block;
      margin-left: 2em;
      font-weight: bold
    }
    span.speaker { 
      display: inline;
    }
    span.typename { 
      display: inline;
      font-family: monospace;
    }
    a.selflink {
      text-decoration: none; 
      color: initial;
    }
   
  div.scrap {
    margin-top: 0.5em; 
    background-color: #CFEFCF; 
    background-color: #E7F7E7; 
    padding: 0.6em;
    margin-bottom: 0.5em;
  }
  pre.scrapbody {
    margin-left: 0.5em; 
    margin-bottom: 0.5em;
  }
  span.scrapcontinuations {
    font-size:smaller; 
  }
  span.scrapinbound {
    font-size:smaller;
  }
  span.scrapref {
    display: inline-block;
    text-indent: -0.3em;
    font-family: New Times Roman, serif, Lucida Sans Unicode;
  }
  em.scrapptr {
    font-family: New Times Roman, serif, Lucida Sans Unicode;
  }
  dl.desclist {
    list-style-type: none;
  }
  dl.desclist > dt {
    display: run-in;
    padding-right: 0.5em;
/*
*/
  }
  dl.desclist > dd {
    text-indent: -1em;
    margin-left: 1em; 
  }
  ul.desclist { 
    list-style-type: none;
  }
  ul.desclist > li {
    margin-left: 2em;
    text-indent: -2em;
  }
  div.epigraph .Real-P {margin-top: 0em; margin-bottom: 0em;} 
  </style><link xmlns="http://www.w3.org/1999/xhtml" rel="stylesheet" href="../lib/local.css"></head><body><div class="doc">






<h1>Test harness</h1>
<h1>for Aparecium</h1>


<h3>C. M. Sperberg-McQueen</h3>
<h3>4 February 2022, last revised 5 June 2022</h3>

<div class="versionList"><p>Versions defined:</p><ul>
<li id="qd" class="versionentry"><em>qd:</em>&nbsp;Quick and dirty first cut</li>
<li id="alt" class="versionentry"><em>alt:</em>&nbsp;Alternative formulations of some constructs</li>
<li id="v2" class="versionentry"><em>v2:</em>&nbsp;Version 2, with time monitoring (falls back to qd)</li>
<li id="v3" class="versionentry"><em>v3:</em>&nbsp;Version 3, work around implementation dependencies (falls back to v2)</li>
</ul></div>

<hr><a name="toc"></a>
<ul><!-- and a 1! -->
<li>1. <a href="#task">The task</a></li><li>2. <a href="#testcat">The structure of a test catalog and the test report</a></li><li>3. <a href="#testsets">Handling test catalogs and test sets</a><ul>
<!-- and a 2! -->
<li>3.1. <a href="#setup">Preparing to call the <i>t:run-tests()</i> function</a></li>
<li>3.2. <a href="#run-tests">Handling one test catalog: the <i>run-tests()</i> function</a></li>
<li>3.3. <a href="#run-test-set">Handling one test set: the <i>run-test-set()</i> function</a></li>
</ul></li><li>4. <a href="#grammars">Handling the grammar for a test set</a><ul>
<!-- and a 2! -->
<li>4.1. <a href="#grammar-load">Loading the grammar</a></li>
<li>4.2. <a href="#grammar-checkout">Check the grammar for conformance</a></li>
<li>4.3. <a href="#grammar-write-test-result">Write the grammar test results and recur</a></li>
<li>4.4. <a href="#grammar-tests">Running the &lt;<em>grammar-test</em>&gt;</a></li>
</ul></li><li>5. <a href="#testcases">Handling individual test cases</a><ul>
<!-- and a 2! -->
<li>5.1. <a href="#testcases-running">Running the test cases</a><ul><!-- and a 3! -->
<li>5.1.1. <a href="#testcases-running-f">The <i>run-test-case()</i> function</a></li><li>5.1.2. <a href="#testcaserun-prep">Gathering input and expectations</a></li><li>5.1.3. <a href="#testcaserun-runit">Running the test case</a></li></ul></li>
<li>5.2. <a href="#evaluation">Evaluating the test case results</a></li>
<li>5.3. <a href="#output-options">Output options</a></li>
<li>5.4. <a href="#output">Reporting the results</a><ul><!-- and a 3! -->
<li>5.4.1. <a href="#count-results">Providing a summary of the results</a></li><li>5.4.2. <a href="#output-details">Recording the details of a test</a></li></ul></li>
</ul></li><li>A. <a href="#indices">Indices</a></li>
<li>B. <a href="#geniza">Old code</a></li>
</ul>


<hr>
<div class="Real-P">This document describes a test harness for the invisible-XML
processor Aparecium.  It is a &#x2018;literate program&#x2019;:
the executable code (in this case an XQuery module) is embedded in
English prose explaining the program.  The document assumes the reader
is either familiar with XQuery, literate programming, invisible XML,
and Aparecium, or else possessed of a remarkably high tolerance for
boredom.  For more information on literate programming, Donald Knuth's
article of that name remains a good source.</div>

<div class="Real-P">In its current form, this document describes an initial quick and
dirty first cut, taking a lot of shortcuts in order to get something
running.  When that's done, I expect to come back and to a v0.2
version that replaces some of those quick and dirty shortcuts with
better code.</div>

<div class="Real-P">
<i>To do:</i>
<ul><li><i>Revise grammar-test handling to use standard
compile-grammar functions?</i></li>
<li><i>Revise grammar-test handling to put details where
the user asked for them.</i></li>
<li><i>Write out external expected/reported pairs only if there is
an error; currently the R side is too eager to write a
file.</i></li>
<li><i>Work through test catalogs, fixing problems in the test
harness or the tests, filing issue reports for problems in
Aparecium.</i></li>
<li><i>(Interleaved with the above:) Improve reports and
diagnostics as occasion warrants.  In particular, in cases of failure
record more about the test inputs.</i></li>
<li><i>Resume work on more test sets.</i></li>
<li><i>As occasion dictates and opportunity arises,
do better at protecting against and diagnosing errors.</i></li>
<li><i>TO DO: in all uses of try/catch, record the error details as
is done now in <a name="ref-to-lib-rtc-parse" href="#lib-rtc-parse">54</a>.</i></li>
</ul>
</div>


<div class="div">

<div class="quicknav"><span class="arrow">&nbsp;</span><span class="arrow"><a href="#toc">&#x23f6;</a></span><span class="arrow"><a href="#testcat">&#x23f5;</a></span></div><h2><a class="selflink" name="task" id="task" href="#task">1. </a>The task</h2>
<div class="Real-P">Our task is to define a &#x2018;test harness&#x2019; for
Aparecium.  That involves two things: first an XQuery library module
which reads a test catalog, runs the tests, evaluates the results, and
creates a report showing which test cases passed and which failed, and
second a sample XQuery module which imports and calls the library on a
particular catalog and may save or do something with the result.</div>
<div class="Real-P">The overall structure of the calling module is straightforward:
<div class="scrap"><span><a name="dr-top">&#x3008; 1  [File test-driver.xq]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">import module namespace t =
"http://blackmesatech.com/2022/iXML/test-harness"
at "../build/test-harness.xqm";

declare namespace tc =
"https://github.com/invisibleXML/ixml/test-catalog";

declare namespace file =
"http://expath.org/ns/file";

declare namespace db =
"http://basex.org/modules/db";

declare option db:chop "false";

<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#dr-setup">Set up variables and options 5</a></em> &#x3009;</span>

let $dummy  := file:create-dir($outdir),
    $report := t:run-tests($test-catalog-uri, $options)

<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#dr-counts">Count tests and classify results 71</a></em> &#x3009;</span>
    
return ($report,
        file:write($report-uri, $report))
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>


</div>
<div class="Real-P">The overall structure of the library module is similarly
conventional:
<div class="scrap"><span><a name="lib-top">&#x3008; 2  [File test-harness.xqm]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">module namespace t =
"http://blackmesatech.com/2022/iXML/test-harness";
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-nsdecls">Namespace declarations and imports for library module 3</a></em> &#x3009;</span>

<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-functions">Declare library functions 4</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>
</div>
<div class="Real-P">Since the test catalogs we are processing use the
ixml-tests namespace, we need to declare it.
<div class="scrap"><span><a name="lib-nsdecls">&#x3008; 3 Namespace declarations and imports for library module &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare namespace tc =
"https://github.com/invisibleXML/ixml/test-catalog";

</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e518">Namespace declarations and imports, cont'd 20</a>&#x3009;, &#x3008;<a href="#d3e559">Namespace declarations and imports, cont'd 23</a>&#x3009;, &#x3008;<a href="#d3e628">Namespace declarations and imports, cont'd 31</a>&#x3009;, &#x3008;<a href="#d3e965">Namespace declarations and imports, cont'd 56</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-top">[File test-harness.xqm] 2</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">We can look ahead to the set of functions we will define:
<div class="scrap"><span><a name="lib-functions">&#x3008; 4 Declare library functions &#x3009;  &#x2261;</a></span>
<pre class="scrapbody"><span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-run-tests">The run-tests() function 7</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-run-test-set">The run-test-set() function 12</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-test-grammar">The test-grammar() function 39</a></em> &#x3009;</span>
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-run-test-case">The run-test-case() function 49</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-top">[File test-harness.xqm] 2</a> &#x3009; <br></span>
</div>
</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#task">&#x23f4;</a></span><span class="arrow"><a href="#toc">&#x23f6;</a></span><span class="arrow"><a href="#testsets">&#x23f5;</a></span></div><h2><a class="selflink" name="testcat" id="testcat" href="#testcat">2. </a>The structure of a test catalog and the test report</h2>

<div class="Real-P">The test collections we are interested in running will all have
test catalogs in XML, using the vocabulary defined in the author's
<i>ixml-tests</i> repository on GitHub. A test catalog is an
XML document containing one or more <em>test sets</em>; in the
simple case a test set specifies an ixml grammar and a set of test
cases which use that grammar.  Each test case specifies an input
string to be parsed using the grammar and an expected result.</div>
<div class="Real-P">Several variations are possible:
<ul><li>A test set may contain nested test sets, to group tests in
whatever way seems useful.</li>
<li>Test sets, input grammars, input strings, and expected results
may be embedded in the test catalog or stored externally and referred
to from the catalog.  Grammars may be given in ixml (invisible XML) or
vxml (&#x2018;visible&#x2019; XML) form.</li>
<li>At each level (test catalog, test set, test case), metadata may
be provided: prose descriptions, pointers to external documentation,
and application-specific information (embedded in an &lt;<em>app-info</em>&gt;
element).</li>
</ul>
</div>

<div class="Real-P">The test report we are generating will have a similar structure,
with
<ul><li>&lt;<em>test-report</em>&gt; containing results for a given
&lt;<em>test-catalog</em>&gt;</li>
<li>&lt;<em>test-set-results</em>&gt; containing results for a given
&lt;<em>test-set</em>&gt;</li>
<li>&lt;<em>grammar-result</em>&gt; containing the result for a given
&lt;<em>grammar-test</em>&gt;</li>
<li>&lt;<em>test-result</em>&gt; containing the result for a given
&lt;<em>test-case</em>&gt;</li>
</ul>
External test sets will be brought inline, so the report does not
distinguish between &lt;<em>test-set</em>&gt; and &lt;<em>test-set-ref</em>&gt;
elements in the input.</div>

<div class="Real-P">The schema allows &lt;<em>grammar-result</em>&gt; and &lt;<em>test-result</em>&gt;
to record the details of the test and its results.  So a
&lt;<em>grammar-result</em>&gt; can contain
<ul><li>&lt;<em>ixml-grammar</em>&gt;, &lt;<em>ixml-grammar-ref</em>&gt;,
&lt;<em>vxml-grammar</em>&gt;, or &lt;<em>vxml-grammar-ref</em>&gt; (or
several of these)</li>
<li>a &lt;<em>result</em>&gt; element containing
any of the assertions possible in a &lt;<em>grammar-test</em>&gt;,
followed by any of
<ul><li>&lt;<em>reported-xml</em>&gt;</li>
<li>&lt;<em>reported-xml-ref</em>&gt;</li>
<li>&lt;<em>reported-not-a-sentence</em>&gt;</li>
<li>&lt;<em>reported-not-a-grammar</em>&gt;</li>
</ul>
of which the first two can repeat and can occur together
</li>
</ul>
</div>
<div class="Real-P">A &lt;<em>test-result</em>&gt; element similarly can
repeat the test input and expected results from the test
catalog, and it can also include the grammar used
and the results actually returned by the parser.</div>
<div class="Real-P">I'll specify user options to control the output; see
<a href="#output-options">below</a>.
</div>

</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#testcat">&#x23f4;</a></span><span class="arrow"><a href="#toc">&#x23f6;</a></span><span class="arrow"><a href="#grammars">&#x23f5;</a></span></div><h2><a class="selflink" name="testsets" id="testsets" href="#testsets">3. </a>Handling test catalogs and test sets</h2><ul><li>3.1. <a href="#setup">Preparing to call the <i>t:run-tests()</i> function</a></li><li>3.2. <a href="#run-tests">Handling one test catalog: the <i>run-tests()</i> function</a></li><li>3.3. <a href="#run-test-set">Handling one test set: the <i>run-test-set()</i> function</a></li></ul>

<div class="Real-P">Given the test catalog structure just described, the natural
structure for the test harness is thus to iterate over top-level test
sets, and within a test set to iterate over nested test sets and test
cases.</div>


<div class="div">

<div class="quicknav"><span class="arrow">&nbsp;</span><span class="arrow"><a href="#testsets">&#x23f6;</a></span><span class="arrow"><a href="#run-tests">&#x23f5;</a></span></div><h3><a class="selflink" name="setup" id="setup" href="#setup">3.1. </a>Preparing to call the <i>t:run-tests()</i> function</h3>
<div class="Real-P">The driver will call the library's <i>run-tests()</i>
function with the URI of the test catalog to be run.  Several test
catalogs are available; the driver should make it easy to switch from
one to another.  Since the easiest way to refer to a directory can
vary on different machines, I'll start by putting the relevant
directory names into variables.  I'll use relative paths where
possible.  And while we're thinking about directory names, I'll define
the directory where any output should go, including a timestamp in the
directory name to allow the results of multiple test runs to be saved
without interfering with each other.
<div class="scrap"><span><a name="dr-setup">&#x3008; 5 Set up variables and options &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">let $catalog-index := 'bogons' (: which catalog to run? short name :)
    (: bogons 439. 
       test0 2s, test1 5s, hygiene 12s, zeroes 20s.  
       misc 78s, gxxx 153s, wisp-A 100s.
       test2 745s
    :)

let $invdir := "../../cmsmcq-ixml/tests/",
    $apadir := "../../Aparecium/tests/",
    $ixtdir := "../../ixml-tests/tests-straw/",
    $itwdir := "../../ixml-tests/tests-wood/",
    $outdir := resolve-uri($apadir 
                 || 'results' 
                 || '/results-' 
                 || $catalog-index 
                 || '-'
                 || adjust-dateTime-to-timezone(
                      current-dateTime(), () )
                 || '/'
               ,
                 static-base-uri() 
               ),
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#dr-catfiles">List of available test-catalog files 6</a>&#x3009;, &#x3008;<a href="#dr-options">Set the options for the test harness 70</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#dr-top">[File test-driver.xq] 1</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">Next, I'll make a list of catalogs, and choose the one I want by
indexing into the list.  It's easy to change the index.
<div class="scrap"><span><a name="dr-catfiles">&#x3008; 6 List of available test-catalog files [continues <a href="#dr-setup">5 Set up variables and options</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    $catalog-of-catalogs := &lt;test-catalogs&gt;

      &lt;!-- local catalogs, mostly simple --&gt;

      &lt;catalog n="expr1" path="{$apadir}expr1-20220415.xml"/&gt;&lt;!-- ??? s --&gt;
    
      &lt;!-- under 60 seconds (2.1, 4.8, 20.1, 12.4) --&gt;
      &lt;catalog n="test0" path="{$apadir}test0.xml"/&gt;&lt;!-- 2 s --&gt;
      &lt;catalog n="test1" path="{$apadir}test1.xml"/&gt;&lt;!-- 5 s --&gt;
      &lt;catalog n="hygiene" path="{$itwdir}ixml-20220222/hygiene-tests.xml"/&gt;&lt;!-- 12 s --&gt;&gt;
      &lt;catalog n="zeroes" path="{$apadir}zeroes-tests.xml"/&gt;&lt;!-- 20 s --&gt;

      &lt;!-- under 10 minutes --&gt;      
      &lt;catalog n="misc" path="{$apadir}misc-tests.xml"/&gt;&lt;!-- 78.1s --&gt;
      
      &lt;!-- embeds all the gxxx catalogs so they can be done in a single run --&gt;      
      &lt;catalog n="gxxx"
	       path="{$ixtdir}gxxx/gxxx-test-catalog.xml"/&gt;&lt;!-- 153s --&gt;

      &lt;catalog n="bogons" path="{$apadir}bogons-20220310.xml"/&gt;&lt;!-- 439 s --&gt;

      &lt;!-- under 1 hour () --&gt;
      &lt;catalog n="test2" path="{$apadir}test2.xml"/&gt;&lt;!-- 745 s --&gt;

      &lt;!-- under 2 hours () --&gt;
      &lt;!-- under 5 hours () --&gt;

      &lt;!-- over 5 hours () --&gt;
      &lt;!-- ixml-all is very slow (5.5h or so): 
           all of the tests in the ixml repo --&gt;
      &lt;catalog n="ixml-all"
	       path="{$invdir}test-catalog.xml"/&gt;
      
      &lt;!-- to be timed --&gt;
      &lt;catalog n="prolog" path="{$invdir}grammar-misc/prolog-tests.xml"/&gt;&lt;!-- ? s --&gt;
      &lt;catalog n="insert" path="{$invdir}grammar-misc/insertion-tests.xml"/&gt;&lt;!-- ? s --&gt;
      
      &lt;catalog n="jl-insert-old" path="{$apadir}jl-insertion-test-catalog.xml"/&gt;&lt;!-- ? s --&gt;
      &lt;catalog n="jl-prolog-old" path="{$apadir}jl-prolog-test-catalog.xml"/&gt;&lt;!-- ? s --&gt;

      &lt;!-- syntax error tests in ixml repo --&gt;
      &lt;!-- 24s, --&gt;
      &lt;catalog n="syntax-cagt"
       path="{$invdir}syntax/catalog-as-grammar-tests.xml"/&gt;
      &lt;catalog n="syntax-caii"
       path="{$invdir}syntax/catalog-as-instance-tests-ixml.xml"/&gt;
      &lt;catalog n="syntax-caix"
       path="{$invdir}syntax/catalog-as-instance-tests-xml.xml"/&gt;
      &lt;catalog n="syntax-correct"
       path="{$invdir}syntax/catalog-of-correct-tests.xml"/&gt;

      &lt;!-- other tests in ixml repo --&gt;
      &lt;catalog n="ixml-ambi"
	       path="{$invdir}ambiguous/test-catalog.xml"/&gt;
      &lt;catalog n="ixml-corr"
	       path="{$invdir}correct/test-catalog.xml"/&gt;
      &lt;catalog n="ixml-parse"
	       path="{$invdir}parse/test-catalog.xml"/&gt;
      &lt;catalog n="ixml-error"
	       path="{$invdir}error/test-catalog.xml"/&gt;
      &lt;catalog n="ixml-hygiene"
	       path="{$invdir}hygiene/test-catalog.xml"/&gt;

      &lt;!-- ixml-ixml is slow --&gt;
      &lt;catalog n="ixml-ixml"
	       path="{$invdir}ixml/test-catalog.xml"/&gt;
      


      &lt;!-- Positive and negative catalogs for various small grammars --&gt;

      &lt;catalog n="g010"
	       path="{$ixtdir}gxxx/g010.test-catalog.xml"/&gt;
      &lt;catalog n="g010neg"
	       path="{$ixtdir}gxxx/g010.O3.test-catalog.all.neg.xml"/&gt;
      &lt;catalog n="g011"
	       path="{$ixtdir}gxxx/g011.test-catalog.xml"/&gt;
      &lt;catalog n="g011neg"
	       path="{$ixtdir}gxxx/g011.O3.test-catalog.all.neg.xml"/&gt;
      &lt;catalog n="g012"
	       path="{$ixtdir}gxxx/g012.test-catalog.xml"/&gt;
      &lt;catalog n="g012neg"
	       path="{$ixtdir}gxxx/g012.O3.test-catalog.all.neg.xml"/&gt;
      &lt;catalog n="g022"
	       path="{$ixtdir}gxxx/g022.test-catalog.xml"/&gt;
      &lt;catalog n="g022neg"
	       path="{$ixtdir}gxxx/g022.O3.test-catalog.all.neg.xml"/&gt;
      
      &lt;catalog n="g101"
	       path="{$ixtdir}gxxx/g101.test-catalog.xml"/&gt;
      &lt;catalog n="g101neg"
	       path="{$ixtdir}gxxx/g101.O3.test-catalog.all.neg.xml"/&gt;
      &lt;catalog n="g102"
	       path="{$ixtdir}gxxx/g102.test-catalog.xml"/&gt;
      &lt;catalog n="g102neg"
	       path="{$ixtdir}gxxx/g102.O3.test-catalog.all.neg.xml"/&gt;
      &lt;catalog n="g112"
	       path="{$ixtdir}gxxx/g112.test-catalog.xml"/&gt;
      &lt;catalog n="g112neg"
	       path="{$ixtdir}gxxx/g112.O3.test-catalog.all.neg.xml"/&gt;


      &lt;!-- arithmetic expressions, with 
           2, 7638, 2886, 1020, and 338 test cases.
           Broken. --&gt;
      &lt;catalog n="arith-pos"
	       path="{$ixtdir}arith/arith.test-catalog.pos.xml"/&gt;
      &lt;catalog n="arith-a-neg"
	       path="{$ixtdir}arith/arith.O3.test-catalog.arc.neg.xml"/&gt;
      &lt;catalog n="arith-af-neg"
	       path="{$ixtdir}arith/arith.O3.test-catalog.arc-final.neg.xml"/&gt;
      &lt;catalog n="arith-s-neg"
	       path="{$ixtdir}arith/arith.O3.test-catalog.state.neg.xml"/&gt;
      &lt;catalog n="arith-sf-neg"
	       path="{$ixtdir}arith/arith.O3.test-catalog.state-final.neg.xml"/&gt;

      &lt;!--  straw-man tests on ixml itself
           (n.b. old version of ixml grammar) --&gt;
      &lt;catalog n="straw-ixml"
	       path="{$ixtdir}ixml/ixml.test-catalog.pos.xml"/&gt;

      &lt;!--  wisps test set (currently in progress) --&gt;
      &lt;catalog n="wisp-A"
	       path="{$ixtdir}wisps/wisps-001-020-catalog.xml"/&gt;
      &lt;catalog n="wisp-B"
	       path="{$ixtdir}wisps/wisps-021-040-catalog.xml"/&gt;
      &lt;catalog n="wisp-C"
	       path="{$ixtdir}wisps/wisps-041-060-catalog.xml"/&gt;
      &lt;catalog n="wisp-D"
	       path="{$ixtdir}wisps/wisps-061-080-catalog.xml"/&gt;
      &lt;catalog n="wisp-E"
	       path="{$ixtdir}wisps/wisps-081-102-catalog.xml"/&gt;

      &lt;catalog n="wisps"
	       path="{$ixtdir}wisps/wisp-catalog.xml"/&gt;
         
    &lt;/test-catalogs&gt;,

    $test-catalog-path := $catalog-of-catalogs
                          /catalog[@n=$catalog-index]
                          /@path/string(),

    $test-catalog-uri := resolve-uri($test-catalog-path, 
                                     static-base-uri()),

    $report-filename := 'test-report.' 
                        || replace($test-catalog-uri,
                                   "^(.*)/([^/]*)(\.xml)",
                                   "$2")
                        || '.xml', 
    $report-uri := $outdir || $report-filename,
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>



<div class="Real-P">At this point in the program, we will also want to prepare an
&lt;<em>options</em>&gt; element to specify the options we want to use, but we
will define those <a href="#output-options">later</a>.</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#setup">&#x23f4;</a></span><span class="arrow"><a href="#testsets">&#x23f6;</a></span><span class="arrow"><a href="#run-test-set">&#x23f5;</a></span></div><h3><a class="selflink" name="run-tests" id="run-tests" href="#run-tests">3.2. </a>Handling one test catalog: the <i>run-tests()</i> function</h3>

<div class="Real-P">Now for the top-level function of the library.  The
<i>run-tests()</i> function gets a test catalog element and an
&lt;<em>options</em>&gt; element and runs the tests in that test catalog.  It
takes an &lt;<em>options</em>&gt; element to control some aspects of the
library's behavior.
<div class="scrap"><span><a name="lib-run-tests">&#x3008; 7 The run-tests() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function t:run-tests(
  $catalog-uri as xs:string,
  $options as element(options)
) as element(tc:test-report) {

  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rt-load-cat">Load catalog file into $catalog 8</a></em> &#x3009;</span>
  return element tc:test-report {
    <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rt-metadata">Supply basic metadata for the test report 11</a></em> &#x3009;</span>
    <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rt-check-cat-read">Check for errors reading the catalog 10</a></em> &#x3009;</span>
    for $test-set in $catalog/*
        [self::tc:test-set or self::tc:test-set-ref]
    return t:run-test-set($test-set, 
                          (), 
                          $catalog-uri, 
                          $options)
  }
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-functions">Declare library functions 4</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">Let's try to be careful in our I/O.
<div class="scrap"><span><a name="lib-rt-load-cat">&#x3008; 8 Load catalog file into $catalog &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $catalog := try { 
    doc($catalog-uri)/*
  } catch err:FODC0002 {
    &lt;no-such-catalog/&gt;
  }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">Other versions of this code are in &#x3008; <a href="#d3e327">Load catalog file into $catalog  (v. alt) 9</a> &#x3009; <br></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-run-tests">The run-tests() function 7</a> &#x3009; <br></span>
</div>

A simpler version of this might be:
<div class="scrap"><span><a name="d3e332">&#x3008; 9 Load catalog file into $catalog &#x3009; (for version <em>alt</em>) &#x2261;</a></span>
<pre class="scrapbody">  let $catalog := if (doc-available($catalog-uri))
                  then doc($catalog-uri)/*
                  else &lt;no-such-catalog/&gt;
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#lib-rt-load-cat">Load catalog file into $catalog 8</a> &#x3009; </span>
</div>

</div>
<div class="Real-P">If we did not get a catalog, report that fact.
<div class="scrap"><span><a name="lib-rt-check-cat-read">&#x3008; 10 Check for errors reading the catalog &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    if ($catalog/self::no-such-catalog) then
      element tc:error {
        attribute id { "tc:tbd01" },
        element tc:p {
          text { "Nothing found at "},
          $catalog-uri,
          text { "." }
        }
      }
    else
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-run-tests">The run-tests() function 7</a> &#x3009; <br></span>
</div>

Note the trailing <tt>else</tt> here.
</div>
<div class="Real-P">At the top of the test report we should put some metadata.
(I confess that the main motive for putting the test harness
version into an attribute is to force the namespace declaration
for the test-harness namespace onto the root element.)
<div class="scrap"><span><a name="lib-rt-metadata">&#x3008; 11 Supply basic metadata for the test report &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    attribute t:creator { "Aparecium test harness v3" },
    element tc:metadata {
      element tc:name {
        'Test results for ' || $catalog/@name
      },
      element tc:report-date { 
        current-dateTime()
      },
      element tc:processor { "Aparecium" },
      element tc:processor-version { "v0.1" },
      element tc:catalog-uri { $catalog-uri },
      element tc:catalog-date { 
        ($catalog/@release-date/string(), '??')[1] 
      },
      element tc:description {
        element tc:p {
          text { "Test report generated by test-harness.xqm." }
        }
      }
    },

</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-run-tests">The run-tests() function 7</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">This may need further elaboration.</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#run-tests">&#x23f4;</a></span><span class="arrow"><a href="#testsets">&#x23f6;</a></span><span class="arrow">&nbsp;</span></div><h3><a class="selflink" name="run-test-set" id="run-test-set" href="#run-test-set">3.3. </a>Handling one test set: the <i>run-test-set()</i> function</h3>

<div class="Real-P">The <i>run-test-set()</i> function gets a
&lt;<em>test-set</em>&gt; element and an &lt;<em>options</em>&gt; element
and runs the tests in that test set.  The function may
return more than one element, because if it's called with
a &lt;<em>test-set-ref</em>&gt; element, it will retrieve that catalog
and return a test-set report for each &lt;<em>test-set</em>&gt;
or &lt;<em>test-set-ref</em>&gt; in that catalog.</div>
<div class="Real-P">This single-argument version of the function just
calls a recursive version of the function with appropriate
additional arguments.
<div class="scrap"><span><a name="lib-run-test-set">&#x3008; 12 The run-test-set() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function t:run-test-set(
  $test-set as element(),
  $options as element(options)
) as element() {
  t:run-test-set($test-set, (), (), $options)
};
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#lib-rts3">The recursive run-test-set() function 13</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-functions">Declare library functions 4</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The recursive version of <i>run-test-set()</i> takes two
additional arguments, In addition to the test set element itself.
<ul><li><div class="Real-P">The first is an optional grammar.</div>
<div class="Real-P">Test cases normally use the grammar specified in their containing
test set, but since test sets can nest, the grammar may have been
specified by an ancestor.  So when a test set with a grammar calls the
function recursively on nested test sets, it passes the grammar along
as an argument.</div>
</li>
<li><div class="Real-P">The second is a stack of URIs that we have opened.  This is
used to detect reference cycles and snip them.</div></li>
</ul></div>
<div class="Real-P">The overall structure of the function is straightforward:
we check the element we've been handed and handle it appropriately.
<div class="scrap"><span><a name="lib-rts3">&#x3008; 13 The recursive run-test-set() function [continues <a href="#lib-run-test-set">12 The run-test-set() function</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function t:run-test-set(
  $test-set as element(),
  $grammar as element()?,
  $uri-stack as xs:string*,
  $options as element(options)
) as element()+ {

  if ($test-set/self::tc:test-set-ref)
  then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rts-do-ref">Handle a test-set reference 14</a></em> &#x3009;</span>
  else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rts-do-inline">Handle an inline test-set 15</a></em> &#x3009;</span>
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">The element we are dealing with may be a &lt;<em>test-set</em>&gt; element
(the normal case) or a &lt;<em>test-set-ref</em>&gt; element.  If it's the
latter, we fetch the document and deal with its top-level test sets.
<div class="scrap"><span><a name="lib-rts-do-ref">&#x3008; 14 Handle a test-set reference &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">       let $uri0 := base-uri($test-set),
           $uri1 := string($test-set/@href),
           $uri2 := resolve-uri($uri1, $uri0),
           $newcat := try {
             doc($uri2)
           } catch err:FODC0002 { 
             &lt;no-such-test-set/&gt; 
           }
       return if ($newcat/self::no-such-test-set) then
           element tc:error {
             attribute id { "tc:tbd02" },
             element tc:p {
               text { "Nothing found at "},
               $uri2,
               text { "." }
             }
           }
        else for $test-set 
             in $newcat/*/*
                [self::tc:test-set 
                or self::tc:test-set-ref]
             return t:run-test-set($test-set, 
                                   $grammar, 
                                   ($uri2, $uri-stack),
                                   $options)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-rts3">The recursive run-test-set() function 13</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">The main case is for a &#x2018;real&#x2019; test set.
It may contain a grammar (inline or via reference, in ixml or xml),
and it may contain test cases and nested test sets.  
<div class="scrap"><span><a name="lib-rts-do-inline">&#x3008; 15 Handle an inline test-set &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    let $test-set-name := trace(
                            $test-set/@name/string(),
                            "Starting test set: ")
    <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rts-grammar">Load and compile the grammar for a test set 17</a></em> &#x3009;</span>
    <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rts-grammar-test">Set $grammar-test-result 36</a></em> &#x3009;</span>
    return element tc:test-set-results {
          $test-set/@*, 
          <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rts-write-grammar-result">Record grammar test result 30</a></em> &#x3009;</span>
          <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rts-abort">If grammar is bad, stop now 32</a></em> &#x3009;</span>
          else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rts-nested">Handle nested test sets and test cases 16</a></em> &#x3009;</span>
        }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">Other versions of this code are in &#x3008; <a href="#d3e1392">Handle an inline test-set  (v. alt) 82</a> &#x3009; <br></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-rts3">The recursive run-test-set() function 13</a> &#x3009; <br></span>
</div>

<i>There is an old version of this <a href="#geniza">in the appendix</a>.</i>
</div>
<div class="Real-P">Later sections will describe the handling of <a href="#grammars">grammars</a> and <a href="#testcases">test
cases</a>, but the recursion on nested test sets is pretty much what
might be expected: we iterate over them and call the appropriate
function to handle them.
<div class="scrap"><span><a name="lib-rts-nested">&#x3008; 16 Handle nested test sets and test cases &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      for $c in $test-set/*
          [self::tc:test-set 
          or self::tc:test-set-ref
          or self::tc:test-case]
      return if ($c/self::tc:test-set 
                or $c/self::tc:test-set-ref)
      then t:run-test-set($c, 
                          $grammar, 
                          $uri-stack, 
                          $options)
      else if ($c/self::tc:test-case)
      then t:run-test-case($c, $grammar, $options)
      else element tc:error {
        attribute id { "t:tbd03" },
        text { "The laws of logic have been abrogated?" }
      }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-rts-do-inline">Handle an inline test-set 15</a> &#x3009; &#x3008; <a href="#d3e1395">Handle an inline test-set  (v. alt) 82</a> &#x3009; <br></span>
</div>

</div>

</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#testsets">&#x23f4;</a></span><span class="arrow"><a href="#toc">&#x23f6;</a></span><span class="arrow"><a href="#testcases">&#x23f5;</a></span></div><h2><a class="selflink" name="grammars" id="grammars" href="#grammars">4. </a>Handling the grammar for a test set</h2><ul><li>4.1. <a href="#grammar-load">Loading the grammar</a></li><li>4.2. <a href="#grammar-checkout">Check the grammar for conformance</a></li><li>4.3. <a href="#grammar-write-test-result">Write the grammar test results and recur</a></li><li>4.4. <a href="#grammar-tests">Running the &lt;<em>grammar-test</em>&gt;</a></li></ul>

<div class="div">

<div class="quicknav"><span class="arrow">&nbsp;</span><span class="arrow"><a href="#grammars">&#x23f6;</a></span><span class="arrow"><a href="#grammar-checkout">&#x23f5;</a></span></div><h3><a class="selflink" name="grammar-load" id="grammar-load" href="#grammar-load">4.1. </a>Loading the grammar</h3>

<div class="Real-P">A grammar may be given inline or externally, in ixml or in XML
&#x2014; or not at all in the case of a test set which merely groups
other test sets.
The initial steps to be taken vary among the five cases, but once the
grammar is in XML the steps are the same for all except the last.  So
we begin by getting the grammar into XML and into memory, if there is
a grammar, with a five-way branch on the nature of the grammar
specification.
The locally specified grammar unconditionally overrides any grammar
passed in as an argument, and we keep life simple by using the same
name for it.</div>
<div class="Real-P">In order to cater for the possibility of multiple outputs (both the
main output of the <i>t:run-test-set()</i> function and a file
reporting just the grammar test), we assign the results of the test to
variables which may be combined in different ways in different output.
<div class="scrap"><span><a name="lib-rts-grammar">&#x3008; 17 Load and compile the grammar for a test set &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rts-g-new">Set $new-xml-grammar 18</a></em> &#x3009;</span>
      <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rts-vxml-grammar-check">Set $checked-xml-grammar 27</a></em> &#x3009;</span>
      <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rts-grammar-compilation">Set $grammar to compiled grammar 29</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">Other versions of this code are in &#x3008; <a href="#d3e1404">Load and test the grammar for a test set  (v. alt) 83</a> &#x3009; <br></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-rts-do-inline">Handle an inline test-set 15</a> &#x3009; &#x3008; <a href="#d3e1395">Handle an inline test-set  (v. alt) 82</a> &#x3009; <br></span>
</div>

<i>Old version in <a href="#geniza">appendix</a>.</i>
</div>

<div class="Real-P">If a grammar is specified, we get it into XML form as the value
of <i>$new-xml-grammar</i>. The basic form of this is
straightforward:
<div class="scrap"><span><a name="lib-rts-g-new">&#x3008; 18 Set $new-xml-grammar &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      let $new-xml-grammar := if ($test-set/tc:ixml-grammar)
          then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rts-ld-ixml">Cautiously parse ixml grammar 22</a></em> &#x3009;</span>
          else if ($test-set/tc:vxml-grammar)
          then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rts-ld-vxml">Take the inline vxml grammar 24</a></em> &#x3009;</span>
          else if ($test-set/tc:ixml-grammar-ref)
          then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rts-ld-ixml-ref">Cautiously fetch and parse external ixml grammar 25</a></em> &#x3009;</span> 
          else if ($test-set/tc:vxml-grammar-ref)
          then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rts-ld-vxml-ref">Cautiously fetch external vxml grammar 26</a></em> &#x3009;</span>
          else () (: no new grammar:  inherited, or none :)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">Other versions of this code are in &#x3008; <a href="#d3e499">Set $new-xml-grammar  (v. v2) 19</a> &#x3009; &#x3008; <a href="#d3e523">Set $new-xml-grammar  (v. v3) 21</a> &#x3009; <br></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-rts-grammar">Load and compile the grammar for a test set 17</a> &#x3009; &#x3008; <a href="#d3e1407">Load and test the grammar for a test set  (v. alt) 83</a> &#x3009; <br></span>
</div>
</div>

<div class="Real-P">In version 2 of the test harness, we wrap the above in a call to
the BaseX <i>prof:track()</i> function, if it's available.
This allows us to keep track of the time taken, so we can record that
in the test report.
<div class="scrap"><span><a name="d3e503">&#x3008; 19 Set $new-xml-grammar &#x3009; (for version <em>v2</em>) &#x2261;</a></span>
<pre class="scrapbody">      let $nxg-plus := prof:track(
               if ($test-set/tc:ixml-grammar)
               then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rts-ld-ixml">Cautiously parse ixml grammar 22</a></em> &#x3009;</span>
               else if ($test-set/tc:vxml-grammar)
               then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rts-ld-vxml">Take the inline vxml grammar 24</a></em> &#x3009;</span>
               else if ($test-set/tc:ixml-grammar-ref)
               then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rts-ld-ixml-ref">Cautiously fetch and parse external ixml grammar 25</a></em> &#x3009;</span> 
               else if ($test-set/tc:vxml-grammar-ref)
               then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rts-ld-vxml-ref">Cautiously fetch external vxml grammar 26</a></em> &#x3009;</span>
               else () (: no new grammar:  inherited, or none :)
          ),
          $new-xml-grammar := $nxg-plus?value
          
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#lib-rts-g-new">Set $new-xml-grammar 18</a> &#x3009; </span>
</div>

Using <i>prof:track()</i> requires that we declare
the <i>prof</i> namespace.
<div class="scrap"><span><a name="d3e518">&#x3008; 20 Namespace declarations and imports, cont'd [continues <a href="#lib-nsdecls">3 Namespace declarations and imports for library module</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare namespace prof = "http://basex.org/modules/prof";
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>

<div class="Real-P">In version 3 of the test harness, we supply an alternative code
path for implementations in which the BaseX
<i>prof:track()</i> function is not available.  We define the
variable <i>$prof-track</i> to be either
<i>prof:track()</i> or an alternative function that has the
same interface but does not do any time tracking.
<div class="scrap"><span><a name="d3e531">&#x3008; 21 Set $new-xml-grammar &#x3009; (for version <em>v3</em>) &#x2261;</a></span>
<pre class="scrapbody">      let $prof-track := (function-lookup(
                         QName('http://basex.org/modules/prof',
                               'track'),
                         1),
                         function($item) {
                             map {'time':'?', 'value': $item}
                         }
                         )[1]
      let $nxg-plus := $prof-track(
               if ($test-set/tc:ixml-grammar)
               then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rts-ld-ixml">Cautiously parse ixml grammar 22</a></em> &#x3009;</span>
               else if ($test-set/tc:vxml-grammar)
               then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rts-ld-vxml">Take the inline vxml grammar 24</a></em> &#x3009;</span>
               else if ($test-set/tc:ixml-grammar-ref)
               then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rts-ld-ixml-ref">Cautiously fetch and parse external ixml grammar 25</a></em> &#x3009;</span> 
               else if ($test-set/tc:vxml-grammar-ref)
               then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rts-ld-vxml-ref">Cautiously fetch external vxml grammar 26</a></em> &#x3009;</span>
               else () (: no new grammar:  inherited, or none :)
          ),
          $new-xml-grammar := $nxg-plus?value
          
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#lib-rts-g-new">Set $new-xml-grammar 18</a> &#x3009; </span>
</div>

</div>

<div class="Real-P">Each branch of the <tt>if</tt> / <tt>then</tt> / <tt>else
if</tt> sequence needs to be done cautiously.  First is the inline
ixml case.  We just wrap it in a try/catch and hope for the best.
(Quick and dirty, remember.)

<div class="scrap"><span><a name="lib-rts-ld-ixml">&#x3008; 22 Cautiously parse ixml grammar &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">          try {
                ap:parse-grammar-from-string(
                    $test-set/tc:ixml-grammar/string()
                )
          } catch * {
               element tc:error {
                 attribute id { "t:tbd04" },
                 text { "ixml compilation failed.&amp;#xA;" },
                 "Parse function blew up. ",
                 $err:code, $err:value, 
                 " module: ",
                 $err:module, 
                 "(", $err:line-number, ",", 
                 $err:column-number, ")"
               }               
          }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-rts-g-new">Set $new-xml-grammar 18</a> &#x3009; &#x3008; <a href="#d3e503">Set $new-xml-grammar  (v. v2) 19</a> &#x3009; &#x3008; <a href="#d3e531">Set $new-xml-grammar  (v. v3) 21</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">In order to call the <i>parse-grammar-from-string()</i>
function (and its relatives) in the Aparecium library, we are going to
need to import that library:
<div class="scrap"><span><a name="d3e559">&#x3008; 23 Namespace declarations and imports, cont'd [continues <a href="#lib-nsdecls">3 Namespace declarations and imports for library module</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">import module namespace ap =
"http://blackmesatech.com/2019/iXML/Aparecium"
at "Aparecium.xqm";
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>
</div>

<div class="Real-P">The second case is the inline vxml case.  Here the grammar is
already in XML, so we just assign it.
<div class="scrap"><span><a name="lib-rts-ld-vxml">&#x3008; 24 Take the inline vxml grammar &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">          $test-set/tc:vxml-grammar[1]/*
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-rts-g-new">Set $new-xml-grammar 18</a> &#x3009; &#x3008; <a href="#d3e503">Set $new-xml-grammar  (v. v2) 19</a> &#x3009; &#x3008; <a href="#d3e531">Set $new-xml-grammar  (v. v3) 21</a> &#x3009; <br></span>
</div>
</div>

<div class="Real-P">The external-ixml case has several ways to fail.
For now (quick and dirty) we don't cover them all.
<div class="scrap"><span><a name="lib-rts-ld-ixml-ref">&#x3008; 25 Cautiously fetch and parse external ixml grammar &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">          let $uri0 := $test-set/tc:ixml-grammar-ref
                           /@href/string(),
              $uri1 := base-uri($test-set),
              $uri2 := resolve-uri($uri0, $uri1)
              return 
                if (unparsed-text-available($uri2))
                then try {
                       ap:parse-grammar-from-uri($uri2)
                     } catch * {
                       element tc:error {
                         attribute id { "t:tbd06" },
                         "ixml compilation failed.&amp;#xA;",
                         "Parse function blew up. ",
                         $err:code, $err:value, 
                         " module: ",
                         $err:module, 
                         "(", $err:line-number, ",", 
                         $err:column-number, ")"
                       }
                     }
                else element tc:error {
                       attribute id { "t:tbd07" },
                       text { "external ixml not found" }
                     }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-rts-g-new">Set $new-xml-grammar 18</a> &#x3009; &#x3008; <a href="#d3e503">Set $new-xml-grammar  (v. v2) 19</a> &#x3009; &#x3008; <a href="#d3e531">Set $new-xml-grammar  (v. v3) 21</a> &#x3009; <br></span>
</div>
</div>

<div class="Real-P">The external-vxml case also has several ways to fail, most not
covered here.
<div class="scrap"><span><a name="lib-rts-ld-vxml-ref">&#x3008; 26 Cautiously fetch external vxml grammar &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">          let $uri0 := $test-set/tc:vxml-grammar-ref
                           /@href/string(),
              $uri1 := base-uri($test-set),
              $uri2 := resolve-uri($uri0, $uri1)
          return if (doc-available($uri2))
                 then let $xmlTmp := doc($uri2)
                      return if (exists($xmlTmp/ixml))
                             then $xmlTmp/ixml
                             else element tc:error {
                                    attribute id {"t:tbd08"},
                                    $uri0,
                                    "(" || $uri2 || ")",
                                    " is not an ixml grammar."
                             }
                 else element tc:error {
                        attribute id { "t:tbd09" },
                        text { "external vxml grammar"
                              || " not found at " },
                        $uri0,
                        text { " (i.e. "  },
                        $uri2,
                        text { ")." }
                      }
          
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-rts-g-new">Set $new-xml-grammar 18</a> &#x3009; &#x3008; <a href="#d3e503">Set $new-xml-grammar  (v. v2) 19</a> &#x3009; &#x3008; <a href="#d3e531">Set $new-xml-grammar  (v. v3) 21</a> &#x3009; <br></span>
</div>
</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#grammar-load">&#x23f4;</a></span><span class="arrow"><a href="#grammars">&#x23f6;</a></span><span class="arrow"><a href="#grammar-write-test-result">&#x23f5;</a></span></div><h3><a class="selflink" name="grammar-checkout" id="grammar-checkout" href="#grammar-checkout">4.2. </a>Check the grammar for conformance</h3>

<div class="Real-P">Once we have the new XML grammar, we need to check it for
conformance.  Aparecium provides the <i>ap:grammar-ok()</i>
function to do this, and the test harness should not do any better
than Aparecium itself in checking the grammar, so we just call that
function, if we have a new grammar.
<div class="scrap"><span><a name="lib-rts-vxml-grammar-check">&#x3008; 27 Set $checked-xml-grammar &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      let $prof-time := function-lookup(
              QName('http://basex.org/modules/prof',
                    'time'),
              2)

      let $checked-xml-grammar := 
          if (exists($new-xml-grammar)
              and exists($prof-time)) 
          then $prof-time(
                  ap:grammar-ok($new-xml-grammar)
               , 'test-harness: checking XML grammar.')
          else if (exists($new-xml-grammar))
          then ap:grammar-ok($new-xml-grammar)
          else ()
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">Other versions of this code are in &#x3008; <a href="#d3e582">Set $checked-xml-grammar  (v. alt) 28</a> &#x3009; <br></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-rts-grammar">Load and compile the grammar for a test set 17</a> &#x3009; &#x3008; <a href="#d3e1407">Load and test the grammar for a test set  (v. alt) 83</a> &#x3009; <br></span>
</div>

The older version, for reference:
<div class="scrap"><span><a name="d3e589">&#x3008; 28 Set $checked-xml-grammar &#x3009; (for version <em>alt</em>) &#x2261;</a></span>
<pre class="scrapbody">      let $checked-xml-grammar := 
          if (empty($new-xml-grammar))
          then ()
          else if ($new-xml-grammar/self::ixml)
          then $new-xml-grammar
          else element tc:error {
            attribute id { "t:tbd10" },
            text { "XML grammar not conformant:" },
            $new-xml-grammar
          }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#lib-rts-vxml-grammar-check">Set $checked-xml-grammar 27</a> &#x3009; </span>
</div>

</div>

<div class="Real-P">
If the new grammar is OK so far, we need to compile it.
<div class="scrap"><span><a name="lib-rts-grammar-compilation">&#x3008; 29 Set $grammar to compiled grammar &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      let $grammar := if (exists($new-xml-grammar)
                         and $checked-xml-grammar/self::ixml)
          then try {
            ap:compile-grammar-from-xml($checked-xml-grammar)
          } catch * {
            element tc:error {
              attribute id {"t:tbd11"},
              "Error compiling grammar.&amp;#xA;",
              "Parse function blew up. ",
              $err:code, $err:value, 
              " module: ",
              $err:module, 
              "(", $err:line-number, ",", 
              $err:column-number, ")"
            }
          }
      else $grammar
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-rts-grammar">Load and compile the grammar for a test set 17</a> &#x3009; &#x3008; <a href="#d3e1407">Load and test the grammar for a test set  (v. alt) 83</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">At this point, the code digresses to checking whether the user
requested a grammar test or not; that is described in the next
section.  Within the <i>t:run-test-set()</i> function,
the effect of the grammar test is to set some variables.</div>

<div class="Real-P">Then we return the &lt;<em>test-set-results</em>&gt; element, as shown
above in <a name="ref-to-lib-rts-do-inline" href="#lib-rts-do-inline">15</a>.</div>

</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#grammar-checkout">&#x23f4;</a></span><span class="arrow"><a href="#grammars">&#x23f6;</a></span><span class="arrow"><a href="#grammar-tests">&#x23f5;</a></span></div><h3><a class="selflink" name="grammar-write-test-result" id="grammar-write-test-result" href="#grammar-write-test-result">4.3. </a>Write the grammar test results and recur</h3>

<div class="Real-P">We start by writing out the result of any grammar test, if
one was request.  If the user has specified that results should be
written out in separate files for separate tests, we also need 
to write out the file for the grammar test.
<i>Revision needed here.  The results variable will be a
&lt;<em>grammar-test-result</em>&gt; element with all details.
If the user wants details by-file, just take the element
and the attributes, strip the children.</i>
<div class="scrap"><span><a name="lib-rts-write-grammar-result">&#x3008; 30 Record grammar test result &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">        if (($options/@details = 'by-case')
           and exists($grammar-test-result
                      /self::tc:grammar-result))
        then (element tc:grammar-result {
                $grammar-test-result/@*
             }, 
             let $outfn := 'grammar-test-' 
                           || $test-set-name 
                           || '-results.xml',
                 $out := concat(
                         $options/@output-directory, 
                         '/', $outfn)
             return file:write($out, $grammar-test-result)
             )

        else $grammar-test-result
        ,
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-rts-do-inline">Handle an inline test-set 15</a> &#x3009; &#x3008; <a href="#d3e1395">Handle an inline test-set  (v. alt) 82</a> &#x3009; <br></span>
</div>

The use of <i>file:write()</i> means we need to declare
that namespace:
<div class="scrap"><span><a name="d3e628">&#x3008; 31 Namespace declarations and imports, cont'd [continues <a href="#lib-nsdecls">3 Namespace declarations and imports for library module</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare namespace file =
"http://expath.org/ns/file";
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>

<div class="Real-P">Before recurring on nested test sets and contained test cases, we
should check that the grammar is in fact OK.  The check includes
seeing that <i>t:test-grammar()</i> said, but even if no
grammar test was run we need to check to make sure we actually have a
usable grammar.  First, we check for error signals in the
<i>$checked-xml-grammar</i>.
<div class="scrap"><span><a name="lib-rts-abort">&#x3008; 32 If grammar is bad, stop now &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    if ($checked-xml-grammar/self::tc:error)
    then (element tc:description {
           element tc:p {
             "No workable grammar.  Skipping test",
             "&amp;#xA;cases and nested test sets."
           }
         },
         element tc:app-info { $checked-xml-grammar }
         )
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e662">If grammar is not good, stop now 33</a>&#x3009;, &#x3008;<a href="#d3e668">If we failed the grammar test, stop now 34</a>&#x3009;, &#x3008;<a href="#d3e675">If grammar compilation failed, stop now 35</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-rts-do-inline">Handle an inline test-set 15</a> &#x3009; <br></span>
</div>

<i>To do: Change this to keep going, but produce a
<i>not-a-grammar</i> result for each test case.  Make this
if/then/else sequence calculate a value for an
<i>$grammar-error-message</i> variable.  Then in the instance
test cases, if <tt>exists($grammar-error-message)</tt> then
produce not-a-grammar output.</i>
</div>

<div class="Real-P">Then, in a slightly paranoid way, we check that the
grammar is actually an &lt;<em>ixml</em>&gt; element.[<a name="ref-to-d3e655" href="#d3e655" title="&#xA;As the text suggests, this test was inserted in a moment&#xA;of paranoia, with descriptive text including the phrase&#xA;This case is not supposed to happen.  The para">1</a>]
<div class="scrap"><span><a name="d3e662">&#x3008; 33 If grammar is not good, stop now [continues <a href="#lib-rts-abort">32 If grammar is bad, stop now</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    else if (exists($checked-xml-grammar)
             and 
             not($checked-xml-grammar/self::ixml))
    then (element tc:description {
           element tc:p {
             "No workable grammar.  Skipping test",
             "&amp;#xA;cases and nested test sets."
           }
         },
         element tc:app-info { $checked-xml-grammar }
         )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>

<div class="Real-P">We also check to make sure that we actually passed
the grammar test.
<div class="scrap"><span><a name="d3e668">&#x3008; 34 If we failed the grammar test, stop now [continues <a href="#lib-rts-abort">32 If grammar is bad, stop now</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    else if ($grammar-test-result/@result ne 'pass')
    then element tc:description {
           element tc:p {
             "Failed grammar test.  Skipping test",
             "&amp;#xA;cases and nested test sets."
           }
         }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>

<div class="Real-P">If something went wrong in the compilation step, the
compiled grammar will be an error element.
<div class="scrap"><span><a name="d3e675">&#x3008; 35 If grammar compilation failed, stop now [continues <a href="#lib-rts-abort">32 If grammar is bad, stop now</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    else if ($grammar/self::tc:error)
    then (element tc:description {
           element tc:p {
             "Grammar compilation failed.  Skipping",
             "&amp;#xA; test cases and nested test sets."
           }
         },
         element tc:app-info { $grammar }
         )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>

<div class="Real-P">There may be other conditions we should be checking for;
they should be inserted here.</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#grammar-write-test-result">&#x23f4;</a></span><span class="arrow"><a href="#grammars">&#x23f6;</a></span><span class="arrow">&nbsp;</span></div><h3><a class="selflink" name="grammar-tests" id="grammar-tests" href="#grammar-tests">4.4. </a>Running the &lt;<em>grammar-test</em>&gt;</h3>
<div class="Real-P">If a grammar is given, a &lt;<em>grammar-test</em>&gt; may also be
specified.  If so, we delegate the handling of the test to the
<i>t:test-grammar()</i> function.  The basic form of
this is as follows:
<div class="scrap"><span><a name="lib-rts-grammar-test">&#x3008; 36 Set $grammar-test-result &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    let $gt := $test-set/tc:grammar-test
    let $grammar-test-result := 
        if (exists($gt))
        then t:test-grammar($gt, 
                            $checked-xml-grammar, 
                            $options)
        else ()
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">Other versions of this code are in &#x3008; <a href="#d3e688">Set $grammar-test-result  (v. v2) 37</a> &#x3009; &#x3008; <a href="#d3e702">Set $grammar-test-result  (v. v3) 38</a> &#x3009; &#x3008; <a href="#d3e1419">Set $grammar-test-result  (v. alt) 84</a> &#x3009; <br></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-rts-do-inline">Handle an inline test-set 15</a> &#x3009; &#x3008; <a href="#d3e1407">Load and test the grammar for a test set  (v. alt) 83</a> &#x3009; <br></span>
</div>

In order to record the time taken to parse the
grammar, we need to inject some information into
the grammar test result, which we do using the
update facility.  And if there is no grammar test,
we stick a <i>tc:description</i> into the
variable to record the information.
<div class="scrap"><span><a name="d3e699">&#x3008; 37 Set $grammar-test-result &#x3009; (for version <em>v2</em>) &#x2261;</a></span>
<pre class="scrapbody">    let $gt := $test-set/tc:grammar-test,
        $parsetime := attribute t:parsetime {
                        $nxg-plus?time
                      }
    let $grammar-test-result := 
        if (exists($gt))
        then (copy $gtr := t:test-grammar($gt, 
                            $checked-xml-grammar, 
                            $options)
             modify insert node $parsetime 
                           into $gtr
             return $gtr
             )
        else element tc:description {
               $parsetime,
               element tc:p {
                 "Grammar parse time: ",
                 $nxg-plus?time
               }              
             }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#lib-rts-grammar-test">Set $grammar-test-result 36</a> &#x3009; </span>
</div>
</div>

<div class="Real-P">The code just given relies on support for the XQuery Update
Facility; since some of the XQuery engines I want to use don't support
XQUF, it needs to be re-written:
<div class="scrap"><span><a name="d3e704">&#x3008; 38 Set $grammar-test-result &#x3009; (for version <em>v3</em>) &#x2261;</a></span>
<pre class="scrapbody">    let $gt := $test-set/tc:grammar-test,
        $parsetime := attribute t:parsetime {
                        $nxg-plus?time
                      }
    let $grammar-test-result := 
        if (exists($gt))
        then let $gtr0 := t:test-grammar($gt, 
                            $checked-xml-grammar, 
                            $options)
	     return element {name($gtr0)} {
                 $parsetime,
                 $gtr0/@* except $gtr0/@t:parsetime,
                 $gtr0/child::node()
             }

        else element tc:description {
               $parsetime,
               element tc:p {
                 "Grammar parse time: ",
                 $nxg-plus?time
               }              
             }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#lib-rts-grammar-test">Set $grammar-test-result 36</a> &#x3009; </span>
</div>

</div>

<div class="Real-P">The <i>test-grammar()</i> function is called when we have
(a) what looks like an acceptable vxml grammar and (b) a request for a
grammar test.  We must fetch the expected result, if it's external,
and compare our result to the expected result.  For now, we assume
there will never be more than one expected XML result for a grammar.
<div class="scrap"><span><a name="lib-test-grammar">&#x3008; 39 The test-grammar() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function t:test-grammar(
  $grammar-test as element(tc:grammar-test),
  $xml-grammar as element(),
  $options as element(options)
) as element(tc:grammar-result) {
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-tg-fetch">Fetch expected result of grammar test 40</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-tg-compare">Compare the grammar with the expectation 41</a></em> &#x3009;</span>
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-functions">Declare library functions 4</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">First, we fetch any external result.
<div class="scrap"><span><a name="lib-tg-fetch">&#x3008; 40 Fetch expected result of grammar test &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $e0 := $grammar-test/tc:result/*[1],
      $expectation :=
        if ($e0/self::tc:assert-xml-ref)
        then let $uri0 := $e0/@href/string(),
                 $uri1 := base-uri($grammar-test),
                 $uri2 := resolve-uri($uri0, $uri1)
             return if (doc-available($uri2))
                    then (doc($uri2)/ixml,
                         element tc:error {
                           attribute id { "t:tbd12" },
                           $uri2,
                           " is not an ixml grammar."
                         })[1]
                    else element tc:error {
                      attribute id { "t:tbd13" },
                      $uri2,
                      text { " not found." }
                    }
        else if ($e0/self::tc:assert-xml/ixml)
        then $e0/ixml
        else $e0 (: assert-not-a-{grammar,sentence} :)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-test-grammar">The test-grammar() function 39</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">We now have an ixml grammar in one hand and an expectation in
the other.  The core task here is to perform a deep-equal comparison
on the grammar and the expectation, but we also need to check
for error conditions of various kinds.  We break the if-then-else
chain up into several code scraps to avoid having any of them get
too long.  (Informally:  if I can't see it all on one screen, the
scrap is probably too long.)
<div class="scrap"><span><a name="lib-tg-compare">&#x3008; 41 Compare the grammar with the expectation &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  return element tc:grammar-result {
    <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-tg-cf-errors">Check for error conditions, non-conformant grammar 43</a></em> &#x3009;</span>  
    <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-tg-cf-ok">Return pass if grammar is as expected 42</a></em> &#x3009;</span>
    <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-tg-cf-other">Grammar conformant but not as expected 48</a></em> &#x3009;</span>
  }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-test-grammar">The test-grammar() function 39</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The main case is here:
<div class="scrap"><span><a name="lib-tg-cf-ok">&#x3008; 42 Return pass if grammar is as expected &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    else if (deep-equal($xml-grammar, $expectation))
    then (
           (: grammar conformant and as expected :)
           attribute result { "pass" }
         )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-tg-compare">Compare the grammar with the expectation 41</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">However, we can't just run that test without checking
first to make sure the grammar and expectation are
as they should be.  So before the comparison is run, 
we check for and weed out a lot of other cases.
</div>
<div class="Real-P">If we were unable to fetch the expected result,
then the test case counts as not having been run.
<div class="scrap"><span><a name="lib-tg-cf-errors">&#x3008; 43 Check for error conditions, non-conformant grammar &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    if ($expectation/self::tc:error)
    then ( 
           attribute result { "not-run" },
           element tc:description {
             element tc:p {
               "Expected result not found."
             } 
           },
           element tc:app-info {
             $expectation 
           }
         )
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#d3e758">Check for grammar-not-found errors 44</a>&#x3009;, &#x3008;<a href="#d3e764">Check for syntax errors in grammar 45</a>&#x3009;, &#x3008;<a href="#d3e771">Check for not-a-grammar test 46</a>&#x3009;, &#x3008;<a href="#d3e781">Check for other errors in grammar 47</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-tg-compare">Compare the grammar with the expectation 41</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">If the <i>$xml-grammar</i> parameter is a
&lt;<em>tc:error</em>&gt; element indicating the grammar was not
found, then again we did not run the test.
<div class="scrap"><span><a name="d3e758">&#x3008; 44 Check for grammar-not-found errors [continues <a href="#lib-tg-cf-errors">43 Check for error conditions, non-conformant grammar</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    else if ($xml-grammar/self::tc:error
             [@id = ("t:tbd07", "t:tbd08", "t:tbd09")]
             or $xml-grammar/descendant-or-self::ap:error
             [@id = ('ap:tbd01', 'ap:tbd03', 'ap:tbd14')]
            )
    then (
           attribute result { "not-run" },
           element tc:result {
             $expectation
           },
           element tc:app-info { $xml-grammar }
         )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">If we caught intentional syntax errors in the grammar,
then we pass the test.
<div class="scrap"><span><a name="d3e764">&#x3008; 45 Check for syntax errors in grammar [continues <a href="#lib-tg-cf-errors">43 Check for error conditions, non-conformant grammar</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    else if ($expectation[self::tc:assert-not-a-grammar
             or self::tc:assert-not-a-sentence]
             and
             ($xml-grammar/self::tc:error
             [@id = ("t:tbd04", "t:tbd06")]
             or $xml-grammar/self::no-parse
             or $xml-grammar/child::no-parse
             or $xml-grammar/descendant-or-self::ap:error
	     [@id = ('ap:tbd04' (: error compiling G :),
                     'ap:tbd05' (: compiled grammar flawed :), 
                     'ap:tbd06' (: errors found :), 
                     'ap:tbd07' (: syntax error :), 
                     'ap:tbd08' (: ixml/* unknown :),
                     'ap:tbd09' (: rule/* unknown :), 
                     'ap:tbd11' (: non-xml name :), 
                     'ap:tbd12' (: double def :),
                     'ap:tbd13' (: undefined nt :),
                     'ap:tbd15' (: unable to compile :),
		     'ap:tbd16' (: unk char class :)
		     )]
	     (: maybe also 04, 07, 15? :)
             )
            )
    then (
           (: grammar did not parse :)
           attribute result { "pass" },
           element tc:result {
             $expectation
           },
           element tc:app-info { $xml-grammar }
         )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">If the grammar is syntactically OK but intentionally not
conforming, then we pass the test.
<div class="scrap"><span><a name="d3e771">&#x3008; 46 Check for not-a-grammar test [continues <a href="#lib-tg-cf-errors">43 Check for error conditions, non-conformant grammar</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    else if ($expectation[self::tc:assert-not-a-grammar]
             and
             $xml-grammar/self::tc:error
                          [@id = "t:tbd10"])
    then (
           (: grammar parsed but was nonconformant :)
           attribute result { "pass" },
           element tc:result {
             $expectation
           },
           element tc:app-info { $xml-grammar }
         )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">There may be other conditions we should be checking for;
they can be inserted as further if-then-else clauses here.</div>

<div class="Real-P">As a final filter before comparing the grammar to the
expectation we catch any &lt;<em>tc:error</em>&gt; elements we
have not tested for specifically in the grammar argument.
<div class="scrap"><span><a name="d3e781">&#x3008; 47 Check for other errors in grammar [continues <a href="#lib-tg-cf-errors">43 Check for error conditions, non-conformant grammar</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    else if ($xml-grammar/self::tc:error)
    then (
           attribute result { "fail" },
           element tc:result {
             $expectation
           },
           element tc:description {
             element tc:p {
               "Unexpected error in grammar parameter."
             }
	   },
           element tc:app-info { $xml-grammar }
         )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>

<div class="Real-P">Finally, if no error conditions were detected but the 
grammar was not deep-equal to the expected result, we 
have a sort of catch-all error case.
<div class="scrap"><span><a name="lib-tg-cf-other">&#x3008; 48 Grammar conformant but not as expected &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  else (
         (: grammar conformant but not as expected :)
         attribute result { "fail" },
         element tc:result {
           comment {
            "diagnostics should go here"
           },
           element tc:assert-xml { $expectation },
           element tc:reported-xml { $xml-grammar }
         }
       )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-tg-compare">Compare the grammar with the expectation 41</a> &#x3009; <br></span>
</div>

</div>

</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#grammars">&#x23f4;</a></span><span class="arrow"><a href="#toc">&#x23f6;</a></span><span class="arrow">&nbsp;</span></div><h2><a class="selflink" name="testcases" id="testcases" href="#testcases">5. </a>Handling individual test cases</h2><ul><li>5.1. <a href="#testcases-running">Running the test cases</a><ul><li>5.1.1. <a href="#testcases-running-f">The <i>run-test-case()</i> function</a></li><li>5.1.2. <a href="#testcaserun-prep">Gathering input and expectations</a></li><li>5.1.3. <a href="#testcaserun-runit">Running the test case</a><ul><li>5.1.3.1. <a href="#testcaserunrun-plain">First cut: just run it</a></li><li>5.1.3.2. <a href="#testcaserunrun-try">Second cut:  try/catch</a></li><li>5.1.3.3. <a href="#testcaserunrun-timing-data">Gather timing information</a></li><li>5.1.3.4. <a href="#testcaserunrun-alts">Implementation-independent fallbacks</a></li></ul></li></ul></li><li>5.2. <a href="#evaluation">Evaluating the test case results</a></li><li>5.3. <a href="#output-options">Output options</a></li><li>5.4. <a href="#output">Reporting the results</a><ul><li>5.4.1. <a href="#count-results">Providing a summary of the results</a></li><li>5.4.2. <a href="#output-details">Recording the details of a test</a></li></ul></li></ul>

<div class="div">

<div class="quicknav"><span class="arrow">&nbsp;</span><span class="arrow"><a href="#testcases">&#x23f6;</a></span><span class="arrow"><a href="#evaluation">&#x23f5;</a></span></div><h3><a class="selflink" name="testcases-running" id="testcases-running" href="#testcases-running">5.1. </a>Running the test cases</h3><ul><li>5.1.1. <a href="#testcases-running-f">The <i>run-test-case()</i> function</a></li><li>5.1.2. <a href="#testcaserun-prep">Gathering input and expectations</a></li><li>5.1.3. <a href="#testcaserun-runit">Running the test case</a><ul><li>5.1.3.1. <a href="#testcaserunrun-plain">First cut: just run it</a></li><li>5.1.3.2. <a href="#testcaserunrun-try">Second cut:  try/catch</a></li><li>5.1.3.3. <a href="#testcaserunrun-timing-data">Gather timing information</a></li><li>5.1.3.4. <a href="#testcaserunrun-alts">Implementation-independent fallbacks</a></li></ul></li></ul>
<div class="Real-P">Once we reach a test case, we have a compiled grammar ready.
To run and evaluate the test case:
<ul><li>Fetch the test input string, if it's external, catching
exceptions.</li>
<li>Fetch the expected results, if they are external, catching
exceptions.</li>
<li>If we failed on either the input string or the expectations,
mark the test case as not run.</li>
<li>Otherwise, attempt to parse the string with the compiled grammar
for the test set, catching exceptions.</li>
<li>Otherwise, compare the expected result with the actual result.
<ul><li>If an exception was raised in parsing, mark the test
case as failed.  Otherwise continue.</li>
<li>If there was no parse, then
<ul><li>if the expected result is assert-not-a-sentence (or assert-not-a-grammar?),
then report success,</li>
<li>else (expected result is an XML document) report failure.</li>
</ul>
</li>
<li>If there was one parse, then
<ul><li>if it is deep-equal to at least one XML document among the
expected results, then report success,</li>
<li>else (does not match the expected results) report
failure.</li>
<li></li>
</ul></li>
<li>If there are multiple parses, then
<ul><li>if every parse is deep-equal to at least one XML document among the
expected results, then report success,</li>
<li>else (some parse does not match the expected results) report
failure.</li>
<li></li>
</ul></li>
</ul>
</li>
</ul>

<i>TO DO: find a simple way to do a comparison which ignores the
presence or absence of an <em>ixml:state</em> attribute.</i>
</div>


<div class="div">

<div class="quicknav"><span class="arrow">&nbsp;</span><span class="arrow"><a href="#testcases-running">&#x23f6;</a></span><span class="arrow"><a href="#testcaserun-prep">&#x23f5;</a></span></div><h4><a class="selflink" name="testcases-running-f" id="testcases-running-f" href="#testcases-running-f">5.1.1. </a>The <i>run-test-case()</i> function</h4>
<div class="Real-P">The <i>run-test-case()</i> function does the
task described above, step by step.
<div class="scrap"><span><a name="lib-run-test-case">&#x3008; 49 The run-test-case() function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare function t:run-test-case(
  $test-case as element(tc:test-case),
  $G as element()?,
  $options as element(options)
) as element() {
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rtc-misc-var">Set some handy variables 51</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rtc-fetch-input">Set $input-string 50</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rtc-fetch-expected">Set $expectations 52</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rtc-parse">Set $parse-tree by parsing the test input string 54</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rtc-evaluate">Set $result 67</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rtc-errors">Set $error-details 68</a></em> &#x3009;</span>
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rtc-details">Set $details 74</a></em> &#x3009;</span>
  
  return (element tc:test-result {
    $test-case/@*,
    attribute result { $result },
    <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rtc-report-time">Report parse time if available 58</a></em> &#x3009;</span>,
    <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rtc-report-error">If errors arose in a test case, report them 69</a></em> &#x3009;</span>,
    if ($options/@details eq 'inline')
    then $details
    else ()
  },
  <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rtc-write-test-result">Optionally write out test result 81</a></em> &#x3009;</span>
  )
};
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-functions">Declare library functions 4</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#testcases-running-f">&#x23f4;</a></span><span class="arrow"><a href="#testcases-running">&#x23f6;</a></span><span class="arrow"><a href="#testcaserun-runit">&#x23f5;</a></span></div><h4><a class="selflink" name="testcaserun-prep" id="testcaserun-prep" href="#testcaserun-prep">5.1.2. </a>Gathering input and expectations</h4>
<div class="Real-P">If the input string is external, fetch it.  If we have a problem
fetching it (i.e. if there is no text at that URI), we have a problem.
We are expecting a string, and we can't return an error element.  And
we're not set up to throw and catch exceptions.  So we use a magic
string.
<div class="scrap"><span><a name="lib-rtc-fetch-input">&#x3008; 50 Set $input-string &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    let $input-string := 
        if ($test-case/tc:test-string)
        then string($test-case/tc:test-string)
        else if ($test-case/tc:test-string-ref)
        then let $uri0 := $test-case
                          /tc:test-string-ref/@href
                          /string(),
                 $uri1 := base-uri($test-case),
                 $uri2 := resolve-uri($uri0, $uri1)
             return 
                 if (unparsed-text-available($uri2))
                 then unparsed-text($uri2)
                 else $failure-string
        else "Ich versteh die Welt nicht mehr"
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-run-test-case">The run-test-case() function 49</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">As our magic string we use the words &#x201c;NOT FOUND&#x201d; spelled out using the
&#x2018;language tag&#x2019; characters originally put into
Unicode for inline language marking and later deprecated.  We could
use any string sufficiently unlikely to be used as an external test
input.  For example, U+1D350 &#x201c;Tetragram for failure&#x201d; would also
work.  (And be shorter.)
For that matter, U+FFFD &#x201c;Replacement character&#x201d; might be
apposite here.  It's usually used when transcoding into UCS does
not work; this is roughly analogous.
<div class="scrap"><span><a name="lib-rtc-misc-var">&#x3008; 51 Set some handy variables &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  let $dummy := trace($test-case/@name/string(),
                      "Starting test case: ")
  let $failure-string := 
        ("&#xe004e;&#xe004f;&#xe0054;"
         || "&#xe0020;&#xe0046;&#xe004f;"
         || "&#xe0055;&#xe004e;&#xe0044;"
             (: 'NOT FOUND' in tag block :),
         "&#x1d350;" (: Tetragram for failure :),
         "&#xfffd;" (: U+FFFD :)
        )[2]
</pre>
<span class="scrapcontinuations">Continued in &#x3008;<a href="#lib-rtc-mv-testset">Set $test-set-name, $test-case-ID 75</a>&#x3009;<br></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-run-test-case">The run-test-case() function 49</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">If the expected results are external, we need to fetch them, too.
We need to be careful to ensure that the value of
<i>$expectations</i> is an element and not a document node.
<div class="scrap"><span><a name="lib-rtc-fetch-expected">&#x3008; 52 Set $expectations &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    let $expectations := 
        for $e in $test-case/tc:result/*
        return if ($e/self::tc:assert-not-a-sentence)
            then $e
            else if ($e/self::tc:assert-not-a-grammar)
            then $e
            else if ($e/self::tc:assert-dynamic-error)
            then $e
            else if ($e/self::tc:assert-xml)
            then $e/*
            else if ($e/self::tc:assert-xml-ref)
            then let $uri0 := $e/@href
                              /string(),
                     $uri1 := base-uri($test-case),
                     $uri2 := resolve-uri($uri0, $uri1)
                 return 
                 if (doc-available($uri2))
                 then doc($uri2)/*
                 else element tc:error {
                   attribute id { "t:tbd14" },
                   "Expected result at ",
                   $uri0,
                   " not found. Looked for ",
                   $uri2
                 }
            else element tc:error {
                   attribute id { "t:tbd17" },
                   "Unexpected expectation ",
                   $e
                 }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-run-test-case">The run-test-case() function 49</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#testcaserun-prep">&#x23f4;</a></span><span class="arrow"><a href="#testcases-running">&#x23f6;</a></span><span class="arrow">&nbsp;</span></div><h4><a class="selflink" name="testcaserun-runit" id="testcaserun-runit" href="#testcaserun-runit">5.1.3. </a>Running the test case</h4><ul><li>5.1.3.1. <a href="#testcaserunrun-plain">First cut: just run it</a></li><li>5.1.3.2. <a href="#testcaserunrun-try">Second cut:  try/catch</a></li><li>5.1.3.3. <a href="#testcaserunrun-timing-data">Gather timing information</a></li><li>5.1.3.4. <a href="#testcaserunrun-alts">Implementation-independent fallbacks</a></li></ul>

<div class="Real-P">We have input string and expectations ready,
or else we are holding error markers in their place.
Time to run the test.</div>
<div class="Real-P">The code for running the test has gone through
several iterations, perhaps best understood in
roughly chronological order.</div>


<div class="div">

<div class="quicknav"><span class="arrow">&nbsp;</span><span class="arrow"><a href="#testcaserun-runit">&#x23f6;</a></span><span class="arrow"><a href="#testcaserunrun-try">&#x23f5;</a></span></div><h5><a class="selflink" name="testcaserunrun-plain" id="testcaserunrun-plain" href="#testcaserunrun-plain">5.1.3.1. </a>First cut: just run it</h5>
<div class="Real-P">The initial version of the parser call was straightforward:
<div class="scrap"><span><a name="d3e922">&#x3008; 53 Direct invocation of parse for test case &#x3009; (for version <em>alt</em>) &#x2261;</a></span>
<pre class="scrapbody">          ap:parse-string-with-compiled-grammar(
            $input-string,
            $G
          )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#lib-rtc-parse-with-timeout">Parse the input, with a time limit 55</a> &#x3009; </span>
</div>

But that has some drawbacks, including occasional
uncaught exceptions.  </div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#testcaserunrun-plain">&#x23f4;</a></span><span class="arrow"><a href="#testcaserun-runit">&#x23f6;</a></span><span class="arrow"><a href="#testcaserunrun-timing-data">&#x23f5;</a></span></div><h5><a class="selflink" name="testcaserunrun-try" id="testcaserunrun-try" href="#testcaserunrun-try">5.1.3.2. </a>Second cut:  try/catch</h5>
<div class="Real-P">So we wrap it in a try/catch.
That yields the next version.
<div class="scrap"><span><a name="lib-rtc-parse">&#x3008; 54 Set $parse-tree by parsing the test input string &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    let $parse-tree := 
        <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rtc-parse-precheck">If input string, grammar, or expectations is bad, stop now 60</a></em> &#x3009;</span>
        else try {
          <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rtc-parse-with-timeout">Parse the input, with a time limit 55</a></em> &#x3009;</span>
        } catch xquery:timeout {
          element tc:error {
              attribute id { "t:tbd19" },
              "Parse function timed out at ",
              ($options/@timeout/number(), 600)[1],
	      " seconds."
          }
        } catch * {
          element tc:error {
              attribute id { "t:tbd16" },
              "Parse function blew up. ",
              $err:code, $err:value, 
              " module: ",
              $err:module, 
              "(", $err:line-number, ",", 
              $err:column-number, ")"
          }
        }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">Other versions of this code are in &#x3008; <a href="#d3e974">Set $parse-tree by parsing the test input string  (v. v2) 57</a> &#x3009; &#x3008; <a href="#lib-rtc-parse-v3">Set $parse-tree by parsing the test input string  (v. v3) 61</a> &#x3009; <br></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-run-test-case">The run-test-case() function 49</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">Wrapping the call to the parse function in a try/catch expression
helps with some problems, but not all.  It is embarrassing to admit it,
but at the moment, there are some tests in the test suites that
Aparecium currently executes very slowly.  Indeed, there are some for
which I don't have timings because I have always run out of patience
and canceled them before they ran to completion.  Maybe they would
have finished eventually, or maybe they are exercising an infinite
loop of some kind.  I don't know.</div>
<div class="Real-P">But to avoid making it a contest of patience every time I run
certain test cases, I would like to have the tests time out after some
user-specified point number of seconds.  We can do this with the third
parameter to the BaseX <i>xquery:eval()</i> function.
So we wrap the parse request in a call to <i>xquery:eval()</i>,
specifying a maximum amount of time.
<div class="scrap"><span><a name="lib-rtc-parse-with-timeout">&#x3008; 55 Parse the input, with a time limit &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">          let $query := "import module namespace aparecium
                = 'http://blackmesatech.com/2019/iXML/Aparecium'
                at '../build/Aparecium.xqm';
                declare variable $s external;
                declare variable $g external;
                aparecium:parse-string-with-compiled-grammar($s, $g)",
              $bindings := map {
                             's' : $input-string,
                             'g' : $G
                           },
              $options := map { 
                            'timeout' : 
                            ($options/@timeout/number(), 600)[1]
                          }
          return xquery:eval($query, $bindings, $options)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">Other versions of this code are in &#x3008; <a href="#d3e920">Direct invocation of parse for test case  (v. alt) 53</a> &#x3009; &#x3008; <a href="#d3e1063">Parse the input, maybe with a time limit  (v. v3) 64</a> &#x3009; <br></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-rtc-parse">Set $parse-tree by parsing the test input string 54</a> &#x3009; &#x3008; <a href="#d3e980">Set $parse-tree by parsing the test input string  (v. v2) 57</a> &#x3009; &#x3008; <a href="#lib-rtc-parse-v3">Set $parse-tree by parsing the test input string  (v. v3) 61</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">Note that this formulation gives us a processor dependency; when I
get around to trying to run the test harness in Saxon, a different
formulation will be necessary.  (If push comes to shove, we can
generate different modules for BaseX and Saxon, but it would be nicer
to have them co-exist. <i>See now <a href="#testcaserunrun-alts">Implementation-independent fallbacks</a> below.</i>)</div>
<div class="Real-P">So we need to declare the <i>xquery</i> namespace.
<div class="scrap"><span><a name="d3e965">&#x3008; 56 Namespace declarations and imports, cont'd [continues <a href="#lib-nsdecls">3 Namespace declarations and imports for library module</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">declare namespace xquery = "http://basex.org/modules/xquery";
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>
</div>

</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#testcaserunrun-try">&#x23f4;</a></span><span class="arrow"><a href="#testcaserun-runit">&#x23f6;</a></span><span class="arrow"><a href="#testcaserunrun-alts">&#x23f5;</a></span></div><h5><a class="selflink" name="testcaserunrun-timing-data" id="testcaserunrun-timing-data" href="#testcaserunrun-timing-data">5.1.3.3. </a>Gather timing information</h5>

<div class="Real-P">In the next version (v2), we modify the code for setting the
variable <i>$parse-tree</i> to gather timing information as
well, using the BaseX extension function <i>prof:track()</i>.
<div class="scrap"><span><a name="d3e980">&#x3008; 57 Set $parse-tree by parsing the test input string &#x3009; (for version <em>v2</em>) &#x2261;</a></span>
<pre class="scrapbody">    let $pt-plus := prof:track(
        <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rtc-parse-precheck">If input string, grammar, or expectations is bad, stop now 60</a></em> &#x3009;</span>
        else try {
          <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rtc-parse-with-timeout">Parse the input, with a time limit 55</a></em> &#x3009;</span>
        } catch xquery:timeout {
          element tc:error {
              attribute id { "t:tbd19" },
              "Parse function timed out at ",
              ($options/@timeout/number(), 600)[1],
	      " seconds."
          }
        } catch * {
          element tc:error {
              attribute id { "t:tbd16" },
              "Parse function blew up. ",
              $err:code, $err:value, 
              " module: ",
              $err:module, 
              "(", $err:line-number, ",", 
              $err:column-number, ")"
          }
        }
        )
    let $parse-tree := $pt-plus?value 
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#lib-rtc-parse">Set $parse-tree by parsing the test input string 54</a> &#x3009; </span>
</div>

</div>
<div class="Real-P">The variable <i>$pt-plus</i> also has timing
information, which we report as needed.
<div class="scrap"><span><a name="lib-rtc-report-time">&#x3008; 58 Report parse time if available &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">  if (exists($pt-plus))
  then attribute t:parsetime { $pt-plus?time }
  else ()
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-run-test-case">The run-test-case() function 49</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The mechanism for setting options has not yet been described,
but it will be no surprise that it involves an XML document.  We can
set the <i>timeout</i> option this way:
<div class="scrap"><span><a name="set-timeout-option">&#x3008; 59 Set timeout option &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">      attribute timeout { 600 }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#dr-options">Set the options for the test harness 70</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">The preliminary checks before parsing are for failures in fetching
the input string or the expectations, or for a bad grammar.
<div class="scrap"><span><a name="lib-rtc-parse-precheck">&#x3008; 60 If input string, grammar, or expectations is bad, stop now &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">        if ($input-string eq $failure-string)
        then ()
        else if ($expectations/self::tc:error)
        then ()
        else if (not($G/self::ixml))
        then element tc:error {
               attribute id { "t:tbd18" },
               element tc:msg {
                 "This is not an ixml grammar: "
               },
               $G
             }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-rtc-parse">Set $parse-tree by parsing the test input string 54</a> &#x3009; &#x3008; <a href="#d3e980">Set $parse-tree by parsing the test input string  (v. v2) 57</a> &#x3009; &#x3008; <a href="#lib-rtc-parse-v3">Set $parse-tree by parsing the test input string  (v. v3) 61</a> &#x3009; <br></span>
</div>

</div>

</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#testcaserunrun-timing-data">&#x23f4;</a></span><span class="arrow"><a href="#testcaserun-runit">&#x23f6;</a></span><span class="arrow">&nbsp;</span></div><h5><a class="selflink" name="testcaserunrun-alts" id="testcaserunrun-alts" href="#testcaserunrun-alts">5.1.3.4. </a>Implementation-independent fallbacks</h5>

<div class="Real-P">The code given works but has an unfortunate dependency on BaseX,
which works against the goal of making Aparecium work with other
XQuery engines, since that goal requires running the test suite with
those other engines.</div>

<div class="Real-P">So in the next version (v3), we (attempt to) provide alternate code
paths for processors with and without the <i>prof:track()</i>
and <i>xquery:eval()</i> functions.  The overall structure of
the code is very similar, but instead of calling
<i>prof:track()</i> directly we call the value of a variable
named <i>$prof-track</i>, whose value needs to be set up in
advance, as does that of a variable unsurprisingly named
<i>$xquery-eval</i>.

<div class="scrap"><span><a name="lib-rtc-parse-v3">&#x3008; 61 Set $parse-tree by parsing the test input string &#x3009; (for version <em>v3</em>) &#x2261;</a></span>
<pre class="scrapbody">    <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rtc-parse-prof-track">Define $prof-track as implementation-dependent function 62</a></em> &#x3009;</span>
    <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rtc-parse-xquery-eval">Define $xquery-eval-track as implementation-dependent function 63</a></em> &#x3009;</span>

    let $pt-plus := $prof-track(
        <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rtc-parse-precheck">If input string, grammar, or expectations is bad, stop now 60</a></em> &#x3009;</span>
        else try {
          <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rtc-parse-with-timeout">Parse the input, with a time limit 55</a></em> &#x3009;</span>
        } catch xquery:timeout {
          element tc:error {
              attribute id { "t:tbd19" },
              "Parse function timed out at ",
              ($options/@timeout/number(), 600)[1],
	      " seconds."
          }
        } catch * {
          element tc:error {
              attribute id { "t:tbd16" },
              "Parse function blew up. ",
              $err:code, $err:value, 
              " module: ",
              $err:module, 
              "(", $err:line-number, ",", 
              $err:column-number, ")"
          }
        }
        )
    let $parse-tree := $pt-plus?value 
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#lib-rtc-parse">Set $parse-tree by parsing the test input string 54</a> &#x3009; </span>
</div>

</div>

<div class="Real-P">The variable <i>$prof-track</i> will hold either the BaseX
<i>prof:track()</i> function or a dummy function that has
the same interface but produces no useful timing information.
<div class="scrap"><span><a name="lib-rtc-parse-prof-track">&#x3008; 62 Define $prof-track as implementation-dependent function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    let $prof-track := (
        function-lookup(
            QName('http://basex.org/modules/prof',
                  'track'),
            1),
        function($items) { 
            map { 'time': '?', 'value': $items } 
        }
        )[1]
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-rtc-parse-v3">Set $parse-tree by parsing the test input string  (v. v3) 61</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">The <i>$xquery-eval</i> variable, by contrast, does not
have an alternate function: it either holds the
<i>xquery:eval()</i> function or is empty.
<div class="scrap"><span><a name="lib-rtc-parse-xquery-eval">&#x3008; 63 Define $xquery-eval-track as implementation-dependent function &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    let $xquery-eval := function-lookup(
            QName('http://basex.org/modules/xquery',
                  'eval'),
            3)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-rtc-parse-v3">Set $parse-tree by parsing the test input string  (v. v3) 61</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">Using this variable, we can choose two ways to
produce the parse tree.
<div class="scrap"><span><a name="d3e1065">&#x3008; 64 Parse the input, maybe with a time limit &#x3009; (for version <em>v3</em>) &#x2261;</a></span>
<pre class="scrapbody">          if (exists($xquery-eval))
          then <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rtcp-with-eval">Parse the input using xquery:eval() 65</a></em> &#x3009;</span>
          else <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rtcp-without-eval">Parse the input directly 66</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#lib-rtc-parse-with-timeout">Parse the input, with a time limit 55</a> &#x3009; </span>
</div>
</div>
<div class="Real-P">If <i>xquery:eval()</i> is available, we
use it; this code is the same as that for version v2.
<div class="scrap"><span><a name="lib-rtcp-with-eval">&#x3008; 65 Parse the input using xquery:eval() &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">          let $query := "import module namespace aparecium
                = 'http://blackmesatech.com/2019/iXML/Aparecium'
                at '../build/Aparecium.xqm';
                declare variable $s external;
                declare variable $g external;
                aparecium:parse-string-with-compiled-grammar($s, $g)",
              $bindings := map {
                             's' : $input-string,
                             'g' : $G
                           },
              $options := map { 
                            'timeout' : 
                            ($options/@timeout/number(), 600)[1]
                          }
          return $xquery-eval($query, $bindings, $options)
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e1065">Parse the input, maybe with a time limit  (v. v3) 64</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">If <i>xquery:eval()</i> is not available, we go back to a
direct call to <i>ap:parse-string-with-compiled-grammar()</i>.
We are however still wrapped in the try/catch of <a name="ref-to-lib-rtc-parse-v3" href="#lib-rtc-parse-v3">61</a>.

<div class="scrap"><span><a name="lib-rtcp-without-eval">&#x3008; 66 Parse the input directly &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">          ap:parse-string-with-compiled-grammar(
            $input-string,
            $G
          )         
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#d3e1065">Parse the input, maybe with a time limit  (v. v3) 64</a> &#x3009; <br></span>
</div>

</div>

</div>
</div>

</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#testcases-running">&#x23f4;</a></span><span class="arrow"><a href="#testcases">&#x23f6;</a></span><span class="arrow"><a href="#output-options">&#x23f5;</a></span></div><h3><a class="selflink" name="evaluation" id="evaluation" href="#evaluation">5.2. </a>Evaluating the test case results</h3>


<div class="Real-P">Now we compare the parse tree to the expectations and set the three
variables <i>$result</i>, <i>$error-details</i>, and
<i>$details</i>.  Some of the conditions will be repeated,
but I don't see a good way to avoid the repetition.
<div class="scrap"><span><a name="lib-rtc-evaluate">&#x3008; 67 Set $result &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    let $result :=
        if ($input-string eq $failure-string)
        then "not-run"
        else if (exists($expectations
                   /self::tc:error)) 
        then "not-run"
        else if (exists($parse-tree
                 /self::tc:error[@id = 't:tbd18'])) 
        then "fail" (: or should this be "not-run"? :)
        else if (exists($parse-tree
                 /self::tc:error[@id = 't:tbd19'])) 
        then "other" (: timed out - or "not-run"? :)
        else if ($parse-tree/self::no-parse
                 and $expectations
                 /self::tc:assert-not-a-sentence)
        then "pass"
        else if (($parse-tree/self::no-parse
                 or $parse-tree/self::ap:error)
                 and $expectations
                 /self::tc:assert-dynamic-error)
        then "pass"
        else if ($parse-tree/self::no-parse
                 and $expectations
                 /self::tc:assert-not-a-grammar)
        then "pass" (: This case should not arise :)
        else if ($parse-tree/self::forest
              and 
              empty(($expectations/self::tc:assert-not-a-grammar,
              $expectations/self::tc:assert-not-a-sentence))
              and 
              (every $e1 in $parse-tree/* satisfies
              (some $e2 in $expectations satisfies
              deep-equal($e1, $e2))))
        then "pass" 
        else if (some $e1 in $expectations satisfies
                deep-equal($e1, $parse-tree))
        then "pass"
        else "fail"
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-run-test-case">The run-test-case() function 49</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">We only need the error details for the conditions where we caught
an error of some kind.
<div class="scrap"><span><a name="lib-rtc-errors">&#x3008; 68 Set $error-details &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    let $error-details :=
        if ($input-string eq $failure-string)
        then element tc:error {
               attribute id { "t:tbd15" },
               "External test input not found."
             }
        else if (exists($expectations
                 /self::tc:error)) 
        then $expectations/self::tc:error
        else if (exists($parse-tree
                 /self::tc:error)) 
        then $parse-tree
        else ()
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-run-test-case">The run-test-case() function 49</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">
If and only if we caught an error, we will want to wrap
it in an &lt;<em>app-info</em>&gt; element for reporting:
<div class="scrap"><span><a name="lib-rtc-report-error">&#x3008; 69 If errors arose in a test case, report them &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    if (exists($error-details))
    then element tc:app-info {
         $error-details
    }
    else ()
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-run-test-case">The run-test-case() function 49</a> &#x3009; &#x3008; <a href="#lib-rtc-write-test-result">Optionally write out test result 81</a> &#x3009; <br></span>
</div>

</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#evaluation">&#x23f4;</a></span><span class="arrow"><a href="#testcases">&#x23f6;</a></span><span class="arrow"><a href="#output">&#x23f5;</a></span></div><h3><a class="selflink" name="output-options" id="output-options" href="#output-options">5.3. </a>Output options</h3>
<div class="Real-P">At this point, we need to digress for a moment to think about the
output from specific grammar tests and test cases.</div>
<div class="Real-P">Experience makes me believe that when running tests is fast, and
there aren't many tests, I'm happy to have all the results in a single
document.  When running tests is slow, I find myself wishing I could
examine the results from earlier tests while waiting for the run to
finish. So I would like to have the option of having test details
written out test-by-test or not.</div>
<div class="Real-P">And depending on what I'm doing I may want more or less detail on
tests.  Steven Pemberton's test-result files have proven very handy,
with their repetition of the input grammar, the input string, and the
produced output.  I would like to have optional control of what
details are recorded, and where.</div>
<div class="Real-P">Also, when a test fails because the expected result and the
reported result differ, I frequently end up saving each to disk in a
separate file so I can use an interactive comparison program to
find differences.  I'd like an option for that, too.</div>
<div class="Real-P">So the basic questions seem to be:
<ul><li>The basic information on a test, i.e.  of test name and
pass/fail/not-run result, will be given unconditionally. Should
additional details of tests be given
<ul><li>in the main output?, or</li>
<li>test-by-test in separate files (default)?, or</li>
<li>not at all?</li>
</ul>
</li>
<li>When details are given, should the grammar be recorded
<ul><li>inline, in an &lt;<em>ixml-grammar</em>&gt; or &lt;<em>xml-grammar</em>&gt;
element?, or</li>
<li>inline if short (smaller than some user-specified threshold)
and externally otherwise?, or</li>
<li>externally, using an &lt;<em>ixml-grammar-ref</em>&gt; or
a &lt;<em>vxml-grammar-ref</em>&gt; element, or both?, or</li>
<li>not at all?</li>
</ul>
When external representation is requested, the grammar will be written
out to the test-reporting directory and pointed to using a relative
URI.  The name will be generated automatically from the test-set
name.</li>
<li>When details are given, should the input string be recorded
<ul><li>inline, in a &lt;<em>test-input</em>&gt; element?, or</li>
<li>inline if short (smaller than some user-specified threshold)
and externally otherwise?, or</li>
<li>externally, using a &lt;<em>test-string-ref</em>&gt; element?, or</li>
<li>not at all?</li>
</ul>
</li>
<li>When details are given, the expected result will be recorded
if the test fails.  When given, how should it be given?
<ul><li>inline, in an &lt;<em>assert-*</em>&gt; element?, or</li>
<li>inline if short (smaller than some user-specified threshold)
and externally otherwise?, or</li>
<li>externally, using a &lt;<em>assert-xml-ref</em>&gt; element?, or</li>
<li>not at all?</li>
</ul>
</li>
<li>When details are given, should the reported result be recorded
<ul><li>inline, in an &lt;<em>reported-*</em>&gt; element?, or</li>
<li>inline if short (smaller than some user-specified threshold)
and externally otherwise?, or</li>
<li>externally, using a &lt;<em>reported-xml-ref</em>&gt; element?, or</li>
<li>not at all?</li>
</ul>
</li>
<li>In case a test is failed, should the expected and reported
results be written to disk as separate files for easier comparison,
independently of what the user specified on the previous two
questions?  Yes or no.</li>
</ul>
</div>

<div class="Real-P">The options that control what is reported and whether individual
files are written out for each test set or each test case are set in
the driver.  In order to remind myself later of what the expected
options are, I list them all and index into them to choose the one
I want for a given run.
<div class="scrap"><span><a name="dr-options">&#x3008; 70 Set the options for the test harness [continues <a href="#dr-setup">5 Set up variables and options</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    $options := element options {
      attribute details { 
        ('inline', 
        'by-case', 
        'none')[2]
      },
      attribute input-grammar {
        ('inline',
        'inline-if-short', 
        'external',
        'none')[2]
      },
      attribute input-string {
        ('inline', 
        'inline-if-short', 
        'external',
        'none')[2]
      },
      attribute reported-result {
        ('inline', 
        'inline-if-short',
        'external',
        'none')[1]
      },
      attribute expected-result {
        ('inline', 
        'inline-if-short',
        'external',
        'none')[1]
      },
      attribute files-on-failure {
        ('yes', 
        'no')[1]
      },
      attribute inline-string-limit {
        400 
      },
      attribute inline-xml-limit {
        10
      },
      attribute output-directory {
        (
          concat($outdir, file:create-dir($outdir))
        )[1]
      },
      <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#set-timeout-option">Set timeout option 59</a></em> &#x3009;</span>
    }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

<i>N.B. In the current version of this test harness, not all of these
options are actually supported.  And the grammar provided is the
compiled grammar, not the grammar supplied by the user.</i>
</div>
<div class="Real-P">The call to <i>concat()</i> in the value of the
<em>output-directory</em> attribute is just a way to get the call to
<i>file:create-dir()</i> into an expression which must be
evaluated.  It contributes nothing to the value (the function returns
an empty sequence), but my first attempts to call
<i>create-dir()</i> were optimized out of existence by Saxon,
because they involved assigning a value to a dummy variable which was
never referred to again.
</div>
<div class="Real-P"><i>Note to future-self: if comparison of expected results to
reported results becomes a burden, it may be worthwhile to offer a
<i>result-format</i> option with the choices <tt>native</tt>,
<tt>reified</tt>, or <tt>both</tt>.</i></div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#output-options">&#x23f4;</a></span><span class="arrow"><a href="#testcases">&#x23f6;</a></span><span class="arrow">&nbsp;</span></div><h3><a class="selflink" name="output" id="output" href="#output">5.4. </a>Reporting the results</h3><ul><li>5.4.1. <a href="#count-results">Providing a summary of the results</a></li><li>5.4.2. <a href="#output-details">Recording the details of a test</a></li></ul>

<div class="Real-P">The top-level function <i>t:run-tests()</i> returns a
&lt;<em>tc:test-report</em>&gt; element; it would be nice to have a summary of
the results near the top.  Nothing more is needed, I think, in the
test-harness library: the caller is responsible for writing the report
out to a file if desired.</div>

<div class="Real-P">But when the user wants separate reports for different test cases,
the caller cannot do the work; the library must handle it.</div>

<div class="Real-P">The subsections below take care of these two tasks.</div>


<div class="div">

<div class="quicknav"><span class="arrow">&nbsp;</span><span class="arrow"><a href="#output">&#x23f6;</a></span><span class="arrow"><a href="#output-details">&#x23f5;</a></span></div><h4><a class="selflink" name="count-results" id="count-results" href="#count-results">5.4.1. </a>Providing a summary of the results</h4>

<div class="Real-P">I'd like to have a summary at the head of the report
showing how many tests were found, how many were passed and failed, and
so on.  This could be done by the test-harness library, but for now
I'm just going to handle it in the driver. We get back the report,
we make the counts,and we insert them into the report before writing
it out.

<div class="scrap"><span><a name="dr-counts">&#x3008; 71 Count tests and classify results &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">let $grammar-tests := $report//tc:grammar-result
let $gt-summary := element tc:p {
                     "Grammar tests (" 
                     || count($grammar-tests)
                     || "): ",
                     for $gt in $grammar-tests
                     let $res := $gt/@result/string()
                     group by $res
                     return $res[1] || ": " || count($gt) || '. '
                   }
let $test-cases := $report//tc:test-result
let $tc-summary := element tc:p {
                     "Test cases (" 
                     || count($test-cases)
                     || "): ",
                     for $gt in $test-cases
                     let $res := $gt/@result/string()
                     group by $res
                     return $res[1] || ": " || count($gt) || '. '
                   }
let $summary := element tc:description {
                  element tc:p {
                    "Tests run / passed / failed"
                    || " / not-run / other:"
                  },
                  $gt-summary,
                  $tc-summary
                }
<span class="scrapref">&#x3008; <em class="scrapptr"><a href="#dr-insert-counts">Insert result summary into $report 72</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#dr-top">[File test-driver.xq] 1</a> &#x3009; <br></span>
</div>
</div>
<div class="Real-P">The XQuery update facility provides a nice way to
do a near-identity update.  This particular formulation
relies on a clean handling of identifier scopes.  It's
purely declarative even though it looks and behaves a
little bit like a mutating assignment.
<div class="scrap"><span><a name="dr-insert-counts">&#x3008; 72 Insert result summary into $report &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">let $report := copy $x-report := $report
               modify insert node $summary
                      after $x-report/tc:metadata
               return $x-report
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound">Other versions of this code are in &#x3008; <a href="#d3e1271">Insert result summary into $report  (v. v3) 73</a> &#x3009; <br></span><span class="scrapinbound">This code is used in &#x3008; <a href="#dr-counts">Count tests and classify results 71</a> &#x3009; <br></span>
</div>

However, for the sake of XQuery implementations which
don't support XQUF, we rewrite this code.  Again, we rely
on clean handling of identifier scopes.
<div class="scrap"><span><a name="d3e1276">&#x3008; 73 Insert result summary into $report &#x3009; (for version <em>v3</em>) &#x2261;</a></span>
<pre class="scrapbody">let $report := element {name($report)} {
                 $report/@*,
                 $report/tc:metadata[1]
                     /preceding-sibling::node()
                     /self::node(),
                 $report/tc:metadata[1],
                 $summary,
                 $report/tc:metadata[1]
                     /following-sibling::node()
               }
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#dr-insert-counts">Insert result summary into $report 72</a> &#x3009; </span>
</div>

The <tt>/self::node()</tt> step for the preceding siblings of the
&lt;<em>tc:metadata</em>&gt; element is there to ensure that any preceding
siblings come out in document order. (Because I can't be bothered to
check to make sure whether it would come out right anyway.)
</div>
</div>


<div class="div">

<div class="quicknav"><span class="arrow"><a href="#count-results">&#x23f4;</a></span><span class="arrow"><a href="#output">&#x23f6;</a></span><span class="arrow">&nbsp;</span></div><h4><a class="selflink" name="output-details" id="output-details" href="#output-details">5.4.2. </a>Recording the details of a test</h4>

<div class="Real-P">If the user asked for details, we provide them.  This gets
a little tedious, so I've broken it out into smaller bits.
<div class="scrap"><span><a name="lib-rtc-details">&#x3008; 74 Set $details &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    let $details :=
        if ($options/@details = 'none')
        then ()
        else (
            <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rtc-rpt-grammar">Optionally report grammar used 76</a></em> &#x3009;</span>,
            <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rtc-rpt-string">Optionally report input string 77</a></em> &#x3009;</span>,
            <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rtc-rpt-output">Optionally report expected and actual output 78</a></em> &#x3009;</span>
        )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-run-test-case">The run-test-case() function 49</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">When the user asks for things to be written out externally, we will
need a file name.  Since test cases are supposed to be named uniquely
within a test set, and test sets within a test catalog, we should be
able to just concatenate the two names.  There are several values it
will be convenient to have available when putting together the details
of the report, including the identify the containing test set and
the test set where the current grammar appeared (not necessarily the
same set).
<div class="scrap"><span><a name="lib-rtc-mv-testset">&#x3008; 75 Set $test-set-name, $test-case-ID [continues <a href="#lib-rtc-misc-var">51 Set some handy variables</a>]  &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">    let $test-set-parent := $test-case/parent::tc:test-set,
        $test-set-grammar-host := $test-case/
            ancestor::tc:test-set
            [tc:ixml-grammar or tc:vxml-grammar
            or tc:ixml-grammar-ref
            or tc:vxml-grammar-ref]
            [1],
        $test-set-name := $test-set-parent/@name/string(),
        $grammar-name := 'grammar-' 
                         || $test-set-grammar-host
                            /@name/string()
                         || '.xml',
        $test-case-ID := concat($test-set-name, 
                                '-', 
                                $test-case
                                /@name/string())
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound"></span>
</div>

</div>
<div class="Real-P">I ran out of patience with the inline-if-short option, so for now
we only do the other three.</div>
<div class="Real-P">If the user requests that the grammar be recorded, and the ixml
grammar is easy to retrieve, then that's what we record.  Otherwise,
we use the vxml grammar, if it's easy to get.  Here &#x201c;easy to
retrieve&#x201d; means it was inline.  If the user-specified grammar was
external, then we end up using the compiled grammar.
<div class="scrap"><span><a name="lib-rtc-rpt-grammar">&#x3008; 76 Optionally report grammar used &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">            let $kw := $options/@input-grammar
            let $g0 := $test-set-grammar-host
                       /*[self::tc:ixml-grammar
                       or self::tc:vxml-grammar
                       or self::tc:ixml-grammar-ref
                       or self::tc:vxml-grammar-ref]

            return if ($kw = ('inline',
                              'inline-if-short'))
            then ($g0/self::tc:ixml-grammar, 
                  $g0/self::tc:vxml-grammar, 
                  element tc:vxml-grammar {$G})[1]
            else if ($kw eq 'external')
            then element tc:vxml-grammar-ref { 
                   attribute href { $grammar-name },
                   (: and let's write the file :)
                   file:write($options/@output-directory
                             || $grammar-name,
                             $g0)
                 }
            else ()
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-rtc-details">Set $details 74</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">For the input string, it's not too hard to support
the <tt>inline-if-short</tt> option.
<div class="scrap"><span><a name="lib-rtc-rpt-string">&#x3008; 77 Optionally report input string &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">            let $kw := $options/@input-string,
                $fn := $test-case-ID || '.input.txt'
            return if (($kw eq 'inline')
                       or
                       (($kw eq 'inline-if-short')
                        and
                        (string-length($input-string)
                        le 
                        ($options/@inline-string-limit
                         /number(), 400)[1])))
            then element tc:test-string {
                   $input-string
                 }
            else if ($kw = ('external', 
                            'inline-if-short'))
            then element tc:test-string-ref { 
                   attribute href { $fn },
                   (: and let's write the file :)
                   file:write($options/@output-directory
                             || $fn,
                             $input-string)
                 }
            else ()
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-rtc-details">Set $details 74</a> &#x3009; <br></span>
</div>

</div>

<div class="Real-P">If the user requested that either the expected output
or the reported output, or both, be included in the report,
we need to wrap them in a &lt;<em>tc:result</em>&gt; element.
<div class="scrap"><span><a name="lib-rtc-rpt-output">&#x3008; 78 Optionally report expected and actual output &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">            if (
                ($options/@expected-result ne 'none')
                or 
                ($options/@reported-result ne 'none')
                or 
                (($options/@files-on-failure ne 'no')
                 and ($result eq 'fail'))
               )
            then element tc:result {
              <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rtc-rpt-expected">Optionally report expected result 79</a></em> &#x3009;</span>,
              <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rtc-rpt-reported">Optionally report parser output 80</a></em> &#x3009;</span>
            }
            else ()
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-rtc-details">Set $details 74</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">We write out the expected result only if the test case
failed, but not if there was some error.  If the
expectation is not-a-sentence or not-a-grammar, then
we report it regardless of the user's option.  If we
have an XML expectation, then
<ul><li>If the user asked for it inline, we serialize it inline.</li>
<li>If the user asked for it externally (through
either the <i>expected-result</i> option
or the <i>files-on-failure</i> option),
we serialize it externally.</li>
</ul>
<div class="scrap"><span><a name="lib-rtc-rpt-expected">&#x3008; 79 Optionally report expected result &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">            let $kwD := $options/@expected-result,
                $kwE := $options/@files-on-failure,
                $fn  := $test-case-ID || '.expected.xml'

            return 
            if ($result eq 'fail')

            then if ($expectations
                     [self::tc:assert-not-a-sentence
                     or
                     self::tc:assert-not-a-grammar])
                 then $expectations

                 else ( 
                      if ($kwD = ('inline',
                                  'inline-if-short'))
                      then element tc:assert-xml {
                             $expectations
                           }
                      else (),

                      if (($kwD eq 'external')
                          or
                          ($kwE eq 'yes'))
                      then element tc:assert-xml-ref {
                              attribute href {$fn},
                              file:write(
                                $options/@output-directory
                                || $fn,
                                $expectations
                              )
                            }
                      else () (: unknown option, bag it :)
                      )

            else () (: $result ne 'fail' :)            
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-rtc-rpt-output">Optionally report expected and actual output 78</a> &#x3009; <br></span>
</div>

</div>
<div class="Real-P">The logic for reported results is similar but is not
conditional on failure of the test.
<div class="scrap"><span><a name="lib-rtc-rpt-reported">&#x3008; 80 Optionally report parser output &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">            let $kwD := $options/@reported-result,
                $kwE := $options/@files-on-failure,
                $fn  := $test-case-ID || '.reported.xml'
            return 
            if ($parse-tree/self::no-parse)
            then (element tc:reported-not-a-sentence{
                    element tc:app-info {
                      $parse-tree
                    }
                 },
                 if (($kwE eq 'yes') 
                    and ($result eq 'fail'))
                 then file:write(
                        $options/@output-directory
                        || $fn,
                        $parse-tree
                      )
                 else ()
                 )

            else ( 
                   if ($kwD = ('inline', 
                               'inline-if-short'))
                   then element tc:reported-xml {
                          $parse-tree
                        }
                   else (),

                   if (($kwD eq 'external')
                       or
                       (($kwE eq 'yes') 
                        and 
                        ($result eq 'fail'))
                      )
                   then element tc:reported-xml-ref {
                          attribute href {$fn},
                          file:write(
                            $options/@output-directory
                            || $fn,
                            $parse-tree
                          )
                        }
                   else () (: unknown option :)
                 )
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-rtc-rpt-output">Optionally report expected and actual output 78</a> &#x3009; <br></span>
</div>


</div>

<div class="Real-P">If the user has specified that results should be written out in
separate files for separate tests, we need to write out the test
result.
<div class="scrap"><span><a name="lib-rtc-write-test-result">&#x3008; 81 Optionally write out test result &#x3009;  &#x2261;</a></span>
<pre class="scrapbody">        if ($options/@details = 'by-case')
        then let $outfn := $test-case-ID
                           || '-test-result.xml',
                 $out := concat(
                         $options/@output-directory, 
                         $outfn)
             return file:write(
                      $out, 
                      element tc:test-result {
                        $test-case/@*,
                        attribute result { $result },
                        <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rtc-report-error">If errors arose in a test case, report them 69</a></em> &#x3009;</span>,
                        $details
                      }
                    )
        else ()
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is used in &#x3008; <a href="#lib-run-test-case">The run-test-case() function 49</a> &#x3009; <br></span>
</div>

</div>
</div>
</div>
</div>


<hr>

<div class="div">

<h2><a class="selflink" name="indices" id="indices" href="#indices">A. </a>Indices</h2>
<div><h2>Index of file names</h2><ul><li>test-driver.xq: defined in &#x3008; <a href="#dr-top">1 [File test-driver.xq]</a> &#x3009; </li><li>test-harness.xqm: defined in &#x3008; <a href="#lib-top">2 [File test-harness.xqm]</a> &#x3009; </li></ul></div>
<div><h2>Index of scrap names</h2><ul><li><a href="#dr-top">[File test-driver.xq] 1</a></li><li><a href="#lib-top">[File test-harness.xqm] 2</a></li><li><a href="#lib-rts-ld-ixml-ref">Cautiously fetch and parse external ixml grammar 25</a></li><li><a href="#lib-rts-ld-vxml-ref">Cautiously fetch external vxml grammar 26</a></li><li><a href="#lib-rts-ld-ixml">Cautiously parse ixml grammar 22</a></li><li><a href="#lib-tg-cf-errors">Check for error conditions, non-conformant grammar 43</a></li><li><a href="#lib-rt-check-cat-read">Check for errors reading the catalog 10</a></li><li><a href="#d3e758">Check for grammar-not-found errors 44</a></li><li><a href="#d3e771">Check for not-a-grammar test 46</a></li><li><a href="#d3e781">Check for other errors in grammar 47</a></li><li><a href="#d3e764">Check for syntax errors in grammar 45</a></li><li><a href="#lib-tg-compare">Compare the grammar with the expectation 41</a></li><li><a href="#dr-counts">Count tests and classify results 71</a></li><li><a href="#lib-functions">Declare library functions 4</a></li><li><a href="#lib-rtc-parse-prof-track">Define $prof-track as implementation-dependent function 62</a></li><li><a href="#lib-rtc-parse-xquery-eval">Define $xquery-eval-track as implementation-dependent function 63</a></li><li><a href="#d3e922">Direct invocation of parse for test case  (v. alt) 53</a></li><li><a href="#lib-tg-fetch">Fetch expected result of grammar test 40</a></li><li><a href="#lib-tg-cf-other">Grammar conformant but not as expected 48</a></li><li><a href="#lib-rts-do-ref">Handle a test-set reference 14</a></li><li><a href="#lib-rts-do-inline">Handle an inline test-set 15</a></li><li><a href="#d3e1395">Handle an inline test-set  (v. alt) 82</a></li><li><a href="#lib-rts-nested">Handle nested test sets and test cases 16</a></li><li><a href="#lib-rtc-report-error">If errors arose in a test case, report them 69</a></li><li><a href="#d3e675">If grammar compilation failed, stop now 35</a></li><li><a href="#lib-rts-abort">If grammar is bad, stop now 32</a></li><li><a href="#d3e662">If grammar is not good, stop now 33</a></li><li><a href="#lib-rtc-parse-precheck">If input string, grammar, or expectations is bad, stop now 60</a></li><li><a href="#d3e668">If we failed the grammar test, stop now 34</a></li><li><a href="#dr-insert-counts">Insert result summary into $report 72</a></li><li><a href="#d3e1276">Insert result summary into $report  (v. v3) 73</a></li><li><a href="#dr-catfiles">List of available test-catalog files 6</a></li><li><a href="#lib-rts-grammar">Load and compile the grammar for a test set 17</a></li><li><a href="#d3e1407">Load and test the grammar for a test set  (v. alt) 83</a></li><li><a href="#lib-rt-load-cat">Load catalog file into $catalog 8</a></li><li><a href="#d3e332">Load catalog file into $catalog  (v. alt) 9</a></li><li><a href="#lib-nsdecls">Namespace declarations and imports for library module 3</a></li><li><a href="#d3e518">Namespace declarations and imports, cont'd 20</a></li><li><a href="#d3e559">Namespace declarations and imports, cont'd 23</a></li><li><a href="#d3e628">Namespace declarations and imports, cont'd 31</a></li><li><a href="#d3e965">Namespace declarations and imports, cont'd 56</a></li><li><a href="#lib-rtc-rpt-output">Optionally report expected and actual output 78</a></li><li><a href="#lib-rtc-rpt-expected">Optionally report expected result 79</a></li><li><a href="#lib-rtc-rpt-grammar">Optionally report grammar used 76</a></li><li><a href="#lib-rtc-rpt-string">Optionally report input string 77</a></li><li><a href="#lib-rtc-rpt-reported">Optionally report parser output 80</a></li><li><a href="#lib-rtc-write-test-result">Optionally write out test result 81</a></li><li><a href="#lib-rtcp-without-eval">Parse the input directly 66</a></li><li><a href="#lib-rtcp-with-eval">Parse the input using xquery:eval() 65</a></li><li><a href="#d3e1065">Parse the input, maybe with a time limit  (v. v3) 64</a></li><li><a href="#lib-rtc-parse-with-timeout">Parse the input, with a time limit 55</a></li><li><a href="#lib-rts-write-grammar-result">Record grammar test result 30</a></li><li><a href="#lib-rtc-report-time">Report parse time if available 58</a></li><li><a href="#lib-tg-cf-ok">Return pass if grammar is as expected 42</a></li><li><a href="#lib-rts-vxml-grammar-check">Set $checked-xml-grammar 27</a></li><li><a href="#d3e589">Set $checked-xml-grammar  (v. alt) 28</a></li><li><a href="#lib-rtc-details">Set $details 74</a></li><li><a href="#lib-rtc-errors">Set $error-details 68</a></li><li><a href="#lib-rtc-fetch-expected">Set $expectations 52</a></li><li><a href="#lib-rts-grammar-compilation">Set $grammar to compiled grammar 29</a></li><li><a href="#lib-rts-grammar-test">Set $grammar-test-result 36</a></li><li><a href="#d3e699">Set $grammar-test-result  (v. v2) 37</a></li><li><a href="#d3e704">Set $grammar-test-result  (v. v3) 38</a></li><li><a href="#d3e1421">Set $grammar-test-result  (v. alt) 84</a></li><li><a href="#lib-rtc-fetch-input">Set $input-string 50</a></li><li><a href="#lib-rts-g-new">Set $new-xml-grammar 18</a></li><li><a href="#d3e503">Set $new-xml-grammar  (v. v2) 19</a></li><li><a href="#d3e531">Set $new-xml-grammar  (v. v3) 21</a></li><li><a href="#lib-rtc-parse">Set $parse-tree by parsing the test input string 54</a></li><li><a href="#d3e980">Set $parse-tree by parsing the test input string  (v. v2) 57</a></li><li><a href="#lib-rtc-parse-v3">Set $parse-tree by parsing the test input string  (v. v3) 61</a></li><li><a href="#lib-rtc-evaluate">Set $result 67</a></li><li><a href="#lib-rtc-mv-testset">Set $test-set-name, $test-case-ID 75</a></li><li><a href="#lib-rtc-misc-var">Set some handy variables 51</a></li><li><a href="#dr-options">Set the options for the test harness 70</a></li><li><a href="#set-timeout-option">Set timeout option 59</a></li><li><a href="#dr-setup">Set up variables and options 5</a></li><li><a href="#lib-rt-metadata">Supply basic metadata for the test report 11</a></li><li><a href="#lib-rts-ld-vxml">Take the inline vxml grammar 24</a></li><li><a href="#lib-rts3">The recursive run-test-set() function 13</a></li><li><a href="#lib-run-test-case">The run-test-case() function 49</a></li><li><a href="#lib-run-test-set">The run-test-set() function 12</a></li><li><a href="#lib-run-tests">The run-tests() function 7</a></li><li><a href="#lib-test-grammar">The test-grammar() function 39</a></li></ul></div>
</div>

<div><h1>Index of scrap names</h1><ul><li>2022-06-01 : CMSMcQ : Flip to new test-catalog namespace.</li>
<li>2022-03-16 : CMSMcQ : record a to-do item:  the grammar
preparation here should use standard functions, not roll its own.
What were you thinking?</li>
<li>2022-02-09/2022-02-12 : CMSMcQ : finally reach the actual test
cases and slowly knock off rough edges here and there</li>
<li>2022-02-04 : CMSMcQ : made file, to replace earlier test harness
lost in a disk crash</li>
</ul></div>


<div class="div">

<h2><a class="selflink" name="geniza" id="geniza" href="#geniza">B. </a>Old code</h2>
<div class="Real-P">Earlier versions of some code are kept here for reference,
and as a fallback if necessary.</div>

<div class="Real-P"><i>The old version is kept around for a bit.</i>
<div class="scrap"><span><a name="d3e1395">&#x3008; 82 Handle an inline test-set &#x3009; (for version <em>alt</em>) &#x2261;</a></span>
<pre class="scrapbody">    let $test-set-name := $test-set/@name/string(),
        $test-set-results := element tc:test-set-results {
          $test-set/@*, 
          <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rts-grammar">Load and compile the grammar for a test set 17</a></em> &#x3009;</span>
          return (
            $grammar-test-result,
            <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rts-write-grammar-result">Record grammar test result 30</a></em> &#x3009;</span>
            if (($grammar-test-result/@result = 'pass')
               or empty($grammar-test-result)) 
            then (: run the tests, handle nested sets :)
                 <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rts-nested">Handle nested test sets and test cases 16</a></em> &#x3009;</span>
            else (: no point trying to run tests :)
                element tc:description {
                  element tc:p {
                    text { "Grammar test failed, "
                        || "test cases and nested "
                        || "test sets skipped." }
                  }
                }
          )
        }
    return $test-set-results
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#lib-rts-do-inline">Handle an inline test-set 15</a> &#x3009; </span>
</div>

</div><div class="Real-P"><i>The original version of this had a slightly different structure.
I keep it around partly as a menetekel to remind myself that
sometimes things need to be refactored, but mostly in case I need
to go back to it.</i>
<div class="scrap"><span><a name="d3e1407">&#x3008; 83 Load and test the grammar for a test set &#x3009; (for version <em>alt</em>) &#x2261;</a></span>
<pre class="scrapbody">      <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rts-g-new">Set $new-xml-grammar 18</a></em> &#x3009;</span>
      <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rts-vxml-grammar-check">Set $checked-xml-grammar 27</a></em> &#x3009;</span>
      <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rts-grammar-test">Set $grammar-test-result 36</a></em> &#x3009;</span>
      <span class="scrapref">&#x3008; <em class="scrapptr"><a href="#lib-rts-grammar-compilation">Set $grammar to compiled grammar 29</a></em> &#x3009;</span></pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#lib-rts-grammar">Load and compile the grammar for a test set 17</a> &#x3009; </span>
</div>

</div>
<div class="Real-P">
The initial version of the grammar-test code is retained here as a
fallback, for a while.
<div class="scrap"><span><a name="d3e1421">&#x3008; 84 Set $grammar-test-result &#x3009; (for version <em>alt</em>) &#x2261;</a></span>
<pre class="scrapbody">      let $gt := $test-set/tc:grammar-test
      let $grammar-test-result := 
          if (empty($new-xml-grammar) or empty($gt))
          then ()
          else element tc:grammar-result {

              if ($checked-xml-grammar/self::ixml) 
              then t:test-grammar($gt, 
                                  $checked-xml-grammar, 
                                  $options)

              else if ($checked-xml-grammar/self::tc:error
                      /@id = ('tc:tbd04', 'tc:tbd06'))
              then (
                  (: ixml found but did not parse.
                     May be a pass, may be a fail; let
                     t:test-grammar() decide. :)
                  t:test-grammar($gt, 
                                 $checked-xml-grammar,
                                 $options)                  
              )

              else if ($checked-xml-grammar/self::tc:error
                      /@id = ('tc:tbd07', 
                              'tc:tbd08', 
                              'tc:tbd09'))
              then (
                  (: external grammar not found :)
                  attribute result { "not-run" },
                  element tc:app-info {
                      $checked-xml-grammar
                  }
              )

              else if ($checked-xml-grammar/self::tc:error
                      /@id = ('tc:tbd10'))
              then (
                  (: parsed, but is not conformant :)
                  t:test-grammar($gt, 
                                 $checked-xml-grammar,
                                 $options)
              )

              else if (not($checked-xml-grammar/self::ixml))
              then (
                  (: parsed, but did not produce 'ixml'
                     root element :)
                  t:test-grammar($gt, 
                                 $checked-xml-grammar,
                                 $options)
              )
              else (
                  attribute result { "other" },
                  element tc:description {
                    element tc:p {
                      "what on earth happened?"
                    }
                  }
              )
          }      
</pre>
<span class="scrapcontinuations"></span>

<span class="scrapinbound"></span><span class="scrapinbound">This code is a variant of &#x3008; <a href="#lib-rts-grammar-test">Set $grammar-test-result 36</a> &#x3009; </span>
</div>

<i>TO DO: pass options down to this level, if user asks for
individual tests to be reported to files, then do so.  At user option,
on failure write both expected result and reported result to files, to
simplify comparison.</i>
</div>
</div>


</div><div class="notes"><hr><h3>Notes</h3><div class="note">[<a name="d3e655" id="d3e655" href="#ref-to-d3e655">1</a>] 
As the text suggests, this test was inserted in a moment
of paranoia, with descriptive text including the phrase
&#x201c;This case is not supposed to happen.&#x201d;  The paranoia
paid off:  this case now fires normally when Aparecium
finds a conformance error in the grammar.</div></div></body></html>

