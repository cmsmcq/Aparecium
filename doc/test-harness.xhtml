<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<!--Need to find a way to insert the current date-->
<head>
<meta name="generator" content=
"HTML Tidy for HTML5 for Linux version 5.6.0" />
<meta http-equiv="Content-Type" content=
"text/html; charset=utf-8" />
<title>Test harness for Aparecium</title>

<style type="text/css">
/*<![CDATA[*/
      p {
      margin-top: 0.6em;      
      margin-bottom: 0.6em;
    }
    p.bibl {
      margin-top: 0.6em;      
      margin-bottom: 0.6em;
      margin-left: 2em;
      text-indent: -2em;
    }
    .Real-P {
      margin-top: 0.6em;      
      margin-bottom: 0.6em;
    }
    div.sp {
      margin-top: 0.6em;      
      margin-bottom: 0.6em;
    }
    div.address {
      margin-top: 0.6em;      
      margin-bottom: 0.6em;
      margin-left: 2em;
    }
    div.note {
      margin-top: 1em;      
      margin-left: 2em;
      
    }
    pre {  
      font-family: monospace;
      margin-left: 2em 
    }  
    a:hover { 
      background: #CCF 
    }
    td.no { 
      background: #CCF 
    }
    .author { 
      font-size: x-large
    }
    .bio { 
      font-size: small;
      font-style: italic
    }
    span.decision { 
    }
    span.result { 
      font-weight: bold
    }
    span.aye { 
      display: block;
      margin-left: 2em;
    }
    span.nay { 
      display: block;
      margin-left: 2em;
    }
    span.abstain { 
      display: block;
      margin-left: 2em;
    }
    span.result { 
      display: block;
      margin-left: 2em;
      font-weight: bold
    }
    span.speaker { 
      display: inline;
    }
    span.typename { 
      display: inline;
      font-family: monospace;
    }
   
  div.scrap {
    margin-top: 0.5em; 
    background-color: #CFEFCF; 
    background-color: #E7F7E7; 
    padding: 0.6em;
    margin-bottom: 0.5em;
  }
  pre.scrapbody {
    margin-left: 0.5em; 
    margin-bottom: 0.5em;
  }
  span.scrapcontinuations {
    font-size:smaller; 
  }
  span.scrapinbound {
    font-size:smaller;
  }
  span.scrapref {
    display: inline-block;
    text-indent: -0.3em;
    font-family: New Times Roman, serif, Lucida Sans Unicode;
  }
  em.scrapptr {
    font-family: New Times Roman, serif, Lucida Sans Unicode;
  }
  dl.desclist {
    list-style-type: none;
  }
  dl.desclist > dt {
    display: run-in;
    padding-right: 0.5em;
/*
*/
  }
  dl.desclist > dd {
    text-indent: -1em;
    margin-left: 1em; 
  }
  ul.desclist { 
    list-style-type: none;
  }
  ul.desclist > li {
    margin-left: 2em;
    text-indent: -2em;
  }
  div.epigraph .Real-P {margin-top: 0em; margin-bottom: 0em;} 
/*]]>*/
</style>
</head>
<body>
<div class="doc">
<h1>Test harness</h1>
<h1>for Aparecium</h1>
<h3>C. M. Sperberg-McQueen</h3>
<h3>4 February 2022, last revised 9 February 2022</h3>
<div class="versionList">
<p>Versions defined:</p>
<ul>
<li id="qd" class="versionentry">Quick and dirty first cut</li>
<li id="alt" class="versionentry">Alternative formulations of some
constructs</li>
</ul>
</div>
<hr />
<a name="toc" id="toc"></a>
<ul><!-- and a 1! -->
<li>1. <a href="#task">The task</a></li>
<li>2. <a href="#testcat">The structure of a test catalog and the
test report</a></li>
<li>3. <a href="#testsets">Handling test catalogs and test sets</a>
<ul><!-- and a 2! -->
<li>3.1. <a href="#setup">Preparing to call the
<i>t:run-tests()</i> function</a></li>
<li>3.2. <a href="#run-tests">Handling one test catalog: the
<i>run-tests()</i> function</a></li>
<li>3.3. <a href="#run-test-set">Handling one test set: the
<i>run-test-set()</i> function</a></li>
</ul>
</li>
<li>4. <a href="#grammars">Loading and testing the grammar for a
test set</a></li>
<li>5. <a href="#testcases">Running the test cases</a></li>
<li>6. <a href="#evaluation">Evaluating the test case
results</a></li>
<li>7. <a href="#output-options">Output options</a></li>
<li>8. <a href="#output">Reporting the results</a></li>
</ul>
<hr />
<div class="Real-P">This document describes a test harness for the
invisible-XML processor Aparecium. It is a ‘literate program’: the
executable code (in this case an XQuery module) is embedded in
English prose explaining the program. The document assumes the
reader is either familiar with XQuery, literate programming,
invisible XML, and Aparecium, or else possessed of a remarkably
high tolerance for boredom. For more information on literate
programming, Donald Knuth's article of that name remains a good
source.</div>
<div class="Real-P">In its current form, this document describes an
initial quick and dirty first cut, taking a lot of shortcuts in
order to get something running. When that's done, I expect to come
back and to a v0.2 version that replaces some of those quick and
dirty shortcuts with better code.</div>
<div class="Real-P"><i>The current version of some functions is not
even a quick and dirty solution yet: the first version of each
function just emits a Kilroy-was-here place-holder element, and the
second version does that and then processes its children, who also
emit place-holder elements. Once we are traversing the entire test
catalog successfully, we can start worrying about actually running
tests.</i></div>
<div class="Real-P"><i>To do:</i>
<ul>
<li><i>Tell the processor to respect whitespace when reading the
catalog and when reading expected results. It appears that this can
be done with an invocation-time option, with a database command
from the GUI before running the query driver, with the pragma
<tt>(# db:chop false #){ ... }</tt>, with <tt>declare option
db:chop "false"</tt></i></li>
<li><i>Revise the list of catalogs, arrange roughly from simple to
complex, short to long.</i></li>
<li><i>Work through test catalogs, fixing problems in the test
harness or the tests, filing issue reports for problems in
Aparecium.</i></li>
<li><i>(Interleaved with the above:) Improve reports and
diagnostics as occasion warrants. In particular, in cases of
failure record more about the test inputs.</i></li>
<li><i>Resume work on more test sets.</i></li>
</ul>
</div>
<div class="div">
<h2><a name="task" id="task">1.</a> The task</h2>
<div class="Real-P">Our task is to define a ‘test harness’ for
Aparecium. That involves two things: first an XQuery library module
which reads a test catalog, runs the tests, evaluates the results,
and creates a report showing which test cases passed and which
failed, and second a sample XQuery module which imports and calls
the library on a particular catalog and may save or do something
with the result.</div>
<div class="Real-P">The overall structure of the calling module is
straightforward:
<div class="scrap"><span><a name="dr-top" id="dr-top">〈 1 [File
test-driver.xq] 〉 ≡</a></span>
<pre class="scrapbody">
import module namespace t =
"http://blackmesatech.com/2022/iXML/test-harness"
at "../build/test-harness.xqm";

declare namespace tc =
"https://github.com/cmsmcq/ixml-tests";

declare namespace db =
"http://basex.org/modules/db";

declare option db:chop "false";

<span class="scrapref">〈 <em class="scrapptr"><a href=
"#dr-setup">Set up variables and options 5</a></em> 〉</span>

let $dummy   := file:create-dir($outdir),
    $results := t:run-tests($test-catalog-uri, $options)
    
return ($results,
        file:write($report-uri, $results))
</pre></div>
</div>
<div class="Real-P">The overall structure of the library module is
similarly conventional:
<div class="scrap"><span><a name="lib-top" id="lib-top">〈 2 [File
test-harness.xqm] 〉 ≡</a></span>
<pre class="scrapbody">
module namespace t =
"http://blackmesatech.com/2022/iXML/test-harness";
<span class="scrapref">〈 <em class="scrapptr"><a href=
"#lib-nsdecls">Namespace declarations and imports for library module 3</a></em> 〉</span>

<span class="scrapref">〈 <em class="scrapptr"><a href=
"#lib-functions">Declare library functions 4</a></em> 〉</span>
</pre></div>
</div>
<div class="Real-P">Since the test catalogs we are processing use
the ixml-tests namespace, we need to declare it. We will also need
the BaseX <i>db</i> namespace, in order to set the BaseX
<i>chop</i> option to false. Or maybe we won't; BaseX doesn't like
that option being set in a library module.
<div class="scrap"><span><a name="lib-nsdecls" id="lib-nsdecls">〈 3
Namespace declarations and imports for library module 〉
≡</a></span>
<pre class="scrapbody">
declare namespace tc =
"https://github.com/cmsmcq/ixml-tests";

declare namespace db =
"http://basex.org/modules/db";

</pre>
<span class="scrapcontinuations">Continued in 〈<a href=
"#d3e460">Namespace declarations and imports, cont'd
19</a>〉<br /></span> <span class="scrapinbound">This code is used
in 〈 <a href="#lib-top">[File test-harness.xqm] 2</a>
〉<br /></span></div>
</div>
<div class="Real-P">We can look ahead to the set of functions we
will define:
<div class="scrap"><span><a name="lib-functions" id=
"lib-functions">〈 4 Declare library functions 〉 ≡</a></span>
<pre class="scrapbody">
<span class="scrapref">〈 <em class="scrapptr"><a href=
"#lib-run-tests">The run-tests() function 7</a></em> 〉</span>
<span class="scrapref">〈 <em class="scrapptr"><a href=
"#lib-run-test-set">The run-test-set() function 12</a></em> 〉</span>
<span class="scrapref">〈 <em class="scrapptr"><a href=
"#lib-test-grammar">The test-grammar() function 26</a></em> 〉</span>
<span class="scrapref">〈 <em class="scrapptr"><a href=
"#lib-run-test-case">The run-test-case() function 30</a></em> 〉</span>
</pre>
<span class="scrapinbound">This code is used in 〈 <a href=
"#lib-top">[File test-harness.xqm] 2</a> 〉<br /></span></div>
</div>
</div>
<div class="div">
<h2><a name="testcat" id="testcat">2.</a> The structure of a test
catalog and the test report</h2>
<div class="Real-P">The test collections we are interested in
running will all have test catalogs in XML, using the vocabulary
defined in the author's <i>ixml-tests</i> repository on GitHub. A
test catalog is an XML document containing one or more <em>test
sets</em>; in the simple case a test set specifies an ixml grammar
and a set of test cases which use that grammar. Each test case
specifies an input string to be parsed using the grammar and an
expected result.</div>
<div class="Real-P">Several variations are possible:
<ul>
<li>A test set may contain nested test sets, to group tests in
whatever way seems useful.</li>
<li>Test sets, input grammars, input strings, and expected results
may be embedded in the test catalog or stored externally and
referred to from the catalog. Grammars may be given in ixml
(invisible XML) or vxml (‘visible’ XML) form.</li>
<li>At each level (test catalog, test set, test case), metadata may
be provided: prose descriptions, pointers to external
documentation, and application-specific information (embedded in an
&lt;<em>app-info</em>&gt; element).</li>
</ul>
</div>
<div class="Real-P">The test report we are generating will have a
similar structure, with
<ul>
<li>&lt;<em>test-report</em>&gt; containing results for a given
&lt;<em>test-catalog</em>&gt;</li>
<li>&lt;<em>test-set-results</em>&gt; containing results for a
given &lt;<em>test-set</em>&gt;</li>
<li>&lt;<em>grammar-result</em>&gt; containing the result for a
given &lt;<em>grammar-test</em>&gt;</li>
<li>&lt;<em>test-result</em>&gt; containing the result for a given
&lt;<em>test-case</em>&gt;</li>
</ul>
External test sets will be brought inline, so the report does not
distinguish between &lt;<em>test-set</em>&gt; and
&lt;<em>test-set-ref</em>&gt; elements in the input.</div>
<div class="Real-P">The schema allows
&lt;<em>grammar-result</em>&gt; and &lt;<em>test-result</em>&gt; to
record the details of the test and its results. So a
&lt;<em>grammar-result</em>&gt; can contain
<ul>
<li>&lt;<em>ixml-grammar</em>&gt;,
&lt;<em>ixml-grammar-ref</em>&gt;, &lt;<em>vxml-grammar</em>&gt;,
or &lt;<em>vxml-grammar-ref</em>&gt; (or several of these)</li>
<li>a &lt;<em>result</em>&gt; element containing any of the
assertions possible in a &lt;<em>grammar-test</em>&gt;, followed by
any of
<ul>
<li>&lt;<em>reported-xml</em>&gt;</li>
<li>&lt;<em>reported-xml-ref</em>&gt;</li>
<li>&lt;<em>reported-not-a-sentence</em>&gt;</li>
<li>&lt;<em>reported-not-a-grammar</em>&gt;</li>
</ul>
of which the first two can repeat and can occur together</li>
</ul>
</div>
<div class="Real-P">A &lt;<em>test-result</em>&gt; element
similarly can repeat the test input and expected results from the
test catalog, and it can also include the grammar used and the
results actually returned by the parser.</div>
<div class="Real-P">I'll specify user options to control the
output; see <a href="#output-options">below</a>.</div>
</div>
<div class="div">
<h2><a name="testsets" id="testsets">3.</a> Handling test catalogs
and test sets</h2>
<div class="Real-P">Given the test catalog structure just
described, the natural structure for the test harness is thus to
iterate over top-level test sets, and within a test set to iterate
over nested test sets and test cases.</div>
<div class="div">
<h3><a name="setup" id="setup">3.1.</a> Preparing to call the
<i>t:run-tests()</i> function</h3>
<div class="Real-P">The driver will call the library's
<i>run-tests()</i> function with the URI of the test catalog to be
run. Several test catalogs are available; the driver should make it
easy to switch from one to another. Since the easiest way to refer
to a directory can vary on different machines, I'll start by
putting the relevant directory names into variables. I'll use
relative paths where possible. And while we're thinking about
directory names, I'll define the directory where any output should
go, including a timestamp in the directory name to allow the
results of multiple test runs to be saved without interfering with
each other.
<div class="scrap"><span><a name="dr-setup" id="dr-setup">〈 5 Set
up variables and options 〉 ≡</a></span>
<pre class="scrapbody">
let $catalog-number := 1 (: which catalog to run? 1..31 or so :)

let $invdir := "../../ixml/tests/",
    $apadir := "../../Aparecium/tests/",
    $ixtdir := "../../ixml-tests/tests-straw/",
    $outdir := resolve-uri($apadir || 'results-' 
               || adjust-dateTime-to-timezone(
                    current-dateTime(), () )
               || '/',
               static-base-uri() ),
</pre>
<span class="scrapcontinuations">Continued in 〈<a href=
"#dr-catfiles">List of available test-catalog files 6</a>〉,
〈<a href="#dr-options">Set the options for the test harness
38</a>〉<br /></span> <span class="scrapinbound">This code is used
in 〈 <a href="#dr-top">[File test-driver.xq] 1</a>
〉<br /></span></div>
</div>
<div class="Real-P">Next, I'll make a list of catalogs, and choose
the one I want by indexing into the list. It's easy to change the
index.
<div class="scrap"><span><a name="dr-catfiles" id="dr-catfiles">〈 6
List of available test-catalog files [continues</a> <a href=
"#dr-setup">5 Set up variables and options</a>] 〉 ≡</span>
<pre class="scrapbody">

    $test-catalog-path := 
        (

         (: 1 2 3 :)
         $apadir || "test0.xml",
         $apadir || "test1.xml",
         $apadir || "test2.xml",

         (: 4 5 6 :)
         $invdir || "syntax/catalog-as-grammar-tests.xml",
         $invdir || "syntax/catalog-as-instance-tests-ixml.xml",
         $invdir || "syntax/catalog-as-instance-tests-ixml.xml",

         (: 7 8 9 :)
         $invdir || "correct/test-catalog.xml",
         $invdir || "ambiguous/test-catalog.xml",
         $invdir || "parse/test-catalog.xml",

         (: 10 slow :)
         $invdir || "ixml/test-catalog.xml",

         (: 11 very slow - all of the tests in the ixml repo :)
         $invdir || "test-catalog.xml",


         (: Positive and negative catalogs for various small
            grammars :)
         (: 12 13 14 15 :)
         $ixtdir || "gxxx/g010.test-catalog.xml",
         $ixtdir || "gxxx/g010.O3.test-catalog.all.neg.xml",
         $ixtdir || "gxxx/g011.test-catalog.xml",
         $ixtdir || "gxxx/g011.O3.test-catalog.all.neg.xml",

         (: 16 - 20 :)
         $ixtdir || "gxxx/g012.test-catalog.xml",
         $ixtdir || "gxxx/g012.O3.test-catalog.all.neg.xml",
         $ixtdir || "gxxx/g022.test-catalog.xml",
         $ixtdir || "gxxx/g022.O3.test-catalog.all.neg.xml",
         $ixtdir || "gxxx/g101.test-catalog.xml",

         (: 21 - 25 :)
         $ixtdir || "gxxx/g101.O3.test-catalog.all.neg.xml",
         $ixtdir || "gxxx/g102.test-catalog.xml",
         $ixtdir || "gxxx/g102.O3.test-catalog.all.neg.xml",
         $ixtdir || "gxxx/g112.test-catalog.xml",
         $ixtdir || "gxxx/g112.O3.test-catalog.all.neg.xml",

         (: 26-30, with 2, 7638, 2886, 1020, and 338 test cases.
            The positive test cases are broken. :)
         $ixtdir || "arith/arith.test-catalog.pos.xml",
         $ixtdir || "arith/arith.O3.test-catalog.arc.neg.xml",
         $ixtdir || "arith/arith.O3.test-catalog.arc-final.neg.xml",
         $ixtdir || "arith/arith.O3.test-catalog.state.neg.xml",
         $ixtdir || "arith/arith.O3.test-catalog.state-final.neg.xml",

         (: 31:  straw-man tests on ixml itself
            (n.b. old version of ixml grammar) :)
         $ixtdir || "ixml/ixml.test-catalog.pos.xml"

         (: 32:  wisps test set (currently in progress) :)
         $ixtdir || "wisps/wisp-catalog.pos.xml"

         
         )[$catalog-numer],

    $test-catalog-uri := resolve-uri($test-catalog-path, 
                                     static-base-uri()),

    $report-filename := 'test-results.' 
                        || replace($test-catalog-uri,
                                   "^(.*)/([^/]*)(\.xml)",
                                   "$2")
                        || '.xml', 
    $report-uri := $outdir || $report-filename,
</pre></div>
</div>
<div class="Real-P">At this point in the program, we will also want
to prepare an &lt;<em>options</em>&gt; element to specify the
options we want to use, but we will define those <a href=
"#output-options">later</a>.</div>
</div>
<div class="div">
<h3><a name="run-tests" id="run-tests">3.2.</a> Handling one test
catalog: the <i>run-tests()</i> function</h3>
<div class="Real-P">Now for the top-level function of the library.
The <i>run-tests()</i> function gets a test catalog element and an
&lt;<em>options</em>&gt; element and runs the tests in that test
catalog. It takes an &lt;<em>options</em>&gt; element to control
some aspects of the library's behavior.
<div class="scrap"><span><a name="lib-run-tests" id=
"lib-run-tests">〈 7 The run-tests() function 〉 ≡</a></span>
<pre class="scrapbody">

declare function t:run-tests(
  $catalog-uri as xs:string,
  $options as element(options)
) as element(tc:test-report) {

  <span class="scrapref">〈 <em class="scrapptr"><a href=
"#lib-rt-load-cat">Load catalog file into $catalog 8</a></em> 〉</span>
  return element tc:test-report {
    <span class="scrapref">〈 <em class="scrapptr"><a href=
"#lib-rt-metadata">Supply basic metadata for the test report 11</a></em> 〉</span>
    <span class="scrapref">〈 <em class="scrapptr"><a href=
"#lib-rt-check-cat-read">Check for errors reading the catalog 10</a></em> 〉</span>
    for $test-set in $catalog/*
        [self::tc:test-set or self::tc:test-set-ref]
    return t:run-test-set($test-set, 
                          (), 
                          $catalog-uri, 
                          $options)
  }
};
</pre>
<span class="scrapinbound">This code is used in 〈 <a href=
"#lib-functions">Declare library functions 4</a>
〉<br /></span></div>
</div>
<div class="Real-P">Let's try to be careful in our I/O.
<div class="scrap"><span><a name="lib-rt-load-cat" id=
"lib-rt-load-cat">〈 8 Load catalog file into $catalog 〉
≡</a></span>
<pre class="scrapbody">

  let $catalog := try { 
    doc($catalog-uri)/*
  } catch err:FODC0002 {
    &lt;no-such-catalog/&gt;
  }
</pre>
<span class="scrapinbound">Other versions of this code are in 〈
<a href="#d3e314">Load catalog file into $catalog 9</a>
〉<br /></span> <span class="scrapinbound">This code is used in 〈
<a href="#lib-run-tests">The run-tests() function 7</a>
〉<br /></span></div>
A simpler version of this might be:
<div class="scrap"><span><a name="d3e319" id="d3e319">〈 9 Load
catalog file into $catalog 〉 (for version <em>alt</em>)
≡</a></span>
<pre class="scrapbody">

  let $catalog := if (doc-available($catalog-uri))
                  then doc($catalog-uri)/*
                  else &lt;no-such-catalog/&gt;
</pre>
<span class="scrapinbound">This code is a variant of 〈 <a href=
"#lib-rt-load-cat">Load catalog file into $catalog 8</a>
〉</span></div>
</div>
<div class="Real-P">If we did not get a catalog, report that fact.
<div class="scrap"><span><a name="lib-rt-check-cat-read" id=
"lib-rt-check-cat-read">〈 10 Check for errors reading the catalog 〉
≡</a></span>
<pre class="scrapbody">

    if ($catalog/self::no-such-catalog) then
      element tc:error {
        attribute id { "tc:tbd01" },
        element tc:p {
          text { "Nothing found at "},
          $catalog-uri,
          text { "." }
        }
      }
    else
</pre>
<span class="scrapinbound">This code is used in 〈 <a href=
"#lib-run-tests">The run-tests() function 7</a>
〉<br /></span></div>
Note the trailing <tt>else</tt> here.</div>
<div class="Real-P">At the top of the test report we should put
some metadata:
<div class="scrap"><span><a name="lib-rt-metadata" id=
"lib-rt-metadata">〈 11 Supply basic metadata for the test report 〉
≡</a></span>
<pre class="scrapbody">

    element tc:metadata {
      element tc:name {
        'Test results for ' || $catalog/@name
      },
      element tc:report-date { 
        current-dateTime()
      },
      element tc:processor { "Aparecium" },
      element tc:processor-version { "v0.1" },
      element tc:catalog-uri { $catalog-uri },
      element tc:catalog-date { 
        ($catalog/@release-date/string(), '??')[1] 
      },
      element tc:description {
        element tc:p {
          text { "Test report generated by test-harness.xqm." }
        }
      }
    },

</pre>
<span class="scrapinbound">This code is used in 〈 <a href=
"#lib-run-tests">The run-tests() function 7</a>
〉<br /></span></div>
</div>
<div class="Real-P">This may need further elaboration.</div>
</div>
<div class="div">
<h3><a name="run-test-set" id="run-test-set">3.3.</a> Handling one
test set: the <i>run-test-set()</i> function</h3>
<div class="Real-P">The <i>run-test-set()</i> function gets a
&lt;<em>test-set</em>&gt; element and an &lt;<em>options</em>&gt;
element and runs the tests in that test set. The function may
return more than one element, because if it's called with a
&lt;<em>test-set-ref</em>&gt; element, it will retrieve that
catalog and return a test-set report for each
&lt;<em>test-set</em>&gt; or &lt;<em>test-set-ref</em>&gt; in that
catalog.</div>
<div class="Real-P">This single-argument version of the function
just calls a recursive version of the function with appropriate
additional arguments.
<div class="scrap"><span><a name="lib-run-test-set" id=
"lib-run-test-set">〈 12 The run-test-set() function 〉 ≡</a></span>
<pre class="scrapbody">

declare function t:run-test-set(
  $test-set as element(),
  $options as element(options)
) as element() {
  t:run-test-set($test-set, (), (), $options)
};
</pre>
<span class="scrapcontinuations">Continued in 〈<a href=
"#lib-rts3">The recursive run-test-set() function
13</a>〉<br /></span> <span class="scrapinbound">This code is used
in 〈 <a href="#lib-functions">Declare library functions 4</a>
〉<br /></span></div>
</div>
<div class="Real-P">The recursive version of <i>run-test-set()</i>
takes two additional arguments, In addition to the test set element
itself.
<ul>
<li>
<div class="Real-P">The first is an optional grammar.</div>
<div class="Real-P">Test cases normally use the grammar specified
in their containing test set, but since test sets can nest, the
grammar may have been specified by an ancestor. So when a test set
with a grammar calls the function recursively on nested test sets,
it passes the grammar along as an argument.</div>
</li>
<li>
<div class="Real-P">The second is a stack of URIs that we have
opened. This is used to detect reference cycles and snip
them.</div>
</li>
</ul>
</div>
<div class="Real-P">The overall structure of the function is
straightforward: we check the element we've been handed and handle
it appropriately.
<div class="scrap"><span><a name="lib-rts3" id="lib-rts3">〈 13 The
recursive run-test-set() function [continues</a> <a href=
"#lib-run-test-set">12 The run-test-set() function</a>] 〉 ≡</span>
<pre class="scrapbody">

declare function t:run-test-set(
  $test-set as element(),
  $grammar as element()?,
  $uri-stack as xs:string*,
  $options as element(options)
) as element()+ {

  if ($test-set/self::tc:test-set-ref)
  then <span class="scrapref">〈 <em class="scrapptr"><a href=
"#lib-rts-do-ref">Handle a test-set reference 14</a></em> 〉</span>
  else <span class="scrapref">〈 <em class="scrapptr"><a href=
"#lib-rts-do-inline">Handle an inline test-set 15</a></em> 〉</span>
};
</pre></div>
</div>
<div class="Real-P">The element we are dealing with may be a
&lt;<em>test-set</em>&gt; element (the normal case) or a
&lt;<em>test-set-ref</em>&gt; element. If it's the latter, we fetch
the document and deal with its top-level test sets.
<div class="scrap"><span><a name="lib-rts-do-ref" id=
"lib-rts-do-ref">〈 14 Handle a test-set reference 〉 ≡</a></span>
<pre class="scrapbody">

       let $uri0 := base-uri($test-set),
           $uri1 := string($test-set/@href),
           $uri2 := resolve-uri($uri1, $uri0),
           $newcat := try {
             doc($uri2)
           } catch err:FODC0002 { 
             &lt;no-such-test-set/&gt; 
           }
       return if ($newcat/self::no-such-test-set) then
           element tc:error {
             attribute id { "tc:tbd02" },
             element tc:p {
               text { "Nothing found at "},
               $uri2,
               text { "." }
             }
           }
        else for $test-set 
             in $newcat/*/*
                [self::tc:test-set 
                or self::tc:test-set-ref]
             return t:run-test-set($test-set, 
                                   $grammar, 
                                   ($uri2, $uri-stack),
                                   $options)
</pre>
<span class="scrapinbound">This code is used in 〈 <a href=
"#lib-rts3">The recursive run-test-set() function 13</a>
〉<br /></span></div>
</div>
<div class="Real-P">The main case is for a ‘real’ test set. It may
contain a grammar (inline or via reference, in ixml or xml), and it
may contain test cases and nested test sets.
<div class="scrap"><span><a name="lib-rts-do-inline" id=
"lib-rts-do-inline">〈 15 Handle an inline test-set 〉 ≡</a></span>
<pre class="scrapbody">

    let $test-set-name := $test-set/@name/string(),
        $test-set-results := element tc:test-set-results {
          $test-set/@*, 
          <span class="scrapref">〈 <em class="scrapptr"><a href=
"#lib-rts-grammar">Load and test the grammar for a test set 17</a></em> 〉</span>
          return (
            $grammar-test-result,
            <span class="scrapref">〈 <em class="scrapptr"><a href=
"#lib-rts-write-grammar-result">Optionally write out grammar test result 29</a></em> 〉</span>
            if (($grammar-test-result/@result = 'pass')
               or empty($grammar-test-result)) 
            then (: run the tests, handle nested sets :)
                 <span class="scrapref">〈 <em class=
"scrapptr"><a href=
"#lib-rts-nested">Handle nested test sets and test cases 16</a></em> 〉</span>
            else (: no point trying to run tests :)
                element tc:description {
                  element tc:p {
                    text { "Grammar test failed, "
                        || "test cases and nested "
                        || "test sets skipped." }
                  }
                }
          )
        }
    return $test-set-results
</pre>
<span class="scrapinbound">This code is used in 〈 <a href=
"#lib-rts3">The recursive run-test-set() function 13</a>
〉<br /></span></div>
</div>
<div class="Real-P">Later sections will describe the handling of
<a href="#grammars">grammars</a> and <a href="#testcases">test
cases</a>, but the recursion on nested test sets is pretty much
what might be expected: we iterate over them and call the
appropriate function to handle them.
<div class="scrap"><span><a name="lib-rts-nested" id=
"lib-rts-nested">〈 16 Handle nested test sets and test cases 〉
≡</a></span>
<pre class="scrapbody">

      for $c in $test-set/*
          [self::tc:test-set 
          or self::tc:test-set-ref
          or self::tc:test-case]
      return if ($c/self::tc:test-set 
                or $c/self::tc:test-set-ref)
      then t:run-test-set($c, 
                          $grammar, 
                          $uri-stack, 
                          $options)
      else if ($c/self::tc:test-case)
      then t:run-test-case($c, $grammar, $options)
      else element tc:error {
        attribute id { "t:tbd03" },
        text { "The laws of logic have been abrogated?" }
      }
</pre>
<span class="scrapinbound">This code is used in 〈 <a href=
"#lib-rts-do-inline">Handle an inline test-set 15</a>
〉<br /></span></div>
</div>
</div>
</div>
<div class="div">
<h2><a name="grammars" id="grammars">4.</a> Loading and testing the
grammar for a test set</h2>
<div class="Real-P">A grammar may be given inline or externally, in
ixml or in XML. The initial steps to be taken vary among the four
cases, but once the grammar is in XML the steps are the same for
all. So we begin by getting the grammar into XML and into memory,
with a four-way branch on the nature of the grammar specification.
The locally specified grammar unconditionally overrides any grammar
passed in as an argument, and we keep life simple by using the same
name for it.
<div class="scrap"><span><a name="lib-rts-grammar" id=
"lib-rts-grammar">〈 17 Load and test the grammar for a test set 〉
≡</a></span>
<pre class="scrapbody">

      let $new-xml-grammar := if ($test-set/tc:ixml-grammar)
          then <span class="scrapref">〈 <em class=
"scrapptr"><a href=
"#lib-rts-ld-ixml">Cautiously parse ixml grammar 18</a></em> 〉</span>
          else if ($test-set/tc:vxml-grammar)
          then <span class="scrapref">〈 <em class=
"scrapptr"><a href=
"#lib-rts-ld-vxml">Take the inline vxml grammar 20</a></em> 〉</span>
          else if ($test-set/tc:ixml-grammar-ref)
          then <span class="scrapref">〈 <em class=
"scrapptr"><a href=
"#lib-rts-ld-ixml-ref">Cautiously fetch and parse external ixml grammar 21</a></em> 〉</span> 
          else if ($test-set/tc:vxml-grammar-ref)
          then <span class="scrapref">〈 <em class=
"scrapptr"><a href=
"#lib-rts-ld-vxml-ref">Cautiously fetch external vxml grammar 22</a></em> 〉</span>
          else ()
</pre>
<span class="scrapcontinuations">Continued in 〈<a href=
"#lib-rts-vxml-grammar-check">Check the XML grammar for conformance
23</a>〉, 〈<a href="#lib-rts-grammar-test">Handle the grammar test,
if there is one 24</a>〉, 〈<a href=
"#lib-rts-grammar-compilation">Compile the new grammar, if there is
one 25</a>〉<br /></span> <span class="scrapinbound">This code is
used in 〈 <a href="#lib-rts-do-inline">Handle an inline test-set
15</a> 〉<br /></span></div>
<em>[TO DO: prepare for and recover from errors]</em></div>
<div class="Real-P">Each of these needs to be done cautiously.
First is the inline ixml case. We just wrap it in a try/catch and
hope for the best. (Quick and dirty, remember.)
<div class="scrap"><span><a name="lib-rts-ld-ixml" id=
"lib-rts-ld-ixml">〈 18 Cautiously parse ixml grammar 〉 ≡</a></span>
<pre class="scrapbody">

          try {
                ap:parse-grammar-from-string(
                    $test-set/tc:ixml-grammar/string()
                )
          } catch * {
               element tc:error {
                 attribute id { "t:tbd04" },
                 text { "ixml compilation failed" }
               }               
          }
</pre>
<span class="scrapinbound">This code is used in 〈 <a href=
"#lib-rts-grammar">Load and test the grammar for a test set 17</a>
〉<br /></span></div>
</div>
<div class="Real-P">In order to call the
<i>parse-grammar-from-string()</i> function (and its relatives) in
the Aparecium library, we are going to need to import that library:
<div class="scrap"><span><a name="d3e460" id="d3e460">〈 19
Namespace declarations and imports, cont'd [continues</a> <a href=
"#lib-nsdecls">3 Namespace declarations and imports for library
module</a>] 〉 ≡</span>
<pre class="scrapbody">
import module namespace ap =
"http://blackmesatech.com/2019/iXML/Aparecium"
at "Aparecium.xqm";
</pre></div>
</div>
<div class="Real-P">The second case is the inline vxml case. Here
the grammar is already in XML, so we just assign it.
<div class="scrap"><span><a name="lib-rts-ld-vxml" id=
"lib-rts-ld-vxml">〈 20 Take the inline vxml grammar 〉 ≡</a></span>
<pre class="scrapbody">
          $test-set/tc:vxml-grammar[1]/ixml
</pre>
<span class="scrapinbound">This code is used in 〈 <a href=
"#lib-rts-grammar">Load and test the grammar for a test set 17</a>
〉<br /></span></div>
</div>
<div class="Real-P">The external-ixml case has several ways to
fail. For now (quick and dirty) we don't cover them all.
<div class="scrap"><span><a name="lib-rts-ld-ixml-ref" id=
"lib-rts-ld-ixml-ref">〈 21 Cautiously fetch and parse external ixml
grammar 〉 ≡</a></span>
<pre class="scrapbody">

          let $uri0 := $test-set/tc:ixml-grammar-ref
                           /@href/string(),
              $uri1 := base-uri($test-set),
              $uri2 := resolve-uri($uri0, $uri1)
              return 
                if (unparsed-text-available($uri2))
                then try {
                       ap:parse-grammar-from-uri($uri2)
                     } catch * {
                       element tc:error {
                         attribute id { "t:tbd06" },
                         text { "ixml compilation failed" }
                       }
                     }
                else element tc:error {
                       attribute id { "t:tbd07" },
                       text { "external ixml not found" }
                     }
</pre>
<span class="scrapinbound">This code is used in 〈 <a href=
"#lib-rts-grammar">Load and test the grammar for a test set 17</a>
〉<br /></span></div>
</div>
<div class="Real-P">The external-vxml case also has several ways to
fail, most not covered here.
<div class="scrap"><span><a name="lib-rts-ld-vxml-ref" id=
"lib-rts-ld-vxml-ref">〈 22 Cautiously fetch external vxml grammar 〉
≡</a></span>
<pre class="scrapbody">

          let $uri0 := $test-set/tc:vxml-grammar-ref
                           /@href/string(),
              $uri1 := base-uri($test-set),
              $uri2 := resolve-uri($uri0, $uri1)
          return if (doc-available($uri2))
                 then let $xmlTmp := doc($uri2)
                      return if (exists($xmlTmp/ixml))
                             then $xmlTmp/ixml
                             else element tc:error {
                                    attribute id {"t:tbd08"},
                                    $uri0,
                                    "(" || $uri2 || ")",
                                    " is not an ixml grammar."
                             }
                 else element tc:error {
                        attribute id { "t:tbd09" },
                        text { "external vxml grammar"
                              || " not found at " },
                        $uri0,
                        text { " (i.e. "  },
                        $uri2,
                        text { ")." }
                      }
          
</pre>
<span class="scrapinbound">This code is used in 〈 <a href=
"#lib-rts-grammar">Load and test the grammar for a test set 17</a>
〉<br /></span></div>
</div>
<div class="Real-P">Once we have the new XML grammar, we need to
check it for conformance. Aparecium currently lacks any function to
do this, so for the moment this is a nop.
<div class="scrap"><span><a name="lib-rts-vxml-grammar-check" id=
"lib-rts-vxml-grammar-check">〈 23 Check the XML grammar for
conformance [continues</a> <a href="#lib-rts-grammar">17 Load and
test the grammar for a test set</a>] 〉 ≡</span>
<pre class="scrapbody">

      let $checked-xml-grammar := 
          if (true()) (: place-holder :)
          then $new-xml-grammar
          else element tc:error {
            attribute id { "t:tbd10" },
            text { "XML grammar not conformant" }
          }
</pre></div>
</div>
<div class="Real-P">If a grammar is given, a
&lt;<em>grammar-test</em>&gt; may also be specified. We need to
check the value of <i>$new-xml-grammar</i>; if it's a
&lt;<em>tc:error</em>&gt; element, the grammar test failed and the
<em>id</em> attribute should tell us roughly why. If it's anything
other than an &lt;<em>ixml</em>&gt; element, the grammar test
failed, and we may or may not have any inkling of why.
<em>Aparecium needs to do a much better job making the compilation
of grammars reliable and robust. It's tempting to start checking
grammars for problems here, but that work belongs in Aparecium
itself, so we do not do it here.</em>
<div class="scrap"><span><a name="lib-rts-grammar-test" id=
"lib-rts-grammar-test">〈 24 Handle the grammar test, if there is
one [continues</a> <a href="#lib-rts-grammar">17 Load and test the
grammar for a test set</a>] 〉 ≡</span>
<pre class="scrapbody">

      let $gt := $test-set/tc:grammar-test
      let $grammar-test-result := 
          if (empty($new-xml-grammar) or empty($gt))
          then ()
          else element tc:grammar-result {

              if ($new-xml-grammar/self::ixml) 
              then t:test-grammar($gt, 
                                  $new-xml-grammar, 
                                  $options)

              else if ($new-xml-grammar/self::tc:error
                      /@id = ('tc:tbd04', 'tc:tbd06'))
              then (
                  (: ixml found but did not parse.
                     May be a pass, may be a fail; let
                     t:test-grammar() decide. :)
                  t:test-grammar($gt, 
                                 $new-xml-grammar,
                                 $options)                  
              )

              else if ($new-xml-grammar/self::tc:error
                      /@id = ('tc:tbd07', 
                              'tc:tbd08', 
                              'tc:tbd09'))
              then (
                  (: external grammar not found :)
                  attribute result { "not-run" },
                  element tc:app-info {
                      $new-xml-grammar
                  }
              )

              else if ($new-xml-grammar/self::tc:error
                      /@id = ('tc:tbd10'))
              then (
                  (: parsed, but is not conformant :)
                  t:test-grammar($gt, 
                                 $new-xml-grammar,
                                 $options)
              )

              else if (not($new-xml-grammar/self::ixml))
              then (
                  (: parsed, but did not produce 'ixml'
                     root element :)
                  t:test-grammar($gt, 
                                 $new-xml-grammar,
                                 $options)
              )
              else (
                  attribute result { "other" },
                  element tc:description {
                    element tc:p {
                      "what on earth happened?"
                    }
                  }
              )
          }      
</pre></div>
<i>TO DO: pass options down to this level, if user asks for
individual tests to be reported to files, then do so. At user
option, on failure write both expected result and reported result
to files, to simplify comparison.</i></div>
<div class="Real-P">If the new grammar is OK so far, we need to
compile it.
<div class="scrap"><span><a name="lib-rts-grammar-compilation" id=
"lib-rts-grammar-compilation">〈 25 Compile the new grammar, if
there is one [continues</a> <a href="#lib-rts-grammar">17 Load and
test the grammar for a test set</a>] 〉 ≡</span>
<pre class="scrapbody">

      let $grammar := if (exists($new-xml-grammar))
          then try {
            ap:compile-grammar-from-xml($new-xml-grammar)
          } catch * {
            element tc:error {
              attribute id {"t:tbd11"},
              text { 
                "Error compiling grammar"
              }
            }
          }
      else $grammar
</pre></div>
</div>
<div class="Real-P">The <i>test-grammar()</i> function is called
when we have (a) what looks like an acceptable vxml grammar and (b)
a request for a grammar test. We must fetch the expected result, if
it's external, and compare our result to the expected result. For
now, we assume there will never be more than one expected XML
result for a grammar.
<div class="scrap"><span><a name="lib-test-grammar" id=
"lib-test-grammar">〈 26 The test-grammar() function 〉 ≡</a></span>
<pre class="scrapbody">

declare function t:test-grammar(
  $grammar-test as element(tc:grammar-test),
  $xml-grammar as element(),
  $options as element(options)
) as item()* {
  <span class="scrapref">〈 <em class="scrapptr"><a href=
"#lib-tc-fetch">Fetch expected result of grammar test 27</a></em> 〉</span>
  <span class="scrapref">〈 <em class="scrapptr"><a href=
"#lib-tc-compare">Compare the grammar with the expectation 28</a></em> 〉</span>
};
</pre>
<span class="scrapinbound">This code is used in 〈 <a href=
"#lib-functions">Declare library functions 4</a>
〉<br /></span></div>
</div>
<div class="Real-P">First, we fetch any external result.
<div class="scrap"><span><a name="lib-tc-fetch" id="lib-tc-fetch">〈
27 Fetch expected result of grammar test 〉 ≡</a></span>
<pre class="scrapbody">

  let $e0 := $grammar-test/tc:result/*[1],
      $expectation :=
        if ($e0/self::tc:assert-xml-ref)
        then let $uri0 := $e0/@href/string(),
                 $uri1 := base-uri($grammar-test),
                 $uri2 := resolve-uri($uri0, $uri1)
             return if (doc-available($uri2))
                    then (doc($uri2)/ixml,
                         element tc:error {
                           attribute id { "t:tbd12" },
                           $uri2,
                           " is not an ixml grammar."
                         })[1]
                    else element tc:error {
                      attribute id { "t:tbd13" },
                      $uri2,
                      text { " not found." }
                    }
        else $e0
</pre>
<span class="scrapinbound">This code is used in 〈 <a href=
"#lib-test-grammar">The test-grammar() function 26</a>
〉<br /></span></div>
</div>
<div class="Real-P">We now have an ixml grammar in one hand and an
expectation in the other. We perform a deep-equal comparison, and
that's it.
<div class="scrap"><span><a name="lib-tc-compare" id=
"lib-tc-compare">〈 28 Compare the grammar with the expectation 〉
≡</a></span>
<pre class="scrapbody">

  return

  if ($expectation/self::tc:error)
  then ( 
         (: something went wrong w assert-xml-ref :)
         attribute result { "not-run" },
         element tc:result {
           $expectation 
         }
       )

  else if ($expectation[self::tc:assert-not-a-grammar
           or self::tc:assert-not-a-sentence]
           and
           $xml-grammar/self::tc:error[@id = 
           ("t:tbd04", "t:tbd06")])
  then (
         (: grammar did not parse :)
         attribute result { "pass" },
         element tc:result {
           $expectation,
           $xml-grammar
         }         
       )

  else if ($expectation[self::tc:assert-not-a-grammar]
           and
           $xml-grammar/self::tc:error
                        [@id = "t:tbd10"])
  then (
         (: grammar parsed but was nonconformant :)
         attribute result { "pass" },
         element tc:result {
           $expectation,
           $xml-grammar
         }         
       )

  else if (deep-equal($xml-grammar, $expectation))
  then (
         (: grammar conformant and as expected :)
         attribute result { "pass" }
       )

  else (
         (: grammar conformant but not as expected :)
         attribute result { "fail" },
         element tc:result {
           comment {
            "diagnostics should go here"
           },
           element tc:assert-xml { $expectation },
           element tc:reported-xml { $xml-grammar }
         }
       )
</pre>
<span class="scrapinbound">This code is used in 〈 <a href=
"#lib-test-grammar">The test-grammar() function 26</a>
〉<br /></span></div>
<i>TO DO: provide better diagnostics in case of failure.</i></div>
<div class="Real-P">If the user has specified that results should
be written out in separate files for separate tests, we need to
write out the grammar test.
<div class="scrap"><span><a name="lib-rts-write-grammar-result" id=
"lib-rts-write-grammar-result">〈 29 Optionally write out grammar
test result 〉 ≡</a></span>
<pre class="scrapbody">

        if (($options/@details = 'by-case')
           and exists($grammar-test-result))
        then let $outfn := 'grammar-test-' || $test-set-name 
                           || '-results.xml',
                 $out := concat(
                         $options/@output-directory, 
                         '/', $outfn)
             return file:write($out, $grammar-test-result)
        else (),
</pre>
<span class="scrapinbound">This code is used in 〈 <a href=
"#lib-rts-do-inline">Handle an inline test-set 15</a>
〉<br /></span></div>
</div>
</div>
<div class="div">
<h2><a name="testcases" id="testcases">5.</a> Running the test
cases</h2>
<div class="Real-P">Once we reach a test case, we have a compiled
grammar ready. To run and evaluate the test case:
<ul>
<li>Fetch the test input string, if it's external, catching
exceptions.</li>
<li>Fetch the expected results, if they are external, catching
exceptions.</li>
<li>If we failed on either the input string or the expectations,
mark the test case as not run.</li>
<li>Otherwise, attempt to parse the string with the compiled
grammar for the test set, catching exceptions.</li>
<li>Otherwise, compare the expected result with the actual result.
<ul>
<li>If an exception was raised in parsing, mark the test case as
failed. Otherwise continue.</li>
<li>If there was no parse, then
<ul>
<li>if the expected result is assert-not-a-sentence (or
assert-not-a-grammar?), then report success,</li>
<li>else (expected result is an XML document) report failure.</li>
</ul>
</li>
<li>If there was one parse, then
<ul>
<li>if it is deep-equal to at least one XML document among the
expected results, then report success,</li>
<li>else (does not match the expected results) report failure.</li>
</ul>
</li>
<li>If there are multiple parses, then
<ul>
<li>if every parse is deep-equal to at least one XML document among
the expected results, then report success,</li>
<li>else (some parse does not match the expected results) report
failure.</li>
</ul>
</li>
</ul>
</li>
</ul>
<i>TO DO: find a simple way to do a comparison which ignores the
presence or absence of an <em>ixml:state</em> attribute.</i></div>
<div class="Real-P">The <i>run-test-case()</i> function ...
<div class="scrap"><span><a name="lib-run-test-case" id=
"lib-run-test-case">〈 30 The run-test-case() function 〉
≡</a></span>
<pre class="scrapbody">

declare function t:run-test-case(
  $test-case as element(tc:test-case),
  $G as element(ixml),
  $options as element(options)
) as element() {
  <span class="scrapref">〈 <em class="scrapptr"><a href=
"#lib-rtc-misc-var">Set some handy variables 32</a></em> 〉</span>
  <span class="scrapref">〈 <em class="scrapptr"><a href=
"#lib-rtc-fetch-input">Set $input-string 31</a></em> 〉</span>
  <span class="scrapref">〈 <em class="scrapptr"><a href=
"#lib-rtc-fetch-expected">Set $expectations 33</a></em> 〉</span>
  <span class="scrapref">〈 <em class="scrapptr"><a href=
"#lib-rtc-parse">Set $parse-tree by parsing the test input string 34</a></em> 〉</span>
  <span class="scrapref">〈 <em class="scrapptr"><a href=
"#lib-rtc-evaluate">Set $result 35</a></em> 〉</span>
  <span class="scrapref">〈 <em class="scrapptr"><a href=
"#lib-rtc-errors">Set $error-details 36</a></em> 〉</span>
  <span class="scrapref">〈 <em class="scrapptr"><a href=
"#lib-rtc-details">Set $details 39</a></em> 〉</span>
  
  return (element tc:test-result {
    $test-case/@*,
    attribute result { $result },
    <span class="scrapref">〈 <em class="scrapptr"><a href=
"#lib-rtc-report-error">If errors arose in a test case, report them 37</a></em> 〉</span>,
    if ($options/@details eq 'inline')
    then $details
    else ()
  },
  <span class="scrapref">〈 <em class="scrapptr"><a href=
"#lib-rtc-write-test-result">Optionally write out test result 46</a></em> 〉</span>
  )
};
</pre>
<span class="scrapinbound">This code is used in 〈 <a href=
"#lib-functions">Declare library functions 4</a>
〉<br /></span></div>
</div>
<div class="Real-P">If the input string is external, fetch it. If
we have a problem fetching it (i.e. if there is no text at that
URI), we have a problem. We are expecting a string, and we can't
return an error element. And we're not set up to throw and catch
exceptions. So we use a magic string.
<div class="scrap"><span><a name="lib-rtc-fetch-input" id=
"lib-rtc-fetch-input">〈 31 Set $input-string 〉 ≡</a></span>
<pre class="scrapbody">

    let $input-string := 
        if ($test-case/tc:test-string)
        then string($test-case/tc:test-string)
        else if ($test-case/tc:test-string-ref)
        then let $uri0 := $test-case
                          /tc:test-string-ref/@href
                          /string(),
                 $uri1 := base-uri($test-case),
                 $uri2 := resolve-uri($uri0, $uri1)
             return 
                 if (unparsed-text-available($uri2))
                 then unparsed-text($uri2)
                 else $failure-string
        else "Ich versteh die Welt nicht mehr"
</pre>
<span class="scrapinbound">This code is used in 〈 <a href=
"#lib-run-test-case">The run-test-case() function 30</a>
〉<br /></span></div>
</div>
<div class="Real-P">As our magic string we use the words “NOT
FOUND” spelled out using the ‘language tag’ characters originally
put into Unicode for inline language marking and later deprecated.
We could use any string sufficiently unlikely to be used as an
external test input. For example, U+1D350 “Tetragram for failure”
would also work. (And be shorter.) For that matter, U+FFFD
“Replacement character” might be apposite here. It's usually used
when transcoding into UCS does not work; this is roughly analogous.
<div class="scrap"><span><a name="lib-rtc-misc-var" id=
"lib-rtc-misc-var">〈 32 Set some handy variables 〉 ≡</a></span>
<pre class="scrapbody">

  let $failure-string := ("󠁎󠁏󠁔"
                      || "󠀠󠁆󠁏"
                      || "󠁕󠁎󠁄"
                         (: 'NOT FOUND' in tag block :),
                         "𝍐",
                         "�")[2]
</pre>
<span class="scrapcontinuations">Continued in 〈<a href=
"#lib-rtc-mv-testset">Set $test-set-name, $test-case-ID
40</a>〉<br /></span> <span class="scrapinbound">This code is used
in 〈 <a href="#lib-run-test-case">The run-test-case() function
30</a> 〉<br /></span></div>
</div>
<div class="Real-P">If the expected results are external, we need
to fetch them, too. We need to be careful to ensure that the value
of <i>$expectations</i> is an element and not a document node.
<div class="scrap"><span><a name="lib-rtc-fetch-expected" id=
"lib-rtc-fetch-expected">〈 33 Set $expectations 〉 ≡</a></span>
<pre class="scrapbody">

    let $expectations := 
        for $e in $test-case/tc:result/*
        return if ($e/self::tc:assert-not-a-sentence)
            then $e
            else if ($e/self::tc:assert-not-a-grammar)
            then $e
            else if ($e/self::tc:assert-xml)
            then $e/*
            else if ($e/self::tc:assert-xml-ref)
            then let $uri0 := $e/@href
                              /string(),
                     $uri1 := base-uri($test-case),
                     $uri2 := resolve-uri($uri0, $uri1)
                 return 
                 if (doc-available($uri2))
                 then doc($uri2)/*
                 else element tc:error {
                   attribute id { "t:tbd14" },
                   "Expected result at ",
                   $uri0,
                   " not found. Looked for ",
                   $uri2
                 }
            else element tc:error {
                   attribute id { "t:tbd17" },
                   "Unexpected expectation ",
                   $e
                 }
</pre>
<span class="scrapinbound">This code is used in 〈 <a href=
"#lib-run-test-case">The run-test-case() function 30</a>
〉<br /></span></div>
</div>
<div class="Real-P">We have input string and expectations ready, or
else we are holding error markers in their place. Time to run the
test.
<div class="scrap"><span><a name="lib-rtc-parse" id=
"lib-rtc-parse">〈 34 Set $parse-tree by parsing the test input
string 〉 ≡</a></span>
<pre class="scrapbody">

    let $parse-tree := 
        if ($input-string eq $failure-string)
        then ()
        else if ($expectations/self::tc:error)
        then ()
        else try {
          ap:parse-string-with-compiled-grammar(
            $input-string,
            $G
          )
        } catch * {
          element tc:error {
              attribute id { "t:tbd16" },
              "Parse function blew up. ",
              $err:code, $err:value, 
              " module: ",
              $err:module, 
              "(", $err:line-number, ",", 
              $err:column-number, ")"
          }
        }
</pre>
<span class="scrapinbound">This code is used in 〈 <a href=
"#lib-run-test-case">The run-test-case() function 30</a>
〉<br /></span></div>
<i>TO DO: in other uses of try/catch, record the error.</i></div>
</div>
<div class="div">
<h2><a name="evaluation" id="evaluation">6.</a> Evaluating the test
case results</h2>
<div class="Real-P">Now we compare the parse tree to the
expectations and set the three variables <i>$result</i>,
<i>$error-details</i>, and <i>$details</i>. Some of the conditions
will be repeated, but I don't see a good way to avoid the
repetition.
<div class="scrap"><span><a name="lib-rtc-evaluate" id=
"lib-rtc-evaluate">〈 35 Set $result 〉 ≡</a></span>
<pre class="scrapbody">

    let $result :=
        if ($input-string eq $failure-string)
        then "not-run"
        else if (exists($expectations
                   /self::tc:error)) 
        then "not-run"
        else if ($parse-tree/self::no-parse
                 and $expectations
                 /self::tc:assert-not-a-sentence)
        then "pass"
        else if ($parse-tree/self::no-parse
                 and $expectations
                 /self::tc:assert-not-a-grammar)
        then "pass" (: This case should not arise :)
        else if ($parse-tree/self::forest
              and 
              empty(($expectations/self::tc:assert-not-a-grammar,
              $expectations/self::tc:assert-not-a-sentence))
              and 
              (every $e1 in $parse-tree/* satisfies
              (some $e2 in $expectations satisfies
              deep-equal($e1, $e2))))
        then "pass" 
        else if (some $e1 in $expectations satisfies
                deep-equal($e1, $parse-tree))
        then "pass"
        else "fail"
</pre>
<span class="scrapinbound">This code is used in 〈 <a href=
"#lib-run-test-case">The run-test-case() function 30</a>
〉<br /></span></div>
</div>
<div class="Real-P">We only need the error details for the
conditions where we caught an error of some kind.
<div class="scrap"><span><a name="lib-rtc-errors" id=
"lib-rtc-errors">〈 36 Set $error-details 〉 ≡</a></span>
<pre class="scrapbody">

    let $error-details :=
        if ($input-string eq $failure-string)
        then element tc:error {
               attribute id { "t:tbd15" },
               "External test input not found."
             }
        else if (exists($expectations
                 /self::tc:error)) 
        then $expectations/self::tc:error
        else ()
</pre>
<span class="scrapinbound">This code is used in 〈 <a href=
"#lib-run-test-case">The run-test-case() function 30</a>
〉<br /></span></div>
</div>
<div class="Real-P">If and only if we caught an error, we will want
to wrap it in an &lt;<em>app-info</em>&gt; element for reporting:
<div class="scrap"><span><a name="lib-rtc-report-error" id=
"lib-rtc-report-error">〈 37 If errors arose in a test case, report
them 〉 ≡</a></span>
<pre class="scrapbody">

    if (exists($error-details))
    then element tc:app-info {
         $error-details
    }
    else ()
</pre>
<span class="scrapinbound">This code is used in 〈 <a href=
"#lib-run-test-case">The run-test-case() function 30</a> 〉 〈
<a href="#lib-rtc-write-test-result">Optionally write out test
result 46</a> 〉<br /></span></div>
</div>
</div>
<div class="div">
<h2><a name="output-options" id="output-options">7.</a> Output
options</h2>
<div class="Real-P">At this point, we need to digress for a moment
to think about the output from specific grammar tests and test
cases.</div>
<div class="Real-P">Experience makes me believe that when running
tests is fast, and there aren't many tests, I'm happy to have all
the results in a single document. When running tests is slow, I
find myself wishing I could examine the results from earlier tests
while waiting for the run to finish. So I would like to have the
option of having test details written out test-by-test or
not.</div>
<div class="Real-P">And depending on what I'm doing I may want more
or less detail on tests. Steven Pemberton's test-result files have
proven very handy, with their repetition of the input grammar, the
input string, and the produced output. I would like to have
optional control of what details are recorded, and where.</div>
<div class="Real-P">Also, when a test fails because the expected
result and the reported result differ, I frequently end up saving
each to disk in a separate file so I can use an interactive
comparison program to find differences. I'd like an option for
that, too.</div>
<div class="Real-P">So the basic questions seem to be:
<ul>
<li>The basic information on a test, i.e. of test name and
pass/fail/not-run result, will be given unconditionally. Should
additional details of tests be given
<ul>
<li>in the main output?, or</li>
<li>test-by-test in separate files (default)?, or</li>
<li>not at all?</li>
</ul>
</li>
<li>When details are given, should the grammar be recorded
<ul>
<li>inline, in an &lt;<em>ixml-grammar</em>&gt; or
&lt;<em>xml-grammar</em>&gt; element?, or</li>
<li>inline if short (smaller than some user-specified threshold)
and externally otherwise?, or</li>
<li>externally, using an &lt;<em>ixml-grammar-ref</em>&gt; or a
&lt;<em>vxml-grammar-ref</em>&gt; element, or both?, or</li>
<li>not at all?</li>
</ul>
When external representation is requested, the grammar will be
written out to the test-reporting directory and pointed to using a
relative URI. The name will be generated automatically from the
test-set name.</li>
<li>When details are given, should the input string be recorded
<ul>
<li>inline, in a &lt;<em>test-input</em>&gt; element?, or</li>
<li>inline if short (smaller than some user-specified threshold)
and externally otherwise?, or</li>
<li>externally, using a &lt;<em>test-string-ref</em>&gt; element?,
or</li>
<li>not at all?</li>
</ul>
</li>
<li>When details are given, the expected result will be recorded if
the test fails. When given, how should it be given?
<ul>
<li>inline, in an &lt;<em>assert-*</em>&gt; element?, or</li>
<li>inline if short (smaller than some user-specified threshold)
and externally otherwise?, or</li>
<li>externally, using a &lt;<em>assert-xml-ref</em>&gt; element?,
or</li>
<li>not at all?</li>
</ul>
</li>
<li>When details are given, should the reported result be recorded
<ul>
<li>inline, in an &lt;<em>reported-*</em>&gt; element?, or</li>
<li>inline if short (smaller than some user-specified threshold)
and externally otherwise?, or</li>
<li>externally, using a &lt;<em>reported-xml-ref</em>&gt; element?,
or</li>
<li>not at all?</li>
</ul>
</li>
<li>In case a test is failed, should the expected and reported
results be written to disk as separate files for easier comparison,
independently of what the user specified on the previous two
questions? Yes or no.</li>
</ul>
</div>
<div class="Real-P">The options that control what is reported and
whether individual files are written out for each test set or each
test case are set in the driver. In order to remind myself later of
what the expected options are, I list them all and index into them
to choose the one I want for a given run.
<div class="scrap"><span><a name="dr-options" id="dr-options">〈 38
Set the options for the test harness [continues</a> <a href=
"#dr-setup">5 Set up variables and options</a>] 〉 ≡</span>
<pre class="scrapbody">

    $options := element options {
      attribute details { 
        ('inline', 
        'by-case', 
        'none')[2]
      },
      attribute input-grammar {
        ('inline',
        'inline-if-short', 
        'external',
        'none')[2]
      },
      attribute input-string {
        ('inline', 
        'inline-if-short', 
        'external',
        'none')[2]
      },
      attribute reported-result {
        ('inline', 
        'inline-if-short',
        'external',
        'none')[1]
      },
      attribute expected-result {
        ('inline', 
        'inline-if-short',
        'external',
        'none')[1]
      },
      attribute files-on-failure {
        ('yes', 
        'no')[1]
      },
      attribute inline-string-limit {
        400 
      },
      attribute inline-xml-limit {
        10
      },
      attribute output-directory {
        ($outdir)[1]
      }
    }
</pre></div>
<i>N.B. In the current version of this test harness, not all of
these options are actually supported. And the grammar provided is
the compiled grammar, not the grammar supplied by the
user.</i></div>
<div class="Real-P"><i>Note to future-self: if comparison of
expected results to reported results becomes a burden, it may be
worthwhile to offer a result-format option with the choices
<tt>native</tt>, <tt>reified</tt>, or <tt>both</tt>.</i></div>
</div>
<div class="div">
<h2><a name="output" id="output">8.</a> Reporting the results</h2>
<div class="Real-P">The top-level function <i>t:run-tests()</i>
returns a &lt;<em>tc:test-report</em>&gt; element; the caller is
responsible for writing it out to a file if desired.</div>
<div class="Real-P">But when the user wants separate reports for
different test cases, the caller cannot do the work; the library
must handle it.</div>
<div class="Real-P">If the user asked for details, we provide them.
This gets a little tedious, so I've broken it out into smaller
bits.
<div class="scrap"><span><a name="lib-rtc-details" id=
"lib-rtc-details">〈 39 Set $details 〉 ≡</a></span>
<pre class="scrapbody">

    let $details :=
        if ($options/@details = 'none')
        then ()
        else (
            <span class="scrapref">〈 <em class="scrapptr"><a href=
"#lib-rtc-rpt-grammar">Optionally report grammar used 41</a></em> 〉</span>,
            <span class="scrapref">〈 <em class="scrapptr"><a href=
"#lib-rtc-rpt-string">Optionally report input string 42</a></em> 〉</span>,
            <span class="scrapref">〈 <em class="scrapptr"><a href=
"#lib-rtc-rpt-output">Optionally report expected and actual output 43</a></em> 〉</span>
        )
</pre>
<span class="scrapinbound">This code is used in 〈 <a href=
"#lib-run-test-case">The run-test-case() function 30</a>
〉<br /></span></div>
</div>
<div class="Real-P">When the user asks for things to be written out
externally, we will need a file name. Since test cases are supposed
to be named uniquely within a test set, and test sets within a test
catalog, we should be able to just concatenate the two names. There
are several values it will be convenient to have available when
putting together the details of the report, including the identify
the containing test set and the test set where the current grammar
appeared (not necessarily the same set).
<div class="scrap"><span><a name="lib-rtc-mv-testset" id=
"lib-rtc-mv-testset">〈 40 Set $test-set-name, $test-case-ID
[continues</a> <a href="#lib-rtc-misc-var">32 Set some handy
variables</a>] 〉 ≡</span>
<pre class="scrapbody">

    let $test-set-parent := $test-case/parent::tc:test-set,
        $test-set-grammar-host := $test-case/
            ancestor::tc:test-set
            [tc:ixml-grammar or tc:vxml-grammar
            or tc:ixml-grammar-ref
            or tc:vxml-grammar-ref]
            [1],
        $test-set-name := $test-set-parent/@name/string(),
        $grammar-name := 'grammar-' 
                         || $test-set-grammar-host
                            /@name/string()
                         || '.xml',
        $test-case-ID := concat($test-set-name, 
                                '-', 
                                $test-case
                                /@name/string())
</pre></div>
</div>
<div class="Real-P">I ran out of patience with the inline-if-short
option, so for now we only do the other three.</div>
<div class="Real-P">If the user requests that the grammar be
recorded, and the ixml grammar is easy to retrieve, then that's
what we record. Otherwise, we use the vxml grammar, if it's easy to
get. Here “easy to retrieve” means it was inline. If the
user-specified grammar was external, then we end up using the
compiled grammar.
<div class="scrap"><span><a name="lib-rtc-rpt-grammar" id=
"lib-rtc-rpt-grammar">〈 41 Optionally report grammar used 〉
≡</a></span>
<pre class="scrapbody">

            let $kw := $options/@input-grammar
            let $g0 := $test-set-grammar-host
                       /*[self::tc:ixml-grammar
                       or self::tc:vxml-grammar
                       or self::tc:ixml-grammar-ref
                       or self::tc:vxml-grammar-ref]

            return if ($kw = ('inline',
                              'inline-if-short'))
            then ($g0/self::tc:ixml-grammar, 
                  $g0/self::tc:vxml-grammar, 
                  element tc:vxml-grammar {$G})[1]
            else if ($kw eq 'external')
            then element tc:vxml-grammar-ref { 
                   attribute href { $grammar-name },
                   (: and let's write the file :)
                   file:write($options/@output-directory
                             || '/' || $grammar-name,
                             $g0)
                 }
            else ()
</pre>
<span class="scrapinbound">This code is used in 〈 <a href=
"#lib-rtc-details">Set $details 39</a> 〉<br /></span></div>
</div>
<div class="Real-P">For the input string, it's not too hard to
support the <tt>inline-if-short</tt> option.
<div class="scrap"><span><a name="lib-rtc-rpt-string" id=
"lib-rtc-rpt-string">〈 42 Optionally report input string 〉
≡</a></span>
<pre class="scrapbody">

            let $kw := $options/@input-string,
                $fn := $test-case-ID || '.input.txt'
            return if (($kw eq 'inline')
                       or
                       (($kw eq 'inline-if-short')
                        and
                        (string-length($input-string)
                        le 
                        ($options/@inline-string-limit
                         /number(), 400)[1])))
            then element tc:test-string {
                   $input-string
                 }
            else if ($kw = ('external', 
                            'inline-if-short'))
            then element tc:test-string-ref { 
                   attribute href { $fn },
                   (: and let's write the file :)
                   file:write($options/@output-directory
                             || '/' || $fn,
                             $input-string)
                 }
            else ()
</pre>
<span class="scrapinbound">This code is used in 〈 <a href=
"#lib-rtc-details">Set $details 39</a> 〉<br /></span></div>
</div>
<div class="Real-P">If the user requested that either the expected
output or the reported output, or both, be included in the report,
we need to wrap them in a &lt;<em>tc:result</em>&gt; element.
<div class="scrap"><span><a name="lib-rtc-rpt-output" id=
"lib-rtc-rpt-output">〈 43 Optionally report expected and actual
output 〉 ≡</a></span>
<pre class="scrapbody">

            if (($options/@expected-result ne 'none')
               or ($options/@reported-result ne 'none')
               or ($options/@files-on-failure ne 'no'))
            then element tc:result {
              <span class="scrapref">〈 <em class=
"scrapptr"><a href="#lib-rtc-rpt-expected">Optionally report expected result 44</a></em> 〉</span>,
              <span class="scrapref">〈 <em class=
"scrapptr"><a href="#lib-rtc-rpt-reported">Optionally report parser output 45</a></em> 〉</span>
            }
            else ()
</pre>
<span class="scrapinbound">This code is used in 〈 <a href=
"#lib-rtc-details">Set $details 39</a> 〉<br /></span></div>
</div>
<div class="Real-P">We write out the expected result only if the
test case failed, but not if there was some error. If the
expectation is not-a-sentence or not-a-grammar, then we report it
regardless of the user's option. If we have an XML expectation,
then
<ul>
<li>If the user asked for it inline, we serialize it inline.</li>
<li>If the user asked for it externally (through either the
<i>expected-result</i> option or the <i>files-on-failure</i>
option), we serialize it externally.</li>
</ul>
<div class="scrap"><span><a name="lib-rtc-rpt-expected" id=
"lib-rtc-rpt-expected">〈 44 Optionally report expected result 〉
≡</a></span>
<pre class="scrapbody">

            let $kwD := $options/@expected-result,
                $kwE := $options/@files-on-failure,
                $fn  := $test-case-ID || '.expected.xml'

            return 
            if ($result eq 'fail')

            then if ($expectations
                     [self::tc:assert-not-a-sentence
                     or
                     self::tc:assert-not-a-grammar])
                 then $expectations

                 else ( 
                      if ($kwD = ('inline',
                                  'inline-if-short'))
                      then element tc:assert-xml {
                             $expectations
                           }
                      else (),

                      if (($kwD eq 'external')
                          or
                          ($kwE eq 'yes'))
                      then element tc:assert-xml-ref {
                              attribute href {$fn},
                              file:write(
                                $options/@output-directory
                                || '/' || $fn,
                                $expectations
                              )
                            }
                      else () (: unknown option, bag it :)
                      )

            else () (: $result ne 'fail' :)            
</pre>
<span class="scrapinbound">This code is used in 〈 <a href=
"#lib-rtc-rpt-output">Optionally report expected and actual output
43</a> 〉<br /></span></div>
</div>
<div class="Real-P">The logic for reported results is similar but
is not conditional on failure of the test.
<div class="scrap"><span><a name="lib-rtc-rpt-reported" id=
"lib-rtc-rpt-reported">〈 45 Optionally report parser output 〉
≡</a></span>
<pre class="scrapbody">

            let $kwD := $options/@reported-result,
                $kwE := $options/@files-on-failure,
                $fn  := $test-case-ID || '.reported.xml'
            return 
            if ($parse-tree/self::no-parse)
            then (element tc:reported-not-a-sentence{},
                  element tc:app-info {
                    $parse-tree
                  })

            else ( 
                   if ($kwD = ('inline', 
                               'inline-if-short'))
                   then element tc:reported-xml {
                          $parse-tree
                        }
                   else (),

                   if (($kwD eq 'external')
                       or
                       ($kwE eq 'yes'))
                   then element tc:reported-xml-ref {
                          attribute href {$fn},
                          file:write(
                            $options/@output-directory
                            || '/' || $fn,
                            $parse-tree
                          )
                        }
                   else () (: unknown option :)
                 )
</pre>
<span class="scrapinbound">This code is used in 〈 <a href=
"#lib-rtc-rpt-output">Optionally report expected and actual output
43</a> 〉<br /></span></div>
</div>
<div class="Real-P">If the user has specified that results should
be written out in separate files for separate tests, we need to
write out the test result.
<div class="scrap"><span><a name="lib-rtc-write-test-result" id=
"lib-rtc-write-test-result">〈 46 Optionally write out test result 〉
≡</a></span>
<pre class="scrapbody">

        if ($options/@details = 'by-case')
        then let $outfn := $test-case-ID
                           || '-test-result.xml',
                 $out := concat(
                         $options/@output-directory, 
                         '/', $outfn)
             return file:write(
                      $out, 
                      element tc:test-result {
                        $test-case/@*,
                        attribute result { $result },
                        <span class="scrapref">〈 <em class=
"scrapptr"><a href=
"#lib-rtc-report-error">If errors arose in a test case, report them 37</a></em> 〉</span>,
                        $details
                      }
                    )
        else ()
</pre>
<span class="scrapinbound">This code is used in 〈 <a href=
"#lib-run-test-case">The run-test-case() function 30</a>
〉<br /></span></div>
</div>
</div>
<hr />
<ul>
<li>test-driver.xq: defined in 〈 <a href="#dr-top">1 [File
test-driver.xq]</a> 〉</li>
<li>test-harness.xqm: defined in 〈 <a href="#lib-top">2 [File
test-harness.xqm]</a> 〉</li>
</ul>
<ul>
<li><a href="#dr-top">[File test-driver.xq] 1</a></li>
<li><a href="#lib-top">[File test-harness.xqm] 2</a></li>
<li><a href="#lib-rts-ld-ixml-ref">Cautiously fetch and parse
external ixml grammar 21</a></li>
<li><a href="#lib-rts-ld-vxml-ref">Cautiously fetch external vxml
grammar 22</a></li>
<li><a href="#lib-rts-ld-ixml">Cautiously parse ixml grammar
18</a></li>
<li><a href="#lib-rt-check-cat-read">Check for errors reading the
catalog 10</a></li>
<li><a href="#lib-rts-vxml-grammar-check">Check the XML grammar for
conformance 23</a></li>
<li><a href="#lib-tc-compare">Compare the grammar with the
expectation 28</a></li>
<li><a href="#lib-rts-grammar-compilation">Compile the new grammar,
if there is one 25</a></li>
<li><a href="#lib-functions">Declare library functions 4</a></li>
<li><a href="#lib-tc-fetch">Fetch expected result of grammar test
27</a></li>
<li><a href="#lib-rts-do-ref">Handle a test-set reference
14</a></li>
<li><a href="#lib-rts-do-inline">Handle an inline test-set
15</a></li>
<li><a href="#lib-rts-nested">Handle nested test sets and test
cases 16</a></li>
<li><a href="#lib-rts-grammar-test">Handle the grammar test, if
there is one 24</a></li>
<li><a href="#lib-rtc-report-error">If errors arose in a test case,
report them 37</a></li>
<li><a href="#dr-catfiles">List of available test-catalog files
6</a></li>
<li><a href="#lib-rts-grammar">Load and test the grammar for a test
set 17</a></li>
<li><a href="#lib-rt-load-cat">Load catalog file into $catalog
8</a></li>
<li><a href="#d3e319">Load catalog file into $catalog 9</a></li>
<li><a href="#lib-nsdecls">Namespace declarations and imports for
library module 3</a></li>
<li><a href="#d3e460">Namespace declarations and imports, cont'd
19</a></li>
<li><a href="#lib-rtc-rpt-output">Optionally report expected and
actual output 43</a></li>
<li><a href="#lib-rtc-rpt-expected">Optionally report expected
result 44</a></li>
<li><a href="#lib-rtc-rpt-grammar">Optionally report grammar used
41</a></li>
<li><a href="#lib-rtc-rpt-string">Optionally report input string
42</a></li>
<li><a href="#lib-rtc-rpt-reported">Optionally report parser output
45</a></li>
<li><a href="#lib-rts-write-grammar-result">Optionally write out
grammar test result 29</a></li>
<li><a href="#lib-rtc-write-test-result">Optionally write out test
result 46</a></li>
<li><a href="#lib-rtc-details">Set $details 39</a></li>
<li><a href="#lib-rtc-errors">Set $error-details 36</a></li>
<li><a href="#lib-rtc-fetch-expected">Set $expectations 33</a></li>
<li><a href="#lib-rtc-fetch-input">Set $input-string 31</a></li>
<li><a href="#lib-rtc-parse">Set $parse-tree by parsing the test
input string 34</a></li>
<li><a href="#lib-rtc-evaluate">Set $result 35</a></li>
<li><a href="#lib-rtc-mv-testset">Set $test-set-name, $test-case-ID
40</a></li>
<li><a href="#lib-rtc-misc-var">Set some handy variables
32</a></li>
<li><a href="#dr-options">Set the options for the test harness
38</a></li>
<li><a href="#dr-setup">Set up variables and options 5</a></li>
<li><a href="#lib-rt-metadata">Supply basic metadata for the test
report 11</a></li>
<li><a href="#lib-rts-ld-vxml">Take the inline vxml grammar
20</a></li>
<li><a href="#lib-rts3">The recursive run-test-set() function
13</a></li>
<li><a href="#lib-run-test-case">The run-test-case() function
30</a></li>
<li><a href="#lib-run-test-set">The run-test-set() function
12</a></li>
<li><a href="#lib-run-tests">The run-tests() function 7</a></li>
<li><a href="#lib-test-grammar">The test-grammar() function
26</a></li>
</ul>
<ul>
<li>2022-02-09 : CMSMcQ : finally reach the actual test cases
...</li>
<li>2022-02-04 : CMSMcQ : made file, to replace earlier test
harness lost in a disk crash</li>
</ul>
</div>
</body>
</html>
